# 다양한 날짜 형식으로 테스트

이제 기본적인 검증 함수가 있으므로, 다양한 입력에 대한 동작 방식을 이해하기 위해 다른 날짜 형식으로 테스트해 보겠습니다.

## 테스트 스위트 생성

다양한 날짜 형식을 검사하기 위해 포괄적인 테스트 스위트를 생성해 보겠습니다.

1. `dateTester.js`라는 새 파일을 생성합니다.
2. 다음 코드를 추가합니다.

```javascript
// isISOString 함수를 가져옵니다.
const isISOString = require("./isISODate");

// 다른 날짜 문자열을 테스트하는 함수
function testDate(description, dateString) {
  console.log(`테스트: ${description}`);
  console.log(`입력: "${dateString}"`);
  console.log(`ISO 형식 여부: ${isISOString(dateString)}`);
  console.log("-----------------------");
}

// 유효한 ISO 날짜 예시
testDate("표준 ISO 날짜 (시간대 Z)", "2023-05-12T14:30:15.123Z");
testDate("밀리초가 0 인 ISO 날짜", "2020-10-12T10:10:10.000Z");

// 유효하지 않거나 ISO 형식이 아닌 예시
testDate("날짜만 (시간 구성 요소 없음)", "2023-05-12");
testDate("밀리초가 없는 날짜 및 시간", "2023-05-12T14:30:15Z");
testDate("Z 대신 시간대 오프셋이 있는 날짜", "2023-05-12T14:30:15+01:00");
testDate(
  "유효하지 않은 날짜 (13 월은 존재하지 않음)",
  "2023-13-12T14:30:15.123Z"
);
testDate("날짜가 아닌 문자열", "Hello World");
```

3. 터미널에서 테스트 스위트를 실행합니다.

```bash
node dateTester.js
```

어떤 문자열이 유효한 ISO 날짜이고 그렇지 않은지 보여주는 출력을 볼 수 있습니다.

## 결과 이해

각 테스트 케이스가 유효하거나 유효하지 않은 이유를 분석해 보겠습니다.

1. `2023-05-12T14:30:15.123Z` - UTC 시간대 표시자 (Z) 와 함께 완전한 ISO 8601 형식을 따르므로 유효합니다.

2. `2020-10-12T10:10:10.000Z` - 밀리초가 명시적으로 000 으로 설정되어 있으므로 이것도 유효합니다.

3. `2023-05-12` - 유효한 날짜이지만 시간 구성 요소가 없으므로 ISO 형식이 아닙니다.

4. `2023-05-12T14:30:15Z` - ISO 형식으로 보이지만 엄격한 ISO 형식에 필요한 밀리초가 없습니다.

5. `2023-05-12T14:30:15+01:00` - 'Z' 대신 시간대 오프셋 (+01:00) 을 사용합니다. ISO 8601 에 따르면 유효하지만, 우리 함수는 `toISOString()`에서 생성된 정확한 형식을 요구하며, 이는 항상 'Z'를 사용합니다.

6. `2023-13-12T14:30:15.123Z` - 유효하지 않은 날짜 (13 월은 존재하지 않음) 이므로 `new Date()`는 유효하지 않은 Date 객체를 생성합니다.

7. `Hello World` - 이것은 전혀 날짜가 아니므로 `new Date()`는 유효하지 않은 Date 객체를 생성합니다.

우리 검증 함수는 구체적으로 두 가지 조건을 확인합니다.

1. 문자열이 유효한 날짜로 파싱되어야 합니다 (NaN 이 아님).
2. 해당 날짜가 ISO 문자열로 다시 변환될 때 원래 입력과 정확히 일치해야 합니다.

이 접근 방식은 JavaScript 의 `toISOString()` 메서드에서 생성된 정확한 ISO 형식을 검증하도록 보장합니다.
