# Создать и собрать Docker-образ

А что, если у вас не установлена ​​Python локально? Не беспокойтесь! Потому что вам это не нужно. Одним из преимуществ использования контейнеров является то, что вы можете устанавливать Python внутри контейнеров, не устанавливая его на хост-машине.

Создайте `Dockerfile`, выполнив следующую команду. (скопируйте и вставьте весь код блока)

```bash
echo 'FROM python:3.8-alpine
RUN pip install flask
CMD ["python","app.py"]
COPY app.py /app.py' > Dockerfile
```

Dockerfile перечисляет инструкции, необходимые для сборки Docker-образа. Давайте рассмотрим этот файл построчно.

**FROM python:3.8-alpine**
Это точка начала для вашего Dockerfile. Каждый Dockerfile должен начинаться с строки `FROM`, которая является базовым образом, на котором вы будете строить свои слои.

В этом случае мы выбираем базовый слой `python:3.8-alpine` (см. [Dockerfile для python3.8/alpine3.12](https://github.com/docker-library/python/blob/9ff5f04241c7bcb224303ff8cea9434e9976f8af/3.8/alpine3.12/Dockerfile)), так как в нем уже есть нужная версия Python и pip для запуска нашего приложения.

Версия `alpine` означает, что она использует дистрибутив [Alpine Linux](https://en.wikipedia.org/wiki/Alpine_Linux), который значительно меньше многих альтернативных дистрибутивов Linux, размером около 8 МБ, в то время как минимальная установка на диск может быть около 130 МБ. Менее большой образ означает, что он будет скачиваться (разворачиваться) намного быстрее, и он также имеет преимущества для безопасности, так как имеет меньшую поверхность атаки. [Alpine Linux](https://alpinelinux.org/downloads/) - это дистрибутив Linux, основанный на musl и BusyBox.

Здесь мы используем тег "3.8-alpine" для образа Python. Посмотрите на доступные теги для официального образа Python на [Docker Hub](https://hub.docker.com/_/python/). Лучшим практикой является использование конкретного тега при наследовании родительского образа, чтобы контролировать изменения в родительской зависимости. Если тег не указан, то действует тег "latest", который является динамической ссылкой, указывающей на последнюю версию образа.

出于安全考虑，了解您在其上构建Docker镜像的层非常重要。因此，强烈建议仅使用在 [docker hub](https://hub.docker.com/) 中找到的“官方”镜像，或在docker-store中找到的非社区镜像。这些镜像经过 [审核](https://docs.docker.com/docker-hub/official_repos/) 以满足某些安全要求，并且也有非常好的文档供用户参考。您可以在 [docker hub](https://hub.docker.com) 上找到有关此 [Python基础镜像](https://hub.docker.com/_/python) 以及您可以使用的所有其他镜像的更多信息。

对于更复杂的应用程序，您可能会发现需要使用更高层次的 `FROM` 镜像。例如，我们的Python应用程序的父 [Dockerfile](https://github.com/docker-library/python/blob/9ff5f04241c7bcb224303ff8cea9434e9976f8af/3.8/alpine3.12/Dockerfile) 以 `FROM alpine` 开头，然后为镜像指定一系列 `CMD` 和 `RUN` 命令。如果您需要更细粒度的控制，可以从 `FROM alpine`（或其他发行版）开始并自己运行这些步骤。不过，首先我建议使用与您的需求密切匹配的官方镜像。

**RUN pip install flask**
`RUN` команда выполняет команды, необходимые для настройки образа для вашего приложения, таких как установка пакетов, редактирование файлов или изменение прав доступа к файлам. В этом случае мы устанавливаем flask. Команды `RUN` выполняются во время сборки и добавляются в слои вашего образа.

**CMD ["python","app.py"]**
`CMD` - это команда, которая выполняется при запуске контейнера. Здесь мы используем `CMD` для запуска нашего приложения на Python.

В каждом Dockerfile может быть только одна команда `CMD`. Если вы укажите несколько команд `CMD`, то последняя команда `CMD` будет действовать. Родительский образ python:3.8-alpine также задает `CMD` (`CMD python3`). Вы можете найти Dockerfile для официального образа python:alpine [здесь](https://github.com/docker-library/python/blob/9ff5f04241c7bcb224303ff8cea9434e9976f8af/3.8/alpine3.12/Dockerfile).

Вы можете напрямую использовать официальный образ Python для запуска скриптов на Python, не устанавливая Python на вашем хосте. Но сегодня мы создаем собственный образ, чтобы включить наш исходный код, чтобы мы могли собрать образ с нашим приложением и разместить его в других средах.

**COPY app.py /app.py**
Это копирует app.py в локальной директории (где вы будете запускать `docker image build`) в новый слой образа. Эта инструкция - последняя строка в Dockerfile. Слои, которые часто изменяются, такие как копирование исходного кода в образ, должны быть расположены ближе к концу файла, чтобы充分利用 Docker 层缓存。这使我们能够避免重建原本可以缓存的层。例如，如果 `FROM` 指令发生更改，它将使此镜像的所有后续层的缓存无效。我们将在本实验后面演示这一点。

将此放在 `CMD ["python","app.py"]` 行之后似乎违反直觉。请记住，`CMD` 行仅在容器启动时执行，因此我们在此处不会收到“文件未找到”错误。

Вот и все: очень простой Dockerfile. Полный список команд, которые вы можете поместить в Dockerfile, можно найти [здесь](https://docs.docker.com/engine/reference/builder/). Теперь, когда мы определили наш Dockerfile, давайте используем его для сборки нашего собственного Docker-образа.

Соберите Docker-образ.

Передайте `-t`, чтобы присвоить имени вашему образу `python-hello-world`.

```bash
docker image build -t python-hello-world.
```

Проверьте, что ваш образ появился в списке ваших образов.

```bash
docker image ls
```

**Обратите внимание**, что ваш базовый образ `python:3.8-alpine` также находится в списке.

Вы можете выполнить команду history, чтобы показать историю образа и его слоев,

```bash
docker history python-hello-world
docker history python:3.8-alpine
```
