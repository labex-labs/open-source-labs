# Понимание слоев образов

Одной из основных особенностей дизайна Docker является использование объединенной файловой системы.

Рассмотрим `Dockerfile`, который мы создали ранее:

```bash
FROM python:3.8-alpine
RUN pip install flask
CMD ["python","app.py"]
COPY app.py /app.py
```

Каждой из этих строк соответствует слой. Каждый слой содержит только дельту, разницу или изменения по сравнению с предыдущими слоями. Чтобы собрать эти слои в единый работающий контейнер, Docker использует `объединенную файловую систему`, чтобы наложить слои прозрачно в единый вид.

Каждый слой образа является `только для чтения`, за исключением самого верхнего слоя, который создается для работающего контейнера. Читательско-записной слой контейнера реализует "копирование при записи", что означает, что файлы, хранящиеся в нижних слоях образа, поднимаются в читательско-записной слой контейнера только при внесении изменений в эти файлы. Затем эти изменения сохраняются в слое работающего контейнера. Функция "копирование при записи" очень быстрая и в подавляющем большинстве случаев не оказывает заметного влияния на производительность. Вы можете проверить, какие файлы были подняты на уровень контейнера, с помощью команды `docker diff`. Более подробную информацию о том, как использовать `docker diff`, можно найти [здесь](https://docs.docker.com/engine/reference/commandline/diff/).

![understanding image layers](../assets/lab2_understanding_image_layers_1.png)

Поскольку слои образов `только для чтения`, они могут быть разделены между образами и работающими контейнерами. Например, создание нового приложения на Python с собственным Dockerfile с похожими базовыми слоями, позволит разделить все общие слои с первым приложением на Python.

```bash
FROM python:3.8-alpine
RUN pip install flask
CMD ["python","app2.py"]
COPY app2.py /app2.py
```

![understanding image layers](../assets/lab2_understanding_image_layers_2.png)

Вы также можете убедиться в разделении слоев, когда запускаете несколько контейнеров из одного образа. Поскольку контейнеры используют одинаковые слои только для чтения, вы можете представить, что запуск контейнеров происходит очень быстро и занимает очень мало места на хост-машине.

Вы, возможно, заметите, что в этом Dockerfile и в Dockerfile, который вы создали ранее в этой лабораторной работе, есть повторяющиеся строки. Хотя это очень простой пример, вы можете выделить общие строки обоих Dockerfile в "базовый" Dockerfile, а затем ссылаться на него из каждого из ваших дочерних Dockerfile с помощью команды `FROM`.

Слоирование образов позволяет использовать механизм кеширования Docker для сборок и отправок. Например, вывод вашей последней команды `docker push` показывает, что некоторые слои вашего образа уже существуют в Docker Hub.

```bash
$ docker push $DOCKERHUB_USERNAME/python-hello-world
```

Для более тщательного изучения слоев вы можете использовать команду `docker image history` для образа Python, который мы создали.

```bash
$ docker image history python-hello-world
```

Каждая строка представляет собой слой образа. Вы заметите, что верхние строки соответствуют вашему созданному Dockerfile, а строки ниже извлекаются из родительского образа Python. Не беспокойтесь о тегах "\<missing\>". Это все еще нормальные слои; они просто не получили идентификатор от системы Docker.
