# Развертывание изменений

Приложение "Hello World!" переоценировано. Давайте обновим приложение, чтобы оно вместо этого говорило "Hello Beautiful World!".

## Обновить `app.py`

Замените строку "Hello World" на "Hello Beautiful World!" в `app.py`. Вы можете обновить файл с помощью следующей команды. (скопируйте и вставьте весь код блока)

```bash
echo 'from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "hello beautiful world!"

if __name__ == "__main__":
    app.run(host="0.0.0.0")' > app.py
```

## Пересобрать и отправить ваш образ

Теперь, когда ваше приложение обновлено, вам нужно повторить шаги выше, чтобы пересобрать ваше приложение и отправить его в реестр Docker Hub.

Сначала пересоберите, на этот раз используйте имя пользователя Docker Hub в команде сборки:

```bash
docker image build -t $DOCKERHUB_USERNAME/python-hello-world.
```

Обратите внимание на "Using cache" для шагов 1-3. Эти слои Docker-образа уже были собраны, и `docker image build` будет использовать эти слои из кеша вместо их пересборки.

```bash
docker push $DOCKERHUB_USERNAME/python-hello-world
```

Также есть механизм кеширования для отправки слоев. Docker Hub уже имеет все, кроме одного слоя, от предыдущей отправки, поэтому он отправляет только тот слой, который изменился.

Когда вы изменяете слой, каждый слой, построенный поверх него, будет необходимо пересобрать. Каждая строка в Dockerfile создает новый слой, который строится поверх слоя, созданного из предыдущих строк. Именно поэтому порядок строк в нашем Dockerfile важен. Мы оптимизировали наш Dockerfile так, чтобы слой, наиболее вероятный измениться (`COPY app.py /app.py`), был последней строкой Dockerfile. Как правило, для приложения изменения в коде происходят наиболее часто. Эта оптимизация особенно важна для процессов CI/CD, где вы хотите, чтобы ваша автоматизация работала как можно быстрее.
