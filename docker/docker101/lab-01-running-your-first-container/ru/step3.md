# Запустите несколько контейнеров

## Исследуйте Docker Hub

[Docker Hub](https://hub.docker.com/explore/) - это центральный публичный реестр Docker-образов, который содержит образов сообщества и официальные образы.

При поиске образов вы найдете фильтры для "Docker Certified", "Verified Publisher" и "Official Images" образов. Выберите фильтр "Docker Certified", чтобы найти образов, которые считаются готовыми для использования в корпоративных условиях и которые были протестированы с использованием продукта Docker Enterprise Edition. При разработке собственных образов, предназначенных для развертывания в рабочей среде, важно избегать использования непроверенных контента из Docker Store. Эти непроверенные образы могут содержать уязвимости безопасности или даже вредоносное ПО.

В шаге 2 этого лабара мы запустим несколько контейнеров, используя некоторые проверенные образы из Docker Hub: веб-сервер Nginx и базу данных MongoDB.

## Запустите сервер Nginx

Запустим контейнер, используя [официальный образ Nginx](https://hub.docker.com/_/nginx) из Docker Hub.

```bash
docker container run --detach --publish 8080:80 --name nginx nginx
```

Здесь мы используем несколько новых флагов. Флаг `--detach` запустит этот контейнер в фоновом режиме. Флаг `publish` публикует порт 80 в контейнере (стандартный порт для Nginx), через порт 8080 на нашем хосте. Помните, что пространство имен NET дает процессам контейнера свою собственную сеть. Флаг `--publish` - это функция, которая позволяет нам экспортировать сеть через контейнер на хост.

Как вы знаете, что порт 80 - это стандартный порт для Nginx? Потому что он указан в [документации](https://hub.docker.com/_/nginx) на Docker Hub. В целом, документация по проверенным образам очень хорошая, и вы будете ссылаться на нее при запуске контейнеров с использованием этих образов.

Мы также указываем флаг `--name`, который дает имя контейнеру. Каждый контейнер имеет имя, если вы не укажете его, Docker случайным образом назначит его для вас. Указание собственного имени упрощает выполнение последующих команд на вашем контейнере, так как вы можете ссылаться на имя вместо идентификатора контейнера. Например: `docker container inspect nginx` вместо `docker container inspect 5e1`.

Поскольку это первый раз, когда вы запускаете контейнер Nginx, он загрузит образ Nginx из Docker Store. Последующие контейнеры, созданные из образа Nginx, будут использовать существующий образ, расположенный на вашем хосте.

Nginx - это легковесный веб-сервер. Вы можете получить доступ к серверу Nginx на вкладке **Web 8080** виртуальной машины LabEx. Переключитесь на нее и обновите страницу, чтобы увидеть вывод от Nginx.

![step 2 nginx](../assets/20230829-11-16-04-BazUogDa.png)

## Запустите сервер `mongo` DB

Теперь запустим сервер MongoDB. Мы будем использовать [официальный образ MongoDB](https://hub.docker.com/_/mongo) из Docker Hub. Вместо использования тега `latest` (который является стандартным, если тег не указан), мы будем использовать конкретную версию образа mongo: 4.4.

```bash
docker container run --detach --publish 8081:27017 --name mongo mongo:4.4
```

Опять же, поскольку это первый раз, когда мы запускаем контейнер mongo, мы загрузим образ mongo из Docker Store. Мы используем флаг `--publish`, чтобы экспортировать порт 27017 mongo на нашем хосте. Мы должны использовать другой порт, кроме 8080, для маппинга на хост, так как этот порт уже экспортируется на нашем хосте. Опять же, обратитесь к [официальным документам](https://hub.docker.com/_/mongo) на Docker Hub, чтобы получить более подробную информацию о использовании образа mongo.

Посмотрите вывод от MongoDB, используя `0.0.0.0:8081` в веб-браузере. Вы должны увидеть сообщение, которое вернет предупреждение от MongoDB.

![MongoDB server output warning](../assets/20230829-11-19-23-PkodKK48.png)

Проверьте запущенные контейнеры с помощью `docker container ls`

```bash
$ docker container ls
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
d6777df89fea nginx "nginx -g 'daemon..." Less than a second ago Up 2 seconds 0.0.0.0:8080- nginx > 80/tcp
ead80a0db505 mongo "docker-entrypoint..." 17 seconds ago Up 19 seconds 0.0.0.0:8081- mongo > 27017/tcp
af549dccd5cf ubuntu "top" 5 minutes ago Up 5 minutes priceless_kepler
```

Вы должны увидеть, что у вас есть контейнер веб-сервера Nginx и контейнер MongoDB, работающий на вашем хосте. Обратите внимание, что мы не настроили эти контейнеры для взаимодействия друг с другом.

Вы можете увидеть имена "nginx" и "mongo", которые мы дали нашим контейнерам, и случайное имя (в моем случае "priceless_kepler"), которое было сгенерировано для контейнера ubuntu. Вы также можете увидеть маппинги портов, которые мы указали с помощью флага `--publish`. Для получения более подробной информации о этих запущенных контейнерах вы можете использовать команду `docker container inspect [container id`.

Одно из вещей, которое вы, возможно, заметите, - это то, что контейнер mongo запускает команду `docker-entrypoint`. Это имя исполняемого файла, которое запускается при запуске контейнера. Образ mongo требует некоторой предварительной настройки перед запуском процесса базы данных. Вы можете точно увидеть, что делает этот скрипт, посмотрев на него на [github](https://github.com/docker-library/mongo). Как правило, вы можете найти ссылку на исходный код на github из страницы с описанием образа на сайте Docker Store.

Контейнеры автономны и изолированы, что означает, что мы можем избежать потенциальных конфликтов между контейнерами с разными системными или зависимостями времени выполнения. Например: развертывание приложения, использующего Java 7, и другого приложения, использующего Java 8, на одном и том же хосте. Или запуск нескольких контейнеров Nginx, все они имеют порт 80 в качестве стандартного порта прослушивания (если экспортировать на хост с использованием флага `--publish`, выбранные порты для хоста должны быть уникальными). Преимущества изоляции возможны благодаря пространствам имен Linux.

**Примечание**: Вам не нужно было ничего устанавливать на вашем хосте (кроме Docker), чтобы запустить эти процессы! Каждый контейнер включает в себя зависимости, которые ему нужны внутри контейнера, поэтому вы не должны устанавливать ничего на вашем хосте напрямую.

Запуск нескольких контейнеров на одном и том же хосте позволяет нам полностью использовать ресурсы (CPU, память и т.д.), доступные на одном хосте. Это может привести к значительным экономиям затрат для предприятия.

В то время как запуск образов напрямую из Docker Hub может быть полезным иногда, гораздо более полезно создавать собственные образы и ссылаться на официальные образы в качестве начальной точки для этих образов. Мы углубимся в создание собственных пользовательских образов в Лаборатории 2.
