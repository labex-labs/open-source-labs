# Box`<T>`{=html} を使って既知のサイズを持つ再帰型を取得する方法

Rustは再帰的に定義された型に対してどれだけのスペースを割り当てるかを把握できないため、コンパイラはこの有益な提案とともにエラーを表示します。

    help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List`
    representable
      |
    2 |     Cons(i32, Box<List>),
      |               ++++    +

この提案では、「間接参照」とは、値を直接格納する代わりに、値へのポインタを格納することで間接的に値を格納するようにデータ構造を変更することを意味します。

`Box<T>` はポインタなので、Rustは常に `Box<T>` にどれだけのスペースが必要かを知っています。ポインタのサイズは、それが指すデータ量に基づいて変化しません。これは、`Cons` バリアントの中に別の `List` 値の代わりに `Box<T>` を入れることができることを意味します。`Box<T>` は、`Cons` バリアントの中ではなく、ヒープ上にある次の `List` 値を指します。概念的には、他のリストを保持するリストで作成されたリストがまだありますが、この実装は現在、項目を互いの中に入れるのではなく、互いの隣に配置するようになっています。

リスト15-2の `List` 列挙型の定義と、リスト15-3の `List` の使用方法を、コンパイルされるリスト15-5のコードに変更することができます。

ファイル名: `src/main.rs`

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(
        1,
        Box::new(Cons(
            2,
            Box::new(Cons(
                3,
                Box::new(Nil)
            ))
        ))
    );
}
```

リスト15-5: 既知のサイズを持つように `Box<T>` を使用する `List` の定義

`Cons` バリアントには `i32` のサイズと、ボックスのポインタデータを格納するスペースが必要です。`Nil` バリアントは値を格納していないので、`Cons` バリアントよりも少ないスペースが必要です。これで、任意の `List` 値が `i32` のサイズとボックスのポインタデータのサイズを占めることがわかりました。ボックスを使用することで、無限の再帰チェーンが切断され、コンパイラは `List` 値を格納するために必要なサイズを把握することができます。図15-2は、現在の `Cons` バリアントの様子を示しています。

図15-2: `Cons` が `Box` を保持しているため、無限のサイズを持たない `List`

ボックスは間接参照とヒープ割り当てのみを提供します。他のスマートポインタ型と同じような特別な機能はありません。また、これらの特別な機能に伴うパフォーマンスのオーバーヘッドもありません。したがって、間接参照が必要な唯一の機能であるコンズリストのようなケースでは役立ちます。第17章でボックスのさまざまなユースケースを見ていきます。

`Box<T>` 型はスマートポインタです。なぜなら、`Deref` トレイトを実装しており、これにより `Box<T>` 値を参照のように扱うことができるからです。`Box<T>` 値がスコープ外になると、`Drop` トレイトの実装により、ボックスが指すヒープデータもクリーンアップされます。これらの2つのトレイトは、本章の残りで説明する他のスマートポインタ型によって提供される機能にとってさらに重要になります。これらの2つのトレイトについてもう少し詳しく見ていきましょう。
