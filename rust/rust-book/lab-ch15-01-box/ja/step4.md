# コンズリストに関する詳細情報

「コンズリスト」は、Lisp プログラミング言語とその方言に由来するデータ構造で、ネストされたペアで構成され、リンクリストの Lisp バージョンです。その名前は、Lisp の `cons` 関数（_構築関数_ の略）に由来し、その 2 つの引数から新しいペアを構築します。値と別のペアからなるペアに `cons` を呼び出すことで、再帰的なペアで構成されるコンズリストを構築できます。

たとえば、リスト `1, 2, 3` を含むコンズリストの疑似コード表現は次の通りです（各ペアは括弧で囲まれています）。

```rust
(1, (2, (3, Nil)))
```

コンズリストの各要素は 2 つの要素で構成されます。現在の要素の値と、次の要素です。リストの最後の要素は、次の要素がない `Nil` と呼ばれる値のみを含みます。コンズリストは、再帰的に `cons` 関数を呼び出すことで生成されます。再帰の基本ケースを表す標準的な名前は `Nil` です。これは、第 6 章の「null」または「nil」の概念とは異なり、無効または存在しない値ではありません。

コンズリストは Rust では一般的に使われるデータ構造ではありません。Rust で項目のリストを持つ場合、ほとんどの場合 `Vec<T>` を使う方が良い選択肢です。他の、より複雑な再帰的なデータ型は、さまざまな状況で役立ちますが、この章でコンズリストから始めることで、ボックスがどのように再帰的なデータ型を定義できるかを、あまり邪魔されることなく探ることができます。

リスト 15-2 には、コンズリスト用の列挙型の定義が含まれています。このコードはまだコンパイルされません。なぜなら、`List` 型のサイズが不明だからです。これを示します。

ファイル名：`src/main.rs`

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

リスト 15-2: `i32` 値のコンズリストデータ構造を表す列挙型を定義する最初の試み

> 注：この例の目的で、`i32` 値のみを保持するコンズリストを実装しています。第 10 章で説明したように、ジェネリクスを使って、任意の型の値を格納できるコンズリスト型を定義することもできました。

`List` 型を使ってリスト `1, 2, 3` を格納すると、リスト 15-3 のコードのようになります。

ファイル名：`src/main.rs`

```rust
--snip--

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

リスト 15-3: `List` 列挙型を使ってリスト `1, 2, 3` を格納する

最初の `Cons` 値は `1` と別の `List` 値を保持しています。この `List` 値は、`2` と別の `List` 値を保持する別の `Cons` 値です。この `List` 値は、`3` と `List` 値を保持するさらに 1 つの `Cons` 値で、最後にはリストの終わりを示す非再帰的なバリアントである `Nil` です。

リスト 15-3 のコードをコンパイルしようとすると、リスト 15-4 に示すエラーが表示されます。

```bash
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List`
representable
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

リスト 15-4: 再帰的な列挙型を定義しようとしたときに得られるエラー

このエラーは、この型が「無限のサイズ」であることを示しています。その理由は、`List` を再帰的なバリアントで定義しているからです。つまり、それ自体の別の値を直接保持しているのです。その結果、Rust は `List` 値を格納するためにどれだけのスペースが必要かを把握できません。このエラーが発生する理由を解説しましょう。まずは、Rust が非再帰的な型の値を格納するためにどれだけのスペースが必要かを決定する方法を見てみましょう。
