# 非再帰的な型のサイズの計算

第 6 章で列挙型の定義について説明したときに、リスト 6-2 で定義した `Message` 列挙型を思い出してください。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

`Message` 値に割り当てるスペースの量を決定するために、Rust は各バリアントを調べて、どのバリアントが最も多くのスペースを必要とするかを確認します。Rust は、`Message::Quit` にはスペースが必要ないこと、`Message::Move` には 2 つの `i32` 値を格納するのに十分なスペースが必要であることなどを確認します。1 つのバリアントのみが使用されるため、`Message` 値が必要とする最も多くのスペースは、そのバリアントの中で最も大きいものを格納するのに必要なスペースです。

これとは対照的に、Rust がリスト 15-2 の `List` 列挙型のような再帰型が必要とするスペースの量を決定しようとしたときに何が起こるかを見てみましょう。コンパイラはまず、`i32` 型の値と `List` 型の値を保持する `Cons` バリアントを見ます。したがって、`Cons` には `i32` のサイズと `List` のサイズに等しい量のスペースが必要です。`List` 型が必要とするメモリ量を把握するために、コンパイラはバリアントを調べます。最初に `Cons` バリアントから始めます。`Cons` バリアントは `i32` 型の値と `List` 型の値を保持しており、このプロセスは無限に続きます。図 15-1 に示すようにです。

図 15-1: 無限の `Cons` バリアントからなる無限の `List`
