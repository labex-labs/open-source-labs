# 计算非递归类型的大小

回想一下我们在第 6 章讨论枚举定义时在清单 6-2 中定义的 `Message` 枚举：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

为了确定为一个 `Message` 值分配多少空间，Rust 会遍历每个变体，看看哪个变体需要最多的空间。Rust 发现 `Message::Quit` 不需要任何空间，`Message::Move` 需要足够的空间来存储两个 `i32` 值，依此类推。因为只会使用一个变体，所以一个 `Message` 值需要的最大空间就是存储其最大变体所需的空间。

将此与 Rust 尝试确定像清单 15-2 中的 `List` 枚举这样的递归类型需要多少空间时发生的情况进行对比。编译器首先查看 `Cons` 变体，它包含一个 `i32` 类型的值和一个 `List` 类型的值。因此，`Cons` 需要的空间量等于一个 `i32` 的大小加上一个 `List` 的大小。为了弄清楚 `List` 类型需要多少内存，编译器会查看变体，从 `Cons` 变体开始。`Cons` 变体包含一个 `i32` 类型的值和一个 `List` 类型的值，这个过程会无限持续下去，如图 15-1 所示。

图 15-1：由无限个 `Cons` 变体组成的无限 `List`
