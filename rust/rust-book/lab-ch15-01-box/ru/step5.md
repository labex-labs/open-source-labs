# Вычисление размера нерекурсивного типа

Помните перечисление `Message`, которое мы определили в Листинге 6-2, когда обсуждали определения перечислений в главе 6:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

Чтобы определить, сколько места нужно выделить для значения `Message`, Rust просматривает каждый вариант, чтобы понять, какой вариант требует наибольшего количества места. Rust видит, что `Message::Quit` не требует никакого места, `Message::Move` требует достаточно места для хранения двух значений `i32` и так далее. Поскольку будет использоваться только один вариант, наибольшее количество места, которое может потребоваться для значения `Message`, - это количество места, которое нужно для хранения самого большого из его вариантов.

Сравните это с тем, что происходит, когда Rust пытается определить, сколько места требует рекурсивный тип, такой как перечисление `List` в Листинге 15-2. Компилятор начинает с просмотра варианта `Cons`, который содержит значение типа `i32` и значение типа `List`. Поэтому `Cons` требует количество места, равное размеру `i32` плюс размер `List`. Чтобы понять, сколько памяти требует тип `List`, компилятор просматривает варианты, начиная с варианта `Cons`. Вариант `Cons` содержит значение типа `i32` и значение типа `List`, и этот процесс продолжается бесконечно, как показано на рисунке 15-1.

Рисунок 15-1: Бесконечный `List`, состоящий из бесконечного количества вариантов `Cons`
