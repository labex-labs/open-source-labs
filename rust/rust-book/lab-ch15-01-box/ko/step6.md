# `Box`<T>`{=html}를 사용하여 알려진 크기의 재귀적 타입 얻기

Rust 는 재귀적으로 정의된 타입에 할당할 공간의 크기를 파악할 수 없기 때문에 컴파일러는 다음과 같은 유용한 제안과 함께 오류를 발생시킵니다:

    help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List`
    representable
      |
    2 |     Cons(i32, Box<List>),
      |               ++++    +

이 제안에서 *indirection*은 값을 직접 저장하는 대신, 해당 값에 대한 포인터를 저장하여 간접적으로 값을 저장하도록 데이터 구조를 변경해야 함을 의미합니다.

`Box<T>`는 포인터이므로 Rust 는 `Box<T>`가 얼마나 많은 공간을 필요로 하는지 항상 알고 있습니다: 포인터의 크기는 가리키는 데이터의 양에 따라 변경되지 않습니다. 즉, 다른 `List` 값을 직접 저장하는 대신 `Cons` 변형 내부에 `Box<T>`를 넣을 수 있습니다. `Box<T>`는 `Cons` 변형 내부에 있는 대신 힙에 있는 다음 `List` 값을 가리킬 것입니다. 개념적으로, 우리는 여전히 다른 리스트를 포함하는 리스트로 생성된 리스트를 가지고 있지만, 이 구현은 이제 항목을 서로 안에 넣는 것이 아니라 서로 옆에 배치하는 것과 더 유사합니다.

Listing 15-2 의 `List` enum 정의와 Listing 15-3 의 `List` 사용법을 Listing 15-5 의 코드로 변경할 수 있으며, 이 코드는 컴파일됩니다.

Filename: `src/main.rs`

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(
        1,
        Box::new(Cons(
            2,
            Box::new(Cons(
                3,
                Box::new(Nil)
            ))
        ))
    );
}
```

Listing 15-5: 알려진 크기를 갖기 위해 `Box<T>`를 사용하는 `List`의 정의

`Cons` 변형은 `i32`의 크기 더하기 박스의 포인터 데이터를 저장할 공간이 필요합니다. `Nil` 변형은 값을 저장하지 않으므로 `Cons` 변형보다 적은 공간이 필요합니다. 이제 모든 `List` 값은 `i32`의 크기 더하기 박스의 포인터 데이터의 크기를 차지한다는 것을 알 수 있습니다. 박스를 사용함으로써 무한한 재귀적 체인을 끊었으므로 컴파일러는 `List` 값을 저장하는 데 필요한 크기를 파악할 수 있습니다. 그림 15-2 는 `Cons` 변형이 어떻게 보이는지 보여줍니다.

그림 15-2: `Cons`가 `Box`를 포함하기 때문에 무한한 크기가 아닌 `List`

Box 는 indirection 과 힙 할당만 제공합니다; 다른 스마트 포인터 타입에서 볼 수 있는 다른 특별한 기능은 없습니다. 또한 이러한 특별한 기능으로 인해 발생하는 성능 오버헤드도 없으므로, indirection 이 우리가 필요로 하는 유일한 기능인 cons list 와 같은 경우에 유용할 수 있습니다. 17 장에서 박스에 대한 더 많은 사용 사례를 살펴보겠습니다.

`Box<T>` 타입은 `Deref` 트레이트를 구현하므로 스마트 포인터입니다. 이 트레이트를 통해 `Box<T>` 값을 참조처럼 처리할 수 있습니다. `Box<T>` 값이 범위를 벗어나면 `Drop` 트레이트 구현으로 인해 박스가 가리키는 힙 데이터도 정리됩니다. 이 두 트레이트는 이 장의 나머지 부분에서 논의할 다른 스마트 포인터 타입에서 제공되는 기능에 훨씬 더 중요합니다. 이 두 트레이트를 자세히 살펴보겠습니다.
