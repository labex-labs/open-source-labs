# Структуры, подобные единице, без полей

Вы также можете определить структуры, которые не имеют никаких полей! Они называются _структуры, подобные единице_, потому что они ведут себя подобно `()`, типу единицы, о котором мы говорили в разделе "Тип кортежа". Структуры, подобные единице, могут быть полезны, когда вам нужно реализовать трейт для какого - то типа, но у вас нет никаких данных, которые вы бы хотели хранить в самом типе. Мы обсудим трейты в главе 10. Вот пример объявления и инициализации структуры - единицы с именем `AlwaysEqual`:

Filename: `src/main.rs`

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

Для определения `AlwaysEqual` мы используем ключевое слово `struct`, имя, которое мы хотим, и затем точку с запятой. Не нужно фигурных скобок или круглых скобок! Затем мы можем получить экземпляр `AlwaysEqual` в переменной `subject` аналогичным образом: используя имя, которое мы определили, без каких - то фигурных скобок или круглых скобок. Представьте, что позже мы реализуем поведение для этого типа так, чтобы каждый экземпляр `AlwaysEqual` всегда был равен любому другому экземпляру любого другого типа, возможно, для получения известного результата для целей тестирования. Для реализации этого поведения нам не понадобятся никакие данные! В главе 10 вы увидите, как определить трейты и реализовать их для любого типа, включая структуры, подобные единице.

> **Владеяние данными структуры**
>
> В определении структуры `User` в Листинге 5-1 мы использовали тип `String`, имеющий владение, а не тип строкового слайса `&str`. Это сознательный выбор, потому что мы хотим, чтобы каждый экземпляр этой структуры владел всей своей данными и чтобы эти данные были валидными столько времени, сколько и вся структура.
>
> Также возможно, чтобы структуры хранили ссылки на данные, принадлежащие чему - то другому, но для этого нужно использовать _жизненные периоды_ (lifetimes), функцию Rust, которую мы обсудим в главе 10. Жизненные периоды гарантируют, что данные, на которые ссылается структура, остаются валидными столько времени, сколько и структура. Допустим, вы пытаетесь сохранить ссылку в структуре, не указывая жизненные периоды, как в следующем примере в `src/main.rs`; это не сработает:
>
>     struct User {
>         active: bool,
>         username: &str,
>         email: &str,
>         sign_in_count: u64,
>     }
>
>     fn main() {
>         let user1 = User {
>             active: true,
>             username: "someusername123",
>             email: "someone@example.com",
>             sign_in_count: 1,
>         };
>     }
>
> Компилятор сообщит, что ему нужны спецификаторы жизненных периодов:
>
>     $ `cargo run`
>        Compiling structs v0.1.0 (file:///projects/structs)
>     error[E0106]: missing lifetime specifier
>      --> src/main.rs:3:15
>       |
>     3 |     username: &str,
>       |               ^ expected named lifetime parameter
>       |
>     help: consider introducing a named lifetime parameter
>       |
>     1 ~ struct User<'a> {
>     2 |     active: bool,
>     3 ~     username: &'a str,
>       |
>
>     error[E0106]: missing lifetime specifier
>      --> src/main.rs:4:12
>       |
>     4 |     email: &str,
>       |            ^ expected named lifetime parameter
>       |
>     help: consider introducing a named lifetime parameter
>       |
>     1 ~ struct User<'a> {
>     2 |     active: bool,
>     3 |     username: &str,
>     4 ~     email: &'a str,
>       |
>
> В главе 10 мы обсудим, как исправить эти ошибки, чтобы вы могли хранить ссылки в структурах, но на данный момент мы будем исправлять такие ошибки, используя типы, имеющие владение, такие как `String`, вместо ссылок, таких как `&str`.
