# Создание экземпляров из других экземпляров с использованием синтаксиса обновления структуры

Часто полезно создать новый экземпляр структуры, который включает в себя большинство значений из другого экземпляра, но изменяет некоторые из них. Это можно сделать с использованием _синтаксиса обновления структуры_.

Во - первых, в Листинге 5-6 показано, как создать новый экземпляр `User` в `user2` обычным способом, без синтаксиса обновления. Мы устанавливаем новое значение для `email`, а в остальном используем те же значения, что и в `user1`, который мы создали в Листинге 5-2.

Filename: `src/main.rs`

```rust
fn main() {
    --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

Листинг 5-6: Создание нового экземпляра `User` с использованием одного из значений из `user1`

С использованием синтаксиса обновления структуры мы можем достичь того же эффекта с меньшим количеством кода, как показано в Листинге 5-7. Синтаксис `..` указывает, что оставшиеся не явно заданные поля должны иметь те же значения, что и поля в заданном экземпляре.

Filename: `src/main.rs`

```rust
fn main() {
    --snip--


    let user2 = User {
        email: String::from("another@example.com"),
      ..user1
    };
}
```

Листинг 5-7: Использование синтаксиса обновления структуры для установки нового значения для `email` в экземпляре `User`, но использования остальных значений из `user1`

Код в Листинге 5-7 также создает экземпляр в `user2`, который имеет другое значение для `email`, но имеет те же значения для полей `username`, `active` и `sign_in_count` из `user1`. `..user1` должно быть в конце, чтобы указать, что любые оставшиеся поля должны получать свои значения из соответствующих полей в `user1`, но мы можем выбрать указать значения для любого количества полей в любом порядке, независимо от порядка полей в определении структуры.

Обратите внимание, что синтаксис обновления структуры использует `=` подобно оператору присваивания; это потому, что он перемещает данные, как мы видели в разделе "Переменные и данные, взаимодействующие с Move". В этом примере мы больше не можем использовать `user1` после создания `user2`, потому что `String` в поле `username` из `user1` был перемещен в `user2`. Если бы мы дали `user2` новые значения `String` для обоих `email` и `username`, и таким образом использовали только значения `active` и `sign_in_count` из `user1`, то `user1` по-прежнему был бы валидным после создания `user2`. `active` и `sign_in_count` - это типы, которые реализуют трейт `Copy`, поэтому поведение, о котором мы говорили в разделе "Только стековые данные: Copy", применилось бы.
