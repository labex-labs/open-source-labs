# 構造体更新構文を使って他のインスタンスからインスタンスを作成する

既存のインスタンスの値のほとんどを含み、一部を変更した新しい構造体のインスタンスを作成することは、頻繁に役立ちます。これは、*構造体更新構文*を使って行うことができます。

まず、リスト 5-6 では、更新構文を使わずに通常どおり新しい`User`インスタンス`user2`を作成する方法を示しています。`email`に新しい値を設定しますが、それ以外はリスト 5-2 で作成した`user1`の同じ値を使用します。

ファイル名：`src/main.rs`

```rust
fn main() {
    --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

リスト 5-6: `user1`の値の 1 つを使って新しい`User`インスタンスを作成する

構造体更新構文を使うと、より少ないコードで同じ効果を得ることができます。これはリスト 5-7 に示されています。構文`..`は、明示的に設定されていない残りのフィールドが、与えられたインスタンスのフィールドと同じ値を持つことを指定します。

ファイル名：`src/main.rs`

```rust
fn main() {
    --snip--


    let user2 = User {
        email: String::from("another@example.com"),
      ..user1
    };
}
```

リスト 5-7: 構造体更新構文を使って`User`インスタンスの新しい`email`値を設定し、`user1`の残りの値を使用する

リスト 5-7 のコードも、`user2`にインスタンスを作成します。このインスタンスは、`email`の値が異なりますが、`username`、`active`、および`sign_in_count`のフィールドは`user1`と同じ値を持ちます。`..user1`は、残りのすべてのフィールドが`user1`の対応するフィールドから値を取得することを指定するために最後に来る必要がありますが、構造体の定義におけるフィールドの順序に関係なく、任意の順序で任意の数のフィールドに値を指定することができます。

構造体更新構文は代入のように`=`を使うことに注意してください。これは、「変数とデータのムーブによる相互作用」で見たように、データを移動させるためです。この例では、`user2`を作成した後はもはや`user1`を使用することができません。なぜなら、`user1`の`username`フィールドの`String`が`user2`に移動したからです。もし`user2`に`email`と`username`の両方に新しい`String`値を与え、そのため`user1`の`active`と`sign_in_count`の値のみを使用した場合、`user2`を作成した後も`user1`は有効なままです。`active`と`sign_in_count`の両方は`Copy`トレイトを実装する型なので、「スタックのみのデータ：Copy」で議論した動作が適用されます。
