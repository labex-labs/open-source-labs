# 反復子トレイトと next メソッド

すべての反復子は、標準ライブラリに定義された `Iterator` という名前のトレイトを実装しています。このトレイトの定義は次のようになっています。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // デフォルト実装が省略されたメソッド
}
```

この定義ではいくつかの新しい構文が使われていることに注意してください。`type Item` と `Self::Item` で、このトレイトに関連付けられた型を定義しています。第 19 章で詳しく説明しますが、ここでは知っておく必要のあることは、このコードが `Iterator` トレイトを実装するには、`Item` 型も定義する必要があり、この `Item` 型は `next` メソッドの戻り値の型に使われるということだけです。言い換えると、`Item` 型は反復子から返される型になります。

`Iterator` トレイトは実装者に対して 1 つのメソッドの定義だけを要求しています。それは `next` メソッドで、このメソッドは反復子の 1 つの要素を 1 回に 1 つ返し、`Some` にラップされて返されます。反復処理が終了すると、`None` を返します。

反復子に対して直接 `next` メソッドを呼び出すことができます。リスト 13-12 は、ベクトルから作成した反復子に対して `next` を繰り返し呼び出したときに返される値を示しています。

ファイル名：`src/lib.rs`

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

リスト 13-12: 反復子に対して `next` メソッドを呼び出す

`v1_iter` を可変にする必要があることに注意してください。反復子に対して `next` メソッドを呼び出すと、反復子がシーケンス内のどこにいるかを追跡するために使う内部状態が変更されます。言い換えると、このコードは反復子を _消費_ または _使い果たし_ ます。`next` の各呼び出しは、反復子から 1 つの要素を消費します。`for` ループを使ったときは、`v1_iter` を可変にする必要はありませんでした。なぜなら、ループが `v1_iter` の所有権を取得し、内部的に可変にしてくれたからです。

また、`next` の呼び出しから得られる値は、ベクトル内の値への不変参照であることにも注意してください。`iter` メソッドは不変参照に対する反復子を生成します。`v1` の所有権を取得し、所有された値を返す反復子を作成したい場合は、代わりに `into_iter` を呼び出すことができます。同様に、可変参照を反復処理したい場合は、`iter` の代わりに `iter_mut` を呼び出すことができます。
