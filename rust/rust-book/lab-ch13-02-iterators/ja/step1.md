# 反復子を使った一連の項目の処理

反復子パターンを使うと、一連の項目に対して順番に何かの処理を行うことができます。反復子は、各項目を反復処理するロジックと、シーケンスが終了した時を判断する責任を持っています。反復子を使うときは、自分でそのロジックを再実装する必要はありません。

Rustでは、反復子は _遅延評価_ です。つまり、反復子を消費して使い果たすメソッドを呼び出さない限り、何の影響もありません。たとえば、リスト13-10のコードは、`Vec<T>` で定義された `iter` メソッドを呼び出すことで、ベクトル `v1` の要素に対する反復子を作成しています。このコードだけでは何の役にも立たない処理しか行いません。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

リスト13-10: 反復子の作成

反復子は `v1_iter` 変数に格納されます。反復子を作成したら、さまざまな方法で使うことができます。リスト3-5では、`for` ループを使って配列を反復処理し、その各要素に対して何かのコードを実行していました。内部的には、これは暗黙的に反復子を作成してから消費していましたが、これまでその詳細については触れていませんでした。

リスト13-11の例では、反復子の作成と `for` ループでの反復子の使用を分離しています。`v1_iter` の反復子を使って `for` ループを呼び出すと、反復子の各要素がループの1回の反復で使われ、各値が表示されます。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {val}");
}
```

リスト13-11: `for` ループで反復子を使用する

標準ライブラリに反復子が用意されていない言語では、おそらく同じ機能を、インデックス0から始まる変数を使って実装します。この変数を使ってベクトルにインデックスを指定して値を取得し、ループ内で変数の値をインクリメントしていき、ベクトル内の要素の総数に達するまで繰り返します。

反復子はそのようなロジック全てを代行してくれるため、間違える可能性のある繰り返しコードを減らすことができます。反復子を使えば、ベクトルのようにインデックスを指定できるデータ構造だけでなく、多くの種類のシーケンスに対して同じロジックを使う柔軟性が増えます。では、反復子がどのようにそれを行うのか見てみましょう。
