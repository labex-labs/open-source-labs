# Методы, которые потребляют итератор

Трейт `Iterator` имеет ряд различных методов с дефолтными реализациями, предоставленными стандартной библиотекой; вы можете узнать о этих методах, посмотрев в документации по API стандартной библиотеки для трейта `Iterator`. Некоторые из этих методов вызывают метод `next` в своей определении, и именно поэтому вам нужно реализовать метод `next` при реализации трейта `Iterator`.

Методы, которые вызывают `next`, называются _потребляющими адаптерами_, потому что вызов их использует итератор. Например, метод `sum`, который получает владение за итератором и перебирает элементы, вызывая `next` несколько раз, тем самым потребляя итератор. Во время перебора он добавляет каждый элемент к накопленной сумме и возвращает сумму, когда итерация завершена. В Listing 13-13 приведен тест, иллюстрирующий использование метода `sum`.

Filename: `src/lib.rs`

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

Listing 13-13: Вызов метода `sum` для получения суммы всех элементов в итераторе

После вызова `sum` мы не можем использовать `v1_iter`, потому что `sum` получает владение за итератором, на котором мы его вызываем.
