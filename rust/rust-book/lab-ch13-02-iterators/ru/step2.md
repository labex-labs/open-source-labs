# Трейт Iterator и метод next

Все итераторы реализуют трейт под названием `Iterator`, определенный в стандартной библиотеке. Определение этого трейта выглядит так:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // методы с дефолтными реализациями опущены
}
```

Заметьте, что это определение использует некоторый новый синтаксис: `type Item` и `Self::Item`, которые определяют _ассоциированный тип_ для этого трейта. Мы поговорим о ассоциированных типах более подробно в главе 19. На данный момент все, что вам нужно знать, - это то, что этот код говорит о том, что реализация трейта `Iterator` требует определения типа `Item`, и этот тип `Item` используется в возвращаемом типе метода `next`. Другими словами, тип `Item` будет типом, возвращаемым итератором.

Трейт `Iterator` требует от реализующих его типов определить только один метод: метод `next`, который возвращает по одному элементу итератора за раз, обернутый в `Some`, и, когда итерация завершается, возвращает `None`.

Мы можем вызывать метод `next` на итераторах напрямую; Listing 13-12 демонстрирует, какие значения возвращаются при повторном вызове `next` на итераторе, созданном из вектора.

Filename: `src/lib.rs`

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

Listing 13-12: Вызов метода `next` на итераторе

Заметьте, что нам нужно было сделать `v1_iter` изменяемым: вызов метода `next` на итераторе изменяет внутреннее состояние, которое итератор использует для отслеживания своей позиции в последовательности. Другими словами, этот код _потребляет_, или использует, итератор. Каждый вызов `next` "съедает" один элемент из итератора. Мы не нужно было делать `v1_iter` изменяемым, когда использовали цикл `for`, потому что цикл принял владение за `v1_iter` и сделал его изменяемым "за кулисами".

Также обратите внимание, что значения, которые мы получаем при вызове `next`, - это неизменяемые ссылки на значения в векторе. Метод `iter` создает итератор по неизменяемым ссылкам. Если мы хотим создать итератор, который будет владеть `v1` и возвращать собственные значения, мы можем вызвать `into_iter` вместо `iter`. Аналогично, если мы хотим итерироваться по изменяемым ссылкам, мы можем вызвать `iter_mut` вместо `iter`.
