# Методы, которые создают другие итераторы

_Адаптеры итератора_ - это методы, определенные для трейта `Iterator`, которые не потребляют итератор. Вместо этого они создают разные итераторы, меняя некоторый аспект исходного итератора.

Listing 13-14 показывает пример вызова метода-адаптера итератора `map`, который принимает замыкание, которое будет вызываться для каждого элемента при итерации по ним. Метод `map` возвращает новый итератор, который генерирует модифицированные элементы. Замыкание здесь создает новый итератор, в котором каждый элемент из вектора будет увеличен на 1.

Filename: `src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

Listing 13-14: Вызов адаптера итератора `map` для создания нового итератора

Однако этот код генерирует предупреждение:

    warning: unused `Map` that must be used
     --> src/main.rs:4:5
      |
    4 |     v1.iter().map(|x| x + 1);
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^
      |
      = note: `#[warn(unused_must_use)]` on by default
      = note: итераторы ленивые и ничего не делают, если не потребляются

Код в Listing 13-14 ничего не делает; замыкание, которое мы указали, никогда не вызывается. Предупреждение напоминает нам, почему: адаптеры итератора ленивые, и здесь нам нужно потребовать итератор.

Для исправления этого предупреждения и потребления итератора мы будем использовать метод `collect`, который мы использовали с `env::args` в Listing 12-1. Этот метод потребляет итератор и собирает результирующие значения в коллекцию определенного типа данных.

В Listing 13-15 мы собираем в вектор результаты итерации по итератору, возвращаемому вызовом `map`. Этот вектор в итоге будет содержать каждый элемент из исходного вектора, увеличенный на 1.

Filename: `src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

Listing 13-15: Вызов метода `map` для создания нового итератора, а затем вызов метода `collect` для потребления нового итератора и создания вектора

Поскольку `map` принимает замыкание, мы можем указать любую операцию, которую хотим выполнить для каждого элемента. Это прекрасный пример того, как замыкания позволяют вам настроить некоторое поведение, повторно используя поведение итерации, которое предоставляет трейт `Iterator`.

Вы можете цеплять несколько вызовов методов-адаптеров итератора, чтобы выполнять сложные действия в читаемом виде. Но поскольку все итераторы ленивые, вы должны вызвать один из методов потребляющих адаптеров, чтобы получить результаты вызовов методов-адаптеров итератора.
