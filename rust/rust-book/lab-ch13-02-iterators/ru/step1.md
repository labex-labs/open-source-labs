# Обработка серии элементов с использованием итераторов

Шаблон итератора позволяет выполнять определенную задачу над каждой элементом последовательности по очереди. Итератор отвечает за логику перебора каждого элемента и определения момента окончания последовательности. Когда вы используете итераторы, вам не нужно самостоятельно переосуществлять эту логику.

В Rust итераторы являются _ленивыми_, что означает, что они не оказывают никакого эффекта, пока вы не вызовете методы, которые потребляют итератор, чтобы его исчерпать. Например, код в Listing 13-10 создает итератор по элементам вектора `v1`, вызвав метод `iter`, определенный для `Vec<T>`. Сам по себе этот код не делает ничего полезного.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

Listing 13-10: Создание итератора

Итератор хранится в переменной `v1_iter`. После создания итератора мы можем использовать его по разному. В Listing 3-5 мы перебирали массив с использованием цикла `for`, чтобы выполнить некоторый код для каждого его элемента. Под капотом это неявно создавалось и затем использовалось итератор, но до сих пор мы упускали, как это работает именно.

В примере в Listing 13-11 мы отделяем создание итератора от его использования в цикле `for`. Когда цикл `for` вызывается с использованием итератора в `v1_iter`, каждый элемент итератора используется в одной итерации цикла, что выводит каждое значение.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {val}");
}
```

Listing 13-11: Использование итератора в цикле `for`

В языках, которые не предоставляют итераторы в своих стандартных библиотеках, вы, вероятно, бы написали такую же функциональность, начиная переменную с индекса 0, используя эту переменную для обращения к вектору и получения значения, и увеличивая значение переменной в цикле, пока оно не достигнет общего количества элементов в векторе.

Итераторы обрабатывают всю эту логику за вас, сокращая количество повторяющегося кода, который вы могли бы ошибочно переписать. Итераторы дают вам больше гибкости для использования одной и той же логики с разными типами последовательностей, не только с данными структурами, к которым можно обращаться по индексу, таким как векторы. Давайте рассмотрим, как это делают итераторы.
