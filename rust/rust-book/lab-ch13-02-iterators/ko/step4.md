# 다른 반복자를 생성하는 메서드

*반복자 어댑터 (Iterator adapters)*는 반복자를 소모하지 않는 `Iterator` 트레이트에 정의된 메서드입니다. 대신, 원래 반복자의 일부 측면을 변경하여 다른 반복자를 생성합니다.

Listing 13-14 는 반복자 어댑터 메서드 `map`을 호출하는 예제를 보여줍니다. `map`은 각 항목을 반복할 때 각 항목에 대해 호출할 클로저 (closure) 를 사용합니다. `map` 메서드는 수정된 항목을 생성하는 새로운 반복자를 반환합니다. 여기의 클로저는 벡터의 각 항목이 1 씩 증가하는 새로운 반복자를 생성합니다.

파일 이름: `src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

Listing 13-14: 새로운 반복자를 생성하기 위해 반복자 어댑터 `map` 호출하기

그러나 이 코드는 경고를 생성합니다.

    warning: unused `Map` that must be used
     --> src/main.rs:4:5
      |
    4 |     v1.iter().map(|x| x + 1);
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^
      |
      = note: `#[warn(unused_must_use)]` on by default
      = note: iterators are lazy and do nothing unless consumed

Listing 13-14 의 코드는 아무것도 수행하지 않습니다. 우리가 지정한 클로저는 호출되지 않습니다. 경고는 그 이유를 알려줍니다. 반복자 어댑터는 지연 (lazy) 되며, 여기에서 반복자를 소모해야 합니다.

이 경고를 수정하고 반복자를 소모하기 위해 Listing 12-1 에서 `env::args`와 함께 사용했던 `collect` 메서드를 사용합니다. 이 메서드는 반복자를 소모하고 결과 값을 컬렉션 데이터 타입으로 수집합니다.

Listing 13-15 에서 `map` 호출에서 반환된 반복자를 반복한 결과들을 벡터로 수집합니다. 이 벡터는 원래 벡터의 각 항목에 1 을 더한 값을 포함하게 됩니다.

파일 이름: `src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

Listing 13-15: `map` 메서드를 호출하여 새로운 반복자를 생성한 다음, `collect` 메서드를 호출하여 새로운 반복자를 소모하고 벡터를 생성하기

`map`은 클로저를 사용하므로 각 항목에 대해 수행하려는 모든 작업을 지정할 수 있습니다. 이것은 클로저가 `Iterator` 트레이트가 제공하는 반복 동작을 재사용하면서 일부 동작을 사용자 정의할 수 있게 해주는 훌륭한 예입니다.

여러 번의 반복자 어댑터 호출을 연결하여 복잡한 작업을 읽기 쉬운 방식으로 수행할 수 있습니다. 그러나 모든 반복자는 지연되므로, 반복자 어댑터 호출에서 결과를 얻으려면 소모 어댑터 메서드 중 하나를 호출해야 합니다.
