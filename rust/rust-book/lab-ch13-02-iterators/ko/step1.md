# 반복자를 사용하여 일련의 항목 처리하기

반복자 패턴을 사용하면 일련의 항목에 대해 차례로 어떤 작업을 수행할 수 있습니다. 반복자는 각 항목을 반복하고 시퀀스가 종료되었을 때를 결정하는 로직을 담당합니다. 반복자를 사용하면 해당 로직을 직접 다시 구현할 필요가 없습니다.

Rust 에서 반복자는 _지연 (lazy)_ 방식으로 작동합니다. 즉, 반복자를 소모하여 사용하기 위해 메서드를 호출할 때까지 아무런 효과가 없습니다. 예를 들어, Listing 13-10 의 코드는 `Vec<T>`에 정의된 `iter` 메서드를 호출하여 벡터 `v1`의 항목에 대한 반복자를 생성합니다. 이 코드 자체로는 아무런 유용한 작업을 수행하지 않습니다.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

Listing 13-10: 반복자 생성하기

반복자는 `v1_iter` 변수에 저장됩니다. 반복자를 생성한 후에는 다양한 방식으로 사용할 수 있습니다. Listing 3-5 에서 `for` 루프를 사용하여 배열을 반복하고 각 항목에 대해 코드를 실행했습니다. 내부적으로는 암묵적으로 반복자를 생성한 다음 소모했지만, 지금까지 정확히 어떻게 작동하는지 자세히 설명하지 않았습니다.

Listing 13-11 의 예제에서는 반복자 생성과 `for` 루프에서 반복자 사용을 분리합니다. `v1_iter`의 반복자를 사용하여 `for` 루프가 호출되면 반복자의 각 요소가 루프의 한 번의 반복에서 사용되어 각 값을 출력합니다.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {val}");
}
```

Listing 13-11: `for` 루프에서 반복자 사용하기

표준 라이브러리에서 반복자를 제공하지 않는 언어에서는, 아마도 인덱스 0 에서 변수를 시작하고, 해당 변수를 사용하여 벡터를 인덱싱하여 값을 얻고, 루프에서 변수 값을 증가시켜 벡터의 총 항목 수에 도달할 때까지 이와 동일한 기능을 작성할 것입니다.

반복자는 이 모든 로직을 처리하여 잠재적으로 엉망으로 만들 수 있는 반복적인 코드를 줄여줍니다. 반복자는 벡터와 같이 인덱싱할 수 있는 데이터 구조뿐만 아니라 다양한 종류의 시퀀스에서 동일한 로직을 사용할 수 있는 더 많은 유연성을 제공합니다. 반복자가 어떻게 그렇게 하는지 살펴보겠습니다.
