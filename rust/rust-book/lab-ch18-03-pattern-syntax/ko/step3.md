# 명명된 변수 매칭 (Matching Named Variables)

명명된 변수는 모든 값과 일치하는 반박할 수 없는 패턴이며, 이 책에서 여러 번 사용했습니다. 그러나 `match` 표현식에서 명명된 변수를 사용할 때 복잡한 문제가 발생합니다. `match`는 새로운 범위를 시작하기 때문에, `match` 표현식 내부의 패턴의 일부로 선언된 변수는 모든 변수와 마찬가지로 `match` 구조 외부에서 동일한 이름을 가진 변수를 가립니다. Listing 18-11 에서 `Some(5)` 값을 가진 `x`라는 변수와 `10` 값을 가진 `y`라는 변수를 선언합니다. 그런 다음 `x` 값에 대한 `match` 표현식을 생성합니다. match arm 의 패턴과 마지막 `println!`을 살펴보고 이 코드를 실행하거나 더 읽기 전에 코드가 무엇을 출력할지 생각해 보십시오.

파일 이름: `src/main.rs`

```rust
fn main() {
  1 let x = Some(5);
  2 let y = 10;

    match x {
      3 Some(50) => println!("Got 50"),
      4 Some(y) => println!("Matched, y = {y}"),
      5 _ => println!("Default case, x = {:?}", x),
    }

  6 println!("at the end: x = {:?}, y = {y}", x);
}
```

Listing 18-11: 그림자 변수 `y`를 도입하는 arm 이 있는 `match` 표현식

`match` 표현식이 실행될 때 어떤 일이 발생하는지 살펴보겠습니다. 첫 번째 match arm \[3]의 패턴은 정의된 `x` 값 \[1]과 일치하지 않으므로 코드는 계속 진행됩니다.

두 번째 match arm \[4]의 패턴은 `Some` 값 내부의 모든 값과 일치하는 `y`라는 새로운 변수를 도입합니다. `match` 표현식 내부의 새로운 범위에 있으므로, 이것은 처음 \[2]에 `10` 값을 가진 `y`가 아닌 새로운 `y` 변수입니다. 이 새로운 `y` 바인딩은 `Some` 내부의 모든 값과 일치하며, 이는 `x`에 있는 값입니다. 따라서 이 새로운 `y`는 `x`의 `Some` 내부 값에 바인딩됩니다. 그 값은 `5`이므로 해당 arm 에 대한 표현식이 실행되고 `Matched, y = 5`를 출력합니다.

`x`가 `Some(5)` 대신 `None` 값이었다면, 처음 두 arm 의 패턴은 일치하지 않았을 것이므로 값은 밑줄 \[5]과 일치했을 것입니다. 밑줄 arm 의 패턴에서 `x` 변수를 도입하지 않았으므로 표현식의 `x`는 여전히 가려지지 않은 외부 `x`입니다. 이 가상적인 경우, `match`는 `Default case, x = None`을 출력합니다.

`match` 표현식이 완료되면 해당 범위가 종료되고 내부 `y`의 범위도 종료됩니다. 마지막 `println!` \[6]은 `at the end: x = Some(5), y = 10`을 생성합니다.

그림자 변수를 도입하는 대신 외부 `x`와 `y`의 값을 비교하는 `match` 표현식을 만들려면 대신 match guard 조건문을 사용해야 합니다. "Match Guard 를 사용한 추가 조건문"에서 match guard 에 대해 이야기하겠습니다.
