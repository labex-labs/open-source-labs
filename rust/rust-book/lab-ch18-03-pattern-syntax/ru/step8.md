# Деструктуризация перечислений (Destructuring Enums)

Мы уже деструктурировали перечисления в этой книге (например, в листинге 6 - 5), но еще не разбирали явно, что шаблон для деструктуризации перечисления соответствует способу определения данных, хранящихся в перечислении. В качестве примера, в листинге 18 - 15 мы используем перечисление `Message` из листинга 6 - 2 и пишем выражение `match` с шаблонами, которые будут деструктурировать каждое внутреннее значение.

Имя файла: `src/main.rs`

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
  1 let msg = Message::ChangeColor(0, 160, 255);

    match msg {
      2 Message::Quit => {
            println!(
                "The Quit variant has no data to destructure."
            );
        }
      3 Message::Move { x, y } => {
            println!(
                "Move in the x dir {x}, in the y dir {y}"
            );
        }
      4 Message::Write(text) => {
            println!("Text message: {text}");
        }
      5 Message::ChangeColor(r, g, b) => println!(
            "Change color to red {r}, green {g}, and blue {b}"
        ),
    }
}
```

Листинг 18 - 15: Деструктуризация вариантов перечисления, которые хранят разные типы значений

Этот код напечатает `Change color to red 0, green 160, and blue 255`. Попробуйте изменить значение `msg` [1], чтобы увидеть выполнение кода других веток.

Для вариантов перечисления без каких - либо данных, таких как `Message::Quit` [2], мы не можем деструктурировать значение дальше. Мы можем только сопоставить литеральное значение `Message::Quit`, и в этом шаблоне нет переменных.

Для вариантов перечисления, похожих на структуры, таких как `Message::Move` [3], мы можем использовать шаблон, похожий на тот, который мы задаем для сопоставления структур. После имени варианта мы ставим фигурные скобки и затем перечисляем поля с переменными, чтобы разделить части и использовать их в коде этой ветки. Здесь мы используем сокращенную форму, как в листинге 18 - 13.

Для вариантов перечисления, похожих на кортежи, таких как `Message::Write`, который хранит кортеж с одним элементом [4], и `Message::ChangeColor`, который хранит кортеж с тремя элементами [5], шаблон похож на тот, который мы задаем для сопоставления кортежей. Количество переменных в шаблоне должно совпадать с количеством элементов в варианте, с которым мы сопоставляем.
