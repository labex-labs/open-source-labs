# Игнорирование оставшихся частей значения с использованием `..`

Для значений, состоящих из многих частей, мы можем использовать синтаксис `..`, чтобы использовать определенные части и игнорировать остальные, избавившись от необходимости перечислять подчеркивания для каждого игнорируемого значения. Шаблон `..` игнорирует любые части значения, которые мы не явно сопоставили в остальной части шаблона. В листинге 18 - 23 у нас есть структура `Point`, которая представляет координату в трехмерном пространстве. В выражении `match` мы хотим работать только с координатой `x` и игнорировать значения полей `y` и `z`.

Имя файла: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x,.. } => println!("x is {x}"),
}
```

Листинг 18 - 23: Игнорирование всех полей структуры `Point`, кроме `x`, с использованием `..`

Мы перечисляем значение `x`, а затем добавляем шаблон `..`. Это быстрее, чем перечислять `y: _` и `z: _`, особенно когда мы работаем со структурами, имеющими много полей, и только одно или два поля имеют значение.

Синтаксис `..` будет охватывать столько значений, сколько необходимо. Листинг 18 - 24 показывает, как использовать `..` с кортежем.

Имя файла: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first,.., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
```

Листинг 18 - 24: Сопоставление только первого и последнего значений в кортеже и игнорирование всех остальных значений

В этом коде первое и последнее значения сопоставляются с `first` и `last`. Шаблон `..` сопоставит и проигнорирует все значения в середине.

Однако использование `..` должно быть однозначным. Если неясно, какие значения должны быть сопоставлены, а какие игнорированы, Rust выдаст ошибку. Листинг 18 - 25 показывает пример неоднозначного использования `..`, поэтому этот код не скомпилируется.

Имя файла: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second,..) => {
            println!("Some numbers: {second}");
        },
    }
}
```

Листинг 18 - 25: Попытка использовать `..` неоднозначно

При компиляции этого примера мы получим такую ошибку:

```bash
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second,..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here
```

Rust не может определить, сколько значений в кортеже нужно игнорировать перед тем, как сопоставить значение с `second`, и сколько значений нужно игнорировать после этого. Этот код может означать, что мы хотим игнорировать `2`, связать `second` с `4`, а затем игнорировать `8`, `16` и `32`; или что мы хотим игнорировать `2` и `4`, связать `second` с `8`, а затем игнорировать `16` и `32` и так далее. Имя переменной `second` не имеет особого значения для Rust, поэтому мы получаем ошибку компилятора, так как использование `..` в двух местах таким образом является неоднозначным.
