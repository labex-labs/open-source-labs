# Деструктуризация структур (Destructuring Structs)

В листинге 18 - 12 показана структура `Point` с двумя полями, `x` и `y`, которые мы можем разделить с использованием шаблона в инструкции `let`.

Имя файла: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

Листинг 18 - 12: Деструктуризация полей структуры в отдельные переменные

Этот код создает переменные `a` и `b`, которые соответствуют значениям полей `x` и `y` структуры `p`. В этом примере показано, что имена переменных в шаблоне не обязательно должны совпадать с именами полей структуры. Однако обычно имена переменных совпадают с именами полей, чтобы было легче запомнить, откуда взялись переменные. Из - за такой распространенной практики и из - за того, что запись `let Point { x: x, y: y } = p;` содержит много дублирования, в Rust есть сокращенная запись для шаблонов, которые соответствуют полям структуры: вам нужно только перечислить имена полей структуры, и переменные, созданные из шаблона, будут иметь те же имена. Листинг 18 - 13 работает так же, как код в листинге 18 - 12, но переменные, созданные в шаблоне `let`, - это `x` и `y`, а не `a` и `b`.

Имя файла: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

Листинг 18 - 13: Деструктуризация полей структуры с использованием сокращенной записи для полей структуры

Этот код создает переменные `x` и `y`, которые соответствуют полям `x` и `y` переменной `p`. В результате переменные `x` и `y` содержат значения из структуры `p`.

Мы также можем деструктурировать, используя литеральные значения в качестве части шаблона структуры, вместо создания переменных для всех полей. Это позволяет нам проверить некоторые поля на соответствие определенным значениям, в то время как создаются переменные для деструктуризации других полей.

В листинге 18 - 14 у нас есть выражение `match`, которое разделяет значения `Point` на три случая: точки, лежащие непосредственно на оси `x` (это верно, когда `y = 0`), на оси `y` (`x = 0`) или не на какой - либо из осей.

Имя файла: `src/main.rs`

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

Листинг 18 - 14: Деструктуризация и сопоставление литеральных значений в одном шаблоне

Первая ветка будет совпадать с любой точкой, лежащей на оси `x`, указав, что поле `y` совпадает, если его значение совпадает с литералом `0`. Шаблон все еще создает переменную `x`, которую мы можем использовать в коде этой ветки.

Аналогично, вторая ветка совпадает с любой точкой на оси `y`, указав, что поле `x` совпадает, если его значение равно `0`, и создает переменную `y` для значения поля `y`. Третья ветка не указывает никаких литералов, поэтому она совпадает с любой другой точкой `Point` и создает переменные для полей `x` и `y`.

В этом примере значение `p` совпадает со второй веткой, так как `x` содержит `0`, поэтому этот код напечатает `On the y axis at 7`.

Помните, что выражение `match` прекращает проверку веток, как только оно находит первый совпадающий шаблон, поэтому даже если `Point { x: 0, y: 0}` лежит на оси `x` и на оси `y`, этот код напечатает только `On the x axis at 0`.
