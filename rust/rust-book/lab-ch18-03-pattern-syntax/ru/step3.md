# Сопоставление с именованными переменными (Matching Named Variables)

Именованные переменные представляют собой непреложные шаблоны (irrefutable patterns), которые совпадают с любым значением, и мы использовали их много раз в этой книге. Однако возникает сложность, когда вы используете именованные переменные в выражениях `match`. Поскольку `match` начинает новую область видимости, переменные, объявленные как часть шаблона внутри выражения `match`, будут скрывать переменные с тем же именем вне конструкции `match`, как и все переменные. В листинге 18 - 11 мы объявляем переменную с именем `x` со значением `Some(5)` и переменную `y` со значением `10`. Затем мы создаем выражение `match` для значения `x`. Посмотрите на шаблоны в ветках `match` и на вызов `println!` в конце, и попробуйте понять, что напечатает код, прежде чем запускать его или продолжать чтение.

Имя файла: `src/main.rs`

```rust
fn main() {
  1 let x = Some(5);
  2 let y = 10;

    match x {
      3 Some(50) => println!("Got 50"),
      4 Some(y) => println!("Matched, y = {y}"),
      5 _ => println!("Default case, x = {:?}", x),
    }

  6 println!("at the end: x = {:?}, y = {y}", x);
}
```

Листинг 18 - 11: Выражение `match` с веткой, которая вводит скрывающую переменную `y`

Давайте разберем, что происходит, когда выполняется выражение `match`. Шаблон в первой ветке `match` [3] не совпадает с определенным значением `x` [1], поэтому выполнение кода продолжается.

Шаблон во второй ветке `match` [4] вводит новую переменную с именем `y`, которая будет совпадать с любым значением внутри значения `Some`. Поскольку мы находимся в новой области видимости внутри выражения `match`, это новая переменная `y`, а не та `y`, которую мы объявили в начале со значением `10` [2]. Эта новая привязка `y` будет совпадать с любым значением внутри `Some`, которое у нас есть в `x`. Поэтому эта новая `y` связывается с внутренним значением `Some` в `x`. Это значение равно `5`, поэтому выражение для этой ветки выполняется и выводит `Matched, y = 5`.

Если бы `x` было значением `None` вместо `Some(5)`, шаблоны в первых двух ветках не совпали бы, поэтому значение совпадало бы с подчеркиванием [5]. Мы не ввели переменную `x` в шаблоне ветки с подчеркиванием, поэтому `x` в выражении по-прежнему является внешней переменной `x`, которая не была скрыта. В этом гипотетическом случае `match` напечатал бы `Default case, x = None`.

Когда выполнение выражения `match` завершено, его область видимости заканчивается, и заканчивается область видимости внутренней переменной `y`. Последний вызов `println!` [6] выводит `at the end: x = Some(5), y = 10`.

Чтобы создать выражение `match`, которое сравнивает значения внешних переменных `x` и `y`, вместо введения скрывающей переменной, нам нужно будет использовать условный оператор - охранник (match guard). Мы поговорим об охранниках `match` в разделе "Дополнительные условия с помощью охранников `match` (Extra Conditionals with Match Guards)".
