# 通过以下划线开头来创建未使用的变量

如果你创建了一个变量但在任何地方都不使用它，Rust通常会发出警告，因为未使用的变量可能是一个错误。然而，有时能够创建一个你尚未使用的变量是很有用的，比如在你进行原型设计或刚开始一个项目的时候。在这种情况下，你可以通过以下划线开头来告诉Rust不要因为未使用该变量而警告你。在清单18-20中，我们创建了两个未使用的变量，但当我们编译这段代码时，我们应该只会收到关于其中一个变量的警告。

文件名：`src/main.rs`

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

清单18-20：以下划线开头来创建变量以避免收到未使用变量的警告

在这里，我们收到了关于未使用变量 `y` 的警告，但没有收到关于未使用 `_x` 的警告。

请注意，仅使用 `_` 和以下划线开头的名称之间存在细微差别。语法 `_x` 仍然会将值绑定到变量，而 `_` 根本不会绑定。为了展示这种区别很重要的情况，清单18-21会给我们一个错误。

文件名：`src/main.rs`

```rust
let s = Some(String::from("Hello!"));

if let Some(_s) = s {
    println!("found a string");
}

println!("{:?}", s);
```

清单18-21：以下划线开头的未使用变量仍然会绑定值，这可能会获取该值的所有权。

我们会收到一个错误，因为 `s` 的值仍然会被移动到 `_s` 中，这会阻止我们再次使用 `s`。然而，单独使用下划线永远不会绑定到值。清单18-22会编译通过且没有任何错误，因为 `s` 不会被移动到 `_` 中。

文件名：`src/main.rs`

```rust
let s = Some(String::from("Hello!"));

if let Some(_) = s {
    println!("found a string");
}

println!("{:?}", s);
```

清单18-22：使用下划线不会绑定值。

这段代码运行得很好，因为我们从未将 `s` 绑定到任何东西；它没有被移动。
