# 解构结构体

清单 18-12 展示了一个名为 `Point` 的结构体，它有两个字段 `x` 和 `y`，我们可以使用带有 `let` 语句的模式来拆解它。

文件名：`src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

清单 18-12：将结构体的字段解构为单独的变量

这段代码创建了变量 `a` 和 `b`，它们与结构体 `p` 的 `x` 和 `y` 字段的值相匹配。这个例子表明，模式中的变量名不必与结构体的字段名匹配。然而，通常会将变量名与字段名匹配，以便更容易记住哪些变量来自哪些字段。由于这种常见用法，并且因为编写 `let Point { x: x, y: y } = p;` 包含大量重复，Rust 有一种用于匹配结构体字段的模式的简写形式：你只需要列出结构体字段的名称，从模式创建的变量将具有相同的名称。清单 18-13 的行为与清单 18-12 中的代码相同，但在 `let` 模式中创建的变量是 `x` 和 `y`，而不是 `a` 和 `b`。

文件名：`src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

清单 18-13：使用结构体字段简写形式解构结构体字段

这段代码创建了变量 `x` 和 `y`，它们与变量 `p` 的 `x` 和 `y` 字段相匹配。结果是变量 `x` 和 `y` 包含了来自结构体 `p` 的值。

我们还可以在结构体模式中使用字面量值进行解构，而不是为所有字段创建变量。这样做可以让我们在创建用于解构其他字段的变量时，测试某些字段是否具有特定值。

在清单 18-14 中，我们有一个 `match` 表达式，它将 `Point` 值分为三种情况：直接位于 `x` 轴上的点（当 `y = 0` 时为真）、位于 `y` 轴上的点（`x = 0`）或不在任何轴上的点。

文件名：`src/main.rs`

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

清单 18-14：在一个模式中解构并匹配字面量值

第一个分支将匹配任何位于 `x` 轴上的点，方法是指定如果 `y` 字段的值与字面量 `0` 匹配，则该字段匹配。该模式仍然会创建一个 `x` 变量，我们可以在该分支的代码中使用它。

类似地，第二个分支通过指定如果 `x` 字段的值为 `0`，则该字段匹配，并为 `y` 字段的值创建一个变量 `y`，来匹配任何位于 `y` 轴上的点。第三个分支没有指定任何字面量，因此它匹配任何其他 `Point`，并为 `x` 和 `y` 字段都创建变量。

在这个例子中，值 `p` 由于 `x` 包含 `0` 而与第二个分支匹配，所以这段代码将打印 `On the y axis at 7`。

请记住，`match` 表达式一旦找到第一个匹配的模式，就会停止检查其他分支，所以即使 `Point { x: 0, y: 0}` 既在 `x` 轴上又在 `y` 轴上，这段代码也只会打印 `On the x axis at 0`。
