# 使用匹配守卫进行额外条件判断

匹配守卫（match guard）是在 `match` 分支的模式之后指定的一个额外的 `if` 条件，只有当该条件也匹配时，这个分支才会被选中。匹配守卫对于表达比单独一个模式更复杂的想法很有用。

该条件可以使用在模式中创建的变量。清单 18-26 展示了一个 `match`，其中第一个分支的模式是 `Some(x)`，并且还有一个匹配守卫 `if x % 2 == 0`（如果数字是偶数，该条件将为 `true`）。

文件名：`src/main.rs`

```rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {x} is even"),
    Some(x) => println!("The number {x} is odd"),
    None => (),
}
```

清单 18-26：给模式添加匹配守卫

这个示例将打印 `The number 4 is even`。当 `num` 与第一个分支的模式进行比较时，它匹配，因为 `Some(4)` 匹配 `Some(x)`。然后匹配守卫检查 `x` 除以 2 的余数是否等于 0，因为等于 0，所以选择第一个分支。

如果 `num` 是 `Some(5)`，那么第一个分支中的匹配守卫将为 `false`，因为 5 除以 2 的余数是 1，不等于 0。然后 Rust 会转到第二个分支，该分支会匹配，因为第二个分支没有匹配守卫，因此可以匹配任何 `Some` 变体。

无法在模式中表达 `if x % 2 == 0` 这个条件，所以匹配守卫让我们有能力表达这个逻辑。这种额外表达能力的缺点是，当涉及到匹配守卫表达式时，编译器不会尝试检查是否穷举。

在清单 18-11 中，我们提到可以使用匹配守卫来解决模式遮蔽问题。回想一下，我们在 `match` 表达式的模式中创建了一个新变量，而不是使用 `match` 外部的变量。那个新变量意味着我们无法针对外部变量的值进行测试。清单 18-27 展示了如何使用匹配守卫来解决这个问题。

文件名：`src/main.rs`

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {y}", x);
}
```

清单 18-27：使用匹配守卫来测试与外部变量是否相等

这段代码现在将打印 `Default case, x = Some(5)`。第二个匹配分支中的模式不会引入一个新的变量 `y` 来遮蔽外部的 `y`，这意味着我们可以在匹配守卫中使用外部的 `y`。我们没有将模式指定为 `Some(y)`（那样会遮蔽外部的 `y`），而是指定为 `Some(n)`。这创建了一个新变量 `n`，它不会遮蔽任何东西，因为在 `match` 外部没有 `n` 变量。

匹配守卫 `if n == y` 不是一个模式，因此不会引入新变量。这个 `y` 就是外部的 `y`，而不是一个新的被遮蔽的 `y`，并且我们可以通过将 `n` 与 `y` 进行比较来查找与外部 `y` 值相同的值。

你还可以在匹配守卫中使用逻辑或运算符 `|` 来指定多个模式；匹配守卫条件将应用于所有模式。清单 18-28 展示了在将使用 `|` 的模式与匹配守卫组合时的优先级。这个示例的重点是，`if y` 匹配守卫适用于 `4`、`5` 和 `6`，尽管看起来 `if y` 只适用于 `6`。

文件名：`src/main.rs`

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

清单 18-28：将多个模式与匹配守卫组合

匹配条件表明，只有当 `x` 的值等于 `4`、`5` 或 `6` 并且 `y` 为 `true` 时，该分支才匹配。当这段代码运行时，第一个分支的模式匹配，因为 `x` 是 `4`，但匹配守卫 `if y` 为 `false`，所以不选择第一个分支。代码继续执行到第二个分支，该分支确实匹配，并且这个程序打印 `no`。原因是 `if` 条件适用于整个模式 `4 | 5 | 6`，而不仅仅是最后一个值 `6`。换句话说，匹配守卫相对于模式的优先级行为如下：

```rust
(4 | 5 | 6) if y =>...
```

而不是这样：

```rust
4 | 5 | (6 if y) =>...
```

运行代码后，优先级行为就很明显了：如果匹配守卫仅应用于使用 `|` 运算符指定的值列表中的最后一个值，那么该分支就会匹配，程序就会打印 `yes`。
