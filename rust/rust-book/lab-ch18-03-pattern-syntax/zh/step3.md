# 匹配命名变量

命名变量是不可反驳的模式，可匹配任何值，并且我们在本书中已经多次使用它们。但是，当你在 `match` 表达式中使用命名变量时，会有一个复杂的情况。因为 `match` 会开启一个新的作用域，在 `match` 表达式内部作为模式一部分声明的变量会遮蔽 `match` 结构外部具有相同名称的变量，所有变量都是如此。在清单 18-11 中，我们声明了一个值为 `Some(5)` 的名为 `x` 的变量和一个值为 `10` 的变量 `y`。然后我们对 `x` 的值创建一个 `match` 表达式。查看 `match` 分支中的模式以及最后的 `println!`，在运行这段代码或继续阅读之前，试着弄清楚这段代码会打印什么。

文件名：`src/main.rs`

```rust
fn main() {
  1 let x = Some(5);
  2 let y = 10;

    match x {
      3 Some(50) => println!("Got 50"),
      4 Some(y) => println!("Matched, y = {y}"),
      5 _ => println!("Default case, x = {:?}", x),
    }

  6 println!("at the end: x = {:?}, y = {y}", x);
}
```

清单 18-11：一个 `match` 表达式，其中一个分支引入了一个被遮蔽的变量 `y`

让我们逐步分析 `match` 表达式运行时会发生什么。第一个 `match` 分支 \[3\] 中的模式与定义的 `x` 的值 \[1\] 不匹配，所以代码继续执行。

第二个 `match` 分支 \[4\] 中的模式引入了一个名为 `y` 的新变量，它将匹配 `Some` 值内的任何值。因为我们处于 `match` 表达式内部的一个新作用域中，这是一个新的 `y` 变量，而不是我们在开头声明的那个值为 `10` 的 `y` \[2\]。这个新的 `y` 绑定将匹配 `Some` 内的任何值，这正是我们在 `x` 中所拥有的。因此，这个新的 `y` 绑定到 `x` 中 `Some` 的内部值。那个值是 `5`，所以该分支的表达式会执行并打印 `Matched, y = 5`。

如果 `x` 是 `None` 值而不是 `Some(5)`，前两个分支中的模式将不匹配，所以值将匹配到下划线 \[5\]。我们在 `_` 分支的模式中没有引入 `x` 变量，所以表达式中的 `x` 仍然是未被遮蔽的外部 `x`。在这个假设的情况下，`match` 将打印 `Default case, x = None`。

当 `match` 表达式完成时，它的作用域结束，内部 `y` 的作用域也结束。最后的 `println!` \[6\] 会输出 `at the end: x = Some(5), y = 10`。

要创建一个比较外部 `x` 和 `y` 值的 `match` 表达式，而不是引入一个被遮蔽的变量，我们需要使用匹配守卫条件。我们将在“使用匹配守卫的额外条件”中讨论匹配守卫。
