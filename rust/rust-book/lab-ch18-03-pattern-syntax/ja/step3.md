# 名前付き変数のマッチング

名前付き変数は、どんな値ともマッチする否定不能なパターンであり、この本では何度も使用してきました。ただし、`match` 式で名前付き変数を使用すると、少し複雑なことが起こります。`match` は新しいスコープを開始するため、`match` 式の中でパターンの一部として宣言された変数は、`match` 構造の外で同じ名前の変数を影に隠します。これはすべての変数に当てはまります。リスト18-11では、値 `Some(5)` を持つ `x` という名前の変数と値 `10` を持つ `y` という変数を宣言しています。その後、値 `x` に対する `match` 式を作成します。`match` アームのパターンと最後の `println!` を見て、このコードを実行する前やさらに読み進める前に、コードが何を出力するかを考えてみてください。

ファイル名: `src/main.rs`

```rust
fn main() {
  1 let x = Some(5);
  2 let y = 10;

    match x {
      3 Some(50) => println!("Got 50"),
      4 Some(y) => println!("Matched, y = {y}"),
      5 _ => println!("Default case, x = {:?}", x),
    }

  6 println!("at the end: x = {:?}, y = {y}", x);
}
```

リスト18-11: 影に隠された変数 `y` を導入する `match` 式

`match` 式が実行されたときに何が起こるかを追ってみましょう。最初の `match` アーム \[3\] のパターンは、定義された `x` の値 \[1\] と一致しないため、コードは続行されます。

2番目の `match` アーム \[4\] のパターンは、`Some` 値の中のどんな値とも一致する新しい変数 `y` を導入します。`match` 式の中で新しいスコープにいるため、これは新しい `y` 変数であり、最初に値 `10` で宣言した `y` \[2\] ではありません。この新しい `y` バインドは、`Some` の中のどんな値とも一致します。これは、`x` に含まれている値です。したがって、この新しい `y` は、`x` の `Some` の内側の値にバインドされます。その値は `5` であるため、そのアームの式が実行され、`Matched, y = 5` が出力されます。

`x` が `Some(5)` ではなく `None` 値であった場合、最初の2つのアームのパターンは一致しないため、値はアンダースコアに一致します \[5\]。アンダースコアアームのパターンで `x` 変数を導入していないため、式内の `x` はまだ影に隠されていない外側の `x` です。この仮想的な場合では、`match` は `Default case, x = None` を出力します。

`match` 式が終了すると、そのスコープと内側の `y` のスコープも終了します。最後の `println!` \[6\] は `at the end: x = Some(5), y = 10` を生成します。

影に隠された変数を導入する代わりに、外側の `x` と `y` の値を比較する `match` 式を作成するには、代わりにマッチガード条件を使用する必要があります。「マッチガードによる追加条件」でマッチガードについて説明します。