# 構造体の分解

リスト18-12は、2つのフィールド `x` と `y` を持つ `Point` 構造体を示しており、`let` 文を使ったパターンで分解することができます。

ファイル名: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

リスト18-12: 構造体のフィールドを個別の変数に分解する

このコードは、`p` 構造体の `x` と `y` フィールドの値と一致する `a` と `b` の変数を作成します。この例は、パターン内の変数の名前が構造体のフィールド名と一致する必要はないことを示しています。ただし、どの変数がどのフィールドから来たかを覚えやすくするために、変数名をフィールド名と一致させるのが一般的です。この一般的な使い方のために、また `let Point { x: x, y: y } = p;` を書くのは重複が多いため、Rustには構造体フィールドとマッチするパターンの省略形があります。構造体フィールドの名前を単に列挙するだけで、パターンから作成される変数は同じ名前になります。リスト18-13は、リスト18-12のコードと同じように動作しますが、`let` パターンで作成される変数は `a` と `b` ではなく `x` と `y` です。

ファイル名: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

リスト18-13: 構造体フィールドの省略形を使った構造体の分解

このコードは、`p` 変数の `x` と `y` フィールドと一致する `x` と `y` の変数を作成します。結果として、`x` と `y` の変数には `p` 構造体の値が含まれます。

また、すべてのフィールドに変数を作成する代わりに、構造体パターンの一部としてリテラル値で分解することもできます。これにより、一部のフィールドを特定の値に対してテストしながら、他のフィールドを分解するための変数を作成できます。

リスト18-14では、`match` 式があり、`Point` 値を3つのケースに分けています。`x` 軸上にある点（`y = 0` のときが真）、`y` 軸上にある点（`x = 0`）、どちらの軸上にもない点です。

ファイル名: `src/main.rs`

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

リスト18-14: 1つのパターンでリテラル値を分解してマッチする

最初のアームは、`y` フィールドの値がリテラル `0` と一致する場合にマッチするように指定することで、`x` 軸上にある任意の点をマッチします。このパターンは、このアームのコードで使用できる `x` 変数も作成します。

同様に、2番目のアームは、`x` フィールドの値が `0` の場合にマッチするように指定することで、`y` 軸上にある任意の点をマッチし、`y` フィールドの値に対して `y` 変数を作成します。3番目のアームは、リテラルを指定していないため、任意の他の `Point` とマッチし、`x` と `y` の両方のフィールドに対して変数を作成します。

この例では、`x` に `0` が含まれているため、値 `p` は2番目のアームとマッチします。したがって、このコードは `On the y axis at 7` を出力します。

`match` 式は、最初に一致するパターンを見つけるとアームのチェックを停止することを忘れないでください。したがって、`Point { x: 0, y: 0}` は `x` 軸と `y` 軸の両方にあるにもかかわらず、このコードは `On the x axis at 0` のみを出力します。