# 構造体のデストラクチャリング

リスト 18-12 は、2 つのフィールド `x` と `y` を持つ `Point` 構造体を示しています。これらのフィールドは、`let` 文を使ったパターンで分解することができます。

ファイル名：`src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
```

リスト 18-12: 構造体のフィールドを個別の変数に分解する

このコードは、`p` 構造体の `x` と `y` フィールドの値にマッチする変数 `a` と `b` を作成します。この例は、パターン内の変数名が構造体のフィールド名と一致する必要がないことを示しています。ただし、どの変数がどのフィールドから来たかを覚えやすくするために、変数名をフィールド名と一致させるのが一般的です。この一般的な使い方のため、また `let Point { x: x, y: y } = p;` と書くと重複が多くなるため、Rust には構造体フィールドにマッチするパターンの省略記法があります。構造体フィールドの名前を列挙するだけで、パターンから作成される変数は同じ名前になります。リスト 18-13 は、リスト 18-12 のコードと同じように動作しますが、`let` パターンで作成される変数は `a` と `b` ではなく `x` と `y` です。

ファイル名：`src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

リスト 18-13: 構造体フィールドの省略記法を使って構造体フィールドを分解する

このコードは、`p` 変数の `x` と `y` フィールドにマッチする変数 `x` と `y` を作成します。結果として、変数 `x` と `y` には `p` 構造体の値が含まれます。

また、すべてのフィールドに変数を作成するのではなく、構造体パターンの一部としてリテラル値を使ってデストラクチャリングすることもできます。これにより、一部のフィールドが特定の値に一致するかどうかをテストしながら、他のフィールドを分解する変数を作成することができます。

リスト 18-14 では、`Point` 値を 3 つのケースに分ける `match` 式があります。`x` 軸上にある点（`y = 0` の場合）、`y` 軸上にある点（`x = 0` の場合）、どちらの軸上にもない点です。

ファイル名：`src/main.rs`

```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {x}"),
        Point { x: 0, y } => println!("On the y axis at {y}"),
        Point { x, y } => {
            println!("On neither axis: ({x}, {y})");
        }
    }
}
```

リスト 18-14: 1 つのパターンでリテラル値を分解してマッチさせる

最初のアームは、`y` フィールドの値がリテラル `0` に一致する場合にマッチすることで、`x` 軸上にある任意の点にマッチします。このパターンは、このアームのコードで使用できる `x` 変数も作成します。

同様に、2 番目のアームは、`x` フィールドの値が `0` の場合にマッチすることで、`y` 軸上にある任意の点にマッチし、`y` フィールドの値に対する変数 `y` を作成します。3 番目のアームはリテラルを指定していないため、他の任意の `Point` にマッチし、`x` と `y` の両方のフィールドに対する変数を作成します。

この例では、値 `p` は `x` が `0` であるため 2 番目のアームにマッチするので、このコードは `On the y axis at 7` を出力します。

`match` 式は最初にマッチするパターンを見つけるとアームのチェックを停止することを忘れないでください。したがって、`Point { x: 0, y: 0}` は `x` 軸と `y` 軸の両方にありますが、このコードは `On the x axis at 0` のみを出力します。
