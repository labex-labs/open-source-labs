# `@` バインディング

「at演算子」である `@` を使うと、パターンマッチに対して値をテストすると同時に、その値を保持する変数を作成できます。リスト18-29では、`Message::Hello` の `id` フィールドが `3..=7` の範囲内であることをテストしたいとします。また、その値を `id_variable` という変数にバインドして、アームに関連付けられたコードで使用できるようにしたいとします。この変数には、フィールドと同じ名前である `id` を付けることができますが、この例では別の名前を使用します。

ファイル名: `src/main.rs`

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7,
    } => println!("Found an id in range: {id_variable}"),
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    }
    Message::Hello { id } => println!("Some other id: {id}"),
}
```

リスト18-29: パターン内の値にバインドするために `@` を使用しながら、その値をテストする

この例では、`Found an id in range: 5` が出力されます。範囲 `3..=7` の前に `id_variable @` を指定することで、範囲に一致する値をキャプチャしながら、その値が範囲パターンに一致することもテストしています。

2番目のアームでは、パターンに指定されたのは範囲のみであるため、そのアームに関連付けられたコードには、`id` フィールドの実際の値を含む変数がありません。`id` フィールドの値は10、11、または12のいずれかであった可能性がありますが、そのパターンに関連付けられたコードは、どれがそれであるかを知りません。パターンコードは、`id` 値を変数に保存していないため、`id` フィールドの値を使用することができません。

最後のアームでは、範囲なしで変数を指定しています。この場合、`id` という名前の変数で、アームのコードで使用できる値があります。理由は、構造体フィールドの省略構文を使用しているからです。ただし、このアームでは、最初の2つのアームのように、`id` フィールドの値に対してテストを行っていません。どんな値でもこのパターンに一致します。

`@` を使用することで、1つのパターン内で値をテストして変数に保存することができます。