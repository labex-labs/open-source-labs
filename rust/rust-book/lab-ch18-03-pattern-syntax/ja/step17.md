# `@` バインディング

_アット演算子_ `@` を使用すると、値をパターンマッチングでテストすると同時に、その値を保持する変数を作成することができます。リスト 18 - 29 では、`Message::Hello` の `id` フィールドが `3..=7` の範囲内にあることをテストしたいとします。また、その値を変数 `id_variable` に束縛して、アームに関連付けられたコードで使用できるようにしたいとします。この変数を `id`（フィールド名と同じ）と名付けることもできますが、この例では別の名前を使用します。

ファイル名：`src/main.rs`

```rust
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        id: id_variable @ 3..=7,
    } => println!("Found an id in range: {id_variable}"),
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    }
    Message::Hello { id } => println!("Some other id: {id}"),
}
```

リスト 18 - 29: `@` を使用してパターン内の値をテストしながら変数に束縛する

この例では、`Found an id in range: 5` と出力されます。範囲 `3..=7` の前に `id_variable @` を指定することで、範囲にマッチした値をキャプチャすると同時に、その値が範囲パターンにマッチすることをテストしています。

2 番目のアームでは、パターンに範囲のみを指定しているため、アームに関連付けられたコードには `id` フィールドの実際の値を含む変数がありません。`id` フィールドの値は 10、11、または 12 である可能性がありますが、そのパターンに関連付けられたコードはどれであるかを知りません。パターンコードは `id` フィールドの値を使用することができません。なぜなら、`id` の値を変数に保存していないからです。

最後のアームでは、範囲を指定せずに変数を指定しているため、アームのコードで `id` という名前の変数を使用して値を利用できます。これは、構造体フィールドの省略記法を使用しているためです。ただし、このアームでは、最初の 2 つのアームのように `id` フィールドの値に対するテストを適用していません。つまり、どんな値でもこのパターンにマッチします。

`@` を使用することで、1 つのパターン内で値をテストし、変数に保存することができます。
