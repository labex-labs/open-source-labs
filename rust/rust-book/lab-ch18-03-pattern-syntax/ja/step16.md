# マッチガードによる追加の条件式

_マッチガード_ は、`match` アームのパターンの後に指定される追加の `if` 条件で、そのアームが選択されるためにはこの条件も満たさなければなりません。マッチガードは、パターンだけでは表現できないより複雑な条件を表現するのに便利です。

この条件式は、パターン内で作成された変数を使用することができます。リスト 18 - 26 は、最初のアームに `Some(x)` というパターンがあり、さらに `if x % 2 == 0` というマッチガードがある `match` の例です（この条件は、数値が偶数の場合に `true` になります）。

ファイル名：`src/main.rs`

```rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {x} is even"),
    Some(x) => println!("The number {x} is odd"),
    None => (),
}
```

リスト 18 - 26: パターンにマッチガードを追加する

この例では、`The number 4 is even` と出力されます。`num` が最初のアームのパターンと比較されるとき、`Some(4)` は `Some(x)` にマッチするため、マッチします。次に、マッチガードが `x` を 2 で割った余りが 0 かどうかを確認し、0 であるため、最初のアームが選択されます。

もし `num` が `Some(5)` だった場合、最初のアームのマッチガードは `false` になります。なぜなら、5 を 2 で割った余りは 1 で、0 と等しくないからです。その場合、Rust は 2 番目のアームに進み、2 番目のアームにはマッチガードがないため、任意の `Some` バリアントにマッチします。

`if x % 2 == 0` という条件をパターン内で表現することはできません。そのため、マッチガードを使用することでこのロジックを表現することができます。ただし、この追加の表現力には欠点もあります。マッチガード式が含まれる場合、コンパイラは網羅性のチェックを行いません。

リスト 18 - 11 では、マッチガードを使用してパターンのシャドウイングの問題を解決できることを述べました。`match` 式のパターン内で新しい変数を作成し、`match` の外の変数を使用しなかったことを思い出してください。その新しい変数のため、外側の変数の値と比較することができませんでした。リスト 18 - 27 は、マッチガードを使用してこの問題を解決する方法を示しています。

ファイル名：`src/main.rs`

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {y}", x);
}
```

リスト 18 - 27: 外側の変数との等価性をテストするためにマッチガードを使用する

このコードは、`Default case, x = Some(5)` と出力します。2 番目のマッチアームのパターンは、外側の `y` をシャドウする新しい変数 `y` を導入しません。つまり、マッチガードで外側の `y` を使用することができます。外側の `y` をシャドウする `Some(y)` というパターンを指定する代わりに、`Some(n)` を指定しています。これにより、`match` の外に `n` 変数がないため、何もシャドウしない新しい変数 `n` が作成されます。

マッチガード `if n == y` はパターンではないため、新しい変数を導入しません。この `y` は、新しいシャドウされた `y` ではなく、外側の `y` です。`n` を `y` と比較することで、外側の `y` と同じ値を持つ値を探すことができます。

また、マッチガードで _論理和_ 演算子 `|` を使用して、複数のパターンを指定することもできます。マッチガードの条件は、すべてのパターンに適用されます。リスト 18 - 28 は、`|` を使用したパターンとマッチガードを組み合わせたときの優先順位を示しています。この例の重要な点は、`if y` というマッチガードが `4`、`5`、そして `6` すべてに適用されることです。たとえ `if y` が `6` にのみ適用されるように見えるかもしれませんが。

ファイル名：`src/main.rs`

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

リスト 18 - 28: マッチガードと複数のパターンを組み合わせる

このマッチ条件は、`x` の値が `4`、`5`、または `6` であり、かつ `y` が `true` の場合にのみアームがマッチすることを示しています。このコードが実行されると、最初のアームのパターンは `x` が `4` であるためマッチしますが、マッチガード `if y` は `false` であるため、最初のアームは選択されません。コードは 2 番目のアームに進み、このアームはマッチするため、このプログラムは `no` と出力します。理由は、`if` 条件は `4 | 5 | 6` という全体のパターンに適用され、最後の値 `6` にのみ適用されるわけではないからです。言い換えると、パターンに対するマッチガードの優先順位は次のように動作します。

```rust
(4 | 5 | 6) if y =>...
```

次のようにではなく：

```rust
4 | 5 | (6 if y) =>...
```

コードを実行すると、優先順位の動作が明らかになります。もしマッチガードが `|` 演算子を使用して指定された値のリストの最後の値にのみ適用される場合、アームはマッチし、プログラムは `yes` と出力するでしょう。
