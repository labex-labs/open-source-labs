# マッチガードを使った追加の条件分岐

「マッチガード」は、`match` アーム内のパターンの後に指定される追加の `if` 条件であり、そのアームが選択されるためにはこの条件も一致する必要があります。マッチガードは、単なるパターンだけでは表現できないより複雑な考えを表現するのに役立ちます。

この条件は、パターンで作成された変数を使用することができます。リスト18-26は、最初のアームがパターン `Some(x)` を持ち、かつマッチガードが `if x % 2 == 0` である（数が偶数の場合、これは `true` になります）`match` を示しています。

ファイル名: `src/main.rs`

```rust
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {x} is even"),
    Some(x) => println!("The number {x} is odd"),
    None => (),
}
```

リスト18-26: パターンにマッチガードを追加する

この例では、`The number 4 is even` が出力されます。`num` が最初のアームのパターンと比較されるとき、`Some(4)` が `Some(x)` と一致するため、一致します。次に、マッチガードは `x` を2で割った余りが0に等しいかどうかをチェックし、そうであるため、最初のアームが選択されます。

もし `num` が代わりに `Some(5)` であった場合、最初のアームのマッチガードは `false` になります。なぜなら、5を2で割った余りは1であり、0に等しくないからです。その後、Rustは2番目のアームに移り、これは一致します。なぜなら、2番目のアームにはマッチガードがないため、任意の `Some` バリアントと一致するからです。

パターン内で `if x % 2 == 0` の条件を表現する方法はありません。したがって、マッチガードにより、このロジックを表現する能力が与えられます。この追加の表現力の欠点は、マッチガード式が含まれる場合、コンパイラは網羅性をチェックしようとしないことです。

リスト18-11では、パターンシャドーイングの問題を解決するためにマッチガードを使用できることを述べました。思い出してください。`match` 式のパターン内で、`match` の外側の変数を使用する代わりに新しい変数を作成しました。その新しい変数は、外側の変数の値をテストできないことを意味しました。リスト18-27は、この問題を解決するためにマッチガードをどのように使用できるかを示しています。

ファイル名: `src/main.rs`

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {n}"),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {y}", x);
}
```

リスト18-27: 外側の変数との等価性をテストするためにマッチガードを使用する

このコードは、今では `Default case, x = Some(5)` を出力します。2番目のマッチアームのパターンは、外側の `y` をシャドーイングする新しい変数 `y` を導入しません。これは、マッチガードで外側の `y` を使用できることを意味します。`Some(y)` としてパターンを指定する代わりに（これは外側の `y` をシャドーイングします）、`Some(n)` と指定します。これにより、`match` の外側に `n` 変数がないため、何もシャドーイングしない新しい変数 `n` が作成されます。

マッチガード `if n == y` はパターンではないため、新しい変数を導入しません。この `y` は外側の `y` であり、新しいシャドーイングされた `y` ではありません。`n` と `y` を比較することで、外側の `y` と同じ値を持つ値を探すことができます。

また、マッチガードで _論理和演算子_ `|` を使用して、複数のパターンを指定することもできます。マッチガード条件は、すべてのパターンに適用されます。リスト18-28は、`|` を使用するパターンとマッチガードを組み合わせたときの優先順位を示しています。この例の重要な部分は、`if y` のマッチガードが、`if y` が `6` にのみ適用されるように見える場合でも、`4`、`5`、_および_ `6` に適用されることです。

ファイル名: `src/main.rs`

```rust
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

リスト18-28: マッチガードと複数のパターンを組み合わせる

マッチ条件は、`x` の値が `4`、`5`、または `6` _かつ_ `y` が `true` の場合にのみ、そのアームが一致することを示しています。このコードが実行されると、最初のアームのパターンが一致します。なぜなら、`x` が `4` だからです。しかし、マッチガード `if y` は `false` であるため、最初のアームは選択されません。コードは2番目のアームに移り、これは一致します。そして、このプログラムは `no` を出力します。理由は、`if` 条件がパターン全体 `4 | 5 | 6` に適用されるため、最後の値 `6` にのみ適用されるわけではないからです。言い換えると、マッチガードのパターンに対する優先順位は、次のようになります。

```rust
(4 | 5 | 6) if y =>...
```

これよりもこうではありません。

```rust
4 | 5 | (6 if y) =>...
```

コードを実行した後、優先順位の動作は明らかです。もし、マッチガードが `|` 演算子を使用して指定された値のリストの最後の値にのみ適用される場合、そのアームは一致し、プログラムは `yes` を出力したでしょう。