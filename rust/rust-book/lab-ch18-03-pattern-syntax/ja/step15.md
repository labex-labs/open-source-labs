# `..` を使った値の残りの部分の無視

多くの部分を持つ値では、特定の部分を使用して残りを無視するために、`..` 構文を使用できます。これにより、各無視する値に対してアンダースコアを列挙する必要がなくなります。`..` パターンは、パターンの残りの部分で明示的にマッチしていない値の任意の部分を無視します。リスト18-23では、3次元空間内の座標を保持する `Point` 構造体を持っています。`match` 式では、`x` 座標のみに対して操作を行い、`y` と `z` フィールドの値を無視したいとします。

ファイル名: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x,.. } => println!("x is {x}"),
}
```

リスト18-23: `..` を使って `Point` の `x` 以外のすべてのフィールドを無視する

`x` の値を列挙し、その後 `..` パターンを含めます。これは、`y: _` と `z: _` を列挙するよりも速く、特に1つまたは2つのフィールドのみが関連する場合に多くのフィールドを持つ構造体を扱う際に便利です。

構文 `..` は必要なだけ多くの値に展開されます。リスト18-24は、タプルで `..` をどのように使用するかを示しています。

ファイル名: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first,.., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
```

リスト18-24: タプルの最初と最後の値のみをマッチさせ、それ以外のすべての値を無視する

このコードでは、最初と最後の値が `first` と `last` にマッチします。`..` は中間のすべての値をマッチさせて無視します。

ただし、`..` を使用する場合、曖昧さがない必要があります。どの値がマッチするために意図され、どの値が無視されるべきかが不明確な場合、Rustはエラーを表示します。リスト18-25は、曖昧に `..` を使用する例を示しており、コンパイルされません。

ファイル名: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second,..) => {
            println!("Some numbers: {second}");
        },
    }
}
```

リスト18-25: 曖昧な方法で `..` を使用しようとする

この例をコンパイルすると、次のエラーが表示されます。

```bash
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second,..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here
```

`second` と値をマッチさせる前にタプル内のどれだけの値を無視するか、その後さらにどれだけの値を無視するかをRustが判断することは不可能です。このコードは、`2` を無視して `second` に `4` をバインドし、その後 `8`、`16`、`32` を無視することを意味するかもしれません。または、`2` と `4` を無視して `second` に `8` をバインドし、その後 `16` と `32` を無視することを意味するかもしれません。などです。変数名 `second` はRustにとって特別な意味を持たないため、このように2つの場所で `..` を使用すると曖昧になるため、コンパイラエラーが表示されます。