# `..` で値の残りの部分を無視する

多くの部分を持つ値に対しては、`..` 構文を使用して特定の部分を使用し、残りを無視することができます。これにより、無視する各値に対してアンダースコアを列挙する必要がなくなります。`..` パターンは、パターンの残りの部分で明示的にマッチさせていない値の部分をすべて無視します。リスト 18 - 23 では、3 次元空間の座標を保持する `Point` 構造体を持っています。`match` 式では、`x` 座標のみを操作し、`y` および `z` フィールドの値を無視したいとします。

ファイル名: `src/main.rs`

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x,.. } => println!("x is {x}"),
}
```

リスト 18 - 23: `..` を使用して `x` 以外の `Point` のすべてのフィールドを無視する

`x` の値を列挙し、その後に `..` パターンを含めます。これは、特に関連するフィールドが 1 つまたは 2 つだけの多くのフィールドを持つ構造体を扱う場合に、`y: _` と `z: _` を列挙するよりも迅速です。

`..` 構文は、必要なだけの値に展開されます。リスト 18 - 24 は、タプルで `..` を使用する方法を示しています。

ファイル名: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first,.., last) => {
            println!("Some numbers: {first}, {last}");
        }
    }
}
```

リスト 18 - 24: タプルの最初と最後の値のみをマッチさせ、他のすべての値を無視する

このコードでは、最初と最後の値が `first` と `last` にマッチします。`..` は中間のすべての値をマッチさせて無視します。

ただし、`..` の使用は明確でなければなりません。どの値がマッチさせる対象で、どの値を無視するかが不明確な場合、Rust はエラーを返します。リスト 18 - 25 は、`..` を曖昧に使用した例であり、コンパイルされません。

ファイル名: `src/main.rs`

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second,..) => {
            println!("Some numbers: {second}");
        },
    }
}
```

リスト 18 - 25: `..` を曖昧に使用しようとする試み

この例をコンパイルすると、次のエラーが表示されます。

```bash
error: `..` can only be used once per tuple pattern
 --> src/main.rs:5:22
  |
5 |         (.., second,..) => {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here
```

Rust は、値を `second` にマッチさせる前にタプル内のどれだけの値を無視し、その後さらにどれだけの値を無視するかを判断することができません。このコードは、`2` を無視し、`second` を `4` に束縛し、その後 `8`、`16`、`32` を無視することを意味する場合もあれば、`2` と `4` を無視し、`second` を `8` に束縛し、その後 `16` と `32` を無視することを意味する場合もあります。変数名 `second` は Rust にとって特別な意味を持たないため、このように 2 か所で `..` を使用すると曖昧になるため、コンパイラエラーが発生します。
