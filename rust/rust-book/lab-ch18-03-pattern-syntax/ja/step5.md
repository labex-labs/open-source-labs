# `..=` を使った値の範囲のマッチング

`..=` 構文を使用すると、包括的な値の範囲にマッチさせることができます。次のコードでは、パターンが指定された範囲内のいずれかの値とマッチすると、そのアームが実行されます。

ファイル名: `src/main.rs`

```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

`x` が `1`、`2`、`3`、`4`、または `5` の場合、最初のアームがマッチします。この構文は、同じ考えを `|` 演算子を使って表現するよりも、複数のマッチ値に対して便利です。`|` を使う場合、`1 | 2 | 3 | 4 | 5` と指定する必要があります。範囲を指定する方がはるかに短くなります。特に、1 から 1000 までの任意の数値にマッチさせたい場合などでは便利です。

コンパイラはコンパイル時に範囲が空でないことをチェックします。Rust が範囲が空かどうかを判断できる型は `char` と数値型のみなので、範囲は数値型または `char` 型の値でのみ使用できます。

以下は `char` 型の値の範囲を使用した例です。

ファイル名: `src/main.rs`

```rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```

Rust は `'c'` が最初のパターンの範囲内であることを判断し、`early ASCII letter` を出力します。
