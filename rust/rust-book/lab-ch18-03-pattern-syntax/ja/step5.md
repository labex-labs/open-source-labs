#..= を使った値の範囲のマッチング

`..=` 構文を使うと、値の包含範囲とマッチさせることができます。次のコードでは、パターンが指定された範囲内の値のいずれかと一致すると、そのアームが実行されます。

ファイル名: `src/main.rs`

```rust
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
```

`x` が `1`、`2`、`3`、`4`、または `5` の場合、最初のアームが一致します。この構文は、同じ考えを表現するために `|` 演算子を使うよりも、複数のマッチ値に対して便利です。`|` を使う場合、`1 | 2 | 3 | 4 | 5` を指定する必要があります。範囲を指定する方がはるかに短く、たとえば、1から1000の間の任意の数とマッチさせたい場合など、特に便利です！

コンパイラは、コンパイル時に範囲が空でないことをチェックします。Rustが範囲が空かどうかを判断できるのは、`char` 型と数値型のみなので、範囲は数値型または `char` 型の値のみで使用できます。

以下は、`char` 型の値の範囲を使った例です。

ファイル名: `src/main.rs`

```rust
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
```

Rustは、`'c'` が最初のパターンの範囲内にあることがわかり、`early ASCII letter` を出力します。