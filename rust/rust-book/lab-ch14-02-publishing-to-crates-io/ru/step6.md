# Экспорт удобного публичного API с использованием `pub use`

Структура вашего публичного API является важным аспектом при публикации коробки. Пользователи вашей коробки менее знакомы с ее структурой, чем вы, и могут иметь проблемы с поиском нужных элементов, если ваша коробка имеет большую иерархию модулей.

В главе 7 мы рассмотрели, как делать элементы публичными с использованием ключевого слова `pub` и как подтягивать элементы в область видимости с использованием ключевого слова `use`. Однако структура, которая имеет смысл для вас при разработке коробки, может быть не очень удобной для ваших пользователей. Вы можете хотеть организовать свои структуры в иерархию с несколькими уровнями, но тогда люди, которые хотят использовать тип, определенный глубоко в иерархии, могут иметь проблемы с обнаружением существования этого типа. Они также могут быть раздражены тем, что должны вводить `use my_crate::some_module::another_module::UsefulType;` вместо `use my_crate::UsefulType;`.

Хорошие новости заключаются в том, что если структура _не_ удобна для использования другими библиотеками, вы не должны перестраивать свою внутреннюю организацию: вместо этого вы можете переэкспортировать элементы, чтобы создать публичную структуру, которая отличается от вашей приватной структуры, используя `pub use`. _Переэкспорт_ берет публичный элемент в одном месте и делает его публичным в другом месте, как будто он был определен в другом месте.

Например, предположим, что мы создали библиотеку под названием `art` для моделирования художественных концепций. В этой библиотеке есть два модуля: модуль `kinds`, содержащий два перечисления под названием `PrimaryColor` и `SecondaryColor`, и модуль `utils`, содержащий функцию под названием `mix`, как показано в Списке 14-3.

Имя файла: `src/lib.rs`

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(
        c1: PrimaryColor,
        c2: PrimaryColor,
    ) -> SecondaryColor {
        --snip--
    }
}
```

Список 14-3: Библиотека `art` с элементами, организованными в модули `kinds` и `utils`

На рис. 14-3 показано, как будет выглядеть первая страница документации для этой коробки, сгенерированная с помощью `cargo doc`.

Рисунок 14-3: Первая страница документации для `art`, которая перечисляет модули `kinds` и `utils`

Заметим, что типы `PrimaryColor` и `SecondaryColor` не перечислены на первой странице, а также функция `mix` не перечислена. Мы должны нажать на `kinds` и `utils`, чтобы увидеть их.

Другая коробка, которая зависит от этой библиотеки, должна использовать инструкции `use`, чтобы подтянуть элементы из `art` в область видимости, указывая текущую определенную структуру модулей. Список 14-4 показывает пример коробки, которая использует элементы `PrimaryColor` и `mix` из коробки `art`.

Имя файла: `src/main.rs`

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

Список 14-4: Коробка, которая использует элементы коробки `art` с экспортом ее внутренней структуры

Автор кода в Списке 14-4, который использует коробку `art`, должен был понять, что `PrimaryColor` находится в модуле `kinds`, а `mix` находится в модуле `utils`. Структура модулей коробки `art` более важна для разработчиков, работающих над коробкой `art`, чем для тех, кто ее использует. Внутренняя структура не содержит полезной информации для тех, кто пытается понять, как использовать коробку `art`, а вместо этого вызывает путаницу, потому что разработчики, которые ее используют, должны определить, где искать, и должны указывать имена модулей в инструкциях `use`.

Чтобы удалить внутреннюю организацию из публичного API, мы можем изменить код коробки `art` в Списке 14-3, добавив инструкции `pub use`, чтобы переэкспортировать элементы на верхнем уровне, как показано в Списке 14-5.

Имя файла: `src/lib.rs`

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    --snip--
}

pub mod utils {
    --snip--
}
```

Список 14-5: Добавление инструкций `pub use` для переэкспорта элементов

Документация API, которую `cargo doc` генерирует для этой коробки, теперь будет перечислять и ссылаться на переэкспорты на первой странице, как показано на рис. 14-4, что делает типы `PrimaryColor` и `SecondaryColor` и функцию `mix`更容易找到。

Рисунок 14-4: Первая страница документации для `art`, которая перечисляет переэкспорты

Пользователи коробки `art` по-прежнему могут видеть и использовать внутреннюю структуру из Списка 14-3, как показано в Списке 14-4, или они могут использовать более удобную структуру из Списка 14-5, как показано в Списке 14-6.

Имя файла: `src/main.rs`

```rust
use art::mix;
use art::PrimaryColor;

fn main() {
    --snip--
}
```

Список 14-6: Программа, которая использует переэкспортированные элементы из коробки `art`

В случаях, когда есть много вложенных модулей, переэкспорт типов на верхнем уровне с использованием `pub use` может значительно улучшить опыт пользователей, которые используют коробку. Другое распространенное использование `pub use` - это переэкспорт определений зависимости в текущей коробке, чтобы определения этой коробки стали частью публичного API вашей коробки.

Создание полезной структуры публичного API - это больше искусство, чем наука, и вы можете поэкспериментировать, чтобы найти API, которое лучше всего подходит для ваших пользователей. Выбор `pub use` дает вам гибкость в организации внутренней структуры вашей коробки и позволяет отделить внутреннюю структуру от той, которую вы представляете пользователям. Посмотрите на часть кода некоторых установленных коробок, чтобы увидеть, отличается ли их внутренняя структура от их публичного API.
