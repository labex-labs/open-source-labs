# Deref トレイトを実装する

「型に対するトレイトの実装」で説明したように、トレイトを実装するには、トレイトの必要なメソッドの実装を提供する必要があります。標準ライブラリによって提供される`Deref`トレイトでは、`deref`という名前の 1 つのメソッドを実装する必要があります。このメソッドは`self`を借用し、内部データへの参照を返します。リスト 15-10 には、`MyBox<T>`の定義に追加する`Deref`の実装が含まれています。

ファイル名：`src/main.rs`

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
  1 type Target = T;

    fn deref(&self) -> &Self::Target {
      2 &self.0
    }
}
```

リスト 15-10: `MyBox<T>`に`Deref`を実装する

`type Target = T;`の構文\[1\]は、`Deref`トレイトが使用する関連型を定義します。関連型は、ジェネリックパラメータを宣言する少し異なる方法ですが、今は心配する必要はありません。第 19 章で詳細を説明します。

`deref`メソッドの本体を`&self.0`で埋めます。これにより、`deref`は`*`演算子でアクセスしたい値への参照を返します\[2\]。「名前付きフィールドなしのタプル構造体を使って異なる型を作成する」で学んだように、`.0`はタプル構造体の最初の値にアクセスします。リスト 15-9 の`main`関数で`MyBox<T>`値に対して`*`を呼び出すと、今はコンパイルされ、アサーションが通過します！

`Deref`トレイトがなければ、コンパイラは`&`参照のみを参照解除できます。`deref`メソッドにより、コンパイラは`Deref`を実装する任意の型の値を取り、`deref`メソッドを呼び出して、参照解除できる`&`参照を取得することができます。

リスト 15-9 で`*y`を入力したとき、裏で Rust は実際にこのコードを実行しました。

```rust
*(y.deref())
```

Rust は`*`演算子を`deref`メソッドの呼び出しに置き換え、その後単純な参照解除を行うため、`deref`メソッドを呼び出す必要があるかどうかを考える必要がありません。この Rust の機能により、通常の参照でも`Deref`を実装する型でも、同じように機能するコードを書くことができます。

`deref`メソッドが値への参照を返し、`*(y.deref())`の括弧外の単純な参照解除がまだ必要な理由は、所有権システムに関係しています。`deref`メソッドが値そのものではなく値への参照を返した場合、値は`self`から移動されてしまいます。この場合や、参照解除演算子を使用するほとんどの場合では、`MyBox<T>`内の内部値の所有権を取得したくありません。

コード内で`*`を使用するたびに、`*`演算子は`deref`メソッドの呼び出しに置き換えられ、その後`*`演算子の呼び出しに置き換えられます。`*`演算子の置き換えが無限に再帰しないため、最終的には`i32`型のデータが得られ、これはリスト 15-9 の`assert_eq!`の`5`と一致します。
