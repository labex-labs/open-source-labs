# 参照解除強制が不変性とどのように相互作用するか

不変参照における`*`演算子をオーバーライドするために`Deref`トレイトを使用する方法と同様に、可変参照における`*`演算子をオーバーライドするために`DerefMut`トレイトを使用することができます。

Rust は、3 つのケースで型とトレイトの実装を見つけたときに参照解除強制を行います。

- `T: Deref<Target=U>`の場合、`&T`から`&U`
- `T: DerefMut<Target=U>`の場合、`&mut T`から`&mut U`
- `T: Deref<Target=U>`の場合、`&mut T`から`&U`

最初の 2 つのケースは、2 番目のケースが可変性を実装している点を除いて同じです。最初のケースは、`&T`があり、`T`がある型`U`に対して`Deref`を実装している場合、透明に`&U`を取得できることを述べています。2 番目のケースは、可変参照に対しても同じ参照解除強制が行われることを述べています。

3 番目のケースはややこしいです。Rust はまた、可変参照を不変参照に強制変換します。しかし、逆は不可能です。不変参照は決して可変参照に強制変換されません。借用規則により、可変参照がある場合、その可変参照はそのデータへの唯一の参照でなければなりません（そうでなければ、プログラムはコンパイルされません）。1 つの可変参照を 1 つの不変参照に変換することは、借用規則を決して破壊しません。不変参照を可変参照に変換するには、最初の不変参照がそのデータへの唯一の不変参照である必要がありますが、借用規則はそれを保証しません。したがって、Rust は不変参照を可変参照に変換することが可能であると仮定することができません。
