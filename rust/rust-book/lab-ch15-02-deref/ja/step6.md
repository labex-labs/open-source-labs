# 関数とメソッドによる暗黙的な参照解除強制

参照解除強制は、`Deref`トレイトを実装する型への参照を別の型への参照に変換します。たとえば、参照解除強制は`&String`を`&str`に変換できます。なぜなら、`String`は`Deref`トレイトを実装しており、`&str`を返すからです。参照解除強制は、Rust が関数とメソッドの引数に対して行う便利な機能であり、`Deref`トレイトを実装する型にのみ機能します。関数またはメソッドの定義におけるパラメータ型と一致しない型の値への参照を関数またはメソッドの引数として渡すときに、自動的に行われます。`deref`メソッドへの一連の呼び出しにより、提供した型をパラメータが必要とする型に変換します。

参照解除強制は Rust に追加されたため、関数とメソッド呼び出しを書くプログラマは、`&`と`*`を使った明示的な参照と参照解除をそれほど多く追加する必要がなくなりました。参照解除強制機能により、参照またはスマートポインタのどちらでも動作するコードをより多く書くことができます。

参照解除強制の動作を見てみましょう。リスト 15-8 で定義した`MyBox<T>`型と、リスト 15-10 で追加した`Deref`の実装を使います。リスト 15-11 は、文字列スライスパラメータを持つ関数の定義を示しています。

ファイル名：`src/main.rs`

```rust
fn hello(name: &str) {
    println!("Hello, {name}!");
}
```

リスト 15-11: 型`&str`のパラメータ`name`を持つ`hello`関数

たとえば、`hello("Rust");`のように、文字列スライスを引数として`hello`関数を呼び出すことができます。参照解除強制により、`MyBox<String>`型の値への参照を使って`hello`を呼び出すことが可能になります。これはリスト 15-12 に示されています。

ファイル名：`src/main.rs`

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

リスト 15-12: 参照解除強制のおかげで動作する、`MyBox<String>`型の値への参照を使って`hello`を呼び出す

ここでは、引数`&m`で`hello`関数を呼び出しています。これは`MyBox<String>`型の値への参照です。リスト 15-10 で`MyBox<T>`に`Deref`トレイトを実装したため、Rust は`deref`を呼び出すことで`&MyBox<String>`を`&String`に変換することができます。標準ライブラリは`String`に対して`Deref`の実装を提供しており、文字列スライスを返します。これは`Deref`の API ドキュメントに記載されています。Rust はさらに`deref`を呼び出して`&String`を`&str`に変換し、これが`hello`関数の定義と一致します。

Rust が参照解除強制を実装していなかった場合、`&MyBox<String>`型の値で`hello`を呼び出すには、リスト 15-13 のコードのように書かなければなりません。

ファイル名：`src/main.rs`

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

リスト 15-13: Rust に参照解除強制がなかった場合に書かなければならないコード

`(*m)`は`MyBox<String>`を`String`に参照解除します。その後、`&`と`[..]`は、文字列全体と等しい`String`の文字列スライスを取得して、`hello`のシグネチャに一致させます。これらの記号がすべて含まれるため、参照解除強制がないこのコードは読みにくく、書きにくく、理解しにくいです。参照解除強制により、Rust がこれらの変換を自動的に処理してくれます。

関係する型に対して`Deref`トレイトが定義されている場合、Rust は型を分析し、パラメータの型と一致する参照を取得するために必要なだけ`Deref::deref`を何度も使用します。`Deref::deref`を挿入する必要のある回数はコンパイル時に解決されるため、参照解除強制を利用することによる実行時のペナルティはありません！
