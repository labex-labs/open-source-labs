# 跟随指针找到值

普通引用是一种指针类型，而将指针看作是指向存储在其他地方的值的箭头是一种思考方式。在清单 15-6 中，我们创建了一个指向 `i32` 值的引用，然后使用解引用运算符来跟随该引用找到值。

文件名：`src/main.rs`

```rust
fn main() {
  1 let x = 5;
  2 let y = &x;

  3 assert_eq!(5, x);
  4 assert_eq!(5, *y);
}
```

清单 15-6：使用解引用运算符跟随指向 `i32` 值的引用

变量 `x` 存储了一个 `i32` 值 `5` （第 1 行）。我们将 `y` 设置为指向 `x` 的引用（第 2 行）。我们可以断言 `x` 等于 `5` （第 3 行）。然而，如果我们想要对 `y` 中的值进行断言，我们必须使用 `*y` 来跟随引用找到它所指向的值（即解引用），这样编译器才能比较实际的值（第 4 行）。一旦我们对 `y` 进行解引用，我们就可以访问 `y` 所指向的整数值，然后将其与 `5` 进行比较。

如果我们尝试写成 `assert_eq!(5, y);`，我们会得到如下编译错误：

```bash
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} ==
&{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented
for `{integer}`
```

不允许比较一个数字和一个指向数字的引用，因为它们是不同的类型。我们必须使用解引用运算符来跟随引用找到它所指向的值。
