# 实现 Deref 特性

如“在类型上实现特性”中所讨论的，要实现一个特性，我们需要为该特性的所需方法提供实现。标准库提供的 `Deref` 特性要求我们实现一个名为 `deref` 的方法，该方法借用 `self` 并返回对内部数据的引用。清单 15-10 包含了一个要添加到 `MyBox<T>` 定义中的 `Deref` 实现。

文件名：`src/main.rs`

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
  1 type Target = T;

    fn deref(&self) -> &Self::Target {
      2 &self.0
    }
}
```

清单 15-10：在 `MyBox<T>` 上实现 `Deref`

`type Target = T;` 语法（第 1 行）为 `Deref` 特性定义了一个关联类型以供使用。关联类型是声明泛型参数的一种稍有不同的方式，但目前你无需担心；我们将在第 19 章更详细地介绍它们。

我们在 `deref` 方法的主体中填入 `&self.0`，这样 `deref` 就返回一个对我们想用 `*` 运算符访问的值的引用（第 2 行）；回想一下“使用没有命名字段的元组结构体创建不同类型”，`.0` 用于访问元组结构体中的第一个值。清单 15-9 中对 `MyBox<T>` 值调用 `*` 的 `main` 函数现在可以编译了，并且断言通过！

如果没有 `Deref` 特性，编译器只能对 `&` 引用进行解引用。`deref` 方法让编译器能够获取任何实现了 `Deref` 的类型的值，并调用 `deref` 方法以获得一个它知道如何解引用的 `&` 引用。

当我们在清单 15-9 中输入 `*y` 时，在幕后 Rust 实际上运行了这段代码：

```rust
*(y.deref())
```

Rust 用对 `deref` 方法的调用替换 `*` 运算符，然后进行一次普通的解引用，这样我们就不必考虑是否需要调用 `deref` 方法。这个 Rust 特性让我们编写的代码，无论使用的是普通引用还是实现了 `Deref` 的类型，其功能都是相同的。

`deref` 方法返回对一个值的引用，并且在 `*(y.deref())` 中括号外的普通解引用仍然是必要的，这与所有权系统有关。如果 `deref` 方法直接返回值而不是对值的引用，那么值就会从 `self` 中被移出。在这种情况下，或者在大多数我们使用解引用运算符的情况下，我们都不想获取 `MyBox<T>` 内部值的所有权。

请注意，每次我们在代码中使用 `*` 时，`*` 运算符都会被替换为对 `deref` 方法的调用，然后再进行一次对 `*` 运算符的调用。因为 `*` 运算符的替换不会无限递归，所以最终我们得到的是 `i32` 类型的数据，这与清单 15-9 中 `assert_eq!` 里的 `5` 相匹配。
