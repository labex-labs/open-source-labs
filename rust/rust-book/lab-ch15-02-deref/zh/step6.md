# 函数和方法中的隐式解引用强制转换

**解引用强制转换** 将对实现了 `Deref` 特性的类型的引用转换为对另一种类型的引用。例如，解引用强制转换可以将 `&String` 转换为 `&str`，因为 `String` 实现了 `Deref` 特性，使其返回 `&str`。解引用强制转换是 Rust 对函数和方法的参数执行的一种便利操作，并且仅适用于实现了 `Deref` 特性的类型。当我们将对特定类型值的引用作为参数传递给函数或方法，而该参数类型与函数或方法定义中的参数类型不匹配时，解引用强制转换会自动发生。对 `deref` 方法的一系列调用会将我们提供的类型转换为参数所需的类型。

Rust 中添加解引用强制转换是为了让编写函数和方法调用的程序员无需使用 `&` 和 `*` 添加那么多显式的引用和解引用操作。解引用强制转换特性还使我们能够编写更多既适用于引用又适用于智能指针的代码。

为了看到解引用强制转换的实际效果，我们使用在清单 15-8 中定义的 `MyBox<T>` 类型以及在清单 15-10 中添加的 `Deref` 实现。清单 15-11 展示了一个具有字符串切片参数的函数定义。

文件名：`src/main.rs`

```rust
fn hello(name: &str) {
    println!("Hello, {name}!");
}
```

清单 15-11：一个具有 `&str` 类型参数 `name` 的 `hello` 函数

例如，我们可以用字符串切片作为参数调用 `hello` 函数，比如 `hello("Rust");`。解引用强制转换使得可以用对 `MyBox<String>` 类型值的引用调用 `hello`，如清单 15-12 所示。

文件名：`src/main.rs`

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

清单 15-12：使用对 `MyBox<String>` 值的引用调用 `hello`，这由于解引用强制转换而可行

在这里，我们用参数 `&m` 调用 `hello` 函数，`&m` 是对 `MyBox<String>` 值的引用。因为我们在清单 15-10 中为 `MyBox<T>` 实现了 `Deref` 特性，Rust 可以通过调用 `deref` 将 `&MyBox<String>` 转换为 `&String`。标准库为 `String` 提供了一个返回字符串切片的 `Deref` 实现，这在 `Deref` 的 API 文档中。Rust 再次调用 `deref` 将 `&String` 转换为 `&str`，这与 `hello` 函数的定义相匹配。

如果 Rust 没有实现解引用强制转换，那么我们将不得不编写清单 15-13 中的代码，而不是清单 15-12 中的代码，来用 `&MyBox<String>` 类型的值调用 `hello`。

文件名：`src/main.rs`

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

清单 15-13：如果 Rust 没有解引用强制转换我们将不得不编写的代码

`(*m)` 将 `MyBox<String>` 解引用为 `String`。然后 `&` 和 `[..]` 从 `String` 中获取一个等于整个字符串的字符串切片，以匹配 `hello` 的签名。这段没有解引用强制转换的代码，由于涉及所有这些符号，更难阅读、编写和理解。解引用强制转换允许 Rust 为我们自动处理这些转换。

当为涉及的类型定义了 `Deref` 特性时，Rust 会分析类型，并根据需要多次使用 `Deref::deref` 以获得与参数类型匹配的引用。`Deref::deref` 需要插入的次数在编译时确定，所以利用解引用强制转换不会有运行时开销！
