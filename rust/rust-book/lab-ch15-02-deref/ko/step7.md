# Deref 강제 변환이 가변성과 상호 작용하는 방식

`Deref` 트레이트를 사용하여 불변 참조에 대한 `*` 연산자를 재정의하는 것과 유사하게, `DerefMut` 트레이트를 사용하여 가변 참조에 대한 `*` 연산자를 재정의할 수 있습니다.

Rust 는 세 가지 경우에 타입과 트레이트 구현을 발견하면 Deref 강제 변환을 수행합니다.

- `T: Deref<Target=U>`인 경우 `&T`에서 `&U`로
- `T: DerefMut<Target=U>`인 경우 `&mut T`에서 `&mut U`로
- `T: Deref<Target=U>`인 경우 `&mut T`에서 `&U`로

처음 두 경우는 두 번째가 가변성을 구현한다는 점을 제외하고 동일합니다. 첫 번째 경우는 `&T`가 있고 `T`가 어떤 타입 `U`로 `Deref`를 구현하는 경우, 투명하게 `&U`를 얻을 수 있다고 명시합니다. 두 번째 경우는 가변 참조에 대해 동일한 Deref 강제 변환이 발생한다고 명시합니다.

세 번째 경우는 더 까다롭습니다. Rust 는 가변 참조를 불변 참조로 강제 변환할 수도 있습니다. 그러나 그 반대는 *불가능*합니다. 불변 참조는 가변 참조로 절대 강제 변환되지 않습니다. 빌림 규칙 때문에, 가변 참조가 있는 경우 해당 가변 참조는 해당 데이터에 대한 유일한 참조여야 합니다 (그렇지 않으면 프로그램이 컴파일되지 않습니다). 하나의 가변 참조를 하나의 불변 참조로 변환하는 것은 빌림 규칙을 절대 위반하지 않습니다. 불변 참조를 가변 참조로 변환하려면 초기 불변 참조가 해당 데이터에 대한 유일한 불변 참조여야 하지만, 빌림 규칙은 이를 보장하지 않습니다. 따라서 Rust 는 불변 참조를 가변 참조로 변환하는 것이 가능하다고 가정할 수 없습니다.
