# 값을 가리키는 포인터 따라가기

일반 참조는 일종의 포인터이며, 포인터를 생각하는 한 가지 방법은 어딘가에 저장된 값을 가리키는 화살표로 생각하는 것입니다. Listing 15-6 에서 `i32` 값에 대한 참조를 생성한 다음 역참조 연산자를 사용하여 참조를 따라 값을 찾습니다.

파일 이름: `src/main.rs`

```rust
fn main() {
  1 let x = 5;
  2 let y = &x;

  3 assert_eq!(5, x);
  4 assert_eq!(5, *y);
}
```

Listing 15-6: 역참조 연산자를 사용하여 `i32` 값에 대한 참조를 따라가기

변수 `x`는 `i32` 값 `5`를 저장합니다 \[1]. `y`를 `x`에 대한 참조와 같게 설정합니다 \[2]. `x`가 `5`와 같다고 단언할 수 있습니다 \[3]. 그러나 `y`의 값에 대해 단언하려면 `*y`를 사용하여 참조가 가리키는 값을 따라가야 합니다 (따라서 _역참조_) 컴파일러가 실제 값을 비교할 수 있도록 합니다 \[4]. `y`를 역참조하면 `y`가 가리키는 정수 값에 접근하여 `5`와 비교할 수 있습니다.

대신 `assert_eq!(5, y);`를 작성하려고 하면 다음과 같은 컴파일 오류가 발생합니다.

```bash
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} ==
&{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented
for `{integer}`
```

숫자와 숫자에 대한 참조를 비교하는 것은 허용되지 않습니다. 왜냐하면 서로 다른 타입이기 때문입니다. 역참조 연산자를 사용하여 참조가 가리키는 값을 따라가야 합니다.
