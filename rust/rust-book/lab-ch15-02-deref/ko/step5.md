# Deref 트레이트 구현하기

"트레이트를 타입에 구현하기"에서 논의했듯이, 트레이트를 구현하려면 트레이트의 필수 메서드에 대한 구현을 제공해야 합니다. 표준 라이브러리에서 제공하는 `Deref` 트레이트는 `self`를 빌리고 내부 데이터에 대한 참조를 반환하는 `deref`라는 메서드 하나를 구현하도록 요구합니다. Listing 15-10 은 `MyBox``<T>` 정의에 추가할 `Deref`의 구현을 포함합니다.

파일 이름: `src/main.rs`

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
  1 type Target = T;

    fn deref(&self) -> &Self::Target {
      2 &self.0
    }
}
```

Listing 15-10: `MyBox<T>`에 `Deref` 구현하기

`type Target = T;` 구문 \[1]은 `Deref` 트레이트가 사용할 연관 타입을 정의합니다. 연관 타입은 제네릭 매개변수를 선언하는 약간 다른 방법이지만, 지금은 걱정할 필요가 없습니다. 19 장에서 자세히 다루겠습니다.

`deref` 메서드의 본문을 `&self.0`으로 채우면 `deref`는 `*` 연산자로 접근하려는 값에 대한 참조를 반환합니다 \[2]. "이름 없는 필드를 가진 튜플 구조체를 사용하여 다른 타입 만들기"에서 `.0`이 튜플 구조체의 첫 번째 값에 접근한다는 것을 기억하십시오. `MyBox<T>` 값에 `*`를 호출하는 Listing 15-9 의 `main` 함수는 이제 컴파일되고 단언문이 통과합니다!

`Deref` 트레이트가 없으면 컴파일러는 `&` 참조만 역참조할 수 있습니다. `deref` 메서드는 컴파일러에게 `Deref`를 구현하는 모든 타입의 값을 가져와 `deref` 메서드를 호출하여 역참조하는 방법을 알고 있는 `&` 참조를 얻을 수 있는 기능을 제공합니다.

Listing 15-9 에서 `*y`를 입력했을 때, Rust 는 실제로 다음과 같은 코드를 실행했습니다.

```rust
*(y.deref())
```

Rust 는 `*` 연산자를 `deref` 메서드 호출과 일반 역참조로 대체하므로 `deref` 메서드를 호출해야 하는지 여부에 대해 생각할 필요가 없습니다. 이 Rust 기능을 사용하면 일반 참조 또는 `Deref`를 구현하는 타입이 있는지 여부에 관계없이 동일하게 작동하는 코드를 작성할 수 있습니다.

`deref` 메서드가 값에 대한 참조를 반환하고, `*(y.deref())`의 괄호 밖에서 일반 역참조가 여전히 필요한 이유는 소유권 시스템과 관련이 있습니다. `deref` 메서드가 값에 대한 참조 대신 값을 직접 반환하면 값이 `self`에서 이동됩니다. 이 경우 또는 역참조 연산자를 사용하는 대부분의 경우 `MyBox<T>` 내부의 내부 값을 소유하고 싶지 않습니다.

`*` 연산자는 `deref` 메서드 호출과 `*` 연산자 호출로 한 번만 대체됩니다. 코드에서 `*`를 사용할 때마다. `*` 연산자의 대체는 무한히 재귀되지 않으므로 Listing 15-9 의 `assert_eq!`에서 `5`와 일치하는 `i32` 타입의 데이터로 끝나게 됩니다.
