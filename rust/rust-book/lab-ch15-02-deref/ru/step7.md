# Как взаимодействие преобразования Deref с изменяемостью

Похоже на то, как вы используете трейт `Deref`, чтобы переопределить оператор `*` для неизменяемых ссылок, вы можете использовать трейт `DerefMut`, чтобы переопределить оператор `*` для изменяемых ссылок.

Rust выполняет преобразование Deref, когда находит типы и реализации трейтов в трех случаях:

- От `&T` до `&U`, когда `T: Deref<Target=U>`
- От `&mut T` до `&mut U`, когда `T: DerefMut<Target=U>`
- От `&mut T` до `&U`, когда `T: Deref<Target=U>`

Первые два случая одинаковы, за исключением того, что второй реализует изменяемость. Первый случай означает, что если у вас есть `&T`, и `T` реализует `Deref` для какого-то типа `U`, вы можете получить `&U` прозрачно. Второй случай означает, что то же преобразование Deref происходит для изменяемых ссылок.

Третий случай более сложный: Rust также будет преобразовывать изменяемую ссылку в неизменяемую. Но обратное _невозможно_: неизменяемые ссылки никогда не будут преобразовываться в изменяемые ссылки. По правилам заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на эти данные (иначе программа не скомпилируется). Преобразование одной изменяемой ссылки в одну неизменяемую ссылку никогда не нарушает правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку требует, чтобы исходная неизменяемая ссылка была единственной неизменяемой ссылкой на эти данные, но правила заимствования этого не гарантируют. Поэтому Rust не может предположить, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.
