# Реализация трейта Deref

Как обсуждалось в разделе "Реализация трейта для типа", для реализации трейта нам нужно предоставить реализации для требуемых методов трейта. Трейт `Deref`, предоставляемый стандартной библиотекой, требует от нас реализации одного метода под названием `deref`, который заимствует `self` и возвращает ссылку на внутренние данные. Listing 15-10 содержит реализацию `Deref`, которую нужно добавить в определение `MyBox``<T>`.

Filename: `src/main.rs`

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
  1 type Target = T;

    fn deref(&self) -> &Self::Target {
      2 &self.0
    }
}
```

Listing 15-10: Реализация `Deref` для `MyBox<T>`

Синтаксис `type Target = T;` \[1\] определяет ассоциированный тип для использования в трейте `Deref`. Ассоциированные типы - это немного другой способ объявления обобщенного параметра, но для вас это не нужно беспокоиться на данный момент; мы рассмотрим их более подробно в главе 19.

Мы заполняем тело метода `deref` значением `&self.0`, чтобы метод `deref` возвращал ссылку на значение, которое мы хотим получить с помощью оператора `*` \[2\]; вспомните из раздела "Использование кортежных struct без именованных полей для создания разных типов", что `.0` позволяет получить доступ к первому значению в кортежном struct. Функция `main` в Listing 15-9, которая вызывает `*` для значения `MyBox<T>`, теперь компилируется, и утверждения проходят!

Без трейта `Deref` компилятор может только дереференцировать ссылки `&`. Метод `deref` позволяет компилятору получать значение любого типа, реализующего `Deref`, и вызывать метод `deref`, чтобы получить ссылку `&`, которую он умеет дереференцировать.

Когда мы ввели `*y` в Listing 15-9, на самом деле Rust под капотом запустил этот код:

```rust
*(y.deref())
```

Rust заменяет оператор `*` вызовом метода `deref`, а затем обычной операцией дереференцирования, так что нам не нужно думать, нужно ли вызывать метод `deref` или нет. Эта особенность Rust позволяет нам писать код, работающий одинаково, независимо от того, имеем мы обычную ссылку или тип, реализующий `Deref`.

Причина того, что метод `deref` возвращает ссылку на значение, а обычная операция дереференцирования за скобками в `*(y.deref())` по-прежнему необходима, связана с системой владения. Если метод `deref` возвращал значение напрямую, а не ссылку на значение, то значение было бы перемещено из `self`. Мы не хотим получать владение внутренним значением внутри `MyBox<T>` в этом случае или в большинстве случаев, когда мы используем оператор дереференцирования.

Обратите внимание, что оператор `*` заменяется вызовом метода `deref`, а затем вызовом оператора `*` только один раз каждый раз, когда мы используем `*` в нашем коде. Поскольку замена оператора `*` не происходит бесконечно, мы получаем данные типа `i32`, которые соответствуют `5` в `assert_eq!` в Listing 15-9.
