# Следующая за указателем до значения

Обычная ссылка является типом указателя, и один из способов представить указатель - это как стрелочка, указывающая на значение, хранящееся где-то еще. В Listing 15-6 мы создаем ссылку на значение `i32`, а затем используем оператор дереференцирования, чтобы следовать за ссылкой до значения.

Filename: `src/main.rs`

```rust
fn main() {
  1 let x = 5;
  2 let y = &x;

  3 assert_eq!(5, x);
  4 assert_eq!(5, *y);
}
```

Listing 15-6: Использование оператора дереференцирования для следования за ссылкой на значение `i32`

Переменная `x` хранит значение `i32` равное `5` \[1\]. Мы присваиваем `y` ссылку на `x` \[2\]. Мы можем утверждать, что `x` равно `5` \[3\]. Однако, если мы хотим сделать утверждение о значении в `y`, мы должны использовать `*y`, чтобы следовать за ссылкой до значения, на которое она указывает (отсюда и _дереференцирование_), так что компилятор мог сравнить фактическое значение \[4\]. После того, как мы дереференцируем `y`, мы получаем доступ к целому значению, на которое указывает `y`, которое мы можем сравнить с `5`.

Если бы мы попытались написать `assert_eq!(5, y);` вместо этого, мы бы получили следующую ошибку компиляции:

```bash
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} ==
&{integer}`
  |
  = help: the trait `PartialEq<&{integer}>` is not implemented
for `{integer}`
```

Сравнение числа и ссылки на число не допускается, потому что они имеют разные типы. Мы должны использовать оператор дереференцирования, чтобы следовать за ссылкой до значения, на которое она указывает.
