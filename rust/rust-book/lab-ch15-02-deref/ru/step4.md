# Определение собственного умного указателя

Построим умный указатель, похожий на тип `Box<T>`, предоставляемый стандартной библиотекой, чтобы узнать, как умные указатели по умолчанию ведут себя по-разному от ссылок. Затем мы посмотрим, как добавить возможность использования оператора дереференцирования.

Тип `Box<T>` в конечном итоге определяется как кортежный struct с одним элементом, поэтому Listing 15-8 определяет тип `MyBox<T>` так же. Также определим функцию `new`, чтобы соответствовать функции `new`, определенной для `Box<T>`.

Filename: `src/main.rs`

```rust
 1 struct MyBox<T>(T);

impl<T> MyBox<T> {
  2 fn new(x: T) -> MyBox<T> {
      3 MyBox(x)
    }
}
```

Listing 15-8: Определение типа `MyBox<T>`

Мы определяем struct под названием `MyBox` и объявляем обобщенный параметр `T` \[1\], потому что хотим, чтобы наш тип мог содержать значения любого типа. Тип `MyBox` является кортежным struct с одним элементом типа `T`. Функция `MyBox::new` принимает один параметр типа `T` \[2\] и возвращает экземпляр `MyBox`, содержащий переданное значение \[3\].

Попробуем добавить функцию `main` из Listing 15-7 в Listing 15-8 и изменить ее, чтобы использовать тип `MyBox<T>`, который мы определили, вместо `Box<T>`. Код в Listing 15-9 не скомпилируется, потому что Rust не знает, как дереференцировать `MyBox`.

Filename: `src/main.rs`

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

Listing 15-9: Попытка использовать `MyBox<T>` так же, как мы использовали ссылки и `Box<T>`

Вот результирующая ошибка компиляции:

```bash
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
```

Наше значение `MyBox<T>` не может быть дереференцировано, потому что мы не реализовали эту возможность для нашего типа. Чтобы включить дереференцирование с помощью оператора `*`, мы реализуем трейт `Deref`.
