# Определение модулей для управления областью действия и конфиденциальностью

В этом разделе мы поговорим о модулях и других частях модульной системы, а именно о _путиях_ (`paths`), которые позволяют именовать элементы; ключевом слове `use`, которое позволяет включить путь в область видимости; и ключевом слове `pub`, которое делает элементы доступными для внешнего использования. Также мы обсудим ключевое слово `as`, внешние пакеты и оператор глобального импорта (`glob`).

_Модули_ позволяют нам организовать код внутри коробки (`crate`) для удобства чтения и повторного использования. Модули также позволяют контролировать _конфиденциальность_ элементов, так как код внутри модуля по умолчанию является приватным. Приватные элементы представляют внутренние детали реализации, недоступные для внешнего использования. Мы можем выбрать сделать модули и элементы внутри них доступными для внешнего использования, тем самым exposing их для использования и зависимости от них внешним кодом.

В качестве примера напишем библиотечную коробку (`crate`), которая предоставляет функциональность ресторана. Мы определим сигнатуры функций, но оставим их тела пустыми, чтобы сосредоточиться на организации кода, а не на реализации ресторана.

В индустрии ресторанов некоторые части ресторана называются _фронтом дома_ (`front of house`), а другие - _задним дверям_ (`back of house`). Фронт дома - это то место, где находятся посетители; здесь включаются места, где хозяева размещают посетителей, официанты принимают заказы и оплату, а бармены готовят коктейли. Задний двор - это то место, где повара и кухарки работают в кухне, мойщики убирают посуду, а менеджеры занимаются административными работами.

Чтобы структурировать нашу коробку (`crate`) таким образом, мы можем организовать ее функции в вложенные модули. Создайте новую библиотеку под названием `restaurant`, выполнив команду `cargo new restaurant --lib`. Затем вставьте код из Листинга 7-1 в `src/lib.rs`, чтобы определить некоторые модули и сигнатуры функций; этот код представляет собой раздел фронта дома.

Имя файла: `src/lib.rs`

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

Листинг 7-1: Модуль `front_of_house`, содержащий другие модули, которые в свою очередь содержат функции

Мы определяем модуль с помощью ключевого слова `mod`, за которым следует имя модуля (в данном случае `front_of_house`). Тело модуля затем заключается в фигурные скобки. Внутри модулей мы можем разместить другие модули, как в данном случае с модулями `hosting` и `serving`. Модули также могут содержать определения для других элементов, таких как структуры (`structs`), перечисления (`enums`), константы (`constants`), трейты (`traits`) и - как в Листинге 7-1 - функции.

С использованием модулей мы можем группировать связанные определения вместе и назвать, почему они связаны. Программисты, использующие этот код, могут перемещаться по коду на основе групп, а не читать все определения, что делает легче найти определения, которые им нужны. Программисты, добавляющие новую функциональность в этот код, будут знать, куда вставлять код, чтобы сохранить организацию программы.

Ранее мы упоминали, что `src/main.rs` и `src/lib.rs` называются корневыми файлами коробки (`crate roots`). Причина этого имени заключается в том, что содержимое любого из этих двух файлов образует модуль с именем `crate` в корне структуры модулей коробки, называемой _деревом модулей_ (`module tree`).

Листинг 7-2 показывает дерево модулей для структуры из Листинга 7-1.

```bash
crate
└── front_of_house
├── hosting
│ ├── add_to_waitlist
│ └── seat_at_table
└── serving
├── take_order
├── serve_order
└── take_payment
```

Листинг 7-2: Дерево модулей для кода из Листинга 7-1

Это дерево показывает, как некоторые модули вкладываются внутри других модулей; например, `hosting` вкладывается внутри `front_of_house`. Дерево также показывает, что некоторые модули являются _братьями_ (`siblings`), то есть они определяются в одном модуле; `hosting` и `serving` - братья, определенные внутри `front_of_house`. Если модуль A находится внутри модуля B, мы говорим, что модуль A является _ребенком_ (`child`) модуля B, а модуль B - _родителем_ (`parent`) модуля A. Обратите внимание, что целое дерево модулей имеет корень в неявном модуле с именем `crate`.

Дерево модулей может напомнить вам дерево каталогов файловой системы на вашем компьютере; это очень точное сравнение! Как и каталоги в файловой системе, вы используете модули для организации своего кода. И как и файлы в каталоге, нам нужен способ найти наши модули.
