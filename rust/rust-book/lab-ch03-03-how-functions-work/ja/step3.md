# 文と式

関数の本体は、オプションで式で終わる一連の文で構成されています。これまで見てきた関数では、終わりの式は含まれていませんでしたが、文の一部として式を見てきました。Rustは式ベースの言語であるため、これは理解する重要な違いです。他の言語には同じ違いはありませんので、文と式とは何か、その違いが関数の本体にどのように影響するか見てみましょう。

- **文**：何らかのアクションを実行し、値を返さない命令です。
- **式**：結果の値に評価されます。いくつかの例を見てみましょう。

実際、既に文と式を使ってきました。`let`キーワードを使って変数を作成し、それに値を割り当てるのは文です。リスト3-1の`let y = 6;`は文です。

ファイル名: `src/main.rs`

```rust
fn main() {
    let y = 6;
}
```

リスト3-1：1つの文を含む`main`関数の宣言

関数の定義も文です。前述の例全体自体が文です。

文は値を返しません。したがって、次のコードのように`let`文を別の変数に割り当てることはできません。エラーが発生します。

ファイル名: `src/main.rs`

```rust
fn main() {
    let x = (let y = 6);
}
```

このプログラムを実行すると、次のようなエラーが表示されます。

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for
more information
```

`let y = 6`の文は値を返さないため、`x`がバインドするものがありません。これは、CやRubyなどの他の言語とは異なります。それらの言語では、代入は代入の値を返します。それらの言語では、`x = y = 6`と書くことができ、`x`と`y`の両方に値`6`が入ります。Rustではそうではありません。

式は値に評価され、Rustで書くコードの残りの大部分を構成します。数学演算、たとえば`5 + 6`は、値`11`に評価される式です。式は文の一部になることができます。リスト3-1の文`let y = 6;`の`6`は、値`6`に評価される式です。関数を呼び出すことは式です。マクロを呼び出すことは式です。波括弧で作成された新しいスコープブロックは式です。たとえば：

ファイル名: `src/main.rs`

```rust
fn main() {
  1 let y = {2
        let x = 3;
      3 x + 1
    };

    println!("The value of y is: {y}");
}
```

式\[2\]はブロックで、この場合、値`4`に評価されます。その値は、`let`文\[1\]の一部として`y`にバインドされます。最後にセミコロンがない行\[3\]に注意してください。これは、これまで見てきたほとんどの行とは異なります。式には末尾のセミコロンは含まれません。式の末尾にセミコロンを追加すると、文に変換され、値を返さなくなります。次に関数の戻り値と式を調べる際には、これを覚えておいてください。
