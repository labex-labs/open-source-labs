# Функции с возвращаемыми значениями

Функции могут возвращать значения вызывающему коду. Мы не именуем возвращаемые значения, но мы должны объявить их тип после стрелки (`->`). В Rust возвращаемое значение функции является синонимом значения последнего выражения в блоке тела функции. Вы можете выйти из функции раньше, используя ключевое слово `return` и указав значение, но большинство функций возвращают последнее выражение неявно. Вот пример функции, которая возвращает значение:

Имя файла: `src/main.rs`

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {x}");
}
```

В функции `five` нет вызовов функций, макросов или даже инструкций `let` — просто число `5` само по себе. Это совершенно допустимая функция в Rust. Обратите внимание, что тип возвращаемого значения функции также указан, как `-> i32`. Попробуйте запустить этот код; вывод должен выглядеть так:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
```

Число `5` в `five` является возвращаемым значением функции, поэтому тип возврата `i32`. Давайте рассмотрим это более подробно. Есть два важных момента: во - первых, строка `let x = five();` показывает, что мы используем возвращаемое значение функции для инициализации переменной. Поскольку функция `five` возвращает `5`, эта строка эквивалентна следующей:

```rust
let x = 5;
```

Во - вторых, функция `five` не имеет параметров и определяет тип возвращаемого значения, но тело функции — это одиночное `5` без точки с запятой, потому что это выражение, значение которого мы хотим вернуть.

Давайте рассмотрим еще один пример:

Имя файла: `src/main.rs`

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

Запуск этого кода выведет `The value of x is: 6`. Но если мы поставим точку с запятой в конце строки, содержащей `x + 1`, превращая ее из выражения в инструкцию, мы получим ошибку:

Имя файла: `src/main.rs`

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {x}");
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

Компиляция этого кода приводит к ошибке, как показано ниже:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --> src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: remove this semicolon
```

Основное сообщение об ошибке, `mismatched types` (несовместимые типы), показывает основную проблему с этим кодом. Определение функции `plus_one` говорит, что она вернет `i32`, но инструкции не вычисляются до значения, что выражается как `()`, единичный тип. Поэтому ничего не возвращается, что противоречит определению функции и приводит к ошибке. В этом выводе Rust дает сообщение, которое может помочь исправить эту проблему: он предлагает удалить точку с запятой, что исправит ошибку.
