# Параметры

Мы можем определить функции с _параметрами_, которые являются специальными переменными, входящими в состав сигнатуры функции. Когда функция имеет параметры, вы можете передать ей конкретные значения для этих параметров. Технически конкретные значения называются _аргументами_, но в повседневном общении люди обычно используют термины _параметр_ и _аргумент_ взаимозаменяемо, как для переменных в определении функции, так и для конкретных значений, передаваемых при вызове функции.

В этой версии `another_function` мы добавляем параметр:

Имя файла: `src/main.rs`

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {x}");
}
```

Попробуйте запустить эту программу; вы должны получить следующий вывод:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
```

Объявление `another_function` имеет один параметр с именем `x`. Тип `x` указан как `i32`. Когда мы передаем `5` в `another_function`, макрос `println!` выводит `5` в то место, где в форматированной строке были фигурные скобки с `x`.

В сигнатурах функций вы _должны_ объявить тип каждого параметра. Это сознательный выбор в дизайне Rust: требование указания аннотаций типов в определениях функций означает, что компилятор почти никогда не требует их использования в других местах кода для определения того, какой тип вы имеете в виду. Компилятор также может выдавать более полезные сообщения об ошибках, если он знает, какие типы ожидает функция.

При определении нескольких параметров отделяйте объявления параметров запятыми, как это:

Имя файла: `src/main.rs`

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

В этом примере создается функция с именем `print_labeled_measurement` с двумя параметрами. Первый параметр называется `value` и имеет тип `i32`. Второй называется `unit_label` и имеет тип `char`. Затем функция выводит текст, содержащий как `value`, так и `unit_label`.

Давайте попробуем запустить этот код. Замените программу, которая сейчас находится в файле `src/main.rs` вашего проекта _functions_, на предыдущий пример и запустите ее с помощью `cargo run`:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
```

Поскольку мы вызываем функцию с `5` в качестве значения для `value` и `'h'` в качестве значения для `unit_label`, вывод программы содержит эти значения.
