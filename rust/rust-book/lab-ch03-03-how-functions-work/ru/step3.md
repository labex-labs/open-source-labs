# Выражения и инструкции

Тела функций состоят из серии инструкций, которые могут необязательно заканчиваться выражением. До сих пор функции, которые мы рассматривали, не включали завершающее выражение, но вы уже видели выражение в составе инструкции. Поскольку Rust — это язык, основанный на выражениях, это важное различие, которое необходимо понять. Другие языки не имеют таких же различий, поэтому рассмотрим, что представляют собой инструкции и выражения и как их различия влияют на тела функций.

- **Инструкции**: это инструкции, которые выполняют какое-то действие и не возвращают значение.
- **Выражения**: вычисляются до результирующего значения. Рассмотрим несколько примеров.

Мы уже использовали инструкции и выражения. Создание переменной и присвоение ей значения с использованием ключевого слова `let` — это инструкция. В Листинге 3-1 `let y = 6;` — это инструкция.

Имя файла: `src/main.rs`

```rust
fn main() {
    let y = 6;
}
```

Листинг 3-1: Объявление функции `main`, содержащей одну инструкцию

Определение функции также является инструкцией; вся предыдущая программа в целом является инструкцией.

Инструкции не возвращают значения. Поэтому нельзя присвоить инструкцию `let` другой переменной, как пытается сделать следующий код; вы получите ошибку:

Имя файла: `src/main.rs`

```rust
fn main() {
    let x = (let y = 6);
}
```

Когда вы запускаете эту программу, ошибка, которую вы получите, будет выглядеть так:

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement

error[E0658]: `let` expressions in this position are unstable
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for
more information
```

Инструкция `let y = 6` не возвращает значение, поэтому для `x` нечего связывать. Это отличается от того, что происходит в других языках, таких как C и Ruby, где присваивание возвращает значение присваивания. В этих языках можно написать `x = y = 6` и у `x` и `y` будет значение `6`; в Rust это не так.

Выражения вычисляются до значения и составляют большую часть оставшегося кода, который вы будете писать на Rust. Рассмотрим арифметическую операцию, например, `5 + 6`, которая является выражением, которое вычисляется до значения `11`. Выражения могут быть частью инструкций: в Листинге 3-1 число `6` в инструкции `let y = 6;` — это выражение, которое вычисляется до значения `6`. Вызов функции — это выражение. Вызов макроса — это выражение. Новый блок области видимости, созданный с использованием фигурных скобок, — это выражение, например:

Имя файла: `src/main.rs`

```rust
fn main() {
  1 let y = {2
        let x = 3;
      3 x + 1
    };

    println!("The value of y is: {y}");
}
```

Выражение \[2\] — это блок, который в этом случае вычисляется до `4`. Это значение связывается с `y` как часть инструкции `let` \[1\]. Обратите внимание на строку без точки с запятой в конце \[3\], которая отличается от большинства строк, которые вы видели до сих пор. Выражения не включают завершающие точки с запятой. Если добавить точку с запятой в конец выражения, вы превратите его в инструкцию, и тогда оно не будет возвращать значение.牢记这一点，接下来我们将探讨函数返回值和表达式。
