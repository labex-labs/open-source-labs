# 제네릭을 사용하는 코드의 성능

제네릭 타입 매개변수를 사용할 때 런타임 비용이 있는지 궁금할 수 있습니다. 다행히 제네릭 타입을 사용해도 프로그램이 구체적인 타입을 사용할 때보다 더 느리게 실행되지 않습니다.

Rust 는 컴파일 시간에 제네릭을 사용하는 코드의 단형화 (monomorphization) 를 수행하여 이를 달성합니다. *단형화*는 컴파일 시 사용되는 구체적인 타입을 채워 넣음으로써 제네릭 코드를 특정 코드로 변환하는 과정입니다. 이 과정에서 컴파일러는 Listing 10-5 에서 제네릭 함수를 생성하기 위해 사용했던 단계의 반대 작업을 수행합니다: 컴파일러는 제네릭 코드가 호출되는 모든 위치를 살펴보고 제네릭 코드가 호출되는 구체적인 타입에 대한 코드를 생성합니다.

표준 라이브러리의 제네릭 `Option<T>` 열거형을 사용하여 이것이 어떻게 작동하는지 살펴보겠습니다.

```rust
let integer = Some(5);
let float = Some(5.0);
```

Rust 가 이 코드를 컴파일할 때, 단형화를 수행합니다. 그 과정에서 컴파일러는 `Option<T>` 인스턴스에서 사용된 값을 읽고 두 종류의 `Option<T>`를 식별합니다: 하나는 `i32`이고 다른 하나는 `f64`입니다. 따라서 `Option<T>`의 제네릭 정의를 `i32`와 `f64`에 특화된 두 개의 정의로 확장하여 제네릭 정의를 특정 정의로 대체합니다.

코드의 단형화된 버전은 다음과 유사합니다 (컴파일러는 설명을 위해 여기서 사용하는 것과 다른 이름을 사용합니다).

파일 이름: `src/main.rs`

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

제네릭 `Option<T>`는 컴파일러가 생성한 특정 정의로 대체됩니다. Rust 는 제네릭 코드를 각 인스턴스에서 타입을 지정하는 코드로 컴파일하기 때문에 제네릭을 사용하는 데 런타임 비용이 들지 않습니다. 코드가 실행될 때, 각 정의를 수동으로 복제한 경우와 동일하게 수행됩니다. 단형화 과정은 Rust 의 제네릭을 런타임에서 매우 효율적으로 만듭니다.
