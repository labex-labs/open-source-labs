# 메서드 정의에서

5 장에서 했던 것처럼, 구조체와 열거형에 메서드를 구현하고 정의에서 제네릭 타입을 사용할 수도 있습니다. Listing 10-9 는 Listing 10-6 에서 정의한 `Point<T>` 구조체에 `x`라는 메서드를 구현한 것을 보여줍니다.

파일 이름: `src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

Listing 10-9: `Point<T>` 구조체에 `x`라는 메서드를 구현하여 타입 `T`의 `x` 필드에 대한 참조를 반환합니다.

여기서, `x` 필드의 데이터에 대한 참조를 반환하는 `Point<T>`에 `x`라는 메서드를 정의했습니다.

`impl` 바로 뒤에 `T`를 선언해야 `T`를 사용하여 `Point<T>` 타입에 메서드를 구현하고 있음을 지정할 수 있습니다. `impl` 뒤에 제네릭 타입으로 `T`를 선언함으로써, Rust 는 `Point`의 꺾쇠 괄호 안의 타입이 구체적인 타입이 아닌 제네릭 타입임을 식별할 수 있습니다. 구조체 정의에서 선언된 제네릭 매개변수와 다른 이름을 이 제네릭 매개변수에 대해 선택할 수도 있지만, 동일한 이름을 사용하는 것이 일반적입니다. 제네릭 타입을 선언하는 `impl` 내에서 작성된 메서드는 제네릭 타입을 대체하는 구체적인 타입에 관계없이 해당 타입의 모든 인스턴스에 대해 정의됩니다.

타입에 메서드를 정의할 때 제네릭 타입에 대한 제약 조건을 지정할 수도 있습니다. 예를 들어, 모든 제네릭 타입의 `Point<T>` 인스턴스가 아닌 `Point<f32>` 인스턴스에 대해서만 메서드를 구현할 수 있습니다. Listing 10-10 에서는 구체적인 타입 `f32`를 사용하므로, `impl` 뒤에 어떤 타입도 선언하지 않습니다.

파일 이름: `src/main.rs`

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

Listing 10-10: 제네릭 타입 매개변수 `T`에 특정 구체적인 타입을 가진 구조체에만 적용되는 `impl` 블록

이 코드는 `Point<f32>` 타입이 `distance_from_origin` 메서드를 갖는다는 것을 의미합니다; `T`가 `f32` 타입이 아닌 다른 `Point<T>`의 인스턴스는 이 메서드가 정의되지 않습니다. 이 메서드는 좌표 (0.0, 0.0) 에서 얼마나 멀리 떨어져 있는지 측정하며, 부동 소수점 타입에만 사용할 수 있는 수학적 연산을 사용합니다.

구조체 정의의 제네릭 타입 매개변수는 항상 해당 구조체의 메서드 시그니처에서 사용하는 것과 동일하지는 않습니다. Listing 10-11 은 `Point` 구조체에 대해 제네릭 타입 `X1`과 `Y1`을 사용하고, `mixup` 메서드 시그니처에 대해 `X2`와 `Y2`를 사용하여 예제를 더 명확하게 만듭니다. 이 메서드는 `self` `Point` (타입 `X1`) 의 `x` 값과 전달된 `Point` (타입 `Y2`) 의 `y` 값을 사용하여 새로운 `Point` 인스턴스를 생성합니다.

파일 이름: `src/main.rs`

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

1 impl<X1, Y1> Point<X1, Y1> {
  2 fn mixup<X2, Y2>(
        self,
        other: Point<X2, Y2>,
    ) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
  3 let p1 = Point { x: 5, y: 10.4 };
  4 let p2 = Point { x: "Hello", y: 'c' };

  5 let p3 = p1.mixup(p2);

  6 println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

Listing 10-11: 구조체의 정의와 다른 제네릭 타입을 사용하는 메서드

`main`에서, `x`에 `i32` (값 `5`) 와 `y`에 `f64` (값 `10.4` \[3\]) 를 갖는 `Point`를 정의했습니다. `p2` 변수는 `x`에 문자열 슬라이스 (값 `"Hello"`) 와 `y`에 `char` (값 `c` \[4\]) 를 갖는 `Point` 구조체입니다. `p2` 인수를 사용하여 `p1`에 대해 `mixup`을 호출하면 `p3` \[5\]을 얻게 되며, `x`는 `p1`에서 왔기 때문에 `i32`가 됩니다. `p3` 변수는 `y`가 `p2`에서 왔기 때문에 `char`가 됩니다. `println!` 매크로 호출 \[6\]은 `p3.x = 5, p3.y = c`를 출력합니다.

이 예제의 목적은 일부 제네릭 매개변수가 `impl`로 선언되고 일부는 메서드 정의로 선언되는 상황을 보여주는 것입니다. 여기서, 제네릭 매개변수 `X1`과 `Y1`은 구조체 정의와 함께 사용되므로 `impl` 뒤에 선언됩니다 \[1]. 제네릭 매개변수 `X2`와 `Y2`는 메서드에만 관련되므로 `fn mixup` 뒤에 선언됩니다 \[2].
