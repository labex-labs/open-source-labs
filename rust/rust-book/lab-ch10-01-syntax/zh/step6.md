# 在方法定义中

我们可以在结构体和枚举上实现方法（就像我们在第 5 章中做的那样），并且在方法定义中也可以使用泛型类型。清单 10-9 展示了我们在清单 10-6 中定义的`Point<T>`结构体，并为其实现了一个名为`x`的方法。

文件名：`src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

清单 10-9：在`Point<T>`结构体上实现一个名为`x`的方法，该方法将返回对类型为`T`的`x`字段的引用

在这里，我们在`Point<T>`上定义了一个名为`x`的方法，该方法返回对`x`字段中数据的引用。

请注意，我们必须在`impl`之后声明`T`，这样我们就可以使用`T`来指定我们正在为类型`Point<T>`实现方法。通过在`impl`之后将`T`声明为泛型类型，Rust 可以识别`Point`尖括号中的类型是泛型类型而不是具体类型。我们可以为这个泛型参数选择一个与结构体定义中声明的泛型参数不同的名称，但使用相同的名称是惯例。在声明了泛型类型的`impl`块中编写的方法将在该类型的任何实例上定义，无论最终用什么具体类型替换泛型类型。

我们还可以在为类型定义方法时指定对泛型类型的约束。例如，我们可以只在`Point<f32>`实例上实现方法，而不是在具有任何泛型类型的`Point<T>`实例上实现。在清单 10-10 中，我们使用具体类型`f32`，这意味着我们在`impl`之后不声明任何类型。

文件名：`src/main.rs`

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

清单 10-10：一个`impl`块，仅适用于泛型类型参数`T`为特定具体类型的结构体

这段代码意味着类型`Point<f32>`将有一个`distance_from_origin`方法；`Point<T>`的其他实例（其中`T`不是`f32`类型）将不会定义这个方法。该方法测量我们的点与坐标为 (0.0, 0.0) 的点之间的距离，并使用仅适用于浮点类型的数学运算。

结构体定义中的泛型类型参数并不总是与在该结构体的方法签名中使用的泛型类型参数相同。清单 10-11 对`Point`结构体使用泛型类型`X1`和`Y1`，对`mixup`方法签名使用`X2`和`Y2`，以使示例更清晰。该方法创建一个新的`Point`实例，其`x`值来自`self` `Point`（类型为`X1`），`y`值来自传入的`Point`（类型为`Y2`）。

文件名：`src/main.rs`

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

1 impl<X1, Y1> Point<X1, Y1> {
  2 fn mixup<X2, Y2>(
        self,
        other: Point<X2, Y2>,
    ) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
  3 let p1 = Point { x: 5, y: 10.4 };
  4 let p2 = Point { x: "Hello", y: 'c' };

  5 let p3 = p1.mixup(p2);

  6 println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

清单 10-11：一个使用与结构体定义不同的泛型类型的方法

在`main`函数中，我们定义了一个`Point`，其`x`为`i32`（值为`5`），`y`为`f64`（值为`10.4` \[3\]）。`p2`变量是一个`Point`结构体，其`x`为字符串切片（值为`"Hello"`），`y`为`char`（值为`c` \[4\]）。对`p1`调用`mixup`并传入参数`p2`得到`p3` \[5\]，`p3`的`x`将为`i32`，因为`x`来自`p1`。`p3`变量的`y`将为`char`，因为`y`来自`p2`。`println!`宏调用 \[6\] 将打印`p3.x = 5, p3.y = c`。

这个示例的目的是展示一种情况，即一些泛型参数在`impl`中声明，而一些在方法定义中声明。在这里，泛型参数`X1`和`Y1`在`impl`之后声明 \[1\]，因为它们与结构体定义相关。泛型参数`X2`和`Y2`在`fn mixup`之后声明 \[2\]，因为它们仅与该方法相关。
