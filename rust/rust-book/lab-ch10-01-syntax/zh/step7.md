# 使用泛型的代码性能

你可能想知道使用泛型类型参数时是否会有运行时开销。好消息是，使用泛型类型不会使你的程序运行得比使用具体类型时更慢。

Rust 通过在编译时对使用泛型的代码执行单态化来实现这一点。*单态化*是通过填充编译时使用的具体类型，将泛型代码转换为特定代码的过程。在这个过程中，编译器执行的步骤与我们在清单 10-5 中创建泛型函数时所采取的步骤相反：编译器查看调用泛型代码的所有地方，并为泛型代码所调用的具体类型生成代码。

让我们通过使用标准库的泛型`Option<T>`枚举来看看这是如何工作的：

```rust
let integer = Some(5);
let float = Some(5.0);
```

当 Rust 编译这段代码时，它会执行单态化。在这个过程中，编译器读取在`Option<T>`实例中使用的值，并识别出两种`Option<T>`：一种是`i32`，另一种是`f64`。因此，它将`Option<T>`的泛型定义扩展为专门针对`i32`和`f64`的两个定义，从而用具体定义替换泛型定义。

代码的单态化版本看起来类似于以下内容（编译器使用的名称与我们这里为说明目的而使用的名称不同）：

文件名：`src/main.rs`

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

泛型`Option<T>`被编译器创建的具体定义所取代。因为 Rust 将泛型代码编译为在每个实例中指定类型的代码，所以我们使用泛型不会产生运行时开销。当代码运行时，它的行为就像我们手动复制每个定义一样。单态化过程使 Rust 的泛型在运行时极其高效。
