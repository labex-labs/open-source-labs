# 在枚举定义中

和结构体一样，我们可以定义枚举，使其变体中包含泛型数据类型。让我们再看看标准库提供的`Option<T>`枚举，我们在第 6 章中使用过它：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

现在这个定义对你来说应该更有意义了。如你所见，`Option<T>`枚举对于类型`T`是泛型的，并且有两个变体：`Some`，它持有一个类型为`T`的值；以及`None`变体，它不持有任何值。通过使用`Option<T>`枚举，我们可以表达可选值的抽象概念，并且因为`Option<T>`是泛型的，所以无论可选值的类型是什么，我们都可以使用这个抽象。

枚举也可以使用多个泛型类型。我们在第 9 章中使用的`Result`枚举的定义就是一个例子：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result`枚举对于两个类型`T`和`E`是泛型的，并且有两个变体：`Ok`，它持有一个类型为`T`的值；以及`Err`，它持有一个类型为`E`的值。这个定义使得在任何我们有一个可能成功（返回某种类型`T`的值）或失败（返回某种类型`E`的错误）的操作的地方，使用`Result`枚举都很方便。实际上，这就是我们在清单 9-3 中用于打开文件的方式，当文件成功打开时，`T`被填充为`std::fs::File`类型，当打开文件出现问题时，`E`被填充为`std::io::Error`类型。

当你在代码中识别出多个结构体或枚举定义，它们仅在所持有的值的类型上有所不同时，你可以通过使用泛型类型来避免重复。
