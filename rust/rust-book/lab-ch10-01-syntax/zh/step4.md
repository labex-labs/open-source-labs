# 在结构体定义中

我们还可以使用`<>`语法来定义结构体，以便在一个或多个字段中使用泛型类型参数。清单 10-6 定义了一个`Point<T>`结构体，用于存储任何类型的`x`和`y`坐标值。

文件名：`src/main.rs`

```rust
1 struct Point<T> {
  2 x: T,
  3 y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

清单 10-6：一个存储类型为`T`的`x`和`y`值的`Point<T>`结构体

在结构体定义中使用泛型的语法与在函数定义中使用的语法类似。首先，我们在结构体名称后的尖括号内声明类型参数的名称\[1\]。然后，我们在结构体定义中使用泛型类型，而不是指定具体的数据类型\[23\]。

请注意，因为我们只使用了一个泛型类型来定义`Point<T>`，所以这个定义表明`Point<T>`结构体对于某个类型`T`是泛型的，并且字段`x`和`y` _都是_ 相同的类型，无论该类型是什么。如果我们创建一个`Point<T>`实例，其值具有不同的类型，如清单 10-7 所示，我们的代码将无法编译。

文件名：`src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

清单 10-7：字段`x`和`y`必须是相同类型，因为它们都具有相同的泛型数据类型`T`

在这个例子中，当我们将整数值`5`赋给`x`时，我们让编译器知道对于这个`Point<T>`实例，泛型类型`T`将是一个整数。然后，当我们为`y`指定`4.0`时，我们已经将其定义为与`x`具有相同的类型，我们将得到一个类型不匹配错误，如下所示：

```bash
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-
point number
```

要定义一个`Point`结构体，其中`x`和`y`都是泛型，但可以具有不同的类型，我们可以使用多个泛型类型参数。例如，在清单 10-8 中，我们将`Point`的定义更改为对于类型`T`和`U`是泛型的，其中`x`是`T`类型，`y`是`U`类型。

文件名：`src/main.rs`

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

清单 10-8：一个对两种类型泛型的`Point<T, U>`，以便`x`和`y`可以是不同类型的值

现在，所示的所有`Point`实例都是允许的！你可以在定义中使用任意数量的泛型类型参数，但使用过多会使代码难以阅读。如果你发现代码中需要大量的泛型类型，这可能表明你的代码需要重构为更小的部分。
