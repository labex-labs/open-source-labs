# 列挙型定義におけるジェネリクス

構造体と同じように、列挙型のバリアントにジェネリックデータ型を保持するように列挙型を定義することができます。標準ライブラリが提供する `Option<T>` 列挙型をもう一度見てみましょう。これは、第6章で使用しました。

```rust
enum Option<T> {
    Some(T),
    None,
}
```

この定義が今ではもっと理解できるはずです。ご覧の通り、`Option<T>` 列挙型は型 `T` のジェネリックであり、2つのバリアントを持っています。`Some` は型 `T` の1つの値を保持し、`None` は値を保持しないバリアントです。`Option<T>` 列挙型を使用することで、オプショナルな値の抽象的な概念を表現できます。そして、`Option<T>` はジェネリックなので、オプショナルな値の型が何であれ、この抽象化を使用できます。

列挙型は複数のジェネリック型も使用できます。第9章で使用した `Result` 列挙型の定義がその1つの例です。

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` 列挙型は2つの型 `T` と `E` のジェネリックであり、2つのバリアントを持っています。`Ok` は型 `T` の値を保持し、`Err` は型 `E` の値を保持します。この定義により、成功する可能性のある操作（型 `T` の値を返す）または失敗する操作（型 `E` のエラーを返す）がある場所で `Result` 列挙型を使うのが便利になります。実際、これは第9章のリスト9-3でファイルを開く際に使用したもので、ファイルが正常に開かれたときに `T` は `std::fs::File` 型で埋められ、ファイルを開く際に問題があったときに `E` は `std::io::Error` 型で埋められました。

コード内で保持する値の型だけが異なる複数の構造体または列挙型の定義がある状況に気付いたとき、ジェネリック型を使うことで重複を回避できます。
