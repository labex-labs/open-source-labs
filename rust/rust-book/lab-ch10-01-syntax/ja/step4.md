# 構造体定義におけるジェネリクス

`<>` 構文を使って、1つ以上のフィールドでジェネリック型パラメータを使用する構造体を定義することもできます。リスト10-6は、任意の型の `x` と `y` 座標値を保持する `Point<T>` 構造体を定義しています。

ファイル名: `src/main.rs`

```rust
1 struct Point<T> {
  2 x: T,
  3 y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

リスト10-6: 型 `T` の `x` と `y` の値を保持する `Point<T>` 構造体

構造体定義でジェネリクスを使用する構文は、関数定義で使用する構文と似ています。まず、構造体名の直後の角括弧の中に型パラメータの名前を宣言します \[1\]。その後、具体的なデータ型を指定する場所で、構造体定義でジェネリック型を使用します \[2,3\]。

`Point<T>` を定義するために1つのジェネリック型のみを使用したので、この定義は `Point<T>` 構造体が型 `T` のジェネリックであり、フィールド `x` と `y` の両方が同じ型であることを意味します。たとえば、リスト10-7のように異なる型の値を持つ `Point<T>` のインスタンスを作成すると、コードはコンパイルされません。

ファイル名: `src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

リスト10-7: フィールド `x` と `y` は同じジェネリックデータ型 `T` であるため、同じ型でなければなりません。

この例では、整数値 `5` を `x` に代入するとき、コンパイラに対してこの `Point<T>` のインスタンスに対してジェネリック型 `T` が整数であることを知らせます。その後、`x` と同じ型であると定義した `y` に `4.0` を指定すると、次のような型不一致のエラーが表示されます。

```bash
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-
point number
```

`x` と `y` が両方ともジェネリックであるが、異なる型である可能性のある `Point` 構造体を定義するには、複数のジェネリック型パラメータを使用できます。たとえば、リスト10-8では、`Point` の定義を変更して、`x` が型 `T` で `y` が型 `U` であるように、型 `T` と `U` のジェネリックにします。

ファイル名: `src/main.rs`

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

リスト10-8: 2つの型のジェネリックな `Point<T, U>` で、`x` と `y` が異なる型の値になるようにする

これで、示されたすべての `Point` のインスタンスが許可されます！定義では必要なだけ多くのジェネリック型パラメータを使用できますが、いくつか以上使用するとコードが読みにくくなります。コードでたくさんのジェネリック型が必要になる場合、コードをより小さな部分に再構成する必要があることを示しているかもしれません。
