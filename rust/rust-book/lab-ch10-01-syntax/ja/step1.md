# 関数を抽出して重複を削除する

ジェネリクスを使うことで、特定の型を複数の型を表すプレースホルダに置き換えて、コードの重複を削除できます。ジェネリクスの構文に入る前に、まず、複数の値を表すプレースホルダで特定の値を置き換える関数を抽出することで、ジェネリック型を使わない方法で重複を削除する方法を見てみましょう。次に、同じ手法を使ってジェネリック関数を抽出します！関数に抽出できる重複したコードをどのように認識するかを見ることで、ジェネリクスを使える重複したコードを認識し始めるでしょう。

まず、リスト内の最大値を見つける短いプログラムを示します。

ファイル名: `src/main.rs`

```rust
fn main() {
  1 let number_list = vec![34, 50, 25, 100, 65];

  2 let mut largest = &number_list[0];

  3 for number in &number_list {
      4 if number > largest {
          5 largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

リスト10-1: 数値のリスト内の最大値を見つける

変数 `number_list` に整数のリストを格納し \[1\]、変数 `largest` にリストの最初の数値への参照を格納します \[2\]。そして、リスト内のすべての数値を反復処理し \[3\]、現在の数値が `largest` に格納されている数値より大きい場合 \[4\]、その変数の参照を置き換えます \[5\]。ただし、現在の数値がこれまでに見た最大値以下の場合、変数は変化せず、コードはリスト内の次の数値に進みます。リスト内のすべての数値を考慮した後、`largest` は最大値を指すはずで、この場合では100になります。

次に、2つの異なる数値のリスト内の最大値を見つけるように指示されました。そのために、リスト10-1のコードを複製して、プログラムの2つの異なる場所で同じロジックを使用することができます。

ファイル名: `src/main.rs`

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

リスト10-2: 2つの数値のリスト内の最大値を見つけるコード

このコードは機能しますが、コードを複製するのは面倒でエラーが発生しやすくなります。また、コードを変更したい場合、複数の場所でコードを更新する必要があります。

この重複を排除するために、パラメータとして渡される任意の整数のリストに対して動作する関数を定義することで、抽象化を行います。このソリューションにより、コードがより明確になり、リスト内の最大値を見つける概念を抽象的に表現できるようになります。

リスト10-3では、最大値を見つけるコードを `largest` という名前の関数に抽出します。そして、リスト10-2の2つのリスト内の最大値を見つけるために関数を呼び出します。将来、他の `i32` 値のリストでもこの関数を使用できます。

ファイル名: `src/main.rs`

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```

リスト10-3: 2つのリスト内の最大値を見つける抽象化されたコード

`largest` 関数には `list` というパラメータがあり、これは関数に渡すことができる任意の具体的な `i32` 値のスライスを表します。その結果、関数を呼び出すと、渡した特定の値でコードが実行されます。

要約すると、リスト10-2からリスト10-3にコードを変更するために行った手順は以下の通りです。

1.  重複したコードを特定する。
2.  重複したコードを関数の本体に抽出し、関数のシグネチャでそのコードの入力と戻り値を指定する。
3.  重複したコードの2つのインスタンスを更新して、代わりに関数を呼び出す。

次に、ジェネリクスを使って同じ手順を行い、コードの重複を減らします。関数の本体が特定の値ではなく抽象的な `list` で動作するのと同じように、ジェネリクスを使うことでコードが抽象型で動作するようになります。

たとえば、`i32` 値のスライス内の最大値を見つける関数と `char` 値のスライス内の最大値を見つける関数があったとします。この重複をどのように排除するか見てみましょう！
