# ジェネリックを使用したコードのパフォーマンス

ジェネリック型パラメータを使用するときに実行時のコストがかかるかどうか疑問に思うかもしれません。良い知らせは、ジェネリック型を使用しても、具体的な型を使用した場合よりもプログラムが遅く実行されることはありません。

Rustは、コンパイル時にジェネリックを使用したコードのモノモーフィゼーションを行うことでこれを達成します。 _モノモーフィゼーション_ は、コンパイル時に使用される具体的な型を埋め込むことにより、ジェネリックコードを特定のコードに変換するプロセスです。このプロセスでは、コンパイラはリスト10-5でジェネリック関数を作成する際に使用した手順とは逆のことを行います。コンパイラは、ジェネリックコードが呼び出されるすべての場所を見て、ジェネリックコードが呼び出される具体的な型に対応するコードを生成します。

標準ライブラリのジェネリックな `Option<T>` 列挙型を使って、これがどのように機能するか見てみましょう。

```rust
let integer = Some(5);
let float = Some(5.0);
```

Rustがこのコードをコンパイルするとき、モノモーフィゼーションが行われます。そのプロセスで、コンパイラは `Option<T>` インスタンスで使用されている値を読み取り、2種類の `Option<T>` を識別します。1つは `i32` で、もう1つは `f64` です。その結果、`Option<T>` のジェネリック定義が、`i32` と `f64` に特化した2つの定義に展開され、それによってジェネリック定義が具体的な定義に置き換えられます。

コードのモノモーフィズム化されたバージョンは、次のようになります（説明のために、コンパイラがここで使用する名前とは異なる名前を使っています）。

ファイル名: `src/main.rs`

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

ジェネリックな `Option<T>` は、コンパイラによって作成された具体的な定義に置き換えられます。Rustはジェネリックコードを各インスタンスで型を指定するコードにコンパイルするので、ジェネリックを使用することで実行時のコストはかかりません。コードが実行されるとき、手動で各定義を複製した場合と同じように動作します。モノモーフィゼーションのプロセスにより、Rustのジェネリックは実行時に非常に効率的になります。
