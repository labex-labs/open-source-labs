# メソッド定義におけるジェネリクス

構造体や列挙型にメソッドを実装することができます（第5章で行ったように）、そしてそれらの定義においてもジェネリック型を使用することができます。リスト10-9は、リスト10-6で定義した `Point<T>` 構造体に、`x` という名前のメソッドを実装したものを示しています。

ファイル名: `src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

リスト10-9: `Point<T>` 構造体に `x` という名前のメソッドを実装し、型 `T` の `x` フィールドへの参照を返す

ここでは、`Point<T>` に `x` という名前のメソッドを定義しており、これは `x` フィールドのデータへの参照を返します。

`impl` の直後に `T` を宣言する必要があることに注意してください。これにより、`T` を使って `Point<T>` 型にメソッドを実装していることを指定できます。`impl` の後に `T` をジェネリック型として宣言することで、Rustは `Point` の角括弧内の型が具体的な型ではなくジェネリック型であることを識別できます。構造体定義で宣言されたジェネリックパラメータとは別の名前をこのジェネリックパラメータに選ぶこともできますが、同じ名前を使うのが一般的です。ジェネリック型を宣言する `impl` 内で書かれたメソッドは、ジェネリック型にどの具体的な型が代入されるかに関係なく、その型の任意のインスタンスに定義されます。

また、型にメソッドを定義する際に、ジェネリック型に制約を指定することもできます。たとえば、`Point<T>` インスタンスではなく、`Point<f32>` インスタンスのみにメソッドを実装することができます。リスト10-10では、具体的な型 `f32` を使っています。これは、`impl` の後に型を宣言していないことを意味します。

ファイル名: `src/main.rs`

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

リスト10-10: ジェネリック型パラメータ `T` に対して特定の具体的な型を持つ構造体にのみ適用される `impl` ブロック

このコードは、型 `Point<f32>` が `distance_from_origin` メソッドを持つことを意味します。`T` が `f32` 型でない `Point<T>` の他のインスタンスには、このメソッドは定義されていません。このメソッドは、座標 (0.0, 0.0) の点からの自分たちの点の距離を測定し、浮動小数点数型にのみ利用可能な数学演算を使用しています。

構造体定義におけるジェネリック型パラメータは、同じ構造体のメソッドシグネチャで使用するものと必ずしも同じではありません。リスト10-11では、`Point` 構造体にはジェネリック型 `X1` と `Y1` を使い、`mixup` メソッドシグネチャには `X2` と `Y2` を使っています。これにより、例がより明確になります。このメソッドは、`self` の `Point`（型 `X1`）の `x` 値と、渡された `Point`（型 `Y2`）の `y` 値を使って新しい `Point` インスタンスを作成します。

ファイル名: `src/main.rs`

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

1 impl<X1, Y1> Point<X1, Y1> {
  2 fn mixup<X2, Y2>(
        self,
        other: Point<X2, Y2>,
    ) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
  3 let p1 = Point { x: 5, y: 10.4 };
  4 let p2 = Point { x: "Hello", y: 'c' };

  5 let p3 = p1.mixup(p2);

  6 println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

リスト10-11: 構造体の定義とは異なるジェネリック型を使用するメソッド

`main` 関数では、`x` に `i32`（値は `5`）を持ち、`y` に `f64`（値は `10.4` \[3\]）を持つ `Point` を定義しています。`p2` 変数は、`x` に文字列スライス（値は `"Hello"`）を持ち、`y` に `char`（値は `c` \[4\]）を持つ `Point` 構造体です。`p1` に対して引数 `p2` で `mixup` を呼び出すと、`p3` が得られます \[5\]。`p3` は、`x` が `p1` から来ているため `i32` を持ちます。`p3` 変数は、`y` が `p2` から来ているため `char` を持ちます。`println!` マクロの呼び出し \[6\] は、`p3.x = 5, p3.y = c` を出力します。

この例の目的は、一部のジェネリックパラメータが `impl` で宣言され、一部がメソッド定義で宣言される状況を示すことです。ここでは、ジェネリックパラメータ `X1` と `Y1` は、構造体定義と関連付けられるため、`impl` の後に宣言されています \[1\]。ジェネリックパラメータ `X2` と `Y2` は、メソッドにのみ関係するため、`fn mixup` の後に宣言されています \[2\]。
