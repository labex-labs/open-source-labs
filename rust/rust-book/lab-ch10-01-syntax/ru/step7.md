# Производительность кода с использованием обобщений

Вы, возможно, задаетесь вопросом, есть ли накладные расходы во время выполнения при использовании обобщенных параметров типа. Хорошая новость заключается в том, что использование обобщенных типов не сделает ваш программу работать медленнее, чем при использовании конкретных типов.

Rust достигает этого путём выполнения мономорфизма кода с использованием обобщений на этапе компиляции. _Мономорфизм_ — это процесс превращения обобщенного кода в конкретный код путём подстановки конкретных типов, которые используются при компиляции. В этом процессе компилятор делает обратное тому, что мы делали, чтобы создать обобщенную функцию в Listing 10-5: компилятор рассматривает все места, где вызывается обобщенный код, и генерирует код для конкретных типов, с которыми вызывается обобщенный код.

Посмотрим, как это работает, используя обобщенное перечисление `Option<T>` стандартной библиотеки:

```rust
let integer = Some(5);
let float = Some(5.0);
```

Когда Rust компилирует этот код, он выполняет мономорфизм. Во время этого процесса компилятор читает значения, которые использовались в экземплярах `Option<T>`, и определяет два вида `Option<T>`: один — это `i32`, а другой — `f64`. Таким образом, он расширяет обобщенное определение `Option<T>` на два определения, специализированных для `i32` и `f64`, тем самым заменяя обобщенное определение конкретными.

Мономорфизованная версия кода выглядит подобно следующему (компилятор использует другие имена, чем те, которые мы используем здесь для иллюстрации):

Filename: `src/main.rs`

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

Обобщенное `Option<T>` заменяется конкретными определениями, созданными компилятором. Поскольку Rust компилирует обобщенный код в код, который задает тип в каждом экземпляре, мы не платим никаких накладных расходов во время выполнения за использование обобщений. Когда код выполняется, он работает так же, как будто мы вручную дублировали каждое определение. Процесс мономорфизма делает обобщения Rust 极其эффективными во время выполнения.
