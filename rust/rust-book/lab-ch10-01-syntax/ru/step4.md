# В определениях структур

Мы также можем определить структуры для использования обобщенного параметра типа в одном или нескольких полях с использованием синтаксиса `< >`. Listing 10-6 определяет структуру `Point<T>` для хранения значений координат `x` и `y` любого типа.

Filename: `src/main.rs`

```rust
1 struct Point<T> {
  2 x: T,
  3 y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

Listing 10-6: Структура `Point<T>`, которая хранит значения `x` и `y` типа `T`

Синтаксис для использования обобщений в определениях структур похож на тот, который используется в определениях функций. Во - первых, мы объявляем имя параметра типа внутри угловых скобок сразу после имени структуры \[1\]. Затем мы используем обобщенный тип в определении структуры, где в противном случае мы бы указали конкретные типы данных \[23\].

Обратите внимание, что поскольку мы использовали только один обобщенный тип для определения `Point<T>`, это определение говорит, что структура `Point<T>` является обобщенной по какому - то типу `T`, и поля `x` и `y` _оба_ являются этим же типом, каким бы то ни было этот тип. Если мы создадим экземпляр `Point<T>`, у которого значения разных типов, как в Listing 10-7, наш код не скомпилируется.

Filename: `src/main.rs`

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

Listing 10-7: Поля `x` и `y` должны быть одного типа, потому что оба имеют одинаковый обобщенный тип данных `T`.

В этом примере, когда мы присваиваем целочисленное значение `5` для `x`, мы сообщаем компилятору, что обобщенный тип `T` будет целым числом для этого экземпляра `Point<T>`. Затем, когда мы указываем `4.0` для `y`, которое мы определили как имеющее тот же тип, что и `x`, мы получим ошибку несоответствия типов такого вида:

```bash
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-
point number
```

Чтобы определить структуру `Point`, где `x` и `y` оба являются обобщенными, но могут иметь разные типы, мы можем использовать несколько обобщенных параметров типа. Например, в Listing 10-8 мы меняем определение `Point` так, чтобы оно было обобщенным по типам `T` и `U`, где `x` имеет тип `T`, а `y` имеет тип `U`.

Filename: `src/main.rs`

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

Listing 10-8: Обобщенная структура `Point<T, U>` по двум типам, чтобы `x` и `y` могли быть значениями разных типов

Теперь все показанные экземпляры `Point` допустимы! Вы можете использовать столько обобщенных параметров типа в определении, сколько вам нужно, но использование более двух - трех делает ваш код трудно читать. Если вы замечаете, что вам нужны много обобщенных типов в своем коде, это может означать, что ваш код нуждается в переструктуризации на более мелкие части.
