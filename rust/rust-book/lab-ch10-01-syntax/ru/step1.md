# Удаление дублирования путём извлечения функции

Обобщения позволяют заменить конкретные типы на占位符，представляющий несколько типов, чтобы удалить дублирование кода. Перед изучением синтаксиса обобщений давайте сначала посмотрим, как удалить дублирование таким образом, которое не включает обобщенные типы, путём извлечения функции, которая заменяет конкретные значения на占位符，представляющий несколько значений. Затем мы применим ту же технику для извлечения обобщенной функции! Смотрев на то, как распознавать дублированный код, который можно извлечь в функцию, вы начнёте распознавать дублированный код, который может использовать обобщения.

Начнём с короткой программы в Listing 10-1, которая находит наибольшее число в списке.

Filename: `src/main.rs`

```rust
fn main() {
  1 let number_list = vec![34, 50, 25, 100, 65];

  2 let mut largest = &number_list[0];

  3 for number in &number_list {
      4 if number > largest {
          5 largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

Listing 10-1: Поиск наибольшего числа в списке чисел

Мы храним список целых чисел в переменной `number_list` \[1\] и помещаем ссылку на первое число в списке в переменную с именем `largest` \[2\]. Затем мы перебираем все числа в списке \[3\], и если текущее число больше числа, хранящегося в `largest` \[4\], мы заменяем ссылку в этой переменной \[5\]. Однако, если текущее число меньше или равно наибольшему числу, которое мы видели до сих пор, переменная не меняется, и код переходит к следующему числу в списке. После рассмотрения всех чисел в списке `largest` должен ссылаться на наибольшее число, которое в этом случае равно 100.

Теперь нам поручено найти наибольшее число в двух разных списках чисел. Для этого мы можем выбрать дублировать код из Listing 10-1 и использовать ту же логику в двух разных местах программы, как показано в Listing 10-2.

Filename: `src/main.rs`

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

Listing 10-2: Код для поиска наибольшего числа в _двух_ списках чисел

Хотя этот код работает, дублирование кода является утомительным и подвержено ошибкам. Кроме того, мы должны помнить обновлять код в нескольких местах, когда хотим его изменить.

Чтобы устранить это дублирование, мы создадим абстракцию, определив функцию, которая работает с любым списком целых чисел, переданным в параметре. Это решение делает наш код более понятным и позволяет абстрактно выразить концепцию поиска наибольшего числа в списке.

В Listing 10-3 мы извлекаем код, который находит наибольшее число, в функцию с именем `largest`. Затем мы вызываем функцию, чтобы найти наибольшее число в двух списках из Listing 10-2. Мы также могли бы использовать функцию для любого другого списка значений `i32`, которые могут появиться в будущем.

Filename: `src/main.rs`

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```

Listing 10-3: Абстрагированный код для поиска наибольшего числа в двух списках

Функция `largest` имеет параметр с именем `list`, который представляет собой любую конкретную часть значений `i32`, которые мы можем передать в функцию. Таким образом, когда мы вызываем функцию, код выполняется на конкретных значениях, которые мы передаём.

Кратко, здесь перечислены шаги, которые мы предприняли, чтобы изменить код из Listing 10-2 в Listing 10-3:

1.  Найти дублированный код.
2.  Извлечь дублированный код в тело функции и указать входные и возвращаемые значения этого кода в сигнатуре функции.
3.  Обновить два экземпляра дублированного кода, чтобы вызывать функцию вместо этого.

Далее мы будем использовать эти же шаги с обобщениями, чтобы уменьшить дублирование кода. Таким же образом, как тело функции может работать с абстрактным `list` вместо конкретных значений, обобщения позволяют коду работать с абстрактными типами.

Например, предположим, что у нас есть две функции: одна, которая находит наибольший элемент в срезе значений `i32`, и другая, которая находит наибольший элемент в срезе значений `char`. Как мы можем устранить это дублирование? Давайте узнаем!
