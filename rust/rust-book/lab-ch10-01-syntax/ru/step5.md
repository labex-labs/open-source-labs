# В определениях перечислений

Как и в случае с структурами, мы можем определить перечисления для хранения обобщенных типов данных в их вариантах. Давайте ещё раз рассмотрим перечисление `Option<T>`, которое предоставляет стандартная библиотека и которое мы использовали в главе 6:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Теперь это определение должно казаться более понятным для вас. Как вы можете видеть, перечисление `Option<T>` является обобщенным по типу `T` и имеет два варианта: `Some`, который хранит одно значение типа `T`, и вариант `None`, который не хранит никакого значения. Используя перечисление `Option<T>`, мы можем выразить абстрактную концепцию необязательного значения, и поскольку `Option<T>` является обобщенным, мы можем использовать эту абстракцию независимо от типа необязательного значения.

Перечисления могут также использовать несколько обобщенных типов. Определение перечисления `Result`, которое мы использовали в главе 9, является одним примером:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Перечисление `Result` является обобщенным по двум типам, `T` и `E`, и имеет два варианта: `Ok`, который хранит значение типа `T`, и `Err`, который хранит значение типа `E`. Это определение делает удобным использование перечисления `Result` в любом месте, где у нас есть операция, которая может завершиться успешно (вернуть значение какого - то типа `T`) или неудачно (вернуть ошибку какого - то типа `E`). На самом деле, именно это мы использовали для открытия файла в Listing 9-3, где `T` заполнялось типом `std::fs::File`, когда файл был успешно открыт, а `E` заполнялось типом `std::io::Error`, когда возникли проблемы с открытием файла.

Когда вы замечаете в своём коде ситуации с несколькими определениями структур или перечислений, которые отличаются только типами значений, которые они хранят, вы можете избежать дублирования, используя обобщенные типы вместо этого.
