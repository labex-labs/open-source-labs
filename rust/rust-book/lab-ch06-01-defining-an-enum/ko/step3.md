# Option Enum 과 Null 값에 대한 장점

이 섹션에서는 표준 라이브러리에 정의된 또 다른 enum 인 `Option`의 사례 연구를 살펴봅니다. `Option` 유형은 값이 있을 수도 있고 없을 수도 있는 매우 일반적인 시나리오를 인코딩합니다.

예를 들어, 여러 항목이 포함된 목록에서 첫 번째 항목을 요청하면 값을 얻게 됩니다. 빈 목록에서 첫 번째 항목을 요청하면 아무것도 얻지 못합니다. 이 개념을 유형 시스템 측면에서 표현한다는 것은 컴파일러가 처리해야 하는 모든 경우를 처리했는지 확인할 수 있음을 의미합니다. 이 기능은 다른 프로그래밍 언어에서 매우 흔한 버그를 방지할 수 있습니다.

프로그래밍 언어 설계는 포함하는 기능 측면에서 종종 생각되지만, 제외하는 기능도 중요합니다. Rust 에는 다른 많은 언어에 있는 null 기능이 없습니다. *Null*은 값이 없음을 의미하는 값입니다. null 이 있는 언어에서 변수는 항상 null 또는 not-null 의 두 가지 상태 중 하나일 수 있습니다.

2009 년 프레젠테이션 "Null References: The Billion Dollar Mistake"에서 null 의 발명가인 Tony Hoare 는 다음과 같이 말했습니다.

> 저는 이것을 제 10 억 달러짜리 실수라고 부릅니다. 당시 저는 객체 지향 언어에서 참조에 대한 최초의 포괄적인 유형 시스템을 설계하고 있었습니다. 제 목표는 컴파일러가 자동으로 수행하는 검사를 통해 모든 참조 사용이 절대적으로 안전하도록 보장하는 것이었습니다. 그러나 구현하기가 너무 쉬워서 null 참조를 넣고 싶은 유혹을 참을 수 없었습니다. 이것은 지난 40 년 동안 수많은 오류, 취약성 및 시스템 충돌로 이어졌으며, 아마도 10 억 달러의 고통과 피해를 초래했을 것입니다. null 값의 문제는 null 값을 not-null 값으로 사용하려고 하면 어떤 종류의 오류가 발생한다는 것입니다. 이 null 또는 not-null 속성은 널리 퍼져 있기 때문에 이러한 종류의 오류를 쉽게 만들 수 있습니다.

그러나 null 이 표현하려는 개념은 여전히 유용합니다. null 은 어떤 이유로 현재 유효하지 않거나 부재하는 값입니다.

문제는 실제로 개념이 아니라 특정 구현에 있습니다. 따라서 Rust 에는 null 이 없지만, 값이 존재하거나 부재하는 개념을 인코딩할 수 있는 enum 이 있습니다. 이 enum 은 `Option<T>`이며, 표준 라이브러리에 다음과 같이 정의되어 있습니다.

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` enum 은 매우 유용하여 prelude 에도 포함되어 있습니다. 명시적으로 범위를 가져올 필요가 없습니다. 해당 변형도 prelude 에 포함되어 있습니다. `Option::` 접두사 없이 `Some`과 `None`을 직접 사용할 수 있습니다. `Option<T>` enum 은 여전히 일반적인 enum 이며, `Some(T)`와 `None`은 여전히 `Option<T>` 유형의 변형입니다.

`<T>` 구문은 아직 이야기하지 않은 Rust 의 기능입니다. 이는 제네릭 유형 매개변수이며, 10 장에서 제네릭에 대해 자세히 다룰 것입니다. 지금은 `<T>`가 `Option` enum 의 `Some` 변형이 모든 유형의 데이터 조각 하나를 보유할 수 있으며, `T` 대신 사용되는 각 구체적인 유형이 전체 `Option<T>` 유형을 다른 유형으로 만든다는 것만 알면 됩니다. 다음은 숫자 유형과 문자열 유형을 보유하기 위해 `Option` 값을 사용하는 몇 가지 예입니다.

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

`some_number`의 유형은 `Option<i32>`입니다. `some_char`의 유형은 `Option<char>`이며, 이는 다른 유형입니다. Rust 는 `Some` 변형 내부에 값을 지정했기 때문에 이러한 유형을 추론할 수 있습니다. `absent_number`의 경우, Rust 는 전체 `Option` 유형에 주석을 달도록 요구합니다. 컴파일러는 `None` 값만 보고 해당 `Some` 변형이 보유할 유형을 추론할 수 없습니다. 여기서 우리는 `absent_number`가 `Option<i32>` 유형이 되도록 하려고 Rust 에 알립니다.

`Some` 값이 있으면 값이 있고 해당 값이 `Some` 내에 있음을 알 수 있습니다. `None` 값이 있으면, 어떤 의미에서는 null 과 동일한 의미입니다. 유효한 값이 없는 것입니다. 그렇다면 `Option<T>`을 갖는 것이 null 을 갖는 것보다 나은 이유는 무엇일까요?

간단히 말해서, `Option<T>`와 `T`(여기서 `T`는 모든 유형일 수 있음) 는 서로 다른 유형이므로 컴파일러는 `Option<T>` 값을 확실히 유효한 값인 것처럼 사용하도록 허용하지 않습니다. 예를 들어, 이 코드는 `i8`을 `Option<i8>`에 추가하려고 하므로 컴파일되지 않습니다.

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

이 코드를 실행하면 다음과 같은 오류 메시지가 표시됩니다.

```bash
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
```

강렬하죠! 실제로 이 오류 메시지는 Rust 가 `i8`과 `Option<i8>`을 더하는 방법을 이해하지 못한다는 것을 의미합니다. 왜냐하면 서로 다른 유형이기 때문입니다. Rust 에서 `i8`과 같은 유형의 값이 있으면 컴파일러는 항상 유효한 값이 있는지 확인합니다. 해당 값을 사용하기 전에 null 을 확인할 필요 없이 자신 있게 진행할 수 있습니다. `Option<i8>`(또는 우리가 작업하는 값의 유형) 이 있는 경우에만 값이 없을 수 있다는 것을 걱정해야 하며, 컴파일러는 해당 값을 사용하기 전에 해당 경우를 처리하도록 합니다.

다시 말해, `Option<T>`를 `T`로 변환해야만 `T` 연산을 수행할 수 있습니다. 일반적으로, 이것은 null 과 관련된 가장 일반적인 문제 중 하나인 실제로 null 인데 null 이 아니라고 가정하는 것을 잡는 데 도움이 됩니다.

잘못된 not-null 값을 가정할 위험을 제거하면 코드에 대해 더 자신감을 가질 수 있습니다. null 일 수 있는 값을 가지려면 해당 값의 유형을 `Option<T>`로 명시적으로 선택해야 합니다. 그런 다음 해당 값을 사용할 때, 값이 null 인 경우를 명시적으로 처리해야 합니다. 값이 `Option<T>`가 아닌 유형을 갖는 모든 곳에서, 해당 값이 null 이 아니라고 _안전하게_ 가정할 수 있습니다. 이것은 null 의 광범위성을 제한하고 Rust 코드의 안전성을 높이기 위한 Rust 의 의도적인 설계 결정이었습니다.

그렇다면 `Option<T>` 유형의 값을 가지고 있을 때 `Some` 변형에서 `T` 값을 어떻게 얻어 해당 값을 사용할 수 있을까요? `Option<T>` enum 에는 다양한 상황에서 유용한 많은 메서드가 있습니다. 해당 문서를 확인할 수 있습니다. `Option<T>`의 메서드에 익숙해지는 것은 Rust 여정에서 매우 유용할 것입니다.

일반적으로, `Option<T>` 값을 사용하려면 각 변형을 처리하는 코드를 원합니다. `Some(T)` 값이 있는 경우에만 실행되는 코드를 원하며, 이 코드는 내부 `T`를 사용할 수 있습니다. `None` 값이 있는 경우에만 실행되는 다른 코드를 원하며, 해당 코드에는 `T` 값이 없습니다. `match` 표현식은 enum 과 함께 사용될 때 바로 이 작업을 수행하는 제어 흐름 구성입니다. enum 의 어떤 변형이 있는지에 따라 다른 코드를 실행하며, 해당 코드는 일치하는 값 내의 데이터를 사용할 수 있습니다.
