# `Option` 列挙型とnull値に比べた利点

このセクションでは、標準ライブラリによって定義されるもう1つの列挙型である `Option` のケーススタディを探ります。`Option` 型は、値が何かあるか、または何もないという非常に一般的なシナリオをエンコードします。

たとえば、複数の要素を含むリストの最初の要素を要求すると、値が返されます。空のリストの最初の要素を要求すると、何も返されません。型システムの観点からこの概念を表現すると、コンパイラがすべき場合すべてを処理したかどうかをチェックできます。この機能により、他のプログラミング言語で非常に一般的なバグを防ぐことができます。

プログラミング言語の設計は、含める機能について考えられることが多いですが、除外する機能も同じく重要です。Rustには、他の多くの言語にあるnull機能はありません。 _null_ は、そこに値がないことを意味する値です。nullがある言語では、変数は常に2つの状態のいずれかになります。nullまたはnot-nullです。

nullの発明者であるトニー・ホアは、2009年の講演「Null References: The Billion Dollar Mistake」でこう述べています。

> これを私の10億ドルのミスと呼んでいます。当時、私はオブジェクト指向言語における参照用の最初の包括的な型システムを設計していました。私の目標は、すべての参照の使用が絶対的に安全であり、コンパイラによって自動的にチェックされることを確実にすることでした。しかし、実装が簡単だったため、私はnull参照を入れるという誘惑に負けました。これは、過去40年間でおそらく10億ドルの損害と苦しみをもたらした、数え切れないエラー、脆弱性、システムクラッシュにつながりました。null値の問題は、null値をnot-null値として使用しようとすると、何らかのエラーが発生するということです。このnullまたはnot-nullの特性があまりにも普及しているため、この種のエラーを犯すのは非常に簡単です。

しかし、nullが表現しようとしている概念は依然として有用です。nullは、現在、何らかの理由で無効または存在しない値です。

問題は、本質的には概念ではなく、特定の実装にあります。そのため、Rustにはnullはありませんが、値が存在するか存在しないかという概念をエンコードできる列挙型があります。この列挙型は `Option<T>` で、標準ライブラリによって次のように定義されています。

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` 列挙型は非常に便利で、プレリュードにも含まれています。明示的にスコープに持ち込む必要はありません。そのバリアントもプレリュードに含まれています。`Option::` 接頭辞なしで直接 `Some` と `None` を使用できます。`Option<T>` 列挙型は依然として通常の列挙型であり、`Some(T)` と `None` は依然として `Option<T>` 型のバリアントです。

`<T>` の構文は、まだ話していないRustの機能です。これはジェネリック型パラメータで、第10章でジェネリクスについてもっと詳しく説明します。今のところ、知っておく必要のあることは、`<T>` が `Option` 列挙型の `Some` バリアントが任意の型の1つのデータを保持できることを意味し、`T` の代わりに使用される各具体的な型が全体の `Option<T>` 型を異なる型にすることです。次は、数値型と文字列型を保持するために `Option` 値を使用する例です。

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

`some_number` の型は `Option<i32>` です。`some_char` の型は `Option<char>` で、これは異なる型です。Rustはこれらの型を推論できます。なぜなら、`Some` バリアントの中に値を指定しているからです。`absent_number` の場合、Rustは全体の `Option` 型を明示的に指定する必要があります。コンパイラは、`None` 値だけを見て対応する `Some` バリアントが保持する型を推論することはできません。ここでは、`absent_number` の型が `Option<i32>` であることをRustに伝えています。

`Some` 値がある場合、値が存在することがわかり、値は `Some` の中に保持されています。`None` 値がある場合、ある意味ではnullと同じことを意味します。有効な値がありません。では、なぜ `Option<T>` がnullよりも良いのでしょうか？

簡単に言えば、`Option<T>` と `T`（`T` は任意の型）は異なる型であるため、コンパイラは `Option<T>` 値を必ずしも有効な値として使用しようとしないようにします。たとえば、このコードはコンパイルされません。なぜなら、`i8` に `Option<i8>` を加えようとしているからです。

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

このコードを実行すると、次のようなエラーメッセージが表示されます。

```bash
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
```

深刻です！実際、このエラーメッセージは、Rustが `i8` と `Option<i8>` をどのように加えるかを理解できないことを意味しています。なぜなら、それらは異なる型だからです。Rustで `i8` のような型の値がある場合、コンパイラは常に有効な値があることを保証します。その値を使用する前にnullをチェックする必要はありません。`Option<i8>`（または作業している値の型）がある場合にのみ、値がない可能性があることを心配する必要があり、コンパイラは値を使用する前にその場合を処理するようにします。

言い換えると、`Option<T>` を `T` に変換しなければ、それを使って `T` の操作を行うことはできません。一般的に、これはnullに関する最も一般的な問題の1つをキャッチするのに役立ちます。実際はnullであるのに、nullでないと仮定することです。

not-null値を誤って仮定するリスクを排除することで、コードに自信を持つことができます。nullになり得る値を持つには、その値の型を `Option<T>` にすることで明示的に選択する必要があります。そして、その値を使用するときは、値がnullの場合を明示的に処理する必要があります。値の型が `Option<T>` でないすべての場所では、値がnullでないことを安全に仮定できます。これは、Rustがnullの普及を制限し、Rustコードの安全性を高めるための意図的な設計決定でした。

では、`Option<T>` 型の値がある場合、`Some` バリアントから `T` の値をどのように取得して、その値を使用できるようにするのでしょうか？`Option<T>` 列挙型には、さまざまな状況で役立つ多数のメソッドがあります。ドキュメントを参照してください。`Option<T>` のメソッドに慣れることは、Rustの学習において非常に役立ちます。

一般的に、`Option<T>` 値を使用するには、各バリアントを処理するコードが必要です。`Some(T)` 値がある場合にのみ実行されるコードが必要で、このコードは内部の `T` を使用できます。`None` 値がある場合にのみ実行される他のコードが必要で、そのコードは `T` の値を持っていません。`match` 式は、列挙型とともに使用するとこのような制御フロー構造を行います。列挙型のどのバリアントであるかに応じて異なるコードを実行し、そのコードは一致する値の中のデータを使用できます。
