# `Option` 列挙型と null 値に比べた利点

このセクションでは、標準ライブラリによって定義されるもう 1 つの列挙型である `Option` のケーススタディを探ります。`Option` 型は、値が何かあるか、または何もないという非常に一般的なシナリオをエンコードします。

たとえば、複数の要素を含むリストの最初の要素を要求すると、値が返されます。空のリストの最初の要素を要求すると、何も返されません。型システムの観点からこの概念を表現すると、コンパイラがすべき場合すべてを処理したかどうかをチェックできます。この機能により、他のプログラミング言語で非常に一般的なバグを防ぐことができます。

プログラミング言語の設計は、含める機能について考えられることが多いですが、除外する機能も同じく重要です。Rust には、他の多くの言語にある null 機能はありません。_null_ は、そこに値がないことを意味する値です。null がある言語では、変数は常に 2 つの状態のいずれかになります。null または not-null です。

null の発明者であるトニー・ホアは、2009 年の講演「Null References: The Billion Dollar Mistake」でこう述べています。

> これを私の 10 億ドルのミスと呼んでいます。当時、私はオブジェクト指向言語における参照用の最初の包括的な型システムを設計していました。私の目標は、すべての参照の使用が絶対的に安全であり、コンパイラによって自動的にチェックされることを確実にすることでした。しかし、実装が簡単だったため、私は null 参照を入れるという誘惑に負けました。これは、過去 40 年間でおそらく 10 億ドルの損害と苦しみをもたらした、数え切れないエラー、脆弱性、システムクラッシュにつながりました。null 値の問題は、null 値を not-null 値として使用しようとすると、何らかのエラーが発生するということです。この null または not-null の特性があまりにも普及しているため、この種のエラーを犯すのは非常に簡単です。

しかし、null が表現しようとしている概念は依然として有用です。null は、現在、何らかの理由で無効または存在しない値です。

問題は、本質的には概念ではなく、特定の実装にあります。そのため、Rust には null はありませんが、値が存在するか存在しないかという概念をエンコードできる列挙型があります。この列挙型は `Option<T>` で、標準ライブラリによって次のように定義されています。

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` 列挙型は非常に便利で、プレリュードにも含まれています。明示的にスコープに持ち込む必要はありません。そのバリアントもプレリュードに含まれています。`Option::` 接頭辞なしで直接 `Some` と `None` を使用できます。`Option<T>` 列挙型は依然として通常の列挙型であり、`Some(T)` と `None` は依然として `Option<T>` 型のバリアントです。

`<T>` の構文は、まだ話していない Rust の機能です。これはジェネリック型パラメータで、第 10 章でジェネリクスについてもっと詳しく説明します。今のところ、知っておく必要のあることは、`<T>` が `Option` 列挙型の `Some` バリアントが任意の型の 1 つのデータを保持できることを意味し、`T` の代わりに使用される各具体的な型が全体の `Option<T>` 型を異なる型にすることです。次は、数値型と文字列型を保持するために `Option` 値を使用する例です。

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

`some_number` の型は `Option<i32>` です。`some_char` の型は `Option<char>` で、これは異なる型です。Rust はこれらの型を推論できます。なぜなら、`Some` バリアントの中に値を指定しているからです。`absent_number` の場合、Rust は全体の `Option` 型を明示的に指定する必要があります。コンパイラは、`None` 値だけを見て対応する `Some` バリアントが保持する型を推論することはできません。ここでは、`absent_number` の型が `Option<i32>` であることを Rust に伝えています。

`Some` 値がある場合、値が存在することがわかり、値は `Some` の中に保持されています。`None` 値がある場合、ある意味では null と同じことを意味します。有効な値がありません。では、なぜ `Option<T>` が null よりも良いのでしょうか？

簡単に言えば、`Option<T>` と `T`（`T` は任意の型）は異なる型であるため、コンパイラは `Option<T>` 値を必ずしも有効な値として使用しようとしないようにします。たとえば、このコードはコンパイルされません。なぜなら、`i8` に `Option<i8>` を加えようとしているからです。

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

このコードを実行すると、次のようなエラーメッセージが表示されます。

```bash
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
```

深刻です！実際、このエラーメッセージは、Rust が `i8` と `Option<i8>` をどのように加えるかを理解できないことを意味しています。なぜなら、それらは異なる型だからです。Rust で `i8` のような型の値がある場合、コンパイラは常に有効な値があることを保証します。その値を使用する前に null をチェックする必要はありません。`Option<i8>`（または作業している値の型）がある場合にのみ、値がない可能性があることを心配する必要があり、コンパイラは値を使用する前にその場合を処理するようにします。

言い換えると、`Option<T>` を `T` に変換しなければ、それを使って `T` の操作を行うことはできません。一般的に、これは null に関する最も一般的な問題の 1 つをキャッチするのに役立ちます。実際は null であるのに、null でないと仮定することです。

not-null 値を誤って仮定するリスクを排除することで、コードに自信を持つことができます。null になり得る値を持つには、その値の型を `Option<T>` にすることで明示的に選択する必要があります。そして、その値を使用するときは、値が null の場合を明示的に処理する必要があります。値の型が `Option<T>` でないすべての場所では、値が null でないことを安全に仮定できます。これは、Rust が null の普及を制限し、Rust コードの安全性を高めるための意図的な設計決定でした。

では、`Option<T>` 型の値がある場合、`Some` バリアントから `T` の値をどのように取得して、その値を使用できるようにするのでしょうか？`Option<T>` 列挙型には、さまざまな状況で役立つ多数のメソッドがあります。ドキュメントを参照してください。`Option<T>` のメソッドに慣れることは、Rust の学習において非常に役立ちます。

一般的に、`Option<T>` 値を使用するには、各バリアントを処理するコードが必要です。`Some(T)` 値がある場合にのみ実行されるコードが必要で、このコードは内部の `T` を使用できます。`None` 値がある場合にのみ実行される他のコードが必要で、そのコードは `T` の値を持っていません。`match` 式は、列挙型とともに使用するとこのような制御フロー構造を行います。列挙型のどのバリアントであるかに応じて異なるコードを実行し、そのコードは一致する値の中のデータを使用できます。
