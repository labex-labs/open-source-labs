# 列挙型の値

`IpAddrKind` の 2 つのバリアントのそれぞれのインスタンスをこのように作成できます。

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

列挙型のバリアントは、その識別子の下に名前空間があり、2 つを区切るためにダブルコロンを使用します。これは便利です。なぜなら、`IpAddrKind::V4` と `IpAddrKind::V6` の両方の値が同じ型 `IpAddrKind` であるからです。そのため、たとえば、任意の `IpAddrKind` を受け取る関数を定義できます。

```rust
fn route(ip_kind: IpAddrKind) {}
```

そして、どちらのバリアントでもこの関数を呼び出すことができます。

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

列挙型を使用するとさらに利点があります。IP アドレスの型についてもう少し考えてみましょう。現時点では、実際の IP アドレス _データ_ を格納する方法がありません。どの _種類_ であるかだけを知っています。第 5 章で構造体について学んだばかりなので、構造体を使ってこの問題を解決しようとするかもしれません。リスト 6-1 に示すようにです。

```rust
1 enum IpAddrKind {
    V4,
    V6,
}

2 struct IpAddr {
  3 kind: IpAddrKind,
  4 address: String,
}

5 let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

6 let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```

リスト 6-1：`struct` を使って IP アドレスのデータと `IpAddrKind` バリアントを格納する

ここでは、2 つのフィールドを持つ `IpAddr` 構造体を定義しています \[2\]。1 つは `kind` フィールドで \[3\]、その型は `IpAddrKind` です（先に定義した列挙型 \[1\]）。もう 1 つは `address` フィールドで \[4\]、その型は `String` です。この構造体のインスタンスは 2 つあります。最初は `home` で \[5\]、`kind` には `IpAddrKind::V4` の値があり、関連付けられたアドレスデータは `127.0.0.1` です。2 番目のインスタンスは `loopback` で \[6\]。`kind` の値には `IpAddrKind` のもう 1 つのバリアントである `V6` があり、関連付けられたアドレスは `::1` です。構造体を使って `kind` と `address` の値をまとめています。したがって、バリアントが値に関連付けられています。

ただし、列挙型だけを使って同じ概念を表現する方が簡潔です。構造体の中の列挙型ではなく、列挙型の各バリアントに直接データを入れることができます。`IpAddr` 列挙型のこの新しい定義は、`V4` と `V6` の両方のバリアントに関連付けられた `String` 型の値があることを意味します。

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

列挙型の各バリアントに直接データを付け加えるので、追加の構造体は不要です。ここでは、列挙型がどのように機能するかの別の詳細もわかりやすくなります。定義した各列挙型バリアントの名前も、列挙型のインスタンスを構築する関数になります。つまり、`IpAddr::V4()` は、`String` 型の引数を取り、`IpAddr` 型のインスタンスを返す関数呼び出しです。列挙型を定義することで、自動的にこのコンストラクタ関数が定義されます。

構造体よりも列挙型を使う利点がもう 1 つあります。各バリアントには、異なる型と量の関連付けられたデータを持つことができます。バージョン 4 の IP アドレスは常に 4 つの数値コンポーネントを持ち、その値は 0 から 255 の間になります。`V4` アドレスを 4 つの `u8` 型の値として格納したいが、`V6` アドレスを 1 つの `String` 型の値として表現したい場合、構造体ではこれを行うことができません。列挙型はこの場合を簡単に処理します。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

バージョン 4 とバージョン 6 の IP アドレスを格納するためのデータ構造を定義するいくつかの異なる方法を示しました。しかし、実際には、IP アドレスを格納してその種類をエンコードすることが非常に一般的であるため、標準ライブラリには使用できる定義があります。標準ライブラリが `IpAddr` をどのように定義しているか見てみましょう。これは、私たちが定義して使用した列挙型とバリアントがまったく同じですが、アドレスデータを 2 つの異なる構造体の形式でバリアントの中に埋め込んでいます。各バリアントで異なる定義がされています。

```rust
struct Ipv4Addr {
    --snip--
}

struct Ipv6Addr {
    --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

このコードは、列挙型のバリアントの中に任意の種類のデータを入れることができることを示しています。たとえば、文字列、数値型、または構造体です。さらに、別の列挙型も含めることができます！また、標準ライブラリの型は、自分で考えつくものよりも複雑ではありません。

標準ライブラリには `IpAddr` の定義が含まれていますが、まだ自分たちの定義を作成して使用することができます。なぜなら、標準ライブラリの定義をスコープに持ち込んでいないからです。第 7 章で型をスコープに持ち込む方法についてもっと詳しく説明します。

リスト 6-2 の列挙型の別の例を見てみましょう。これは、バリアントにさまざまな型が埋め込まれています。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

リスト 6-2：各バリアントが異なる量と型の値を格納する `Message` 列挙型

この列挙型は、異なる型の 4 つのバリアントを持っています。

- `Quit` にはまったく関連付けられたデータがありません。
- `Move` には、構造体と同じように名前付きのフィールドがあります。
- `Write` には、1 つの `String` が含まれています。
- `ChangeColor` には、3 つの `i32` 型の値が含まれています。

リスト 6-2 のようなバリアントを持つ列挙型を定義することは、さまざまな種類の構造体定義を定義することに似ています。ただし、列挙型は `struct` キーワードを使用せず、すべてのバリアントが `Message` 型の下にグループ化されています。次の構造体は、前述の列挙型バリアントが保持するデータと同じデータを保持することができます。

```rust
struct QuitMessage; // ユニット構造体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // タプル構造体
struct ChangeColorMessage(i32, i32, i32); // タプル構造体
```

しかし、それぞれ独自の型を持つ異なる構造体を使用した場合、リスト 6-2 で定義した `Message` 列挙型のように、これらの種類のメッセージのいずれかを受け取る関数を定義することはできません。列挙型と構造体にはもう 1 つの類似点があります。構造体では `impl` を使ってメソッドを定義できるように、列挙型でもメソッドを定義できます。ここでは、`Message` 列挙型に定義できる `call` という名前のメソッドを示します。

```rust
impl Message {
    fn call(&self) {
      1 // メソッド本体はここに定義されます
    }
}

2 let m = Message::Write(String::from("hello"));
m.call();
```

メソッドの本体は、`self` を使ってメソッドを呼び出した値を取得します。この例では、`Message::Write(String::from("hello"))` の値を持つ変数 `m` を作成しています \[2\]。そして、`m.call()` が実行されるとき、`call` メソッドの本体 \[1\] で `self` はその値になります。

標準ライブラリにある非常に一般的で便利な別の列挙型を見てみましょう。`Option` です。
