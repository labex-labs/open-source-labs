# Значения перечисления

Мы можем создать экземпляры каждого из двух вариантов `IpAddrKind` следующим образом:

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

Обратите внимание, что варианты перечисления находятся в пространстве имен под его идентификатором, и мы используем двойную точку, чтобы разделить их. Это полезно, потому что теперь оба значения `IpAddrKind::V4` и `IpAddrKind::V6` имеют один и тот же тип: `IpAddrKind`. Затем мы, например, можем определить функцию, которая принимает любой `IpAddrKind`:

```rust
fn route(ip_kind: IpAddrKind) {}
```

И мы можем вызвать эту функцию с любым вариантом:

```rust
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

Использование перечислений имеет еще больше преимуществ. Подумаем больше о типе нашего IP-адреса. В данный момент у нас нет способа хранить фактические данные IP-адреса; мы знаем только, какой _вид_ он. С учетом того, что вы только что узнали о структурах в главе 5, вы, возможно, захотите решить эту проблему с использованием структур, как показано в листинге 6-1.

```rust
1 enum IpAddrKind {
    V4,
    V6,
}

2 struct IpAddr {
  3 kind: IpAddrKind,
  4 address: String,
}

5 let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

6 let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```

Листинг 6-1: Сохранение данных и варианта `IpAddrKind` IP-адреса с использованием `struct`

Здесь мы определили структуру `IpAddr` \[2\], которая имеет два поля: поле `kind` \[3\], которое имеет тип `IpAddrKind` (перечисление, которое мы определили ранее \[1\]), и поле `address` \[4\] типа `String`. У нас есть два экземпляра этой структуры. Первый - это `home` \[5\], и у него значение `IpAddrKind::V4` в качестве `kind` с ассоциированными данными адреса `127.0.0.1`. Второй экземпляр - это `loopback` \[6\]. Он имеет другой вариант `IpAddrKind` в качестве значения `kind`, `V6`, и имеет адрес `::1`, связанный с ним. Мы использовали структуру, чтобы связать значения `kind` и `address` вместе, так что теперь вариант связан с значением.

Однако представление того же концепта с использованием только перечисления гораздо более компактно: вместо перечисления внутри структуры мы можем напрямую поместить данные в каждый вариант перечисления. Эта новая определение перечисления `IpAddr` говорит, что оба варианта `V4` и `V6` будут иметь ассоциированные значения `String`:

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

Мы напрямую прикрепляем данные к каждому варианту перечисления, поэтому не требуется дополнительная структура. Здесь также проще увидеть еще один аспект работы с перечислениями: имя каждого определенного нами варианта перечисления также становится функцией, которая создает экземпляр перечисления. То есть, `IpAddr::V4()` - это вызов функции, которая принимает аргумент `String` и возвращает экземпляр типа `IpAddr`. Мы автоматически получаем эту конструктор-функцию при определении перечисления.

Есть еще одно преимущество использования перечисления вместо структуры: каждый вариант может иметь разные типы и количества ассоциированных данных. IP-адреса версии четыре всегда будут иметь четыре числовых компонента, значения которых будут находиться в диапазоне от 0 до 255. Если бы мы хотели хранить адреса `V4` в виде четырех значений `u8`, но по-прежнему представлять адреса `V6` в виде одного значения `String`, мы не могли бы этого сделать с использованием структуры. Перечисления обрабатывают этот случай с легкостью:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

Мы показали несколько разных способов определения структур данных для хранения IP-адресов версии четыре и версии шесть. Однако, на самом деле, желание хранить IP-адреса и закодировать их вид настолько распространено, что в стандартной библиотеке есть определение, которое мы можем использовать! Посмотрим, как стандартная библиотека определяет `IpAddr`: у нее есть такое же перечисление и варианты, как мы определили и использовали, но она встраивает данные адреса внутри вариантов в виде двух разных структур, которые определяются по-разному для каждого варианта:

```rust
struct Ipv4Addr {
    --snip--
}

struct Ipv6Addr {
    --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Этот код показывает, что вы можете помещать любые типы данных внутри варианта перечисления: строки, числовые типы или структуры, например. Вы даже можете включить другое перечисление! Также стандартные типы библиотеки часто не сильно сложнее, чем те, которые вы могли бы придумать сами.

Обратите внимание, что даже несмотря на то, что в стандартной библиотеке есть определение для `IpAddr`, мы по-прежнему можем создавать и использовать собственное определение без конфликта, потому что мы не импортировали определение стандартной библиотеки в нашу область видимости. Мы поговорим больше о том, как подключать типы в область видимости в главе 7.

Посмотрим на еще один пример перечисления в листинге 6-2: в нем в вариантах встроено большое количество разных типов.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

Листинг 6-2: Перечисление `Message`, варианты которого хранят разные количества и типы значений

Это перечисление имеет четыре варианта с разными типами:

- `Quit` вообще не имеет ассоциированных данных.
- `Move` имеет именованные поля, как и структура.
- `Write` включает в себя одну `String`.
- `ChangeColor` включает три значения `i32`.

Определение перечисления с вариантами, подобными тем, что показаны в листинге 6-2, похоже на определение разных типов структур, за исключением того, что перечисление не использует ключевое слово `struct`, и все варианты группируются вместе под типом `Message`. Следующие структуры могли бы содержать те же данные, что и предыдущие варианты перечисления:

```rust
struct QuitMessage; // единичная структура
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // кортежная структура
struct ChangeColorMessage(i32, i32, i32); // кортежная структура
```

Но если бы мы использовали разные структуры, каждая из которых имеет свой собственный тип, мы не могли бы так легко определить функцию, которая принимает любой из этих типов сообщений, как мы могли бы сделать с перечислением `Message`, определенным в листинге 6-2, которое является одним типом.

Есть еще одна сходство между перечислениями и структурами: так же, как мы можем определить методы для структур с использованием `impl`, мы также можем определить методы для перечислений. Вот метод под названием `call`, который мы могли бы определить для нашего перечисления `Message`:

```rust
impl Message {
    fn call(&self) {
      1 // тело метода будет определено здесь
    }
}

2 let m = Message::Write(String::from("hello"));
m.call();
```

Тело метода будет использовать `self`, чтобы получить значение, для которого был вызван метод. В этом примере мы создали переменную `m` \[2\], которая имеет значение `Message::Write(String::from("hello"))`, и это то, что будет `self` в теле метода `call` \[1\], когда выполняется `m.call()`.

Посмотрим на еще одно перечисление в стандартной библиотеке, которое очень распространено и полезно: `Option`.
