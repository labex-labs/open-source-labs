# Перечисление Option и его преимущества по сравнению с null-значениями

В этом разделе мы рассмотрим пример использования `Option`, которое является еще одним перечислением, определенным в стандартной библиотеке. Тип `Option` кодирует очень распространенную ситуацию, когда значение может быть чем-то или быть отсутствующим.

Например, если вы запрашиваете первый элемент в списке, содержащем несколько элементов, вы получите значение. Если вы запрашиваете первый элемент в пустом списке, вы ничего не получите. Выражение этой концепции в рамках типовой системы означает, что компилятор может проверить, обрабатываете ли вы все случаи, которые должны быть обработаны; эта функциональность может предотвратить ошибки, которые встречаются очень часто в других языках программирования.

В дизайне языков программирования часто говорят о том, какие функции вы включаете, но важны и те, которые вы исключаете. Rust не имеет функции null, как это есть в многих других языках. _Null_ - это значение, означающее, что там нет значения. В языках с null переменные всегда могут находиться в одном из двух состояний: null или not-null.

В своем докладе "Null References: The Billion Dollar Mistake" в 2009 году Tony Hoare, изобретатель null, говорит следующее:

> Я называю это моей ошибкой на миллиард долларов. Тогда я проектировал первую всеобъемлющую типовую систему для ссылок в объектно-ориентированном языке. Моя цель была гарантировать, что все использование ссылок будет абсолютно безопасным, с автоматической проверкой компилятором. Но я не смог сопротивиться соблазну вставить null-референс, просто потому, что он был настолько легко реализовать. Это привело к innumerable ошибкам, уязвимостям и сбоям системы, которые, вероятно, вызвали миллиард долларов урона и ущерба за последние сорок лет.
>
> Проблема с null-значениями заключается в том, что если вы пытаетесь использовать null-значение как not-null-значение, вы получите какую-то ошибку. Поскольку эта особенность null или not-null является всеобщей, очень легко допустить этот тип ошибки.

Однако концепция, которую пытается выразить null, по-прежнему полезна: null - это значение, которое в настоящее время недопустимо или отсутствует по какой-то причине.

Проблема не в самой концепции, а в конкретной реализации. Поэтому Rust не имеет null, но имеет перечисление, которое может закодировать концепцию наличия или отсутствия значения. Это перечисление - `Option<T>`, и оно определено в стандартной библиотеке следующим образом:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

Перечисление `Option<T>` настолько полезно, что даже включено в прелюд (prelude); вам не нужно явно подключать его в область видимости. Его варианты также включены в прелюд: вы можете напрямую использовать `Some` и `None` без префикса `Option::`. Перечисление `Option<T>` по-прежнему является обычным перечислением, и `Some(T)` и `None` по-прежнему являются вариантами типа `Option<T>`.

Синтаксис `<T>` - это особенность Rust, о которой мы еще не говорили. Это обобщенный параметр типа, и мы рассмотрим обобщения более подробно в главе 10. На данный момент все, что вам нужно знать, - это то, что `<T>` означает, что вариант `Some` перечисления `Option` может содержать одно значение любого типа, и каждый конкретный тип, используемый вместо `T`, делает весь тип `Option<T>` другим типом. Вот несколько примеров использования значений `Option` для хранения числовых типов и строковых типов:

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

Тип `some_number` - `Option<i32>`. Тип `some_char` - `Option<char>`, что является другим типом. Rust может вывести эти типы, потому что мы указали значение внутри варианта `Some`. Для `absent_number` Rust требует, чтобы мы указали общий тип `Option`: компилятор не может вывести тип, который будет содержаться в соответствующем варианте `Some`, только посмотрев на значение `None`. Здесь мы говорим Rust, что мы имеем в виду, что `absent_number` имеет тип `Option<i32>`.

Когда у нас есть значение `Some`, мы знаем, что значение присутствует, и оно содержится внутри `Some`. Когда у нас есть значение `None`, в некотором смысле это означает то же самое, что и null: у нас нет действительного значения. Тогда почему иметь `Option<T>` лучше, чем иметь null?

Коротко говоря, потому что `Option<T>` и `T` (где `T` может быть любым типом) - это разные типы, и компилятор не позволит нам использовать значение `Option<T>` так, будто оно определенно действительное значение. Например, этот код не скомпилируется, потому что он пытается сложить `i8` и `Option<i8>`:

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

Если мы запустим этот код, мы получим сообщение об ошибке, похожее на это:

```bash
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
```

Очень серьезная ошибка! По сути, это сообщение об ошибке означает, что Rust не понимает, как сложить `i8` и `Option<i8>`, потому что они - разные типы. Когда у нас есть значение типа `i8` в Rust, компилятор гарантирует, что у нас всегда есть действительное значение. Мы можем с уверенностью продолжать работу, не проверяя на null перед использованием этого значения. Только когда у нас есть `Option<i8>` (или любой другой тип значения, с которым мы работаем), мы должны беспокоиться о том, что может не быть значения, и компилятор убедит нас обработать этот случай перед использованием значения.

Другими словами, вы должны преобразовать `Option<T>` в `T`, прежде чем сможете выполнять операции с `T`. В целом, это помогает избежать одной из самых распространенных проблем с null: полагаться на то, что что-то не null, когда на самом деле оно является null.

Исключение риска неправильного полагания, что значение не null, помогает вам быть более уверенным в своем коде. Чтобы иметь значение, которое может быть null, вы должны явно указать это, сделав тип этого значения `Option<T>`. Затем, когда вы используете это значение, вы должны явно обработать случай, когда значение равно null. Везде, где значение имеет тип, отличный от `Option<T>`, вы _можете_ безопасно полагаться на то, что значение не null. Это была сознательная décision в дизайне Rust, чтобы ограничить распространенность null и повысить безопасность кода Rust.

Итак, как получить значение `T` из варианта `Some`, когда у вас есть значение типа `Option<T>`, чтобы вы могли использовать это значение? Перечисление `Option<T>` имеет большое количество методов, которые полезны в различных ситуациях; вы можете ознакомиться с ними в его документации. Закрепление методов на `Option<T>` будет очень полезно для вас в вашем опыте работы с Rust.

В целом, чтобы использовать значение `Option<T>`, вы должны написать код, который будет обрабатывать каждый вариант. Вы хотите, чтобы какой-то код работал только, когда у вас есть значение `Some(T)`, и этот код может использовать внутреннее значение `T`. Вы хотите, чтобы другой код работал только, если у вас есть значение `None`, и у этого кода нет доступного значения `T`. Выражение `match` - это конструкция управления потоком, которая делает именно это, когда используется с перечислениями: оно будет запускать разные коды в зависимости от варианта перечисления, и этот код может использовать данные внутри совпадающего значения.
