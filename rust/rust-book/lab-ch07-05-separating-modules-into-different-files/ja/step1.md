# モジュールを別々のファイルに分離する

これまで、この章のすべての例は 1 つのファイル内に複数のモジュールを定義してきました。モジュールが大きくなると、コードを読みやすくするために、それらの定義を別のファイルに移動したい場合があります。

たとえば、リスト 7-17 の複数のレストランモジュールがあるコードから始めましょう。すべてのモジュールをクレートのルートファイルに定義するのではなく、モジュールをファイルに抽出します。この場合、クレートのルートファイルは`src/lib.rs`ですが、この手順はクレートのルートファイルが`src/main.rs`であるバイナリクレートでも機能します。

まず、`front_of_house`モジュールを独自のファイルに抽出します。`front_of_house`モジュールの波括弧内のコードを削除し、`mod front_of_house;`宣言のみ残します。そうすると、`src/lib.rs`にはリスト 7-21 に示すコードが含まれます。ただし、リスト 7-22 の`src/front_of_house.rs`ファイルを作成するまで、これはコンパイルされません。

ファイル名：`src/lib.rs`

```rust
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

リスト 7-21: `front_of_house`モジュールを宣言し、その本体は`src/front_of_house.rs`にある

次に、波括弧内のコードを新しいファイル`src/front_of_house.rs`に配置します。コンパイラは、クレートのルートに`front_of_house`という名前のモジュール宣言に遭遇したので、このファイルを参照するようになっています。

ファイル名：`src/front_of_house.rs`

```rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
```

リスト 7-22: `src/front_of_house.rs`内の`front_of_house`モジュール内の定義

モジュールツリー内では、`mod`宣言を使用してファイルを読み込む必要は 1 回だけです。コンパイラがファイルがプロジェクトの一部であることを知り、`mod`ステートメントを配置した場所によってコードがモジュールツリーのどこにあるかを知っていると、プロジェクト内の他のファイルは宣言された場所へのパスを使用して、読み込まれたファイルのコードを参照する必要があります。これは、「モジュールツリー内のアイテムを参照するためのパス」で説明されています。言い換えると、`mod`は他のプログラミング言語で見たことのある「include」操作ではありません。

次に、`hosting`モジュールを独自のファイルに抽出します。プロセスは少し異なります。なぜなら、`hosting`は`front_of_house`の子モジュールであり、ルートモジュールの子モジュールではないからです。`hosting`のファイルを、モジュールツリー内のその親に基づいて名前付けられる新しいディレクトリに配置します。この場合、*src/front_of_house*です。

`hosting`を移動し始めるには、`src/front_of_house.rs`を変更して、`hosting`モジュールの宣言のみを含めます。

ファイル名：`src/front_of_house.rs`

```rust
pub mod hosting;
```

次に、`src/front_of_house`ディレクトリと`hosting.rs`ファイルを作成して、`hosting`モジュールで行われた定義を含めます。

ファイル名：`src/front_of_house/hosting.rs`

```rust
pub fn add_to_waitlist() {}
```

`hosting.rs`を`src`ディレクトリに置いた場合、コンパイラは`hosting.rs`のコードがクレートのルートに宣言された`hosting`モジュールにあり、`front_of_house`モジュールの子として宣言されていないことを期待します。コンパイラがどのモジュールのコードをどのファイルをチェックするかのルールは、ディレクトリとファイルがモジュールツリーとより密接に一致することを意味します。

> **代替ファイルパス**
>
> これまで、Rust コンパイラが使用する最も慣用的なファイルパスについて説明しましたが、Rust は古いスタイルのファイルパスもサポートしています。クレートのルートに宣言された`front_of_house`という名前のモジュールに対して、コンパイラは次の場所でモジュールのコードを探します。
>
> - `src/front_of_house.rs` (ここで説明したもの)
> - `src/front_of_house/mod.rs` (古いスタイル、まだサポートされているパス)
>
> `front_of_house`のサブモジュールである`hosting`という名前のモジュールに対して、コンパイラは次の場所でモジュールのコードを探します。
>
> - `src/front_of_house/hosting.rs` (ここで説明したもの)
> - `src/front_of_house/hosting/mod.rs` (古いスタイル、まだサポートされているパス)
>
> 同じモジュールで両方のスタイルを使用すると、コンパイラエラーが発生します。同じプロジェクト内の異なるモジュールで両方のスタイルを混合して使用することは可能ですが、プロジェクトを見て回る人にとって混乱する場合があります。
>
> `mod.rs`という名前のファイルを使用するスタイルの主な欠点は、プロジェクトに`mod.rs`という名前のファイルがたくさんある場合があり、エディタで同時に開いているときに混乱することがあることです。

各モジュールのコードを別々のファイルに移動しましたが、モジュールツリーは同じままです。`eat_at_restaurant`内の関数呼び出しは、定義が別のファイルにあるにもかかわらず、何の変更も加えずに機能します。このテクニックを使用すると、モジュールが大きくなったときに、モジュールを新しいファイルに移動できます。

`src/lib.rs`内の`pub use crate::front_of_house::hosting`ステートメントも変更されておらず、`use`もクレートの一部としてコンパイルされるファイルに影響を与えません。`mod`キーワードはモジュールを宣言し、Rust はそのモジュールに入るコードのために、モジュールと同じ名前のファイルを探します。
