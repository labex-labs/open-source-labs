# ベクトルの要素の読み取り

ベクトルに格納された値を参照する方法は 2 つあります。インデックスを使う方法と`get`メソッドを使う方法です。以下の例では、これらの関数から返される値の型を注釈付けして、より明確にしています。

リスト 8-4 は、インデックス構文と`get`メソッドの両方を使ってベクトルの値にアクセスする方法を示しています。

```rust
let v = vec![1, 2, 3, 4, 5];

1 let third: &i32 = &v[2];
println!("The third element is {third}");

2 let third: Option<&i32> = v.get(2);
match third  {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

リスト 8-4：インデックス構文と`get`メソッドを使ってベクトルの項目にアクセスする

ここでいくつかの詳細について注意してください。ベクトルは 0 から始まる番号でインデックス付けされるため、3 番目の要素を取得するにはインデックス値`2`を使います\[1\]。`&`と`[]`を使うことで、インデックス値の要素への参照が得られます。引数として渡されたインデックスを使って`get`メソッドを使うとき\[2\]、`Option<&T>`が得られ、これを`match`で使うことができます。

Rust はこの 2 つの方法を提供しています。既存の要素の範囲外のインデックス値を使おうとしたときのプログラムの動作を選ぶことができます。例えば、要素数が 5 のベクトルがあり、それぞれの手法でインデックス 100 の要素にアクセスしようとするときに何が起こるか見てみましょう。これは、リスト 8-5 に示すようになります。

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

リスト 8-5：要素数が 5 のベクトルのインデックス 100 の要素にアクセスしようとする

このコードを実行すると、最初の`[]`メソッドは存在しない要素を参照するため、プログラムがパニックになります。この方法は、ベクトルの末尾を超えて要素にアクセスしようとした場合にプログラムをクラッシュさせたいときに最適です。

`get`メソッドにベクトルの範囲外のインデックスが渡されると、パニックにならずに`None`を返します。通常の状況下でベクトルの範囲外の要素にアクセスすることが時々起こる場合には、この方法を使います。その後、コードは第 6 章で説明したように、`Some(&element)`または`None`のいずれかを持つ論理を持つことになります。たとえば、インデックスは人が数字を入力することから来る場合があります。彼らが偶然大きすぎる数字を入力し、プログラムが`None`値を取得した場合、現在のベクトルに何個の項目があるかをユーザーに伝え、有効な値を入力する機会をもう一度与えることができます。これは、誤字によってプログラムをクラッシュさせるよりもユーザーにやさしいでしょう！

プログラムが有効な参照を持っている場合、借用チェッカーは所有権と借用ルール（第 4 章で説明）を強制して、この参照とベクトルの内容への他の参照が有効なままであることを保証します。同じスコープ内に可変参照と不変参照があってはならないというルールがあることを思い出してください。このルールは、リスト 8-6 に当てはまります。ここでは、ベクトルの最初の要素への不変参照を保持し、末尾に要素を追加しようとしています。この関数の後半で同じ要素を参照しようとすると、このプログラムは動作しません。

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```

リスト 8-6：項目への参照を保持しながらベクトルに要素を追加しようとする

このコードをコンパイルすると、以下のエラーが発生します。

```bash
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here
```

リスト 8-6 のコードは動作するはずのように見えます。なぜ、最初の要素への参照がベクトルの末尾の変更に関係するはずがないのでしょうか。このエラーは、ベクトルの動作方法によるものです。ベクトルはメモリ上で値を隣接させるため、ベクトルの末尾に新しい要素を追加すると、すべての要素をベクトルが現在保存されている場所で隣接させるのに十分な空間がない場合、新しいメモリを割り当てて古い要素を新しい場所にコピーする必要があるかもしれません。その場合、最初の要素への参照は解放されたメモリを指してしまうことになります。借用ルールにより、プログラムがそのような状況に陥らないようになっています。

> 注：`Vec<T>`型の実装の詳細については、*https://doc.rust-lang.org/nomicon/vec/vec.html*の「The Rustonomicon」を参照してください。
