# ベクトル内の値を反復処理する

ベクトル内の各要素に順番にアクセスするには、一度に1つをアクセスするためにインデックスを使うのではなく、すべての要素を反復処理します。リスト8-7は、`for`ループを使って`i32`値のベクトル内の各要素に不変参照を取得し、それらを表示する方法を示しています。

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

リスト8-7：`for`ループを使って要素を反復処理してベクトル内の各要素を表示する

可変ベクトル内の各要素の可変参照を反復処理して、すべての要素に変更を加えることもできます。リスト8-8の`for`ループは、各要素に`50`を加えます。

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

リスト8-8：ベクトル内の要素の可変参照を反復処理する

可変参照が参照する値を変更するには、`+=`演算子を使う前に`*`参照解除演算子を使って`i`の値にアクセスする必要があります。「ポインタをたどって値に到達する」で参照解除演算子についてもっと話します。

借用チェッカーのルールのおかげで、ベクトルを不変または可変で反復処理することは安全です。リスト8-7とリスト8-8の`for`ループの本体で項目を挿入または削除しようとすると、リスト8-6のコードと同じようなコンパイラエラーが発生します。`for`ループが保持するベクトルへの参照により、ベクトル全体の同時変更が防止されます。
