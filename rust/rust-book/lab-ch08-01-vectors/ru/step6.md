# Использование перечисления для хранения нескольких типов

Векторы могут хранить только значения одного и того же типа. Это может быть неудобно; определенно есть сценарии использования, когда нужно хранить список элементов разных типов. К счастью, варианты перечисления определяются внутри одного и того же типа перечисления, поэтому когда нам нужен один тип для представления элементов разных типов, мы можем определить и использовать перечисление!

Например, предположим, что мы хотим получить значения из строки в электронной таблице, в которой некоторые столбцы строки содержат целые числа, некоторые — числа с плавающей точкой, а некоторые — строки. Мы можем определить перечисление, варианты которого будут хранить разные типы значений, и все варианты перечисления будут считаться одним и тем же типом: типом перечисления. Затем мы можем создать вектор для хранения этого перечисления и, таким образом, в конечном итоге хранить разные типы. Мы продемонстрировали это в Листинге 8-9.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

Листинг 8-9: Определение `enum` для хранения значений разных типов в одном векторе

Rust должен знать, какие типы будут в векторе на этапе компиляции, чтобы точно знать, сколько памяти на куче потребуется для хранения каждого элемента. Мы также должны быть явными о том, какие типы допустимы в этом векторе. Если Rust разрешал вектор хранить любой тип, есть вероятность, что один или несколько типов вызовут ошибки при выполнении операций над элементами вектора. Использование перечисления плюс выражение `match` означает, что Rust обеспечит обработку каждого возможного случая на этапе компиляции, как обсуждалось в главе 6.

Если вы не знаете полный набор типов, которые программа получит во время выполнения для хранения в векторе, метод с использованием перечисления не сработает. Вместо этого вы можете использовать объект-особность, о котором мы поговорим в главе 17.

Теперь, когда мы обсудили некоторые из самых распространенных способов использования векторов, обязательно ознакомьтесь с документацией по API для всех множества полезных методов, определенных для `Vec<T>` стандартной библиотекой. Например, помимо `push`, метод `pop` удаляет и возвращает последний элемент.
