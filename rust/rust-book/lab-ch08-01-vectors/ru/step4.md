# Чтение элементов векторов

Существует два способа обращаться к значению, хранящемуся в векторе: с использованием индексации или с использованием метода `get`. В следующих примерах мы указали типы возвращаемых значений из этих функций для большей ясности.

Листинг 8-4 показывает оба способа доступа к значению в векторе: с использованием синтаксиса индексации и метода `get`.

```rust
let v = vec![1, 2, 3, 4, 5];

1 let third: &i32 = &v[2];
println!("The third element is {third}");

2 let third: Option<&i32> = v.get(2);
match third  {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

Листинг 8-4: Использование синтаксиса индексации и метода `get` для доступа к элементу в векторе

Обратите внимание на несколько деталей здесь. Мы используем индексное значение `2`, чтобы получить третий элемент \[1\], потому что векторы индексируются числами, начиная с нуля. Использование `&` и `[]` дает нам ссылку на элемент с указанным индексным значением. Когда мы используем метод `get` с переданным в качестве аргумента индексом \[2\], мы получаем `Option<&T>`, которое мы можем использовать с `match`.

Rust предоставляет эти два способа обращаться к элементу, чтобы вы могли выбрать, как программа будет вести себя, когда вы пытаетесь использовать индексное значение за пределами диапазона существующих элементов. Например, давайте посмотрим, что произойдет, когда у нас есть вектор из пяти элементов, а затем мы пытаемся получить элемент с индексом 100 с использованием каждого из методов, как показано в Листинге 8-5.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

Листинг 8-5: Попытка получить элемент с индексом 100 в векторе, содержащем пять элементов

Когда мы запускаем этот код, первый метод `[]` вызовет панику программы, потому что он ссылается на несуществующий элемент. Этот метод лучше использовать, когда вы хотите, чтобы ваша программа завершилась с ошибкой, если есть попытка получить доступ к элементу за пределами конца вектора.

Когда методу `get` передается индекс, выходящий за пределы вектора, он возвращает `None` без паники. Вы бы использовали этот метод, если доступ к элементу за пределами диапазона вектора может偶尔 случаться при нормальных обстоятельствах. Затем в вашем коде будет логика для обработки ситуации, когда есть либо `Some(&element)`, либо `None`, как обсуждалось в главе 6. Например, индекс может поступать от пользователя, который вводит число. Если они случайно введут слишком большое число и программа получит значение `None`, вы можете сообщить пользователю, сколько элементов в текущем векторе, и дать им еще один шанс ввести правильное значение. Это будет более дружелюбным по отношению к пользователю, чем завершение программы из-за опечатки!

Когда программа имеет допустимую ссылку, проверщик ссылок накладывает правила владения и заимствования (рассмотренные в главе 4), чтобы убедиться, что эта ссылка и любые другие ссылки на содержимое вектора остаются валидными. Назовем правило, по которому нельзя иметь изменяемую и неизменяемую ссылки в одной области видимости. Это правило применяется в Листинге 8-6, где у нас есть неизменяемая ссылка на первый элемент в векторе, и мы пытаемся добавить элемент в конец. Эта программа не будет работать, если мы также попытаемся обратиться к этому элементу позже в функции.

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```

Листинг 8-6: Попытка добавить элемент в вектор, удерживая ссылку на элемент

Компиляция этого кода приведет к следующей ошибке:

```bash
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here
```

Код в Листинге 8-6 может показаться работоспособным: почему ссылка на первый элемент должна зависеть от изменений в конце вектора? Эта ошибка возникает из-за того, как работают векторы: поскольку векторы размещают значения рядом с друг другом в памяти, добавление нового элемента в конец вектора может потребовать выделения новой памяти и копирования старых элементов в новое пространство, если не хватает места, чтобы поместить все элементы рядом, где вектор текущий хранится. В таком случае ссылка на первый элемент будет указывать на освобожденную память. Правила заимствования препятствуют возникновению такой ситуации в программах.

> Примечание: Для получения дополнительной информации об имплементационных деталях типа `Vec<T>` см. "Rustonomicon" по адресу *https://doc.rust-lang.org/nomicon/vec/vec.html*.
