# 벡터의 요소 읽기

벡터에 저장된 값을 참조하는 방법에는 두 가지가 있습니다: 인덱싱 (indexing) 을 사용하거나 `get` 메서드를 사용하는 것입니다. 다음 예제에서는 추가적인 명확성을 위해 이러한 함수에서 반환되는 값의 타입을 주석 처리했습니다.

Listing 8-4 는 인덱싱 구문과 `get` 메서드를 사용하여 벡터의 값에 접근하는 두 가지 방법을 모두 보여줍니다.

```rust
let v = vec![1, 2, 3, 4, 5];

1 let third: &i32 = &v[2];
println!("The third element is {third}");

2 let third: Option<&i32> = v.get(2);
match third  {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

Listing 8-4: 인덱싱 구문과 `get` 메서드를 사용하여 벡터의 항목에 접근

여기서 몇 가지 세부 사항에 유의하세요. 벡터는 0 부터 시작하는 숫자로 인덱싱되므로 세 번째 요소를 얻기 위해 인덱스 값 `2`를 사용합니다 \[1]. `&`와 `[]`를 사용하면 인덱스 값의 요소에 대한 참조를 얻습니다. `get` 메서드를 인수로 전달된 인덱스와 함께 사용하면 \[2], `match`와 함께 사용할 수 있는 `Option<&T>`를 얻습니다.

Rust 는 기존 요소 범위를 벗어난 인덱스 값을 사용하려는 경우 프로그램이 어떻게 동작할지 선택할 수 있도록 이러한 두 가지 방법으로 요소에 접근할 수 있도록 합니다. 예를 들어, 다섯 개의 요소가 있는 벡터가 있고 각 기술을 사용하여 인덱스 100 의 요소에 접근하려는 경우 어떻게 되는지 Listing 8-5 에서 살펴보겠습니다.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

Listing 8-5: 다섯 개의 요소를 포함하는 벡터에서 인덱스 100 의 요소에 접근 시도

이 코드를 실행하면 첫 번째 `[]` 메서드는 존재하지 않는 요소를 참조하므로 프로그램이 패닉 (panic) 상태가 됩니다. 이 메서드는 벡터의 끝을 넘어 요소에 접근하려는 시도가 있을 경우 프로그램이 충돌하도록 하려는 경우에 가장 적합합니다.

`get` 메서드가 벡터 범위를 벗어난 인덱스를 전달받으면 패닉하지 않고 `None`을 반환합니다. 벡터 범위를 벗어난 요소에 접근하는 것이 정상적인 상황에서 가끔 발생할 수 있는 경우 이 메서드를 사용합니다. 그러면 코드는 6 장에서 설명한 대로 `Some(&element)` 또는 `None`을 처리하는 로직을 갖게 됩니다. 예를 들어, 인덱스는 사용자가 숫자를 입력하는 것에서 가져올 수 있습니다. 실수로 너무 큰 숫자를 입력하여 프로그램이 `None` 값을 얻으면 현재 벡터에 몇 개의 항목이 있는지 사용자에게 알리고 유효한 값을 입력할 수 있는 기회를 다시 줄 수 있습니다. 이는 오타로 인해 프로그램이 충돌하는 것보다 사용자 친화적입니다!

프로그램에 유효한 참조가 있는 경우, borrow checker 는 소유권 및 빌림 규칙 (4 장에서 다룸) 을 적용하여 이 참조와 벡터 내용에 대한 다른 모든 참조가 유효하게 유지되도록 합니다. 동일한 범위에서 가변 및 불변 참조를 가질 수 없다는 규칙을 기억하세요. 이 규칙은 Listing 8-6 에 적용됩니다. 여기서는 벡터의 첫 번째 요소에 대한 불변 참조를 유지하고 끝에 요소를 추가하려고 합니다. 이 프로그램은 함수에서 나중에 해당 요소를 참조하려는 경우 작동하지 않습니다.

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```

Listing 8-6: 항목에 대한 참조를 유지하면서 벡터에 요소를 추가하려는 시도

이 코드를 컴파일하면 다음과 같은 오류가 발생합니다.

```bash
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here
```

Listing 8-6 의 코드는 작동해야 하는 것처럼 보일 수 있습니다: 첫 번째 요소에 대한 참조가 벡터의 끝에서 변경 사항에 대해 왜 신경 써야 할까요? 이 오류는 벡터가 작동하는 방식 때문입니다: 벡터는 메모리에서 값을 서로 옆에 배치하므로, 벡터의 끝에 새 요소를 추가하려면 벡터가 현재 저장된 위치에 모든 요소를 서로 옆에 배치할 공간이 충분하지 않은 경우 새 메모리를 할당하고 이전 요소를 새 공간으로 복사해야 할 수 있습니다. 이 경우 첫 번째 요소에 대한 참조는 할당 해제된 메모리를 가리키게 됩니다. 빌림 규칙은 프로그램이 그런 상황에 빠지는 것을 방지합니다.

> 참고: `Vec<T>` 타입의 구현 세부 사항에 대한 자세한 내용은 *https://doc.rust-lang.org/nomicon/vec/vec.html*에서 "The Rustonomicon"을 참조하세요.
