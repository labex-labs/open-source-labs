# 열거형 (Enum) 을 사용하여 여러 타입 저장

벡터는 동일한 타입의 값만 저장할 수 있습니다. 이는 불편할 수 있습니다; 서로 다른 타입의 항목 목록을 저장해야 하는 사용 사례가 분명히 있습니다. 다행히, 열거형의 변형 (variant) 은 동일한 열거형 타입으로 정의되므로, 서로 다른 타입의 요소를 나타내는 하나의 타입이 필요할 때 열거형을 정의하고 사용할 수 있습니다!

예를 들어, 스프레드시트의 행에서 값을 가져오려고 하는데, 행의 일부 열에는 정수, 일부 부동 소수점 숫자, 일부 문자열이 포함되어 있다고 가정해 보겠습니다. 서로 다른 값 타입을 저장할 변형을 가진 열거형을 정의할 수 있으며, 모든 열거형 변형은 동일한 타입, 즉 열거형의 타입으로 간주됩니다. 그런 다음 해당 열거형을 저장하는 벡터를 생성할 수 있으며, 궁극적으로 서로 다른 타입을 저장합니다. Listing 8-9 에서 이를 시연했습니다.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

Listing 8-9: 하나의 벡터에 서로 다른 타입의 값을 저장하기 위해 `enum` 정의

Rust 는 컴파일 시간에 벡터에 어떤 타입이 포함될지 알아야 각 요소를 저장하는 데 필요한 힙 (heap) 메모리의 양을 정확히 알 수 있습니다. 또한 이 벡터에서 허용되는 타입에 대해 명시적으로 지정해야 합니다. Rust 가 벡터가 모든 타입을 저장하도록 허용하면 하나 이상의 타입이 벡터의 요소에 대해 수행되는 연산에서 오류를 발생시킬 가능성이 있습니다. 열거형과 `match` 표현식을 사용하면 Rust 는 6 장에서 설명한 대로 컴파일 시간에 모든 가능한 경우를 처리하도록 보장합니다.

프로그램이 런타임에 벡터에 저장할 타입의 전체 집합을 모르는 경우, 열거형 기술은 작동하지 않습니다. 대신, 17 장에서 다룰 트레이트 객체 (trait object) 를 사용할 수 있습니다.

이제 벡터를 사용하는 가장 일반적인 몇 가지 방법을 논의했으므로, 표준 라이브러리에 의해 `Vec<T>`에 정의된 많은 유용한 메서드의 API 문서를 검토하십시오. 예를 들어, `push` 외에도 `pop` 메서드는 마지막 요소를 제거하고 반환합니다.
