# Обновление значения на основе старого значения

Другой распространенный случай использования хеш - таблиц (hash maps) - это поиск значения по ключу и его обновление на основе старого значения. Например, в листинге 8 - 25 показан код, который подсчитывает, сколько раз каждое слово встречается в некотором тексте. Мы используем хеш - таблицу, где ключами являются слова, и увеличиваем значение, чтобы отслеживать, сколько раз мы встретили это слово. Если это первое появление слова, мы сначала вставим значение `0`.

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
```

Листинг 8 - 25: Подсчет количества вхождений слов с использованием хеш - таблицы, которая хранит слова и их количество

Этот код выведет `{"world": 2, "hello": 1, "wonderful": 1}`. Возможно, вы увидите те же пары ключ - значение, выведенные в другом порядке: помните, что из раздела "Доступ к значениям в хеш - таблице" итерирование по хеш - таблице происходит в произвольном порядке.

Метод `split_whitespace` возвращает итератор по подстрокам, разделенным пробелами, в значении переменной `text`. Метод `or_insert` возвращает изменяемую ссылку (`&mut V`) на значение для указанного ключа. Здесь мы сохраняем эту изменяемую ссылку в переменной `count`, поэтому, чтобы присвоить новое значение, мы должны сначала разыменовать `count` с помощью звездочки (`*`). Изменяемая ссылка выходит из области видимости в конце цикла `for`, поэтому все эти изменения безопасны и разрешены правилами заимствования (borrowing rules).
