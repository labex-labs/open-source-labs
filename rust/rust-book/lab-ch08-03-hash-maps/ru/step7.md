# Добавление ключа и значения только в случае, если ключ отсутствует

Часто требуется проверить, существует ли в хеш - таблице определенный ключ с каким - то значением, и затем предпринять следующие действия: если ключ уже есть в хеш - таблице, существующее значение должно остаться без изменений; если ключа нет, то вставить его и соответствующее значение.

Для этого хеш - таблицы имеют специальный API под названием `entry`, который принимает в качестве параметра ключ, который вы хотите проверить. Возвращаемое значение метода `entry` представляет собой перечисление (enum) под названием `Entry`, которое представляет собой значение, которое может существовать или не существовать. Предположим, что мы хотим проверить, есть ли у ключа для команды Yellow связанное с ним значение. Если нет, мы хотим вставить значение `50`, и то же самое для команды Blue. Используя API `entry`, код выглядит как в листинге 8 - 24.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
```

Листинг 8 - 24: Использование метода `entry` для вставки значения только в случае, если ключ еще не имеет значения

Метод `or_insert` у типа `Entry` возвращает изменяемую ссылку на значение для соответствующего ключа `Entry`, если этот ключ существует, и если нет, он вставляет переданный параметр в качестве нового значения для этого ключа и возвращает изменяемую ссылку на новое значение. Этот подход намного чище, чем написание такой логики самостоятельно, и, кроме того, лучше работает с механизмом проверки заимствования (borrow checker).

При запуске кода из листинга 8 - 24 будет выведено `{"Yellow": 50, "Blue": 10}`. Первый вызов `entry` вставит ключ для команды Yellow со значением `50`, потому что у команды Yellow еще нет значения. Второй вызов `entry` не изменит хеш - таблицу, потому что у команды Blue уже есть значение `10`.
