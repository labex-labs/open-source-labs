# キーが存在しない場合のみキーと値を追加する

特定のキーがハッシュマップにすでに値と関連付けられているかどうかを確認し、以下のアクションを実行することはよくあることです。キーがハッシュマップに存在する場合、既存の値はそのままにします。キーが存在しない場合、キーとそれに対する値を挿入します。

ハッシュマップにはこのための特別な API があり、`entry` と呼ばれています。この API は、確認したいキーをパラメータとして受け取ります。`entry` メソッドの戻り値は `Entry` という列挙型で、存在する場合と存在しない場合がある値を表します。Yellow チームのキーに関連付けられた値があるかどうかを確認したいとしましょう。値がない場合、値 `50` を挿入したいとします。Blue チームについても同様です。`entry` API を使用すると、コードはリスト 8-24 のようになります。

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
```

リスト 8-24: キーにすでに値がない場合のみ挿入するために `entry` メソッドを使用する

`Entry` の `or_insert` メソッドは、対応する `Entry` キーが存在する場合、そのキーの値への可変参照を返し、存在しない場合、パラメータをこのキーの新しい値として挿入し、新しい値への可変参照を返すように定義されています。この手法は、自分でロジックを書くよりもはるかにクリーンであり、さらに、借用チェッカーとの相性も良いです。

リスト 8-24 のコードを実行すると、`{"Yellow": 50, "Blue": 10}` が出力されます。最初の `entry` 呼び出しでは、Yellow チームにまだ値がないため、Yellow チームのキーに値 `50` が挿入されます。2 回目の `entry` 呼び出しでは、Blue チームにすでに値 `10` があるため、ハッシュマップは変更されません。
