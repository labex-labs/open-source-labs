# ワークスペースの作成

「ワークスペース」は、同じ「Cargo.lock」と出力ディレクトリを共有する一連のパッケージです。ワークスペースを使ってプロジェクトを作成してみましょう。単純なコードを使うので、ワークスペースの構造に集中できます。ワークスペースを構造化する方法は複数ありますが、一般的な方法の 1 つを示します。バイナリと 2 つのライブラリを含むワークスペースを作成します。メインの機能を提供するバイナリは、2 つのライブラリに依存します。1 つのライブラリは`add_one`関数を、もう 1 つのライブラリは`add_two`関数を提供します。これらの 3 つのクレートは同じワークスペースの一部になります。まず、ワークスペース用の新しいディレクトリを作成します。

```bash
mkdir add
cd add
```

次に、`add`ディレクトリ内で、ワークスペース全体を構成する`Cargo.toml`ファイルを作成します。このファイルには`[package]`セクションはありません。代わりに、`[workspace]`セクションから始まり、バイナリクレートがあるパッケージのパスを指定することで、ワークスペースにメンバーを追加できます。この場合、そのパスは「adder」です。

ファイル名：`Cargo.toml`

```toml
[workspace]

members = [
    "adder",
]
```

次に、`add`ディレクトリ内で`cargo new`を実行して`adder`バイナリクレートを作成します。

```bash
$ cargo new adder
     Created binary (application) `adder` package
```

この時点で、`cargo build`を実行することでワークスペースをビルドできます。`add`ディレクトリ内のファイルは次のようになっているはずです。

    ├── Cargo.lock
    ├── Cargo.toml
    ├── adder
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    └── target

ワークスペースには、コンパイル済みのアーティファクトが配置されるトップレベルの 1 つの`target`ディレクトリがあります。`adder`パッケージには独自の`target`ディレクトリはありません。たとえ`adder`ディレクトリ内から`cargo build`を実行しても、コンパイル済みのアーティファクトは`add/target`に配置され、`add/adder/target`にはなりません。Cargo はワークスペース内の`target`ディレクトリをこのように構造化します。なぜなら、ワークスペース内のクレートは互いに依存するように意図されているからです。各クレートが独自の`target`ディレクトリを持つ場合、各クレートはワークスペース内の他のクレートすべてを再コンパイルして、アーティファクトを独自の`target`ディレクトリに配置しなければなりません。1 つの`target`ディレクトリを共有することで、クレートは不要な再ビルドを回避できます。
