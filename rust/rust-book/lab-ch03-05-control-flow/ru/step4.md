# Использование if в let-выражении

Поскольку `if` является выражением, мы можем использовать его справа от `let`-выражения для присвоения результата переменной, как показано в Listing 3-2.

Имя файла: `src/main.rs`

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

Listing 3-2: Присваивание результата if-выражения переменной

Переменная `number` будет связана с значением в зависимости от результата `if`-выражения. Запустите этот код, чтобы увидеть, что произойдет:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
```

Помните, что блоки кода оцениваются по последнему выражению в них, а числа сами по себе также являются выражениями. В этом случае значение всего `if`-выражения зависит от того, какой блок кода выполняется. Это означает, что значения, которые могут быть результатами каждой ветви `if`, должны быть одного и того же типа; в Listing 3-2 результаты как ветви `if`, так и ветви `else` были целыми числами `i32`. Если типы не совпадают, как в следующем примере, мы получим ошибку:

Имя файла: `src/main.rs`

```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
```

Когда мы пытаемся скомпилировать этот код, мы получим ошибку. Ветви `if` и `else` имеют типы значений, которые несовместимы, и Rust указывает точно, где найти проблему в программе:

```bash
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { "six" };
  |                                 -          ^^^^^ expected integer, found
`&str`
  |                                 |
  |                                 expected because of this
```

Выражение в блоке `if` оценивается как целое число, а выражение в блоке `else` оценивается как строка. Это не сработает, потому что переменные должны иметь единый тип, и Rust должен знать на этапе компиляции, какой тип имеет переменная `number` определенно. Знание типа `number` позволяет компилятору проверить, что тип допустим во всех местах, где мы используем `number`. Rust не смог бы этого сделать, если тип `number` был определен только во время выполнения; компилятор был бы более сложным и давал бы меньшие гарантии о коде, если бы ему пришлось отслеживать несколько гипотетических типов для любой переменной.
