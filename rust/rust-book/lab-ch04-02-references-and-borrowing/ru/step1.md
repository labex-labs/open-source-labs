# References and Borrowing

Проблема с кодом кортежа в Listing 4-5 заключается в том, что мы должны вернуть `String` в вызывающую функцию, чтобы мы могли по-прежнему использовать `String` после вызова `calculate_length`, потому что `String` была передана в `calculate_length`. Вместо этого мы можем передать ссылку на значение `String`. _Ссылка_ похожа на указатель в том смысле, что это адрес, по которому мы можем получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат другой переменной. В отличие от указателя, гарантируется, что ссылка будет указывать на валидное значение определенного типа на протяжении жизни этой ссылки.

Вот как вы бы определили и использовали функцию `calculate_length`, которая имеет ссылку на объект в качестве параметра вместо взятия владения значением:

Filename: `src/main.rs`

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

Во-первых, обратите внимание, что весь код кортежа в объявлении переменной и возвращаемом значении функции исчез. Во-вторых, обратите внимание, что мы передаем `&s1` в `calculate_length`, а в ее определении мы используем `&String` вместо `String`. Эти амперсанды (`&`) представляют _ссылки_, и они позволяют ссылаться на какое-то значение, не беря при этом его владение. Рисунок 4-5 изображает этот концепт.

Рисунок 4-5: Диаграмма `&String s`, указывающая на `String s1`

> Примечание: Обратной операцией по ссылке, используемой с помощью `&`, является _разыменование_, которое осуществляется с помощью оператора разыменования, `*`. Мы увидим некоторые применения оператора разыменования в главе 8 и обсудим детали разыменования в главе 15.

Давайте более внимательно рассмотрим вызов функции здесь:

```rust
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

Синтаксис `&s1` позволяет нам создать ссылку, которая _ссылается_ на значение `s1`, но не владеет им. Поскольку мы не владеем им, значение, на которое она ссылается, не будет уничтожено, когда ссылка перестанет использоваться.

Аналогично, сигнатура функции использует `&`, чтобы показать, что тип параметра `s` является ссылкой. Добавим некоторые поясняющие аннотации:

```rust
fn calculate_length(s: &String) -> usize { // s - это ссылка на String
    s.len()
} // Здесь переменная s выходит из области видимости. Но поскольку она не имеет
  // владения тем, на что она ссылается, String не уничтожается
```

Область видимости, в которой переменная `s` действительна, совпадает с областью видимости любого параметра функции, но значение, на которое ссылается ссылка, не уничтожается, когда `s` перестает использоваться, потому что `s` не имеет владения. Когда функции имеют ссылки в качестве параметров вместо фактических значений, нам не нужно возвращать значения, чтобы передать обратно владение, потому что мы никогда не имели владения.

Мы называем действие создания ссылки _заимствованием_. Как в реальной жизни, если кто-то владеет чем-то, вы можете взять у него в долг. Когда вы закончите, вам нужно вернуть его. Вы не владеете им.

Так что произойдет, если мы попытаемся изменить что-то, что мы заимствуем? Попробуйте код из Listing 4-6. Предупреждение: это не работает!

Filename: `src/main.rs`

```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

Listing 4-6: Попытка изменить заимствованное значение

Вот ошибка:

```bash
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&`
reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable
reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so
the data it refers to cannot be borrowed as mutable
```

Точно так же, как переменные по умолчанию являются неизменяемыми, так и ссылки. Мы не можем изменить то, на что мы имеем ссылку.
