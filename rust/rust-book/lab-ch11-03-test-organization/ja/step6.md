# tests ディレクトリ

プロジェクトディレクトリのトップレベルに、`src` の隣に `tests` ディレクトリを作成します。Cargo はこのディレクトリ内の統合テストファイルを探すようになっています。その後、必要なだけ多くのテストファイルを作成でき、Cargo は各ファイルを個別のクレートとしてコンパイルします。

統合テストを作成しましょう。`src/lib.rs` ファイルにまだリスト 11-12 のコードがある状態で、`tests` ディレクトリを作成し、新しいファイル `tests/integration_test.rs` を作成します。ディレクトリ構造は以下のようになります。

    adder
    ├── Cargo.lock
    ├── Cargo.toml
    ├── src
    │   └── lib.rs
    └── tests
        └── integration_test.rs

リスト 11-13 のコードを `tests/integration_test.rs` ファイルに入力します。

ファイル名：`tests/integration_test.rs`

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
```

リスト 11-13: `adder` クレート内の関数の統合テスト

`tests` ディレクトリ内の各ファイルは別個のクレートであるため、ライブラリを各テストクレートのスコープに入れる必要があります。そのため、コードの上部に `use adder;` を追加します。これは単体テストでは必要ありませんでした。

`tests/integration_test.rs` 内のコードには `#[cfg(test)]` でアノテートする必要はありません。Cargo は `tests` ディレクトリを特別扱いし、`cargo test` を実行したときのみこのディレクトリ内のファイルをコンパイルします。今 `cargo test` を実行してみましょう。

```bash
[object Object]
```

出力の 3 つのセクションには、単体テスト、統合テスト、ドキュメントテストが含まれています。セクション内のテストが 1 つでも失敗すると、次のセクションは実行されません。たとえば、単体テストが失敗すると、統合テストとドキュメントテストの出力はありません。なぜなら、それらのテストはすべての単体テストが合格した場合にのみ実行されるからです。

単体テストの最初のセクション\[1\]は、これまで見てきたものと同じです。各単体テストに 1 行（リスト 11-12 で追加した `internal` という名前のもの）があり、その後に単体テストのサマリー行があります。

統合テストのセクションは、`Running tests/integration_test.rs` という行で始まります\[2\]。次に、その統合テスト内の各テスト関数に 1 行があり\[3\]、`Doc-tests adder` セクションが始まる直前に統合テストの結果のサマリー行があります\[4\]。

各統合テストファイルには独自のセクションがあるため、`tests` ディレクトリにさらにファイルを追加すると、統合テストのセクションが増えます。

特定の統合テスト関数を実行するには、`cargo test` に対してテスト関数の名前を引数として指定します。特定の統合テストファイル内のすべてのテストを実行するには、`cargo test` の `--test` 引数に続けてファイル名を指定します。

```bash
[object Object]
```

このコマンドは、`tests/integration_test.rs` ファイル内のテストのみを実行します。
