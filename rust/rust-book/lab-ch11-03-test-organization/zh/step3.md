# “tests” 模块与 `#[cfg(test)]`

`tests` 模块上的 `#[cfg(test)]` 注解告诉 Rust 仅在运行 `cargo test` 时才编译并运行测试代码，而在运行 `cargo build` 时不会这样做。这在你只想构建库时节省了编译时间，并且由于测试代码不包含在最终的编译产物中，还节省了空间。你会发现，因为集成测试放在不同的目录中，所以它们不需要 `#[cfg(test)]` 注解。然而，由于单元测试与代码位于同一个文件中，所以你要使用 `#[cfg(test)]` 来指定它们不应包含在编译结果中。

回想一下，当我们在本章的第一部分生成新的 `adder` 项目时，Cargo 为我们生成了以下代码：

文件名：`src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```

这段代码是自动生成的 `tests` 模块。属性 `cfg` 代表“配置”，并告诉 Rust 只有在给定特定配置选项时，才应包含以下项。在这种情况下，配置选项是 `test`，这是 Rust 提供的用于编译和运行测试的选项。通过使用 `cfg` 属性，只有当我们使用 `cargo test` 主动运行测试时，Cargo 才会编译我们的测试代码。这不仅包括用 `#[test]` 注解的函数，还包括该模块中可能存在的任何辅助函数。
