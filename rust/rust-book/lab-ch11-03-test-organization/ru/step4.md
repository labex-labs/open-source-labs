# Тестирование приватных функций

В сообществе тестирования существует дискуссия о том, следует ли тестировать приватные функции напрямую, и в других языках это может быть затруднительно или невозможно. Независимо от того, какому идеологии тестирования вы придерживаетесь, правила приватности Rust позволяют вам тестировать приватные функции. Рассмотрим код в Listing 11-12 с приватной функцией `internal_adder`.

Имя файла: src/lib.rs

```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

Listing 11-12: Тестирование приватной функции

Обратите внимание, что функция `internal_adder` не помечена как `pub`. Тесты - это просто Rust-код, а модуль `tests` - это просто другой модуль. Как мы обсуждали в разделе "Пути для обращения к элементу в дереве модулей", элементы в дочерних модулях могут использовать элементы в их предках. В этом тесте мы подтягиваем все элементы родителя модуля `test` в область видимости с помощью `use super::*`, и затем тест может вызвать `internal_adder`. Если вы не считаете, что приватные функции должны быть тестированы, в Rust ничего не заставит вас это делать.
