# Подмодули в интеграционных тестах

По мере добавления большего количества интеграционных тестов вы, возможно, захотите создать больше файлов в директории `tests`, чтобы упростить их организацию; например, можно сгруппировать тестовые функции по функциональности, которую они тестируют. Как уже упоминалось ранее, каждый файл в директории `tests` компилируется как отдельный крейт, что полезно для создания отдельных областей видимости, чтобы более точно имитировать способ использования вашего крейта конечными пользователями. Однако, это означает, что файлы в директории `tests` не обладают тем же поведением, что и файлы в `src`, как вы узнали в главе 7 о том, как разделить код на модули и файлы.

Различия в поведении файлов директории `tests` наиболее заметны, когда у вас есть набор вспомогательных функций, которые вы хотите использовать в нескольких файлах интеграционных тестов, и вы пытаетесь следовать шагам из раздела "Разделение модулей на разные файлы", чтобы извлечь их в общий модуль. Например, если мы создадим `tests/common.rs` и поместим в него функцию с именем `setup`, мы можем добавить в `setup` некоторый код, который мы хотим вызывать из нескольких тестовых функций в нескольких файлах тестов:

Имя файла: `tests/common.rs`

```rust
pub fn setup() {
    // здесь должен быть код настройки, специфичный для тестов вашей библиотеки
}
```

Когда мы снова запускаем тесты, мы увидим новый раздел в выводе тестов для файла `common.rs`, хотя в этом файле нет никаких тестовых функций, и мы не вызывали функцию `setup` ни откуда:

    running 1 test
    test tests::internal... ok

    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

         Running tests/common.rs (target/debug/deps/common-
    92948b65e88960b4)

    running 0 tests

    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

         Running tests/integration_test.rs
    (target/debug/deps/integration_test-92948b65e88960b4)

    running 1 test
    test it_adds_two... ok

    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

       Doc-tests adder

    running 0 tests

    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

Показать в результатах тестов `common` с `running 0 tests`, не то, что мы хотели. Мы просто хотели поделиться некоторым кодом с другими файлами интеграционных тестов. Чтобы избежать появления `common` в выводе тестов, вместо создания `tests/common.rs` мы создадим `tests/common/mod.rs`. Структура проекта теперь выглядит так:

    ├── Cargo.lock
    ├── Cargo.toml
    ├── src
    │   └── lib.rs
    └── tests
        ├── common
        │   └── mod.rs
        └── integration_test.rs

Это старый стандарт именования, который Rust также понимает, о котором мы говорили в разделе "Альтернативные пути к файлам". Такое именование файла сообщает Rust не рассматривать модуль `common` как файл интеграционного теста. Когда мы переносим код функции `setup` в `tests/common/mod.rs` и удаляем файл `tests/common.rs`, соответствующий раздел в выводе тестов больше не появится. Файлы в поддиректориях директории `tests` не компилируются как отдельные крейты и не появляются в выводе тестов.

После создания `tests/common/mod.rs` мы можем использовать его из любого файла интеграционного теста в качестве модуля. Вот пример вызова функции `setup` из теста `it_adds_two` в `tests/integration_test.rs`:

Имя файла: `tests/integration_test.rs`

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```

Обратите внимание, что объявление `mod common;` такое же, как и объявление модуля, которое мы демонстрировали в Listing 7-21. Затем, в тестовой функции, мы можем вызвать функцию `common::setup()`.
