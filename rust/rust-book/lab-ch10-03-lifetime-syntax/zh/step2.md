# 使用生命周期防止悬空引用

生命周期的主要目的是防止**悬空引用**，悬空引用会导致程序引用的数据并非它原本打算引用的数据。考虑清单 10-16 中的程序，它有一个外层作用域和一个内层作用域。

```rust
fn main() {
  1 let r;

    {
      2 let x = 5;
      3 r = &x;
  4 }

  5 println!("r: {r}");
}
```

清单 10-16：尝试使用其值已超出作用域的引用

> 注意：清单 10-16、10-17 和 10-23 中的示例声明了变量但未给它们赋初始值，所以变量名存在于外层作用域中。乍一看，这似乎与 Rust 没有空值相冲突。然而，如果我们在给变量赋值之前尝试使用它，会得到一个编译时错误，这表明 Rust 确实不允许空值。

外层作用域声明了一个名为`r`的变量，没有初始值\[1\]，内层作用域声明了一个名为`x`的变量，初始值为`5`\[2\]。在内层作用域中，我们尝试将`r`的值设置为对`x`的引用\[3\]。然后内层作用域结束\[4\]，我们尝试打印`r`中的值\[5\]。这段代码无法编译，因为在我们尝试使用`r`时，`r`所引用的值已经超出了作用域。以下是错误信息：

```bash
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                   - borrow later used here
```

错误信息说变量`x`“活得不够长”。原因是当内层作用域在第 7 行结束时，`x`将超出作用域。但`r`在外层作用域中仍然有效；因为它的作用域更大，我们说它“活得更长”。如果 Rust 允许这段代码运行，`r`将引用当`x`超出作用域时被释放的内存，而我们对`r`尝试做的任何事情都不会正确工作。那么 Rust 是如何确定这段代码无效的呢？它使用了一个借用检查器。
