# Общие жизненные циклы в функциях

Мы напишем функцию, которая возвращает более длинную из двух строковых срезов. Эта функция будет принимать два строковых среза и возвращать один строковый срез. После того, как мы реализуем функцию `longest`, код в Listing 10-19 должен вывести `The longest string is abcd`.

Имя файла: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {result}");
}
```

Listing 10-19: Функция `main`, которая вызывает функцию `longest`, чтобы найти более длинную из двух строковых срезов

Обратите внимание, что мы хотим, чтобы функция принимала строковые срезы, которые являются ссылками, а не строки, потому что мы не хотим, чтобы функция `longest` владела своими параметрами. См. раздел "Строковые срезы в качестве параметров", чтобы узнать больше о том, почему параметры, которые мы используем в Listing 10-19, именно те, которые нам нужны.

Если мы попытаемся реализовать функцию `longest`, как показано в Listing 10-20, она не скомпилируется.

Имя файла: `src/main.rs`

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Listing 10-20: Реализация функции `longest`, которая возвращает более длинную из двух строковых срезов, но еще не компилируется

Вместо этого мы получаем следующую ошибку, которая говорит о жизненных циклах:

```bash
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value,
but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++
```

Текст помощи показывает, что возвращаемый тип требует обобщенного параметра жизненного цикла, потому что Rust не может определить, на что ссылается возвращаемая ссылка: на `x` или на `y`. Действительно, мы и сами не знаем, потому что блок `if` в теле этой функции возвращает ссылку на `x`, а блок `else` возвращает ссылку на `y`!

Когда мы определяем эту функцию, мы не знаем конкретных значений, которые будут переданы в эту функцию, поэтому мы не знаем, будет ли выполняться `if`-условие или `else`-условие. Мы также не знаем конкретных жизненных циклов ссылок, которые будут переданы, поэтому мы не можем рассмотреть области видимости, как мы делали в Listings 10-17 и 10-18, чтобы определить, будет ли ссылка, которую мы возвращаем, всегда действительной. Проверщик заимствований также не может определить это, потому что он не знает, как жизненные циклы `x` и `y` связаны с жизненным циклом возвращаемого значения. Чтобы исправить эту ошибку, мы добавим обобщенные параметры жизненных циклов, которые определят связь между ссылками, чтобы проверщик заимствований мог провести свою анализ.
