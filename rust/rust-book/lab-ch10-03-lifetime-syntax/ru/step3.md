# Проверщик заимствований

Компилятор Rust имеет _проверщик заимствований_, который сравнивает области видимости, чтобы определить, все ли заимствования действительны. Listing 10-17 показывает ту же программу, что и Listing 10-16, но с аннотациями, показывающими жизненные циклы переменных.

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

Listing 10-17: Аннотации жизненных циклов `r` и `x`, названных соответственно `'a` и `'b`

Здесь мы аннотировали жизненный цикл `r` как `'a`, а жизненный цикл `x` как `'b`. Как вы можете видеть, внутренний блок `'b` намного меньше внешнего блока с жизненным циклом `'a`. При компиляции Rust сравнивает размер двух жизненных циклов и видит, что `r` имеет жизненный цикл `'a`, но ссылается на память с жизненным циклом `'b`. Программа отклоняется, потому что `'b` короче `'a`: субъект ссылки не живет столько времени, сколько ссылка.

Listing 10-18 исправляет код, чтобы он не имел утечки ссылки и компилируется без ошибок.

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

Listing 10-18: Действительная ссылка, потому что данные имеют более длинный жизненный цикл, чем ссылка

Здесь `x` имеет жизненный цикл `'b`, который в этом случае больше, чем `'a`. Это означает, что `r` может ссылаться на `x`, потому что Rust знает, что ссылка в `r` всегда будет действительной, пока `x` действителен.

Теперь, когда вы знаете, где находятся жизненные циклы ссылок и как Rust анализирует жизненные циклы, чтобы гарантировать, что ссылки всегда будут действительными, давайте исследуем общие жизненные циклы параметров и возвращаемых значений в контексте функций.
