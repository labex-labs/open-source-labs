# Аннотации жизненных циклов в определениях методов

Когда мы реализуем методы на структуре с жизненными циклами, мы используем ту же синтаксис, что и для обобщенных параметров типа, показанного в Listing 10-11. Место, где мы объявляем и используем параметры жизненных циклов, зависит от того, связаны ли они с полями структуры или с параметрами и возвращаемыми значениями метода.

Названия жизненных циклов для полей структуры всегда должны быть объявлены после ключевого слова `impl`, а затем использованы после имени структуры, потому что эти жизненные циклы являются частью типа структуры.

В сигнатурах методов внутри блока `impl` ссылки могут быть связаны с жизненным циклом ссылок в полях структуры или могут быть независимыми. Кроме того, правила элиминации жизненных циклов часто делают так, что аннотации жизненных циклов не нужны в сигнатурах методов. Давайте рассмотрим несколько примеров, используя структуру с именем `ImportantExcerpt`, которую мы определили в Listing 10-24.

Сначала мы используем метод с именем `level`, у которого единственный параметр - это ссылка на `self`, а возвращаемое значение - это `i32`, которое не является ссылкой на что-либо:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

Объявление параметра жизненного цикла после `impl` и его использование после имени типа обязательны, но мы не обязаны аннотировать жизненный цикл ссылки на `self` из-за первого правила элиминации.

Вот пример, где применяется третье правило элиминации жизненных циклов:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```

Есть два входных жизненных цикла, поэтому Rust применяет первое правило элиминации жизненных циклов и дает как `&self`, так и `announcement` свои собственные жизненные циклы. Затем, потому что один из параметров - это `&self`, возвращаемый тип получает жизненный цикл `&self`, и все жизненные циклы учтены.
