# Мышление в терминах жизненных циклов

Способ, которым нужно указывать параметры жизненных циклов, зависит от того, что делает ваша функция. Например, если мы изменим реализацию функции `longest` так, чтобы она всегда возвращала первый параметр, а не самый длинный строковый срез, нам не нужно указывать жизненный цикл для параметра `y`. Следующий код скомпилируется:

Имя файла: `src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

Мы указали параметр жизненного цикла `'a` для параметра `x` и возвращаемого типа, но не для параметра `y`, потому что жизненный цикл `y` не имеет никакого отношения с жизненным циклом `x` или возвращаемым значением.

При возврате ссылки из функции параметр жизненного цикла для возвращаемого типа должен совпадать с параметром жизненного цикла для одного из параметров. Если возвращаемая ссылка НЕ ссылается на один из параметров, она должна ссылаться на значение, созданное внутри этой функции. Однако, это будет утечка ссылки, потому что значение выйдет за пределы области видимости в конце функции. Рассмотрим эту попытку реализации функции `longest`, которая не скомпилируется:

Имя файла: `src/main.rs`

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

Здесь, хотя мы указали параметр жизненного цикла `'a` для возвращаемого типа, эта реализация не скомпилируется, потому что жизненный цикл возвращаемого значения не имеет никакого отношения с жизненным циклом параметров. Вот сообщение об ошибке, которое мы получаем:

```bash
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the
current function
```

Проблема в том, что `result` выходит за пределы области видимости и очищается в конце функции `longest`. Мы также пытаемся вернуть ссылку на `result` из функции. Мы не можем указать параметры жизненных циклов, которые бы изменили утечку ссылки, и Rust не позволит нам создать утечку ссылки. В этом случае лучшим решением будет возвращение типа данных, владеющего значением, а не ссылки, чтобы вызывающая функция была ответственна за очистку значения.

В конечном итоге синтаксис жизненных циклов связан с соединением жизненных циклов различных параметров и возвращаемых значений функций. Как только они соединены, Rust имеет достаточно информации, чтобы позволить безопасные операции с памятью и запретить операции, которые могут создать утечку указателей или иначе нарушить безопасность памяти.
