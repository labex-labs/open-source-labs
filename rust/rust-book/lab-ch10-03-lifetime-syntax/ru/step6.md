# Аннотации жизненных циклов в сигнатурах функций

Для использования аннотаций жизненных циклов в сигнатурах функций нам нужно объявить обобщенные параметры _жизненного цикла_ внутри угловых скобок между именем функции и списком параметров, так же, как мы это делали с обобщенными параметрами _типа_.

Мы хотим, чтобы сигнатура выражала следующее ограничение: возвращаемая ссылка будет действительной столько долго, сколько и оба параметра. Это отношение между жизненными циклами параметров и возвращаемым значением. Мы назовем жизненный цикл `'a` и затем добавим его к каждой ссылке, как показано в Listing 10-21.

Имя файла: `src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Listing 10-21: Определение функции `longest`, которое указывает, что все ссылки в сигнатуре должны иметь один и тот же жизненный цикл `'a`

Этот код должен скомпилироваться и дать результат, который мы хотим, когда мы используем его с функцией `main` из Listing 10-19.

Сигнатура функции теперь говорит Rust, что для некоторого жизненного цикла `'a` функция принимает два параметра, оба из которых являются строковыми срезами, которые живут по крайней мере столько же времени, сколько и жизненный цикл `'a`. Сигнатура функции также говорит Rust, что строковый срез, возвращаемый функцией, будет жить по крайней мере столько же времени, сколько и жизненный цикл `'a`. На практике это означает, что жизненный цикл ссылки, возвращаемой функцией `longest`, совпадает с меньшим из жизненных циклов значений, на которые ссылаются аргументы функции. Эти отношения - то, что мы хотим, чтобы Rust использовал при анализе этого кода.

Помните, когда мы указываем параметры жизненных циклов в этой сигнатуре функции, мы не меняем жизненные циклы любых переданных или возвращаемых значений. Вместо этого мы указываем, что проверщик заимствований должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что функция `longest` не должна точно знать, насколько долго будут жить `x` и `y`, только что какой-то объем области видимости может быть подставлен вместо `'a`, который будет удовлетворять этой сигнатуре.

При аннотации жизненных циклов в функциях аннотации размещаются в сигнатуре функции, а не в теле функции. Аннотации жизненных циклов становятся частью контракта функции, очень похожими на типы в сигнатуре. То, что сигнатуры функций содержат контракт жизненного цикла, означает, что анализ, который делает компилятор Rust, может быть проще. Если есть проблема с тем, как функция аннотирована или вызывается, ошибки компилятора могут указывать на часть нашего кода и ограничения точнее. Если бы вместо этого компилятор Rust делал больше выводов о том, какие отношения между жизненными циклами мы имеем в виду, компилятор, возможно, смог бы только указать на использование нашего кода на много шагов от причины проблемы.

Когда мы передаем конкретные ссылки в `longest`, конкретный жизненный цикл, который подставляется вместо `'a`, - это часть области видимости `x`, которая пересекается с областью видимости `y`. Другими словами, обобщенный жизненный цикл `'a` получит конкретный жизненный цикл, равный меньшему из жизненных циклов `x` и `y`. Поскольку мы аннотировали возвращаемую ссылку тем же параметром жизненного цикла `'a`, возвращаемая ссылка также будет действительной в течение времени меньшего из жизненных циклов `x` и `y`.

Давайте посмотрим, как аннотации жизненных циклов ограничивают функцию `longest`, передавая ссылки с разными конкретными жизненными циклами. Listing 10-22 - простой пример.

Имя файла: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

Listing 10-22: Использование функции `longest` с ссылками на значения `String`, которые имеют разные конкретные жизненные циклы

В этом примере `string1` действителен до конца внешней области видимости, `string2` действителен до конца внутренней области видимости, и `result` ссылается на что-то, что действительно до конца внутренней области видимости. Запустите этот код, и вы увидите, что проверщик заимствований одобряет его; он скомпилируется и выведет `The longest string is long string is long`.

Далее, давайте попробуем пример, который покажет, что жизненный цикл ссылки в `result` должен быть меньшим жизненным циклом из двух аргументов. Мы переместите объявление переменной `result` за пределы внутренней области видимости, но оставим присвоение значения переменной `result` внутри области видимости с `string2`. Затем мы переместим `println!`, которое использует `result`, за пределы внутренней области видимости, после того, как внутренняя область видимости закончится. Код в Listing 10-23 не скомпилируется.

Имя файла: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

Listing 10-23: Попытка использовать `result` после того, как `string2` вышло за пределы области видимости

Когда мы пытаемся скомпилировать этот код, мы получаем эту ошибку:

```bash
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value
does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                      ------ borrow later used here
```

Ошибка показывает, что для того, чтобы `result` был действительным для инструкции `println!`, `string2` должен быть действительным до конца внешней области видимости. Rust знает это, потому что мы аннотировали жизненные циклы параметров функции и возвращаемого значения с использованием одного и того же параметра жизненного цикла `'a`.

Как люди, мы можем посмотреть на этот код и понять, что `string1` длиннее `string2`, и поэтому, `result` будет содержать ссылку на `string1`. Поскольку `string1` еще не вышло за пределы области видимости, ссылка на `string1` по-прежнему будет действительной для инструкции `println!`. Однако, компилятор не может увидеть, что ссылка действительна в этом случае. Мы сказали Rust, что жизненный цикл ссылки, возвращаемой функцией `longest`, совпадает с меньшим из жизненных циклов переданных ссылок. Поэтому проверщик заимствований не позволяет коду в Listing 10-23, так как он может иметь недействительную ссылку.

Попробуйте спроектировать больше экспериментов, которые изменяют значения и жизненные циклы ссылок, передаваемых в функцию `longest`, и то, как возвращаемая ссылка используется. Сделайте гипотезы о том, пройдет ли ваш эксперимент проверку заимствований до компиляции; затем проверьте, правильно ли вы угадали!
