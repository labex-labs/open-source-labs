# Предотвращение утечки ссылок с использованием жизненных циклов

Основная цель жизненных циклов - предотвратить _утечку ссылок_, которая заставляет программу ссылаться на данные, отличные от тех, на которые она должна ссылаться. Рассмотрим программу в Listing 10-16, которая имеет внешнюю и внутреннюю области видимости.

```rust
fn main() {
  1 let r;

    {
      2 let x = 5;
      3 r = &x;
  4 }

  5 println!("r: {r}");
}
```

Listing 10-16: Попытка использовать ссылку, значение которой вышло за пределы области видимости

> Примечание: Примеры в Listing 10-16, 10-17 и 10-23 объявляют переменные без инициализации значений, поэтому имя переменной существует в внешней области видимости. С первого взгляда это может показаться противоречащим тому, что в Rust нет значений null. Однако, если мы попытаемся использовать переменную до того, как присвоить ей значение, мы получим ошибку компиляции, что показывает, что Rust действительно не позволяет использовать значения null.

Внешняя область видимости объявляет переменную `r` без начального значения \[1\], а внутренняя область видимости объявляет переменную `x` с начальным значением `5` \[2\]. Внутри внутренней области видимости мы пытаемся присвоить значение `r` ссылкой на `x` \[3\]. Затем внутренняя область видимости заканчивается \[4\], и мы пытаемся вывести значение из `r` \[5\]. Этот код не скомпилируется, потому что значение, на которое ссылается `r`, вышло за пределы области видимости до того, как мы пытаемся использовать его. Вот сообщение об ошибке:

```bash
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                   - borrow later used here
```

Сообщение об ошибке говорит, что переменная `x` "не живет достаточно долго". Причина в том, что `x` будет вне области видимости, когда внутренняя область видимости заканчивается на строке 7. Но `r` по-прежнему действителен для внешней области видимости; так как ее область видимости больше, мы говорим, что она "живет дольше". Если Rust разрешил бы этот код работать, `r` ссылался бы на память, которая была освобождена, когда `x` вышло за пределы области видимости, и все, что мы бы хотели сделать с `r`, не работало бы правильно. Так как же Rust определяет, что этот код недействителен? Он использует проверщик заимствований.
