# 寿命省略

あなたは、すべての参照には寿命があり、参照を使用する関数や構造体には寿命パラメータを指定する必要があることを学びました。しかし、リスト 4-9 にある関数を見てみましょう。これは、リスト 10-25 に再掲されていますが、寿命注釈なしでコンパイルされました。

ファイル名：`src/lib.rs`

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

リスト 10-25：寿命注釈なしでコンパイルされた、リスト 4-9 で定義した関数。パラメータと返り値の型は参照であるにもかかわらず

この関数が寿命注釈なしでコンパイルされる理由は、歴史的なものです。Rust の初期バージョン（1.0 以前）では、このコードはコンパイルされませんでした。なぜなら、すべての参照に明示的な寿命が必要だったからです。当時、関数のシグネチャはこのように書かれていました。

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

多くの Rust コードを書いた後、Rust の開発チームは、Rust のプログラマが特定の状況で同じ寿命注釈を何度も入力していることに気付きました。これらの状況は予測可能で、いくつかの決定論的なパターンに従っていました。開発者たちは、これらのパターンをコンパイラのコードにプログラムしました。その結果、借用チェッカーはこれらの状況での寿命を推論することができ、明示的な注釈が必要なくなりました。

この Rust の歴史は重要です。なぜなら、より多くの決定論的なパターンが現れ、コンパイラに追加される可能性があるからです。将来的には、さらに少ない寿命注釈が必要になるかもしれません。

Rust の参照分析にプログラムされたパターンは、「寿命省略規則」と呼ばれます。これは、プログラマが従う規則ではありません。コンパイラが考慮する特定のケースのセットであり、あなたのコードがこれらのケースに適合する場合、明示的に寿命を書く必要はありません。

省略規則は完全な推論を提供しません。Rust が規則を決定論的に適用しても、参照の寿命が何であるかに関して曖昧さが残る場合、コンパイラは残りの参照の寿命が何であるべきかを推測することはありません。推測する代わりに、コンパイラは寿命注釈を追加することで解決できるエラーを表示します。

関数またはメソッドのパラメータの寿命は「入力寿命」と呼ばれ、返り値の寿命は「出力寿命」と呼ばれます。

明示的な注釈がない場合、コンパイラは 3 つの規則を使って参照の寿命を判断します。最初の規則は入力寿命に適用され、2 番目と 3 番目の規則は出力寿命に適用されます。コンパイラが 3 つの規則の最後まで到達しても、寿命を判断できない参照がまだある場合、コンパイラはエラーで停止します。これらの規則は、`fn`定義だけでなく、`impl`ブロックにも適用されます。

最初の規則は、コンパイラが参照である各パラメータに寿命パラメータを割り当てることです。言い換えると、1 つのパラメータを持つ関数は 1 つの寿命パラメータを取得します。`fn foo<'a>(x: &'a i32)`; 2 つのパラメータを持つ関数は 2 つの別々の寿命パラメータを取得します。`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; などです。

2 番目の規則は、入力寿命パラメータが正確に 1 つの場合、その寿命がすべての出力寿命パラメータに割り当てられることです。`fn foo<'a>(x: &'a i32) -> &'a i32`。

3 番目の規則は、入力寿命パラメータが複数ある場合でも、そのうちの 1 つが`&self`または`&mut self`である場合（これはメソッドであるため）、`self`の寿命がすべての出力寿命パラメータに割り当てられることです。この 3 番目の規則により、メソッドは読みやすく書きやすくなります。なぜなら、必要なシンボルが少なくなるからです。

コンパイラになってみましょう。リスト 10-25 の`first_word`関数のシグネチャにおける参照の寿命を判断するために、これらの規則を適用します。シグネチャは、参照に関連付けられた寿命がない状態から始まります。

```rust
fn first_word(s: &str) -> &str {
```

そして、コンパイラは最初の規則を適用します。この規則によれば、各パラメータに独自の寿命が割り当てられます。いつものように`'a`と呼びます。すると、現在のシグネチャはこうなります。

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

2 番目の規則が適用されます。なぜなら、入力寿命が正確に 1 つだからです。2 番目の規則によれば、1 つの入力パラメータの寿命が出力寿命に割り当てられます。したがって、現在のシグネチャはこうなります。

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

これで、この関数のシグネチャ内のすべての参照に寿命があり、コンパイラはこの関数のシグネチャ内の寿命を注釈する必要がなく、分析を続けることができます。

もう 1 つの例を見てみましょう。今回は、リスト 10-20 で最初に取り扱ったときに寿命パラメータがなかった`longest`関数を使います。

```rust
fn longest(x: &str, y: &str) -> &str {
```

最初の規則を適用しましょう。各パラメータに独自の寿命が割り当てられます。今回は 1 つではなく 2 つのパラメータがあるので、2 つの寿命があります。

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

2 番目の規則は適用されません。なぜなら、入力寿命が 1 つ以上あるからです。3 番目の規則も適用されません。なぜなら、`longest`は関数であり、メソッドではないからです。したがって、どのパラメータも`self`ではありません。3 つの規則すべてを適用しても、まだ返り値の寿命が何であるかを判断できません。これが、リスト 10-20 のコードをコンパイルしようとしたときにエラーが発生した理由です。コンパイラは寿命省略規則を適用しましたが、シグネチャ内の参照のすべての寿命を判断することができませんでした。

3 番目の規則は実際には主にメソッドのシグネチャにのみ適用されます。次に、このコンテキストで寿命を見てみましょう。なぜ 3 番目の規則が、メソッドのシグネチャで寿命を頻繁に注釈する必要がないことを意味するのかを理解するためです。
