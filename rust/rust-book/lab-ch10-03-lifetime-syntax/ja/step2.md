# 寿命を使ったダングリング参照の防止

寿命の主な目的は、プログラムが参照するべきデータ以外のデータを参照するようにする「ダングリング参照」を防止することです。リスト 10-16 のプログラムを見てみましょう。このプログラムには外側のスコープと内側のスコープがあります。

```rust
fn main() {
  1 let r;

    {
      2 let x = 5;
      3 r = &x;
  4 }

  5 println!("r: {r}");
}
```

リスト 10-16：値のスコープが終了した参照を使用しようとするコード

> 注：リスト 10-16、10-17、および 10-23 の例では、変数を宣言して初期値を与えていません。したがって、変数名は外側のスコープに存在します。一見すると、これは Rust には null 値がないことと矛盾しているように見えるかもしれません。しかし、値を与える前に変数を使用しようとすると、コンパイル時エラーが発生します。これは、Rust が実際に null 値を許可していないことを示しています。

外側のスコープでは、初期値を持たない`r`という名前の変数が宣言されています\[1\]。内側のスコープでは、初期値が`5`の`x`という名前の変数が宣言されています\[2\]。内側のスコープ内では、`r`の値を`x`への参照として設定しようとしています\[3\]。そして内側のスコープが終了します\[4\]。その後、`r`の値を表示しようとします\[5\]。このコードはコンパイルされません。なぜなら、`r`が参照する値は、使用しようとする前にスコープが終了してしまっているからです。エラーメッセージは次の通りです。

```bash
error[E0597]: `x` does not live long enough
 --> src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |
9 |     println!("r: {r}");
  |                   - borrow later used here
```

エラーメッセージには、変数`x`が「十分に長く生存していません」と表示されています。その理由は、`x`は 7 行目で内側のスコープが終了するときにスコープ外になってしまうからです。一方、`r`は外側のスコープでは依然として有効です。そのスコープが大きいため、「より長く生存している」と言います。もし Rust がこのコードを動作させるように許可した場合、`r`は`x`がスコープ外になったときに解放されたメモリを参照してしまい、`r`を使って行おうとした何らかの操作が正しく機能しなくなります。では、Rust はどのようにしてこのコードが無効であることを判断するのでしょうか？それは借用チェッカーを使っています。
