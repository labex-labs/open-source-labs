# 関数シグネチャにおける寿命注釈

関数シグネチャで寿命注釈を使用するには、関数名とパラメータリストの間の角括弧の中にジェネリックな「寿命」パラメータを宣言する必要があります。これは、ジェネリックな「型」パラメータを宣言する場合と同じです。

シグネチャには次の制約を表現してほしいです。返される参照は、両方のパラメータが有効な限り有効です。これがパラメータの寿命と返り値の寿命の関係です。寿命を`'a`と名付け、それを各参照に追加します。リスト10-21を参照してください。

ファイル名: `src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

リスト10-21：シグネチャ内のすべての参照が同じ寿命`'a`を持つことを指定する`longest`関数の定義

このコードはコンパイルされ、リスト10-19の`main`関数と一緒に使用したときに期待する結果を生成するはずです。

関数シグネチャは現在、Rustに対して、ある寿命`'a`に対して、関数は2つのパラメータを受け取り、その両方が少なくとも寿命`'a`と同じ期間生存する文字列スライスであることを伝えています。関数シグネチャはまた、関数から返される文字列スライスが少なくとも寿命`'a`と同じ期間生存することもRustに伝えています。実際のところ、これは`longest`関数が返す参照の寿命が、関数引数が参照する値の寿命の小さい方と同じであることを意味します。これらの関係は、Rustがこのコードを分析する際に使用するものです。

覚えておいてください。この関数シグネチャで寿命パラメータを指定するとき、渡される値や返される値の寿命を変更するわけではありません。むしろ、借用チェッカーがこれらの制約に準拠しない値を拒否するように指定しているのです。`longest`関数は、`x`と`y`がどれくらいの期間生存するかを正確に知る必要はありません。ただ、このシグネチャを満たす`'a`に置き換えることができるあるスコープがあることだけを知っていればよいのです。

関数の寿命を注釈する場合、注釈は関数シグネチャに入り、関数本体には入りません。寿命注釈は、シグネチャ内の型と同じように、関数の契約の一部になります。関数シグネチャに寿命契約を含めることで、Rustコンパイラが行う分析を簡単にすることができます。関数の注釈方法や呼び出し方法に問題がある場合、コンパイラエラーはコードの部分と制約をより正確に指摘することができます。逆に、Rustコンパイラが寿命の関係をどのように推論するかをもっと行う場合、コンパイラは問題の原因から何段階も離れたコードの使用箇所を指摘できるだけかもしれません。

`longest`に具体的な参照を渡すとき、`'a`に置き換えられる具体的な寿命は、`x`のスコープのうち`y`のスコープと重なる部分です。言い換えると、ジェネリックな寿命`'a`は、`x`と`y`の寿命の小さい方に等しい具体的な寿命を取得します。返される参照に同じ寿命パラメータ`'a`を付けたので、返される参照も`x`と`y`の寿命の小さい方の期間だけ有効になります。

次に、異なる具体的な寿命を持つ参照を渡すことで、寿命注釈が`longest`関数をどのように制限するかを見てみましょう。リスト10-22は簡単な例です。

ファイル名: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

リスト10-22：異なる具体的な寿命を持つ`String`値への参照を使って`longest`関数を使用する

この例では、`string1`は外側のスコープの終了まで有効で、`string2`は内側のスコープの終了まで有効で、`result`は内側のスコープの終了まで有効なものを参照しています。このコードを実行すると、借用チェッカーが承認することがわかります。コンパイルされ、`The longest string is long string is long`と表示されます。

次に、`result`の参照の寿命が2つの引数のうち小さい方の寿命でなければならないことを示す例を試してみましょう。`result`変数の宣言を内側のスコープの外に移動しますが、`result`変数への値の代入は`string2`があるスコープ内に残します。そして、`result`を使用する`println!`を内側のスコープの外に、内側のスコープが終了した後に移動します。リスト10-23のコードはコンパイルされません。

ファイル名: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

リスト10-23：`string2`がスコープ外になった後に`result`を使用しようとする

このコードをコンパイルしようとすると、次のエラーが表示されます。

```bash
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value
does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                      ------ borrow later used here
```

このエラーは、`println!`文に対して`result`が有効であるためには、`string2`が外側のスコープの終了まで有効である必要があることを示しています。Rustはこれを知っています。なぜなら、関数のパラメータと返り値の寿命を同じ寿命パラメータ`'a`を使って注釈付けしたからです。

人間としては、このコードを見ると`string1`が`string2`より長いことがわかり、したがって、`result`は`string1`への参照を含むことになります。`string1`がまだスコープ外になっていないので、`string1`への参照は`println!`文に対してまだ有効です。しかし、コンパイラはこの場合に参照が有効であることを見ることができません。`longest`関数が返す参照の寿命が、渡された参照の寿命の小さい方と同じであることを私たちはRustに伝えています。したがって、借用チェッカーは、リスト10-23のコードが無効な参照を持つ可能性があるために許可しません。

`longest`関数に渡される参照の値や寿命、および返される参照の使用方法を変えるような、さらに多くの実験を試してみてください。コンパイルする前に、実験が借用チェッカーを通過するかどうかについて仮説を立ててみてください。そして、あなたが正しいかどうかを確認してみてください！
