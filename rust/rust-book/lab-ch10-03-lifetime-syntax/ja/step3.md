# 借用チェッカー

Rustコンパイラには、すべての借用が有効であるかどうかを判断するためにスコープを比較する「借用チェッカー」があります。リスト10-17は、リスト10-16と同じコードですが、変数の寿命を示す注釈付きです。

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

リスト10-17：それぞれ`'a`と`'b`と名付けられた`r`と`x`の寿命の注釈

ここでは、`r`の寿命を`'a`で、`x`の寿命を`'b`で注釈付けしています。ご覧の通り、内側の`'b`ブロックは外側の`'a`寿命ブロックよりもはるかに小さいです。コンパイル時に、Rustは2つの寿命のサイズを比較し、`r`が`'a`の寿命を持っていることを確認しますが、それが寿命`'b`のメモリを参照していることも確認します。このプログラムは拒否されます。なぜなら、`'b`は`'a`よりも短いからです。つまり、参照の対象は参照自体よりも長く生存しません。

リスト10-18では、コードを修正してダングリング参照がなく、コンパイルエラーなくコンパイルできるようにしました。

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

リスト10-18：データの寿命が参照よりも長いため、有効な参照

ここでは、`x`が寿命`'b`を持ち、この場合、`'b`は`'a`よりも大きいです。これは、`r`が`x`を参照できることを意味します。なぜなら、Rustは`r`の参照が`x`が有効な限り常に有効であることを知っているからです。

これで、参照の寿命がどこにあるか、およびRustが寿命をどのように分析して参照が常に有効であることを保証するかをご理解いただけたので、関数のコンテキストでのパラメータと戻り値のジェネリックな寿命を探ってみましょう。
