# 함수 시그니처의 생명주기 어노테이션

함수 시그니처에서 생명주기 어노테이션을 사용하려면, 제네릭 _타입_ 매개변수를 사용했던 것처럼, 함수 이름과 매개변수 목록 사이에 꺾쇠 괄호 안에 제네릭 _생명주기_ 매개변수를 선언해야 합니다.

반환된 참조가 두 매개변수 모두 유효한 한 유효하도록 시그니처를 표현하고 싶습니다. 이것이 매개변수의 생명주기와 반환 값 간의 관계입니다. 생명주기를 `'a`로 지정한 다음, Listing 10-21 과 같이 각 참조에 추가합니다.

Filename: `src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Listing 10-21: 시그니처의 모든 참조가 동일한 생명주기 `'a`를 가져야 함을 지정하는 `longest` 함수 정의

이 코드는 Listing 10-19 의 `main` 함수와 함께 사용하면 컴파일되고 원하는 결과를 생성해야 합니다.

이제 함수 시그니처는 Rust 에게 어떤 생명주기 `'a`에 대해, 함수가 두 개의 매개변수를 가지며, 둘 다 생명주기 `'a`만큼 오래 지속되는 문자열 슬라이스임을 알려줍니다. 함수 시그니처는 또한 함수에서 반환된 문자열 슬라이스가 생명주기 `'a`만큼 오래 지속될 것임을 Rust 에게 알려줍니다. 실제로, 이것은 `longest` 함수에 의해 반환된 참조의 생명주기가 함수 인수에 의해 참조되는 값의 생명주기 중 더 작은 것과 같다는 것을 의미합니다. 이러한 관계는 Rust 가 이 코드를 분석할 때 사용하기를 원하는 것입니다.

이 함수 시그니처에서 생명주기 매개변수를 지정할 때, 전달되거나 반환되는 값의 생명주기를 변경하는 것이 아님을 기억하십시오. 대신, 이러한 제약 조건을 준수하지 않는 모든 값을 차용 검사기가 거부하도록 지정하는 것입니다. `longest` 함수는 `x`와 `y`가 정확히 얼마나 오래 지속될지 알 필요가 없으며, 이 시그니처를 만족할 수 있는 어떤 범위가 `'a`를 대체할 수 있다는 것만 알면 됩니다.

함수에서 생명주기를 어노테이션할 때, 어노테이션은 함수 본문이 아닌 함수 시그니처에 들어갑니다. 생명주기 어노테이션은 시그니처의 타입과 마찬가지로 함수의 계약의 일부가 됩니다. 함수 시그니처에 생명주기 계약이 포함되어 있으면 Rust 컴파일러가 수행하는 분석이 더 간단해질 수 있습니다. 함수가 어노테이션된 방식이나 호출된 방식에 문제가 있는 경우, 컴파일러 오류는 코드의 해당 부분과 제약 조건을 더 정확하게 가리킬 수 있습니다. 반대로, Rust 컴파일러가 생명주기의 관계가 의도한 바를 더 많이 추론한다면, 컴파일러는 문제의 원인에서 여러 단계 떨어진 코드 사용만을 가리킬 수 있을 것입니다.

구체적인 참조를 `longest`에 전달할 때, `'a`를 대체하는 구체적인 생명주기는 `x`의 범위와 `y`의 범위가 겹치는 부분입니다. 즉, 제네릭 생명주기 `'a`는 `x`와 `y`의 생명주기 중 더 작은 것과 같은 구체적인 생명주기를 얻게 됩니다. 반환된 참조에 동일한 생명주기 매개변수 `'a`를 어노테이션했으므로, 반환된 참조는 `x`와 `y`의 생명주기 중 더 작은 기간 동안 유효합니다.

생명주기 어노테이션이 서로 다른 구체적인 생명주기를 가진 참조를 전달하여 `longest` 함수를 어떻게 제한하는지 살펴보겠습니다. Listing 10-22 는 간단한 예입니다.

Filename: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {result}");
    }
}
```

Listing 10-22: 서로 다른 구체적인 생명주기를 가진 `String` 값에 대한 참조와 함께 `longest` 함수 사용

이 예에서 `string1`은 외부 범위의 끝까지 유효하고, `string2`는 내부 범위의 끝까지 유효하며, `result`는 내부 범위의 끝까지 유효한 것을 참조합니다. 이 코드를 실행하면 차용 검사기가 승인하는 것을 볼 수 있습니다. 컴파일되어 `The longest string is long string is long`을 출력합니다.

다음으로, `result`의 참조의 생명주기가 두 인수의 더 작은 생명주기여야 함을 보여주는 예제를 시도해 보겠습니다. `result` 변수의 선언을 내부 범위 외부로 이동하지만, 값을 `result` 변수에 할당하는 것은 `string2`와 함께 범위 내에 둡니다. 그런 다음 `result`를 사용하는 `println!`을 내부 범위 외부, 즉 내부 범위가 종료된 후에 이동합니다. Listing 10-23 의 코드는 컴파일되지 않습니다.

Filename: `src/main.rs`

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {result}");
}
```

Listing 10-23: `string2`가 범위를 벗어난 후 `result`를 사용하려고 시도

이 코드를 컴파일하려고 하면 다음과 같은 오류가 발생합니다.

```bash
error[E0597]: `string2` does not live long enough
 --> src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^^^^^^^^^^ borrowed value
does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!("The longest string is {result}");
  |                                      ------ borrow later used here
```

오류는 `result`가 `println!` 문에 대해 유효하려면 `string2`가 외부 범위의 끝까지 유효해야 함을 보여줍니다. Rust 는 동일한 생명주기 매개변수 `'a`를 사용하여 함수 매개변수와 반환 값의 생명주기를 어노테이션했기 때문에 이를 알고 있습니다.

사람으로서, 우리는 이 코드를 보고 `string1`이 `string2`보다 길다는 것을 알 수 있으며, 따라서 `result`는 `string1`에 대한 참조를 포함합니다. `string1`이 아직 범위를 벗어나지 않았으므로, `string1`에 대한 참조는 여전히 `println!` 문에 대해 유효합니다. 그러나 컴파일러는 이 경우 참조가 유효하다는 것을 알 수 없습니다. 우리는 Rust 에게 `longest` 함수에 의해 반환된 참조의 생명주기가 전달된 참조의 생명주기 중 더 작은 것과 같다고 말했습니다. 따라서 차용 검사기는 Listing 10-23 의 코드가 잠재적으로 유효하지 않은 참조를 가질 수 있다고 거부합니다.

`longest` 함수에 전달된 참조의 값과 생명주기를 변경하고 반환된 참조가 사용되는 방식을 변경하는 더 많은 실험을 설계해 보십시오. 컴파일하기 전에 실험이 차용 검사기를 통과할지 여부에 대한 가설을 세우고, 그런 다음 맞는지 확인하십시오!
