# 메서드 정의의 생명주기 어노테이션

생명주기를 가진 구조체에 메서드를 구현할 때, Listing 10-11 에 표시된 제네릭 타입 매개변수와 동일한 구문을 사용합니다. 생명주기 매개변수를 선언하고 사용하는 위치는 구조체 필드와 관련이 있는지 또는 메서드 매개변수 및 반환 값과 관련이 있는지에 따라 달라집니다.

구조체 필드의 생명주기 이름은 항상 `impl` 키워드 뒤에 선언된 다음, 구조체의 이름 뒤에 사용되어야 합니다. 왜냐하면 해당 생명주기는 구조체의 타입의 일부이기 때문입니다.

`impl` 블록 내부의 메서드 시그니처에서 참조는 구조체 필드의 참조의 생명주기에 묶일 수도 있고, 독립적일 수도 있습니다. 또한, 생명주기 생략 규칙은 종종 메서드 시그니처에서 생명주기 어노테이션이 필요하지 않도록 만듭니다. Listing 10-24 에서 정의한 `ImportantExcerpt`라는 구조체를 사용하여 몇 가지 예제를 살펴보겠습니다.

먼저, 유일한 매개변수가 `self`에 대한 참조이고 반환 값이 `i32`인 `level`이라는 메서드를 사용합니다. `i32`는 어떤 것에 대한 참조가 아닙니다.

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

`impl` 뒤의 생명주기 매개변수 선언과 타입 이름 뒤의 사용은 필수이지만, 첫 번째 생략 규칙 때문에 `self`에 대한 참조의 생명주기를 주석 처리할 필요는 없습니다.

다음은 세 번째 생명주기 생략 규칙이 적용되는 예입니다.

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {announcement}");
        self.part
    }
}
```

두 개의 입력 생명주기가 있으므로, Rust 는 첫 번째 생명주기 생략 규칙을 적용하고 `&self`와 `announcement` 모두에 자체 생명주기를 부여합니다. 그런 다음, 매개변수 중 하나가 `&self`이므로 반환 타입은 `&self`의 생명주기를 갖게 되며, 모든 생명주기가 고려되었습니다.
