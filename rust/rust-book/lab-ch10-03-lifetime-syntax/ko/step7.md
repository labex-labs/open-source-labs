# 생명주기 관점에서 생각하기

생명주기 매개변수를 지정해야 하는 방식은 함수가 수행하는 작업에 따라 다릅니다. 예를 들어, `longest` 함수의 구현을 가장 긴 문자열 슬라이스 대신 항상 첫 번째 매개변수를 반환하도록 변경하면, `y` 매개변수에 생명주기를 지정할 필요가 없습니다. 다음 코드는 컴파일됩니다.

Filename: `src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

매개변수 `x`와 반환 타입에 대해 생명주기 매개변수 `'a`를 지정했지만, 매개변수 `y`에 대해서는 지정하지 않았습니다. 왜냐하면 `y`의 생명주기는 `x` 또는 반환 값의 생명주기와 아무런 관계가 없기 때문입니다.

함수에서 참조를 반환할 때, 반환 타입의 생명주기 매개변수는 매개변수 중 하나의 생명주기 매개변수와 일치해야 합니다. 반환된 참조가 매개변수 중 하나를 _참조하지_ 않는 경우, 이 함수 내에서 생성된 값을 참조해야 합니다. 그러나 이 값은 함수가 끝날 때 범위를 벗어나기 때문에 이는 댕글링 참조 (dangling reference) 가 됩니다. 컴파일되지 않는 `longest` 함수의 이 시도된 구현을 고려하십시오.

Filename: `src/main.rs`

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

여기서는 반환 타입에 대해 생명주기 매개변수 `'a`를 지정했지만, 이 구현은 반환 값의 생명주기가 매개변수의 생명주기와 전혀 관련이 없기 때문에 컴파일에 실패합니다. 다음은 우리가 얻는 오류 메시지입니다.

```bash
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the
current function
```

문제는 `result`가 범위를 벗어나고 `longest` 함수의 끝에서 정리된다는 것입니다. 또한 함수에서 `result`에 대한 참조를 반환하려고 합니다. 댕글링 참조를 변경할 수 있는 생명주기 매개변수를 지정할 방법이 없으며, Rust 는 댕글링 참조를 생성하도록 허용하지 않습니다. 이 경우, 가장 좋은 해결책은 참조 대신 소유된 데이터 타입을 반환하여 호출 함수가 값을 정리하도록 하는 것입니다.

궁극적으로, 생명주기 구문은 함수의 다양한 매개변수와 반환 값의 생명주기를 연결하는 것입니다. 일단 연결되면, Rust 는 메모리 안전한 작업을 허용하고 댕글링 포인터를 생성하거나 메모리 안전성을 위반하는 작업을 허용하지 않도록 충분한 정보를 갖게 됩니다.
