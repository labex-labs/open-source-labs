# 생명주기 생략

모든 참조에는 생명주기가 있으며, 참조를 사용하는 함수 또는 구조체에 생명주기 매개변수를 지정해야 한다는 것을 배웠습니다. 그러나 Listing 4-9 에 있는 함수는 Listing 10-25 에 다시 표시되었으며, 생명주기 어노테이션 없이 컴파일되었습니다.

Filename: `src/lib.rs`

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Listing 10-25: 매개변수와 반환 타입이 참조임에도 불구하고 생명주기 어노테이션 없이 컴파일된 Listing 4-9 에서 정의한 함수

이 함수가 생명주기 어노테이션 없이 컴파일되는 이유는 역사적인 이유 때문입니다. 초기 버전 (1.0 이전) 의 Rust 에서는 모든 참조에 명시적인 생명주기가 필요했기 때문에 이 코드는 컴파일되지 않았을 것입니다. 당시 함수 시그니처는 다음과 같이 작성되었을 것입니다.

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

많은 Rust 코드를 작성한 후, Rust 팀은 Rust 프로그래머가 특정 상황에서 동일한 생명주기 어노테이션을 반복해서 입력하고 있다는 것을 발견했습니다. 이러한 상황은 예측 가능했으며 몇 가지 결정론적 패턴을 따랐습니다. 개발자는 이러한 패턴을 컴파일러 코드에 프로그래밍하여 차용 검사기 (borrow checker) 가 이러한 상황에서 생명주기를 추론하고 명시적인 어노테이션이 필요하지 않도록 했습니다.

이 Rust 역사는 더 많은 결정론적 패턴이 나타나 컴파일러에 추가될 수 있기 때문에 관련이 있습니다. 미래에는 더 적은 생명주기 어노테이션이 필요할 수 있습니다.

Rust 의 참조 분석에 프로그래밍된 패턴을 *생명주기 생략 규칙*이라고 합니다. 이것은 프로그래머가 따라야 하는 규칙이 아니라, 컴파일러가 고려할 특정 사례 집합이며, 코드가 이러한 사례에 맞는 경우 생명주기를 명시적으로 작성할 필요가 없습니다.

생략 규칙은 완전한 추론을 제공하지 않습니다. Rust 가 규칙을 결정론적으로 적용하지만 참조가 어떤 생명주기를 갖는지에 대한 모호성이 여전히 있는 경우, 컴파일러는 나머지 참조의 생명주기가 무엇인지 추측하지 않습니다. 추측하는 대신, 컴파일러는 생명주기 어노테이션을 추가하여 해결할 수 있는 오류를 제공합니다.

함수 또는 메서드 매개변수의 생명주기는 *입력 생명주기*라고 하며, 반환 값의 생명주기는 *출력 생명주기*라고 합니다.

컴파일러는 명시적인 어노테이션이 없을 때 참조의 생명주기를 파악하기 위해 세 가지 규칙을 사용합니다. 첫 번째 규칙은 입력 생명주기에 적용되고, 두 번째 및 세 번째 규칙은 출력 생명주기에 적용됩니다. 컴파일러가 세 가지 규칙의 끝에 도달했지만 여전히 생명주기를 파악할 수 없는 참조가 있는 경우, 컴파일러는 오류와 함께 중지됩니다. 이러한 규칙은 `fn` 정의와 `impl` 블록에 적용됩니다.

첫 번째 규칙은 컴파일러가 참조인 각 매개변수에 생명주기 매개변수를 할당한다는 것입니다. 즉, 매개변수가 하나인 함수는 하나의 생명주기 매개변수를 갖습니다: `fn foo<'a>(x: &'a i32)`; 매개변수가 두 개인 함수는 두 개의 별도 생명주기 매개변수를 갖습니다: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; 등등.

두 번째 규칙은 입력 생명주기 매개변수가 정확히 하나인 경우, 해당 생명주기가 모든 출력 생명주기 매개변수에 할당된다는 것입니다: `fn foo<'a>(x: &'a i32) -> &'a i32`.

세 번째 규칙은 입력 생명주기 매개변수가 여러 개 있지만, 메서드이기 때문에 그 중 하나가 `&self` 또는 `&mut self`인 경우, `self`의 생명주기가 모든 출력 생명주기 매개변수에 할당된다는 것입니다. 이 세 번째 규칙은 메서드를 훨씬 더 읽고 쓰기 쉽게 만듭니다. 왜냐하면 더 적은 기호가 필요하기 때문입니다.

컴파일러라고 가정해 봅시다. Listing 10-25 의 `first_word` 함수의 시그니처에 있는 참조의 생명주기를 파악하기 위해 이러한 규칙을 적용해 보겠습니다. 시그니처는 참조와 관련된 생명주기 없이 시작합니다.

```rust
fn first_word(s: &str) -> &str {
```

그런 다음 컴파일러는 첫 번째 규칙을 적용합니다. 이 규칙은 각 매개변수가 자체 생명주기를 갖도록 지정합니다. 평소와 같이 이를 `'a`라고 부르므로, 이제 시그니처는 다음과 같습니다.

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

두 번째 규칙은 입력 생명주기가 정확히 하나이기 때문에 적용됩니다. 두 번째 규칙은 하나의 입력 매개변수의 생명주기가 출력 생명주기에 할당되도록 지정하므로, 이제 시그니처는 다음과 같습니다.

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

이제 이 함수 시그니처의 모든 참조에는 생명주기가 있으며, 컴파일러는 프로그래머가 이 함수 시그니처에서 생명주기를 주석 처리할 필요 없이 분석을 계속할 수 있습니다.

다른 예제를 살펴보겠습니다. 이번에는 Listing 10-20 에서 작업을 시작했을 때 생명주기 매개변수가 없었던 `longest` 함수를 사용합니다.

```rust
fn longest(x: &str, y: &str) -> &str {
```

첫 번째 규칙을 적용해 봅시다: 각 매개변수는 자체 생명주기를 갖습니다. 이번에는 하나가 아닌 두 개의 매개변수가 있으므로, 두 개의 생명주기가 있습니다.

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

두 번째 규칙은 둘 이상의 입력 생명주기가 있으므로 적용되지 않는 것을 볼 수 있습니다. 세 번째 규칙도 적용되지 않습니다. 왜냐하면 `longest`는 메서드가 아닌 함수이므로, 매개변수 중 어느 것도 `self`가 아니기 때문입니다. 세 가지 규칙을 모두 적용한 후에도, 반환 타입의 생명주기가 무엇인지 파악하지 못했습니다. 이것이 Listing 10-20 에서 코드를 컴파일하려고 할 때 오류가 발생한 이유입니다. 컴파일러는 생명주기 생략 규칙을 적용했지만, 여전히 시그니처의 모든 참조의 생명주기를 파악할 수 없었습니다.

세 번째 규칙은 실제로 메서드 시그니처에만 적용되므로, 다음으로 해당 컨텍스트에서 생명주기를 살펴보고 세 번째 규칙이 메서드 시그니처에서 생명주기를 자주 주석 처리할 필요가 없는 이유를 살펴보겠습니다.
