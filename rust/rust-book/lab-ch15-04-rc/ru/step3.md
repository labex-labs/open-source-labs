# Клонирование Rc`<T>`{=html} увеличивает счетчик ссылок

Изменим наш рабочий пример из Listing 15-18, чтобы увидеть, как меняются счетчики ссылок при создании и удалении ссылок на `Rc<List>` в `a`.

В Listing 15-19 мы изменим `main`, чтобы в нем был внутренний блок вокруг списка `c`; затем мы сможем увидеть, как меняется счетчик ссылок, когда `c` выходит из области видимости.

Имя файла: `src/main.rs`

```rust
--snip--

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(
        "count after creating a = {}",
        Rc::strong_count(&a)
    );
    let b = Cons(3, Rc::clone(&a));
    println!(
        "count after creating b = {}",
        Rc::strong_count(&a)
    );
    {
        let c = Cons(4, Rc::clone(&a));
        println!(
            "count after creating c = {}",
            Rc::strong_count(&a)
        );
    }
    println!(
        "count after c goes out of scope = {}",
        Rc::strong_count(&a)
    );
}
```

Listing 15-19: Вывод счетчика ссылок

В каждой точке программы, где меняется счетчик ссылок, мы выводим счетчик ссылок, который получаем, вызвав функцию `Rc::strong_count`. Эта функция называется `strong_count` вместо `count`, потому что тип `Rc<T>` также имеет `weak_count`; мы увидим, для чего используется `weak_count` в разделе "Предотвращение циклов ссылок с использованием Weak`<T>`{=html}".

Этот код выводит следующее:

    count after creating a = 1
    count after creating b = 2
    count after creating c = 3
    count after c goes out of scope = 2

Мы можем видеть, что `Rc<List>` в `a` имеет начальный счетчик ссылок равный 1; затем каждый раз, когда мы вызываем `clone`, счетчик увеличивается на 1. Когда `c` выходит из области видимости, счетчик уменьшается на 1. Мы не должны вызывать функцию для уменьшения счетчика ссылок, как мы вызываем `Rc::clone` для увеличения счетчика ссылок: реализация трейта `Drop` автоматически уменьшает счетчик ссылок, когда значение `Rc<T>` выходит из области видимости.

В этом примере мы не можем увидеть, что когда `b` и затем `a` выйдут из области видимости в конце `main`, счетчик станет равным 0, и `Rc<List>` будет полностью очищен. Использование `Rc<T>` позволяет одному значению иметь несколько владельцев, и счетчик гарантирует, что значение остается валидным, пока есть хотя бы один владелец.

Через неизменяемые ссылки `Rc<T>` позволяет вам разделять данные между несколькими частями вашей программы только для чтения. Если `Rc<T>` также позволял иметь несколько изменяемых ссылок, вы могли бы нарушить одно из правил заимствования, discutриемых в главе 4: несколько изменяемых заимствований в одно и то же место может привести к гонке данных и несовместимости. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим паттерн внутренней изменяемости и тип `RefCell<T>`, который можно использовать совместно с `Rc<T>` для работы с этой ограничением неизменяемости.
