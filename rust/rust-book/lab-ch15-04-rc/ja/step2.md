# Rc`<T>`{=html}を使ってデータを共有する

15-5のコンスリストの例に戻りましょう。これは`Box<T>`を使って定義したものを思い出してください。今回は、3番目のリストの所有権を共有する2つのリストを作成します。概念的には、15-3の図に似ています。

![図15-3：2つのリストbとcが、3番目のリストaの所有権を共有している](https://doc.rust-lang.org/book/img/trpl15-03.svg)

まず、`5`とその後に`10`を含むリスト`a`を作成します。その後、さらに2つのリストを作成します。`3`から始まる`b`と、`4`から始まる`c`です。そして、`b`と`c`の両方のリストは、`5`と`10`を含む最初の`a`のリストに続きます。言い換えると、両方のリストは`5`と`10`を含む最初のリストを共有します。

`Box<T>`を使った`List`の定義を使ってこのシナリオを実装しようとすると、うまくいきません。15-17に示すように、コンパイル時にエラーが発生します。

ファイル名：`src/main.rs`

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
  1 let b = Cons(3, Box::new(a));
  2 let c = Cons(4, Box::new(a));
}
```

リスト15-17：`Box<T>`を使って2つのリストが3番目のリストの所有権を共有しようとするとエラーになることを示す

このコードをコンパイルすると、次のエラーが表示されます。

```bash
error[E0382]: use of moved value: `a`
  --> src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which
does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
```

`Cons`のバリアントは、それが保持するデータを所有しているため、`b`のリストを作成するときに\[1\]、`a`が`b`に移動し、`b`が`a`を所有するようになります。その後、`c`を作成するときに再び`a`を使用しようとすると\[2\]、`a`が移動しているため許可されません。

`Cons`の定義を変更して参照を保持するようにすることもできますが、その場合、寿命期間パラメータを指定する必要があります。寿命期間パラメータを指定することで、リストの各要素がリスト全体と同じくらい長く生き続けることを指定することになります。これは15-17の要素とリストの場合に当てはまりますが、すべてのシナリオでは当てはまりません。

代わりに、`List`の定義を変更して、`Box<T>`の代わりに`Rc<T>`を使用します。15-18に示すように、各`Cons`のバリアントは、値と`List`を指す`Rc<T>`を保持するようになります。`b`を作成するときに、`a`の所有権を取得する代わりに、`a`が保持している`Rc<List>`をクローンします。これにより、参照数が1から2に増え、`a`と`b`がその`Rc<List>`内のデータの所有権を共有するようになります。また、`c`を作成するときにも`a`をクローンし、参照数を2から3に増やします。`Rc::clone`を呼び出すたびに、`Rc<List>`内のデータへの参照カウントが増え、参照がゼロにならない限り、データはクリーンアップされません。

ファイル名：`src/main.rs`

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
1 use std::rc::Rc;

fn main() {
  2 let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
  3 let b = Cons(3, Rc::clone(&a));
  4 let c = Cons(4, Rc::clone(&a));
}
```

リスト15-18：`Rc<T>`を使用する`List`の定義

`Rc<T>`をスコープに入れるために`use`文を追加する必要があります\[1\]。なぜなら、これはプレリュードには含まれていないからです。`main`では、`5`と`10`を保持するリストを作成し、`a`の新しい`Rc<List>`に格納します\[2\]。その後、`b`\[3\]と`c`\[4\]を作成するときに、`Rc::clone`関数を呼び出し、`a`の`Rc<List>`への参照を引数として渡します。

`a.clone()`ではなく`Rc::clone(&a)`を呼ぶこともできますが、この場合、Rustの慣例は`Rc::clone`を使用することです。`Rc::clone`の実装は、ほとんどの型の`clone`の実装のように、すべてのデータの深いコピーを行いません。`Rc::clone`の呼び出しは、参照カウントのみを増やすだけで、それほど時間がかかりません。データの深いコピーには多くの時間がかかる場合があります。参照カウント用に`Rc::clone`を使用することで、深いコピーのクローンと参照カウントを増やすクローンを視覚的に区別することができます。コードのパフォーマンス問題を探すときには、深いコピーのクローンのみを考慮すればよく、`Rc::clone`の呼び出しは無視することができます。
