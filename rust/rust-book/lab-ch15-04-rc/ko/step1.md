# Rc`<T>`{=html}, 참조 카운트 스마트 포인터

대부분의 경우 소유권은 명확합니다. 주어진 값을 정확히 어떤 변수가 소유하는지 알고 있습니다. 그러나 단일 값이 여러 소유자를 가질 수 있는 경우가 있습니다. 예를 들어, 그래프 데이터 구조에서 여러 간선이 동일한 노드를 가리킬 수 있으며, 해당 노드는 개념적으로 이를 가리키는 모든 간선에 의해 소유됩니다. 노드는 이를 가리키는 간선이 없고 소유자가 없는 경우에만 정리되어야 합니다.

Rust 타입 `Rc<T>`를 사용하여 여러 소유권을 명시적으로 활성화해야 합니다. 이는 *참조 카운팅*의 약어입니다. `Rc<T>` 타입은 값에 대한 참조 수를 추적하여 해당 값이 여전히 사용 중인지 여부를 결정합니다. 값에 대한 참조가 0 개인 경우, 참조가 무효화되지 않고 값을 정리할 수 있습니다.

`Rc<T>`를 거실의 TV 라고 상상해 보세요. 한 사람이 TV 를 보기 위해 들어오면 TV 를 켭니다. 다른 사람들도 방에 들어와 TV 를 볼 수 있습니다. 마지막 사람이 방을 나가면 더 이상 사용하지 않으므로 TV 를 끕니다. 다른 사람들이 TV 를 보고 있는 동안 누군가 TV 를 끄면, 남아있는 TV 시청자들로부터 항의가 있을 것입니다!

프로그램의 여러 부분에서 힙에 일부 데이터를 할당하여 읽고 싶고, 컴파일 시간에 어떤 부분이 데이터를 마지막으로 사용할지 결정할 수 없을 때 `Rc<T>` 타입을 사용합니다. 어떤 부분이 마지막으로 끝나는지 알고 있다면, 해당 부분을 데이터의 소유자로 만들 수 있으며, 컴파일 시간에 적용되는 일반적인 소유권 규칙이 적용됩니다.

`Rc<T>`는 단일 스레드 시나리오에서만 사용됩니다. 16 장에서 동시성에 대해 논의할 때, 멀티스레드 프로그램에서 참조 카운팅을 수행하는 방법을 다룰 것입니다.
