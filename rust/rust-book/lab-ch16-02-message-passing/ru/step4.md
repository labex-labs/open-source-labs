# Создание нескольких производителей путём клонирования отправителя

Ранее мы упоминали, что `mpsc` - это сокращение от _multiple producer, single consumer_ (множественные производители, одиночный потребитель). Давайте применим `mpsc` и расширим код из Listing 16-10, чтобы создать несколько потоков, которые все будут отправлять значения в один и тот же получатель. Мы можем это сделать, клонируя отправителя, как показано в Listing 16-11.

Filename: `src/main.rs`

```rust
--snip--

let (tx, rx) = mpsc::channel();

let tx1 = tx.clone();
thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
        String::from("for"),
        String::from("you"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!("Got: {received}");
}

--snip--
```

Listing 16-11: Отправка нескольких сообщений от нескольких производителей

На этот раз, перед созданием первого созданного потока, мы вызываем `clone` на отправителе. Это даст нам новый отправитель, который мы можем передать первому созданному потоку. Мы передаём исходный отправитель второму созданному потоку. Таким образом, у нас есть два потока, каждый из которых отправляет разные сообщения в одного получателя.

Когда вы запускаете код, вывод может выглядеть примерно так:

    Got: hi
    Got: more
    Got: from
    Got: messages
    Got: for
    Got: the
    Got: thread
    Got: you

Возможно, вы увидите значения в другом порядке, в зависимости от вашей системы. Именно это делает параллелизм интересным, а также сложным. Если вы экспериментируете с `thread::sleep`, задавая ей разные значения в разных потоках, каждый запуск будет более неопределённым и создавать разные выводы каждый раз.

Теперь, когда мы рассмотрели, как работают каналы, давайте посмотрим на другой метод параллелизации.
