# Каналы и передача владения

Правила владения играют важную роль при отправке сообщений, так как они помогают вам писать безопасный параллельный код. Предотвращение ошибок при параллельном программировании - это преимущество того, что нужно думать о владении на протяжении всего вашего Rust-программа. Давайте проведём эксперимент, чтобы показать, как каналы и владение работают вместе, чтобы предотвратить проблемы: мы попытаемся использовать значение `val` в созданном потоке _после_, как мы отправили его по каналу. Попробуйте скомпилировать код из Listing 16-9, чтобы понять, почему этот код не допускается.

Filename: `src/main.rs`

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        println!("val is {val}");
    });

    let received = rx.recv().unwrap();
    println!("Got: {received}");
}
```

Listing 16-9: Попытка использовать `val` после отправки его по каналу

Здесь мы пытаемся вывести `val` на печать после того, как отправили его по каналу с помощью `tx.send`. Разрешить это было бы плохой идеей: как только значение было отправлено в другой поток, этот поток мог бы изменить его или удалить, прежде чем мы попытаемся снова использовать значение. Возможно, изменения другого потока могут привести к ошибкам или неожиданным результатам из-за несовместимых или несуществующих данных. Однако, Rust выдаёт ошибку, если мы пытаемся скомпилировать код из Listing 16-9:

```bash
error[E0382]: borrow of moved value: `val`
  --> src/main.rs:10:31
   |
8  |         let val = String::from("hi");
   |             --- move occurs because `val` has type `String`, which does
not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {val}");
   |                           ^^^ value borrowed here after move
```

Наша ошибка при параллелизации вызвала ошибку компиляции. Функция `send` получает владение над своим параметром, и когда значение перемещается, получатель получает за ним владение. Это предотвращает случайное использование значения снова после отправки; система владения проверяет, все ли в порядке.
