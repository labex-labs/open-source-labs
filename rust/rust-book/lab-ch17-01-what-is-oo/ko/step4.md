# 타입 시스템으로서의 상속과 코드 공유

*상속 (Inheritance)*은 객체가 다른 객체의 정의에서 요소를 상속받아 부모 객체의 데이터와 동작을 다시 정의하지 않고 얻을 수 있는 메커니즘입니다.

언어가 객체 지향이 되기 위해 상속이 필수적이라면, Rust 는 그런 언어가 아닙니다. 매크로를 사용하지 않고 부모 구조체의 필드와 메소드 구현을 상속하는 구조체를 정의하는 방법은 없습니다.

그러나 프로그래밍 도구 상자에 상속을 사용하는 데 익숙하다면, 처음부터 상속을 사용하려는 이유에 따라 Rust 에서 다른 솔루션을 사용할 수 있습니다.

상속을 선택하는 주된 이유는 두 가지입니다. 하나는 코드 재사용을 위한 것입니다. 특정 타입에 대한 특정 동작을 구현할 수 있으며, 상속을 통해 다른 타입에 대해 해당 구현을 재사용할 수 있습니다. `Summary` 트레이트에 `summarize` 메소드의 기본 구현을 추가했을 때 Listing 10-14 에서 보았듯이, Rust 코드에서 기본 트레이트 메소드 구현을 사용하여 제한적인 방식으로 이를 수행할 수 있습니다. `Summary` 트레이트를 구현하는 모든 타입은 추가 코드 없이 `summarize` 메소드를 사용할 수 있습니다. 이는 부모 클래스가 메소드의 구현을 가지고 있고 상속하는 자식 클래스도 메소드의 구현을 갖는 것과 유사합니다. 또한 `Summary` 트레이트를 구현할 때 `summarize` 메소드의 기본 구현을 재정의할 수 있는데, 이는 자식 클래스가 부모 클래스에서 상속된 메소드의 구현을 재정의하는 것과 유사합니다.

상속을 사용하는 또 다른 이유는 타입 시스템과 관련이 있습니다. 자식 타입을 부모 타입과 동일한 위치에서 사용할 수 있도록 하기 위해서입니다. 이것을 *다형성 (polymorphism)*이라고도 하며, 이는 런타임에 여러 객체가 특정 특성을 공유하는 경우 서로 대체될 수 있음을 의미합니다.

> **다형성**
>
> 많은 사람들에게 다형성은 상속과 동의어입니다. 그러나 실제로 여러 타입의 데이터로 작업할 수 있는 코드를 지칭하는 더 일반적인 개념입니다. 상속의 경우, 해당 타입은 일반적으로 서브클래스입니다.
>
> 대신 Rust 는 제네릭 (generics) 을 사용하여 서로 다른 가능한 타입을 추상화하고, 트레이트 바운드 (trait bounds) 를 사용하여 해당 타입이 제공해야 하는 것에 제약을 가합니다. 이것을 때때로 *경계된 매개변수 다형성 (bounded parametric polymorphism)*이라고 합니다.

상속은 최근 많은 프로그래밍 언어에서 프로그래밍 디자인 솔루션으로 선호도가 떨어졌습니다. 이는 종종 필요 이상으로 많은 코드를 공유할 위험이 있기 때문입니다. 서브클래스는 항상 부모 클래스의 모든 특성을 공유할 필요는 없지만, 상속을 사용하면 그렇게 됩니다. 이는 프로그램의 디자인을 덜 유연하게 만들 수 있습니다. 또한 서브클래스에 적용되지 않거나 서브클래스에 적용되지 않아 오류를 발생시키는 메소드를 호출할 가능성을 도입합니다. 또한 일부 언어는 단일 상속 (즉, 서브클래스가 하나의 클래스에서만 상속받을 수 있음) 만 허용하여 프로그램 디자인의 유연성을 더욱 제한합니다.

이러한 이유로 Rust 는 상속 대신 트레이트 객체를 사용하는 다른 접근 방식을 취합니다. Rust 에서 트레이트 객체가 다형성을 어떻게 가능하게 하는지 살펴보겠습니다.
