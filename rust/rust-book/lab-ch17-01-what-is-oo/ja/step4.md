# 型システムとコード共有としての継承

「継承」は、オブジェクトが別のオブジェクトの定義から要素を継承し、それにより親オブジェクトのデータと振る舞いを再度定義することなく獲得できる仕組みです。

言語がオブジェクト指向であるためには継承が必要である場合、Rustはそのような言語ではありません。マクロを使用せずに、親構造体のフィールドとメソッドの実装を継承する構造体を定義する方法はありません。

ただし、プログラミングツールボックスに継承があることに慣れている場合、まず最初に継承を求める理由に応じて、Rustで他の解決策を使用できます。

継承を選ぶ主な理由は2つあります。1つはコードの再利用です。特定の振る舞いを1つの型に対して実装し、継承によりその実装を別の型で再利用できます。これは、Rustコードでは、デフォルトのトレイトメソッド実装を使用して制限された方法で行うことができます。これは、第10章のリスト10-14で、`Summary`トレイトに`summarize`メソッドのデフォルト実装を追加したときに見たことがあります。`Summary`トレイトを実装するすべての型は、さらにコードを記述することなく、その型に`summarize`メソッドが利用可能になります。これは、親クラスがメソッドの実装を持ち、継承する子クラスも同じメソッドの実装を持つことに似ています。また、`Summary`トレイトを実装する際に、`summarize`メソッドのデフォルト実装をオーバーライドすることもできます。これは、子クラスが親クラスから継承したメソッドの実装をオーバーライドすることに似ています。

継承を使用するもう1つの理由は、型システムに関係しています。子型を親型と同じ場所で使用できるようにするためです。これは「ポリモーフィズム」とも呼ばれ、実行時に特定の特性を共有する場合、複数のオブジェクトを相互に置き換えることができることを意味します。

> **ポリモーフィズム**
>
> 多くの人にとって、ポリモーフィズムは継承と同義語です。しかし、実際には、複数の型のデータと動作することができるコードを指す、より一般的な概念です。継承の場合、それらの型は一般的にサブクラスです。
>
> Rustでは代わりに、ジェネリクスを使用してさまざまな可能な型を抽象化し、それらの型が提供しなければならないものに制約を課すためにトレイト境界を使用します。これは、時々「境界付きパラメトリックポリモーフィズム」と呼ばれます。

最近、多くのプログラミング言語において、継承はプログラミングデザインの解決策として好まれなくなってきました。なぜなら、必要以上に多くのコードを共有するリスクがあるからです。サブクラスは必ずしも親クラスのすべての特性を共有する必要はありませんが、継承によりそうなってしまいます。これにより、プログラムのデザインが柔軟性に欠ける場合があります。また、サブクラスで意味がないメソッドを呼び出したり、メソッドがサブクラスに適用されないためにエラーが発生する可能性もあります。さらに、一部の言語では単一継承のみが許される場合があり（つまり、サブクラスは1つのクラスからのみ継承できる）、プログラムのデザインの柔軟性がさらに制限されます。

これらの理由から、Rustは継承の代わりにトレイトオブジェクトを使用する異なるアプローチを採用しています。Rustにおけるトレイトオブジェクトがどのようにポリモーフィズムを可能にするか見てみましょう。
