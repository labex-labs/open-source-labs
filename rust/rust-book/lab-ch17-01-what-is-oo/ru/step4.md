# Наследование как система типов и как совместное использование кода

_Наследование_ — это механизм, при котором объект может наследовать элементы из определения другого объекта, тем самым получая данные и поведение родительского объекта, не нужно ли их определять заново.

Если для того, чтобы язык считался объектно-ориентированным, должен быть механизм наследования, то Rust не является таким языком. Нет способа определить структуру, которая бы наследовала поля и реализации методов родительской структуры, не используя макрос.

Однако, если вы привыкли использовать наследование в своей программировочной.toolbox, в Rust есть другие решения, в зависимости от того, зачем вы использовали наследование в первую очередь.

Вы выбираете наследование в основном по двум причинам. Одна из них — повторное использование кода: вы можете реализовать определённое поведение для одного типа, а наследование позволяет вам повторно использовать эту реализацию для другого типа. Вы можете сделать это в ограниченном виде в коде Rust с использованием реализаций методов по умолчанию для трейтов, которые вы видели в листинге 10-14, когда мы добавили реализацию метода `summarize` по умолчанию для трейта `Summary`. Любой тип, реализующий трейт `Summary`, будет иметь метод `summarize` без дополнительного кода. Это похоже на то, когда родительский класс имеет реализацию метода, а наследующий дочерний класс также имеет реализацию этого метода. Мы также можем переопределить реализацию метода `summarize` по умолчанию, когда реализуем трейт `Summary`, что аналогично тому, как дочерний класс переопределяет реализацию метода, унаследованного от родительского класса.

Другая причина использовать наследование связана с системой типов: чтобы дочерний тип мог использоваться в тех же местах, что и родительский тип. Это также называется _полиморфизмом_, что означает, что вы можете заменить несколько объектов друг на друга во время выполнения, если они обладают определёнными общими характеристиками.

> **Полиморфизм**
>
> Для многих людей полиморфизм является синонимом наследования. На самом деле это более общий概念，который относится к коду, который может работать с данными разных типов. Для наследования эти типы обычно являются подклассами.
>
> Вместо этого Rust использует обобщения для абстрагирования над разными возможными типами и ограничения трейтов для наложения ограничений на то, что эти типы должны предоставлять. Это иногда называется _ограниченным параметрическим полиморфизмом_.

Наследование в последнее время потеряло популярность в качестве решения для проектирования программного обеспечения в многих языках программирования, потому что часто рискует поделиться большим количеством кода, чем необходимо. Подклассы не всегда должны делиться всеми характеристиками своего родительского класса, но это происходит при наследовании. Это может сделать дизайн программы менее гибким. Кроме того, это открывает возможность вызвать методы у подклассов, которые не имеют смысла или которые вызывают ошибки, потому что методы не применимы к подклассу. Кроме того, некоторые языки позволяют только одиночное наследование (то есть подкласс может наследоваться только от одного класса), что ещё более ограничивает гибкость в дизайне программы.

По этим причинам Rust использует другой подход — использование объектов трейтов вместо наследования. Посмотрим, как объекты трейтов обеспечивают полиморфизм в Rust.
