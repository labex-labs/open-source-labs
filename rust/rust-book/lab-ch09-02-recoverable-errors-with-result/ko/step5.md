# 오류 전파

함수의 구현이 실패할 수 있는 무언가를 호출할 때, 함수 자체 내에서 오류를 처리하는 대신, 오류를 호출하는 코드에 반환하여 무엇을 할지 결정하도록 할 수 있습니다. 이것을 오류를 *전파*하는 것이라고 하며, 코드의 컨텍스트에서 사용할 수 있는 것보다 오류를 처리하는 방법에 대한 더 많은 정보나 로직이 있을 수 있는 호출하는 코드에 더 많은 제어를 제공합니다.

예를 들어, Listing 9-6 은 파일에서 사용자 이름을 읽는 함수를 보여줍니다. 파일이 존재하지 않거나 읽을 수 없는 경우, 이 함수는 해당 오류를 함수를 호출한 코드에 반환합니다.

파일 이름: `src/main.rs`

```rust
use std::fs::File;
use std::io::{self, Read};

1 fn read_username_from_file() -> Result<String, io::Error> {
  2 let username_file_result = File::open("hello.txt");

  3 let mut username_file = match username_file_result {
      4 Ok(file) => file,
      5 Err(e) => return Err(e),
    };

  6 let mut username = String::new();

  7 match username_file.read_to_string(&mut username) {
      8 Ok(_) => Ok(username),
      9 Err(e) => Err(e),
    }
}
```

Listing 9-6: `match`를 사용하여 오류를 호출하는 코드에 반환하는 함수

이 함수는 훨씬 더 짧은 방식으로 작성할 수 있지만, 오류 처리를 탐구하기 위해 많은 부분을 수동으로 시작할 것입니다. 마지막에 더 짧은 방법을 보여드리겠습니다. 먼저 함수의 반환 타입을 살펴보겠습니다: `Result<String, io::Error>` \[1]. 이것은 함수가 `Result<T, E>` 타입의 값을 반환한다는 것을 의미하며, 여기서 제네릭 매개변수 `T`는 구체적인 타입 `String`으로 채워지고, 제네릭 타입 `E`는 구체적인 타입 `io::Error`로 채워졌습니다.

이 함수가 문제 없이 성공하면, 이 함수를 호출하는 코드는 `String`을 포함하는 `Ok` 값을 받게 됩니다. 즉, 이 함수가 파일에서 읽은 `username` \[8]입니다. 이 함수가 어떤 문제에 직면하면, 호출하는 코드는 문제에 대한 더 많은 정보를 포함하는 `io::Error`의 인스턴스를 포함하는 `Err` 값을 받게 됩니다. 이 함수의 반환 타입으로 `io::Error`를 선택한 이유는 이 함수 본문에서 실패할 수 있는 두 가지 연산, 즉 `File::open` 함수 \[2]와 `read_to_string` 메서드 \[7]에서 반환되는 오류 값의 타입이기 때문입니다.

함수의 본문은 `File::open` 함수 \[2]를 호출하는 것으로 시작합니다. 그런 다음 Listing 9-4 의 `match`와 유사한 `match`로 `Result` 값을 처리합니다. `File::open`이 성공하면, 패턴 변수 `file` \[4]의 파일 핸들이 가변 변수 `username_file` \[3]의 값이 되고 함수는 계속됩니다. `Err`의 경우, `panic!`을 호출하는 대신, `return` 키워드를 사용하여 함수에서 조기에 반환하고, `File::open`에서 가져온 오류 값 (이제 패턴 변수 `e`에 있음) 을 이 함수의 오류 값으로 호출하는 코드에 다시 전달합니다 \[5].

따라서 `username_file`에 파일 핸들이 있는 경우, 함수는 변수 `username` \[6]에 새로운 `String`을 생성하고, `username_file`의 파일 핸들에 대해 `read_to_string` 메서드를 호출하여 파일의 내용을 `username` \[7]에 읽어들입니다. `read_to_string` 메서드도 `Result`를 반환하는데, `File::open`이 성공했음에도 불구하고 실패할 수 있기 때문입니다. 따라서 해당 `Result`를 처리하기 위해 다른 `match`가 필요합니다. `read_to_string`이 성공하면, 우리 함수가 성공한 것이고, 파일에서 가져온 사용자 이름 (이제 `username`에 있음) 을 `Ok`로 래핑하여 반환합니다. `read_to_string`이 실패하면, `File::open`의 반환 값을 처리한 `match`에서 오류 값을 반환한 것과 동일한 방식으로 오류 값을 반환합니다. 그러나 이것이 함수의 마지막 표현식이므로 \[9] 명시적으로 `return`을 말할 필요는 없습니다.

이 코드를 호출하는 코드는 사용자 이름을 포함하는 `Ok` 값 또는 `io::Error`를 포함하는 `Err` 값을 받게 됩니다. 이러한 값으로 무엇을 할지는 호출하는 코드에 달려 있습니다. 호출하는 코드가 `Err` 값을 받으면, `panic!`을 호출하여 프로그램을 충돌시키거나, 기본 사용자 이름을 사용하거나, 예를 들어 파일이 아닌 다른 곳에서 사용자 이름을 찾아볼 수 있습니다. 호출하는 코드가 실제로 무엇을 하려고 하는지에 대한 충분한 정보가 없으므로, 모든 성공 또는 오류 정보를 적절하게 처리할 수 있도록 위로 전파합니다.

이러한 오류 전파 패턴은 Rust 에서 매우 일반적이므로 Rust 는 이를 더 쉽게 만들기 위해 물음표 연산자 `?`를 제공합니다.
