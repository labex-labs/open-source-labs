# Result による回復可能なエラー

ほとんどのエラーは、プログラムを完全に停止させるほど深刻なものではありません。時々、関数が失敗するのは、簡単に解釈して対応できる理由による場合があります。たとえば、ファイルを開こうとしたときに、その操作が失敗しても、それがファイルが存在しないためであれば、プロセスを終了する代わりに、ファイルを作成することができます。

「Result を使った潜在的な失敗の処理」で思い出してください。`Result` 列挙型は、次のように `Ok` と `Err` の 2 つのバリアントを持つように定義されています。

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` と `E` はジェネリック型パラメータです。10 章でより詳細にジェネリクスについて説明します。今すぐ知っておく必要のあることは、`T` が `Ok` バリアント内の成功ケースで返される値の型を表し、`E` が `Err` バリアント内の失敗ケースで返されるエラーの型を表すということです。`Result` がこれらのジェネリック型パラメータを持っているため、返したい成功値とエラー値が異なる多くの異なる状況で、`Result` 型とそれに定義された関数を使用できます。

関数が失敗する可能性があるため、`Result` 値を返す関数を呼び出してみましょう。リスト 9-3 では、ファイルを開こうとしています。

ファイル名：`src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
```

リスト 9-3: ファイルを開く

`File::open` の戻り値の型は `Result<T, E>` です。ジェネリックパラメータ `T` は、成功値の型である `std::fs::File`（ファイルハンドル）で `File::open` の実装によって埋められています。エラー値で使用される `E` の型は `std::io::Error` です。この戻り値の型は、`File::open` の呼び出しが成功して読み書きできるファイルハンドルを返す可能性があることを意味します。関数呼び出しは失敗する可能性もあります。たとえば、ファイルが存在しない場合や、ファイルにアクセスする権限がない場合です。`File::open` 関数は、成功したか失敗したかを伝える方法が必要であり、同時にファイルハンドルまたはエラー情報を提供する必要があります。この情報は、まさに `Result` 列挙型が伝えるものです。

`File::open` が成功した場合、変数 `greeting_file_result` の値は、ファイルハンドルを含む `Ok` のインスタンスになります。失敗した場合、`greeting_file_result` の値は、発生したエラーの種類に関する詳細な情報を含む `Err` のインスタンスになります。

リスト 9-3 のコードに、`File::open` が返す値に応じて異なるアクションを取るように追加する必要があります。リスト 9-4 は、第 6 章で説明した基本的なツールである `match` 式を使って `Result` を処理する 1 つの方法を示しています。

ファイル名：`src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error);
        }
    };
}
```

リスト 9-4: 返される可能性のある `Result` のバリアントを処理するための `match` 式の使用

`Option` 列挙型と同様に、`Result` 列挙型とそのバリアントはプレリュードによってスコープ内に持ち込まれているため、`match` のアーム内の `Ok` と `Err` のバリアントの前に `Result::` を指定する必要はありません。

結果が `Ok` の場合、このコードは `Ok` のバリアントから内部の `file` 値を返し、その後、そのファイルハンドル値を変数 `greeting_file` に代入します。`match` の後では、ファイルハンドルを読み書きに使用できます。

`match` のもう一方のアームは、`File::open` から `Err` 値を取得した場合を処理します。この例では、`panic!` マクロを呼び出すように選択しています。現在のディレクトリに _hello.txt_ という名前のファイルがなく、このコードを実行すると、`panic!` マクロから次の出力が表示されます。

    thread 'main' panicked at 'Problem opening the file: Os { code:
     2, kind: NotFound, message: "No such file or directory" }',
    src/main.rs:8:23

いつものように、この出力は何が間違っているかを正確に伝えてくれます。
