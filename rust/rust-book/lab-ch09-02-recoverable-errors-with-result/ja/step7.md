# 疑問符演算子 `?` を使用できる場所

`?` 演算子は、その使用対象の値と互換性のある戻り値型を持つ関数の中でのみ使用できます。これは、`?` 演算子が、関数からの値の早期返却を行うように定義されているためで、これはリスト 9-6 で定義した `match` 式と同じ方法です。リスト 9-6 では、`match` は `Result` 値を使用しており、早期返却のアームは `Err(e)` 値を返していました。関数の戻り値型は `Result` でなければならず、この `return` と互換性がある必要があります。

リスト 9-10 では、戻り値型が使用対象の値の型と互換性のない `main` 関数で `?` 演算子を使用した場合に得られるエラーを見てみましょう。

ファイル名：`src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
```

リスト 9-10: `()` を返す `main` 関数で `?` を使用しようとするとコンパイルエラーになります。

このコードはファイルを開こうとしますが、失敗する可能性があります。`?` 演算子は `File::open` が返す `Result` 値に続きますが、この `main` 関数の戻り値型は `()` で、`Result` ではありません。このコードをコンパイルすると、次のエラーメッセージが表示されます。

```bash
error[E0277]: the `?` operator can only be used in a function that returns
`Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | / fn main() {
4 | |     let greeting_file = File::open("hello.txt")?;
  | |                                                ^ cannot use the `?`
operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not
implemented for `()`
```

このエラーは、`?` 演算子は `Result`、`Option`、または `FromResidual` を実装する他の型を返す関数の中でのみ使用できることを指摘しています。

エラーを修正するには、2 つの選択肢があります。1 つは、制限がない限り、関数の戻り値型を使用対象の値と互換性のある型に変更することです。もう 1 つは、`match` または `Result<T, E>` のメソッドの 1 つを使用して、適切な方法で `Result<T, E>` を処理することです。

エラーメッセージには、`?` は `Option<T>` 値とも使用できることも記載されています。`Result` で `?` を使用する場合と同様に、`?` を `Option` に使用できるのは、`Option` を返す関数の中でのみです。`Option<T>` に対して `?` 演算子を呼び出したときの動作は、`Result<T, E>` に対して呼び出したときの動作と似ています。値が `None` の場合、その時点で関数から `None` が早期に返されます。値が `Some` の場合、`Some` 内の値が式の結果となり、関数は続行します。リスト 9-11 には、与えられたテキストの最初の行の最後の文字を見つける関数の例があります。

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

リスト 9-11: `Option<T>` 値に対して `?` 演算子を使用する

この関数は `Option<char>` を返します。なぜなら、そこに文字がある可能性もあれば、ない可能性もあるからです。このコードは `text` 文字列をスライス引数として受け取り、その上で `lines` メソッドを呼び出します。これは文字列内の行のイテレータを返します。この関数は最初の行を調べたいので、イテレータに対して `next` を呼び出して、イテレータから最初の値を取得します。`text` が空文字列の場合、この `next` の呼び出しは `None` を返します。その場合、`?` を使用して `last_char_of_first_line` から `None` を返して処理を停止します。`text` が空文字列でない場合、`next` は `text` の最初の行の文字列スライスを含む `Some` 値を返します。

`?` は文字列スライスを抽出し、その文字列スライスに対して `chars` を呼び出して、その文字のイテレータを取得できます。私たちはこの最初の行の最後の文字に興味があるので、`last` を呼び出してイテレータの最後の要素を返します。これは `Option` です。なぜなら、最初の行が空文字列である可能性があるからです。たとえば、`text` が空行から始まり、他の行に文字がある場合（`"\nhi"` のような場合）です。ただし、最初の行に最後の文字がある場合、それは `Some` バリアントで返されます。途中の `?` 演算子は、このロジックを簡潔に表現する方法を提供し、関数を 1 行で実装できるようにします。`Option` に対して `?` 演算子を使用できない場合、このロジックをより多くのメソッド呼び出しや `match` 式を使用して実装する必要があります。

`Result` の上で `?` 演算子を `Result` を返す関数の中で使用でき、`Option` の上で `?` 演算子を `Option` を返す関数の中で使用できますが、混在させることはできません。`?` 演算子は自動的に `Result` を `Option` に変換したり、その逆に変換したりしません。そのような場合、`Result` の `ok` メソッドや `Option` の `ok_or` メソッドのようなメソッドを使用して明示的に変換することができます。

これまでに使用したすべての `main` 関数は `()` を返しています。`main` 関数は特別で、実行可能プログラムのエントリポイントと終了ポイントであるため、予想通りの動作をするためには、その戻り値型に制限があります。

幸いなことに、`main` は `Result<(), E>` を返すこともできます。リスト 9-12 には、リスト 9-10 のコードがありますが、`main` の戻り値型を `Result<(), Box<dyn Error>>` に変更し、末尾に `Ok(())` の戻り値を追加しています。このコードは今ではコンパイルされます。

ファイル名：`src/main.rs`

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
```

リスト 9-12: `main` を `Result<(), E>` を返すように変更することで、`Result` 値に対して `?` 演算子を使用できるようになります。

`Box<dyn Error>` 型は、「異なる型の値を許容するトレイトオブジェクト」で説明します。今のところ、`Box<dyn Error>` は「どんな種類のエラー」を意味すると読むことができます。エラー型が `Box<dyn Error>` の `main` 関数で `Result` 値に対して `?` を使用することが許されるのは、任意の `Err` 値を早期に返すことができるからです。この `main` 関数の本体は、`std::io::Error` 型のエラーのみを返す場合がありますが、`Box<dyn Error>` を指定することで、`main` の本体に他のエラーを返すコードが追加されても、このシグネチャは正しいままです。

`main` 関数が `Result<(), E>` を返す場合、`main` が `Ok(())` を返すときに実行可能プログラムは 0 の値で終了し、`main` が `Err` 値を返すときには非ゼロの値で終了します。C 言語で書かれた実行可能プログラムは終了時に整数を返します。正常に終了するプログラムは整数 0 を返し、エラーが発生したプログラムは 0 以外の整数を返します。Rust もこの規約に準拠して実行可能プログラムから整数を返します。

`main` 関数は、`std::process::Termination` トレイトを実装する任意の型を返すことができます。このトレイトには、`ExitCode` を返す `report` 関数が含まれています。独自の型に対して `Termination` トレイトを実装する方法については、標準ライブラリのドキュメントを参照してください。

これで、`panic!` を呼び出すか `Result` を返す詳細について説明しましたので、どの場合にどちらを使用するかを決定する方法に戻りましょう。
