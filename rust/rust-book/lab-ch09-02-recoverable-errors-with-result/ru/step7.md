# Where the? Operator Can Be Used

Оператор `?` можно использовать только в функциях, возвращаемых тип которых совместим с типом значения, на котором используется `?`. Это связано с тем, что оператор `?` определен для выполнения раннего возврата значения из функции, аналогично выражению `match`, которое мы определили в листинге 9-6. В листинге 9-6 `match` использовал значение `Result`, и ветка раннего возврата возвращала значение `Err(e)`. Возвращаемый тип функции должен быть `Result`, чтобы быть совместимым с этим `return`.

В листинге 9-10 рассмотрим ошибку, которую получим, если использовать оператор `?` в функции `main` с возвращаемым типом, не совместимым с типом значения, на котором мы используем `?`.

Filename: `src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}
```

Листинг 9-10: Попытка использовать `?` в функции `main`, возвращающей `()`, не скомпилируется.

Этот код открывает файл, что может завершиться ошибкой. Оператор `?` следит за значением `Result`, возвращаемым функцией `File::open`, но эта функция `main` имеет возвращаемый тип `()`, а не `Result`. Когда мы компилируем этот код, мы получаем следующее сообщение об ошибке:

```bash
error[E0277]: the `?` operator can only be used in a function that returns
`Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | / fn main() {
4 | |     let greeting_file = File::open("hello.txt")?;
  | |                                                ^ cannot use the `?`
operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not
implemented for `()`
```

Это сообщение об ошибке указывает на то, что мы можем использовать оператор `?` только в функции, возвращающей `Result`, `Option` или другой тип, реализующий `FromResidual`.

Для исправления ошибки у вас есть два варианта. Первый вариант - изменить возвращаемый тип вашей функции, чтобы он был совместим с типом значения, на котором вы используете оператор `?`, при условии, что у вас нет ограничений, препятствующих этому. Второй вариант - использовать `match` или один из методов `Result<T, E>` для обработки `Result<T, E>` любым подходящим способом.

Сообщение об ошибке также упоминало, что `?` можно использовать с значениями `Option<T>`. Как и при использовании `?` с `Result`, вы можете использовать `?` только с `Option` в функции, возвращающей `Option`. Поведение оператора `?`, когда он вызывается для `Option<T>`, похоже на его поведение, когда он вызывается для `Result<T, E>`: если значение равно `None`, `None` будет ранним возвратом из функции в этом месте. Если значение равно `Some`, значение внутри `Some` является результирующим значением выражения, и функция продолжает работу. Листинг 9-11 содержит пример функции, которая находит последний символ первой строки в заданном тексте.

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
```

Листинг 9-11: Использование оператора `?` с значением `Option<T>`

Эта функция возвращает `Option<char>`, потому что возможно, что там есть символ, но также возможно, что его нет. Этот код принимает аргумент `text` - срез строки, и вызывает метод `lines` для него, который возвращает итератор по строкам в строке. Поскольку эта функция хочет проверить первую строку, она вызывает `next` для итератора, чтобы получить первое значение из итератора. Если `text` - это пустая строка, вызов `next` вернет `None`, в этом случае мы используем `?`, чтобы остановиться и вернуть `None` из `last_char_of_first_line`. Если `text` не является пустой строкой, `next` вернет значение `Some`, содержащее срез строки первой строки в `text`.

`?` извлекает срез строки, и мы можем вызвать `chars` для этого среза строки, чтобы получить итератор его символов. Мы интересуемся последним символом в этой первой строке, поэтому вызываем `last`, чтобы вернуть последний элемент в итераторе. Это `Option`, потому что возможно, что первая строка - это пустая строка; например, если `text` начинается с пустой строки, но содержит символы на других строках, как в `"\nhi"`. Однако, если есть последний символ на первой строке, он будет возвращен в варианте `Some`. Оператор `?` в середине дает нам простой способ выразить эту логику, позволяя реализовать функцию в одну строку. Если бы мы не могли использовать оператор `?` с `Option`, нам пришлось бы реализовать эту логику с использованием большего количества вызовов методов или выражения `match`.

Обратите внимание, что вы можете использовать оператор `?` с `Result` в функции, возвращающей `Result`, и вы можете использовать оператор `?` с `Option` в функции, возвращающей `Option`, но нельзя смешивать их. Оператор `?` не автоматически преобразует `Result` в `Option` и наоборот; в таких случаях вы можете использовать методы, такие как метод `ok` для `Result` или метод `ok_or` для `Option`, чтобы явно выполнить преобразование.

До сих пор все функции `main`, которые мы использовали, возвращают `()`. Функция `main` особая, потому что она является точкой входа и выхода исполняемой программы, и существуют ограничения на ее возвращаемый тип, чтобы программа работала как ожидается.

К счастью, `main` может также возвращать `Result<(), E>`. Листинг 9-12 содержит код из листинга 9-10, но мы изменили возвращаемый тип `main` на `Result<(), Box<dyn Error>>` и добавили возвращаемое значение `Ok(())` в конец. Теперь этот код скомпилируется.

Filename: `src/main.rs`

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
```

Листинг 9-12: Изменение `main` на возврат `Result<(), E>` позволяет использовать оператор `?` с значениями `Result`.

Тип `Box<dyn Error>` - это _объект-особность_ (trait object), о котором мы поговорим в разделе "Using Trait Objects That Allow for Values of Different Types". На данный момент вы можете прочитать `Box<dyn Error>` как "любой тип ошибки". Использование `?` с значением `Result` в функции `main` с типом ошибки `Box<dyn Error>` допустимо, потому что это позволяет ранним возврату любого значения `Err`. Даже если тело этой функции `main` будет всегда возвращать ошибки типа `std::io::Error`, указав `Box<dyn Error>`, эта сигнатура останется правильной, даже если в тело `main` добавится больше кода, возвращающего другие ошибки.

Когда функция `main` возвращает `Result<(), E>`, исполняемый файл будет выходить с значением `0`, если `main` возвращает `Ok(())`, и будет выходить с ненулевым значением, если `main` возвращает значение `Err`. Исполняемые файлы, написанные на C, возвращают целые числа при выходе: программы, завершающиеся успешно, возвращают целое число `0`, а программы, завершающиеся с ошибкой, возвращают какое-то целое число, отличное от `0`. Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этой традицией.

Функция `main` может возвращать любые типы, реализующие трейт `std::process::Termination`, который содержит функцию `report`, возвращающую `ExitCode`. См. документацию по стандартной библиотеке для получения дополнительной информации о реализации трейта `Termination` для собственных типов.

Теперь, когда мы обсудили детали вызова `panic!` или возврата `Result`, вернемся к теме, как решать, какой подход использовать в каких случаях.
