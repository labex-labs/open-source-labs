# Matching on Different Errors

Код в листинге 9-4 будет вызывать `panic!`, не зависимо от причины, по которой `File::open` завершилась с ошибкой. Однако, мы хотим выполнять разные действия для разных причин неудачи. Если `File::open` завершилась с ошибкой, потому что файл не существует, мы хотим создать файл и вернуть дескриптор для нового файла. Если `File::open` завершилась с ошибкой по какой-либо другой причине (например, потому что у нас нет разрешения на открытие файла), мы по-прежнему хотим, чтобы код вызывал `panic!` так же, как это было в листинге 9-4. Для этого мы добавляем внутреннее выражение `match`, показанное в листинге 9-5.

Filename: `src/main.rs`

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => {
                match File::create("hello.txt") {
                    Ok(fc) => fc,
                    Err(e) => panic!(
                        "Problem creating the file: {:?}",
                        e
                    ),
                }
            }
            other_error => {
                panic!(
                    "Problem opening the file: {:?}",
                    other_error
                );
            }
        },
    };
}
```

Листинг 9-5: Обработка разных типов ошибок по-разному

Тип значения, которое возвращает `File::open` внутри варианта `Err`, - это `io::Error`, который является структурой, предоставленной стандартной библиотекой. Эта структура имеет метод `kind`, который мы можем вызвать, чтобы получить значение `io::ErrorKind`. Перечисление `io::ErrorKind` предоставляется стандартной библиотекой и имеет варианты, представляющие разные виды ошибок, которые могут возникнуть при операции ввода-вывода. Вариант, который мы хотим использовать, - это `ErrorKind::NotFound`, который указывает на то, что файл, который мы пытаемся открыть, еще не существует. Поэтому мы сопоставляем `greeting_file_result`, но также имеем внутреннее сопоставление по `error.kind()`.

Условие, которое мы хотим проверить в внутреннем сопоставлении, - это то, является ли значение, возвращаемое `error.kind()`, вариантом `NotFound` перечисления `ErrorKind`. Если это так, мы пытаемся создать файл с использованием `File::create`. Однако, поскольку `File::create` также может завершиться с ошибкой, нам нужна вторая ветка в внутреннем выражении `match`. Когда файл не может быть создан, выводится другое сообщение об ошибке. Вторая ветка внешнего `match` остается той же, поэтому программа завершается с паникой при любой ошибке, кроме ошибки отсутствия файла.
