# Propagating Errors

Когда реализация функции вызывает что-то, что может завершиться с ошибкой, вместо обработки ошибки внутри самой функции вы можете вернуть ошибку вызывающему коду, чтобы он мог решить, что делать. Это называется _передачей_ ошибки и дает больше контроля вызывающему коду, где может быть больше информации или логики, которая определяет, как должна быть обработана ошибка, чем у вас есть в контексте вашего кода.

Например, листинг 9-6 показывает функцию, которая читает имя пользователя из файла. Если файл не существует или не может быть прочитан, эта функция вернет эти ошибки вызывающему коду.

Filename: `src/main.rs`

```rust
use std::fs::File;
use std::io::{self, Read};

1 fn read_username_from_file() -> Result<String, io::Error> {
  2 let username_file_result = File::open("hello.txt");

  3 let mut username_file = match username_file_result {
      4 Ok(file) => file,
      5 Err(e) => return Err(e),
    };

  6 let mut username = String::new();

  7 match username_file.read_to_string(&mut username) {
      8 Ok(_) => Ok(username),
      9 Err(e) => Err(e),
    }
}
```

Листинг 9-6: Функция, которая возвращает ошибки вызывающему коду с использованием `match`

Эту функцию можно написать гораздо короче, но мы начнем с более ручного подхода, чтобы изучить обработку ошибок. В конце мы покажем более короткий способ. Давайте сначала рассмотрим возвращаемый тип функции: `Result<String, io::Error>` \[1\]. Это означает, что функция возвращает значение типа `Result<T, E>`, где обобщенный параметр `T` заполнен конкретным типом `String`, а обобщенный тип `E` заполнен конкретным типом `io::Error`.

Если эта функция завершается успешно без проблем, вызывающий код получит значение `Ok`, которое содержит `String` - имя пользователя, которое эта функция прочитала из файла \[8\]. Если эта функция встретит какие-либо проблемы, вызывающий код получит значение `Err`, которое содержит экземпляр `io::Error`, который содержит дополнительную информацию о том, какие были проблемы. Мы выбрали `io::Error` в качестве возвращаемого типа этой функции, потому что именно этот тип ошибки возвращается из обоих операций, которые мы вызываем в теле этой функции и которые могут завершиться с ошибкой: функции `File::open` \[2\] и метода `read_to_string` \[7\].

Тело функции начинается с вызова функции `File::open` \[2\]. Затем мы обрабатываем значение `Result` с использованием `match`, аналогичного `match` в листинге 9-4. Если `File::open` завершается успешно, дескриптор файла в переменной шаблона `file` \[4\] становится значением в изменяемой переменной `username_file` \[3\], и функция продолжает работу. В случае `Err` вместо вызова `panic!` мы используем ключевое слово `return`, чтобы выйти из функции досрочно и передать значение ошибки из `File::open`, которое теперь находится в переменной шаблона `e`, обратно вызывающему коду в качестве ошибочного значения этой функции \[5\].

Таким образом, если у нас есть дескриптор файла в `username_file`, функция затем создает новую `String` в переменной `username` \[6\] и вызывает метод `read_to_string` для дескриптора файла в `username_file`, чтобы прочитать содержимое файла в `username` \[7\]. Метод `read_to_string` также возвращает `Result`, потому что он может завершиться с ошибкой, даже если `File::open` завершается успешно. Поэтому нам нужен еще один `match`, чтобы обработать это `Result`: если `read_to_string` завершается успешно, то наша функция завершилась успешно, и мы возвращаем имя пользователя из файла, которое теперь находится в `username`, обернутое в `Ok`. Если `read_to_string` завершается с ошибкой, мы возвращаем значение ошибки так же, как мы возвращали значение ошибки в `match`, которое обрабатывало возвращаемое значение `File::open`. Однако, мы не нужно явно писать `return`, потому что это последнее выражение в функции \[9\].

Затем вызывающий код должен обработать получение либо значения `Ok`, которое содержит имя пользователя, либо значения `Err`, которое содержит `io::Error`. В决定权 вызывающего кода входит, что делать с этими значениями. Если вызывающий код получает значение `Err`, он может вызвать `panic!` и завершить работу программы, использовать имя пользователя по умолчанию или искать имя пользователя не из файла, например. У нас недостаточно информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы передаем всю информацию об успехе или ошибке вверх, чтобы она была обработана соответствующим образом.

Этот паттерн передачи ошибок настолько распространен в Rust, что Rust предоставляет оператор вопроса `?`, чтобы упростить этот процесс.
