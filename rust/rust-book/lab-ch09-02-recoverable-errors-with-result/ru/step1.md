# Recoverable Errors with Result

Большинство ошибок не настолько серьезны, чтобы требовать полного остановки программы. Иногда, когда функция завершается с ошибкой, это происходит по причине, которую можно легко интерпретировать и на которую можно ответить. Например, если вы пытаетесь открыть файл, а эта операция завершается с ошибкой, потому что файл не существует, вы, возможно, захотите создать файл вместо завершения процесса.

Помните из раздела "Handling Potential Failure with Result", что перечисление `Result` определено как имеющее два варианта: `Ok` и `Err`, как показано ниже:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`T` и `E` - обобщенные параметры типа. Мы поговорим о обобщениях более подробно в главе 10. Что вам нужно знать прямо сейчас, так это то, что `T` представляет тип значения, которое будет возвращено в случае успеха в варианте `Ok`, а `E` представляет тип ошибки, которая будет возвращена в случае неудачи в варианте `Err`. Поскольку `Result` имеет эти обобщенные параметры типа, мы можем использовать тип `Result` и функции, определенные для него, в многих различных ситуациях, где значения успеха и ошибки, которые мы хотим вернуть, могут различаться.

Позвоним функции, которая возвращает значение `Result`, потому что функция может завершиться с ошибкой. В листинге 9-3 мы пытаемся открыть файл.

Filename: `src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
```

Листинг 9-3: Открытие файла

Возвращаемый тип `File::open` - это `Result<T, E>`. Обобщенный параметр `T` заполняется реализацией `File::open` типом значения успеха, `std::fs::File`, который представляет собой дескриптор файла. Тип `E`, используемый в значении ошибки, - это `std::io::Error`. Этот возвращаемый тип означает, что вызов `File::open` может завершиться успешно и вернуть дескриптор файла, с которым можно читать или писать. Функция также может завершиться с ошибкой: например, файл может не существовать, или у нас может не быть разрешения на доступ к файлу. Функция `File::open` должна иметь способ сообщить нам, удалось ли выполнить ее или нет, и одновременно передать нам либо дескриптор файла, либо информацию об ошибке. Эта информация передается именно перечислением `Result`.

В случае успеха вызова `File::open` значение в переменной `greeting_file_result` будет экземпляром `Ok`, содержащим дескриптор файла. В случае неудачи значение в `greeting_file_result` будет экземпляром `Err`, содержащим дополнительную информацию о типе ошибки, которая произошла.

Мы должны добавить в код из листинга 9-3, чтобы выполнять разные действия в зависимости от значения, возвращаемого `File::open`. Листинг 9-4 показывает один способ обработать `Result` с использованием базового инструмента - выражения `match`, о котором мы говорили в главе 6.

Filename: `src/main.rs`

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error);
        }
    };
}
```

Листинг 9-4: Использование выражения `match` для обработки вариантов `Result`, которые могут быть возвращены

Обратите внимание, что, как и в случае с перечислением `Option`, перечисление `Result` и его варианты импортированы в область видимости преамбулой, поэтому мы не нужно указывать `Result::` перед вариантами `Ok` и `Err` в ветках `match`.

Когда результат равен `Ok`, этот код возвращает внутреннее значение `file` из варианта `Ok`, а затем мы присваиваем значение дескриптора файла переменной `greeting_file`. После `match` мы можем использовать дескриптор файла для чтения или записи.

Другая ветка `match` обрабатывает случай, когда мы получаем значение `Err` из `File::open`. В этом примере мы выбрали вызвать макрос `panic!`. Если в текущем каталоге нет файла с именем _hello.txt_ и мы запустим этот код, мы увидим следующий вывод от макроса `panic!`:

    thread 'main' panicked at 'Problem opening the file: Os { code:
     2, kind: NotFound, message: "No such file or directory" }',
    src/main.rs:8:23

Как обычно, этот вывод точно сообщает нам, что пошло не так.
