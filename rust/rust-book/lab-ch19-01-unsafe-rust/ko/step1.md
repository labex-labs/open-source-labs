# Unsafe Rust

지금까지 논의한 모든 코드는 컴파일 시간에 Rust 의 메모리 안전 보장이 적용되었습니다. 그러나 Rust 에는 이러한 메모리 안전 보장을 적용하지 않는 두 번째 언어가 숨겨져 있습니다. 이를 *unsafe Rust*라고 하며, 일반 Rust 와 동일하게 작동하지만 추가적인 능력을 제공합니다.

Unsafe Rust 가 존재하는 이유는 본질적으로 정적 분석이 보수적이기 때문입니다. 컴파일러가 코드가 보장을 준수하는지 여부를 결정하려고 할 때, 일부 유효한 프로그램을 거부하는 것이 일부 유효하지 않은 프로그램을 허용하는 것보다 낫습니다. 코드가 괜찮을 _수_ 있지만, Rust 컴파일러가 확신할 수 있을 만큼 충분한 정보를 가지고 있지 않다면 코드를 거부합니다. 이러한 경우, unsafe 코드를 사용하여 컴파일러에게 "저를 믿으세요, 제가 무엇을 하는지 알고 있습니다."라고 말할 수 있습니다. 하지만 unsafe Rust 를 사용할 때는 위험을 감수해야 합니다. unsafe 코드를 잘못 사용하면 널 포인터 역참조와 같은 메모리 안전성 문제로 인해 문제가 발생할 수 있습니다.

Rust 에 unsafe alter ego 가 있는 또 다른 이유는 기본 컴퓨터 하드웨어가 본질적으로 unsafe 하기 때문입니다. Rust 가 unsafe 작업을 허용하지 않으면 특정 작업을 수행할 수 없습니다. Rust 는 운영 체제와 직접 상호 작용하거나 자체 운영 체제를 작성하는 것과 같은 로우 레벨 시스템 프로그래밍을 허용해야 합니다. 로우 레벨 시스템 프로그래밍 작업은 언어의 목표 중 하나입니다. unsafe Rust 로 무엇을 할 수 있는지, 그리고 어떻게 할 수 있는지 살펴보겠습니다.
