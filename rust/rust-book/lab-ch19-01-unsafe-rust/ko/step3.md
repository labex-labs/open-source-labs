# Raw 포인터 역참조

"Dangling References"에서 컴파일러가 참조가 항상 유효하도록 보장한다고 언급했습니다. Unsafe Rust 에는 참조와 유사한 *raw 포인터*라는 두 가지 새로운 유형이 있습니다. 참조와 마찬가지로 raw 포인터는 불변 또는 가변일 수 있으며 각각 `*const T` 및 `*mut T`로 작성됩니다. 별표는 역참조 연산자가 아닙니다. 이는 유형 이름의 일부입니다. Raw 포인터의 맥락에서 *불변 (immutable)*은 역참조된 후 포인터에 직접 할당할 수 없음을 의미합니다.

참조 및 스마트 포인터와 달리 raw 포인터는 다음과 같습니다.

- 불변 및 가변 포인터 또는 동일한 위치에 대한 여러 가변 포인터를 가짐으로써 borrow 규칙을 무시할 수 있습니다.
- 유효한 메모리를 가리킨다는 보장이 없습니다.
- null 일 수 있습니다.
- 자동 정리를 구현하지 않습니다.

Rust 가 이러한 보장을 적용하지 않도록 선택함으로써, 더 나은 성능을 얻거나 Rust 의 보장이 적용되지 않는 다른 언어 또는 하드웨어와 인터페이스할 수 있는 능력을 얻기 위해 보장된 안전성을 포기할 수 있습니다.

Listing 19-1 은 참조에서 불변 및 가변 raw 포인터를 만드는 방법을 보여줍니다.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

Listing 19-1: 참조에서 raw 포인터 생성

이 코드에는 `unsafe` 키워드를 포함하지 않는다는 점에 유의하십시오. 안전한 코드에서 raw 포인터를 만들 수 있습니다. 잠시 후에 보게 되겠지만, unsafe 블록 외부에서는 raw 포인터를 역참조할 수 없습니다.

`as`를 사용하여 불변 및 가변 참조를 해당 raw 포인터 유형으로 캐스팅하여 raw 포인터를 만들었습니다. 유효하다고 보장된 참조에서 직접 생성했기 때문에 이러한 특정 raw 포인터가 유효하다는 것을 알고 있지만, 임의의 raw 포인터에 대해 그러한 가정을 할 수는 없습니다.

이를 설명하기 위해 다음으로 유효성을 확신할 수 없는 raw 포인터를 만들 것입니다. Listing 19-2 는 메모리의 임의 위치에 대한 raw 포인터를 만드는 방법을 보여줍니다. 임의의 메모리를 사용하려고 하면 정의되지 않은 동작이 발생합니다. 해당 주소에 데이터가 있을 수도 있고 없을 수도 있으며, 컴파일러가 코드를 최적화하여 메모리 접근이 없도록 하거나, 프로그램이 세그먼테이션 오류로 종료될 수 있습니다. 일반적으로 이와 같은 코드를 작성할 좋은 이유는 없지만, 가능합니다.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

Listing 19-2: 임의의 메모리 주소에 대한 raw 포인터 생성

안전한 코드에서 raw 포인터를 만들 수 있지만, raw 포인터를 *역참조*하여 가리키는 데이터를 읽을 수는 없다는 것을 기억하십시오. Listing 19-3 에서 `unsafe` 블록이 필요한 raw 포인터에 역참조 연산자 `*`를 사용합니다.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

Listing 19-3: `unsafe` 블록 내에서 raw 포인터 역참조

포인터를 생성하는 것은 해가 없습니다. 가리키는 값에 접근하려고 할 때만 유효하지 않은 값을 처리하게 될 수 있습니다.

또한 Listing 19-1 및 19-3 에서 `num`이 저장된 동일한 메모리 위치를 가리키는 `*const i32` 및 `*mut i32` raw 포인터를 모두 만들었습니다. 대신 `num`에 대한 불변 및 가변 참조를 만들려고 하면 Rust 의 소유권 규칙에 따라 불변 참조와 동시에 가변 참조를 허용하지 않으므로 코드가 컴파일되지 않습니다. Raw 포인터를 사용하면 동일한 위치에 대한 가변 포인터와 불변 포인터를 생성하고 가변 포인터를 통해 데이터를 변경하여 데이터 경합 (data race) 을 잠재적으로 생성할 수 있습니다. 주의하십시오!

이러한 모든 위험이 있는데, 왜 raw 포인터를 사용해야 할까요? 주요 사용 사례 중 하나는 "Calling an Unsafe Function or Method"에서 보게 될 C 코드와 인터페이스할 때입니다. 또 다른 경우는 borrow checker 가 이해하지 못하는 안전한 추상화를 구축할 때입니다. unsafe 함수를 소개한 다음 unsafe 코드를 사용하는 안전한 추상화의 예를 살펴보겠습니다.
