# Unsafe Rust

Todo o código que discutimos até agora teve as garantias de segurança de memória do Rust impostas em tempo de compilação. No entanto, o Rust tem uma segunda linguagem escondida dentro dele que não impõe essas garantias de segurança de memória: ela é chamada de _unsafe Rust_ e funciona como o Rust regular, mas nos dá superpoderes extras.

O Unsafe Rust existe porque, por natureza, a análise estática é conservadora. Quando o compilador tenta determinar se o código mantém ou não as garantias, é melhor que ele rejeite alguns programas válidos do que aceitar alguns programas inválidos. Embora o código _possa_ estar correto, se o compilador Rust não tiver informações suficientes para ter confiança, ele rejeitará o código. Nesses casos, você pode usar código unsafe para dizer ao compilador: "Confie em mim, eu sei o que estou fazendo." Esteja avisado, no entanto, que você usa o Unsafe Rust por sua própria conta e risco: se você usar código unsafe incorretamente, problemas podem ocorrer devido à insegurança da memória, como a desreferenciação de ponteiros nulos.

Outra razão pela qual o Rust tem um alter ego unsafe é que o hardware subjacente do computador é inerentemente unsafe. Se o Rust não permitisse que você fizesse operações unsafe, você não poderia realizar certas tarefas. O Rust precisa permitir que você faça programação de sistemas de baixo nível, como interagir diretamente com o sistema operacional ou até mesmo escrever seu próprio sistema operacional. Trabalhar com programação de sistemas de baixo nível é um dos objetivos da linguagem. Vamos explorar o que podemos fazer com o Unsafe Rust e como fazê-lo.
