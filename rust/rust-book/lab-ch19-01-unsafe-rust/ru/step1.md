# Unsafe Rust

Все код, который мы обсуждали до сих пор, имел гарантии безопасности памяти Rust, налагаемые во время компиляции. Однако, внутри Rust скрывается вторая языковая часть, которая не налагает эти гарантии безопасности памяти: это называется _unsafe Rust_ и работает так же, как и обычный Rust, но дает нам дополнительные суперспособности.

Unsafe Rust существует потому, что по своей природе статический анализ консервативен. Когда компилятор пытается определить, соответствует ли код гарантиям, для него лучше отвергнуть некоторые валидные программы, чем принять некоторые невалидные программы. Хотя код _возможно_ будет в порядке, если у Rust компилятора недостаточно информации, чтобы быть уверенным, он отвергнет код. В таких случаях вы можете использовать небезопасный код, чтобы сказать компилятору: "Доверьте мне, я знаю, что делаю". Будьте осторожны, однако, поскольку вы используете unsafe Rust на свою ответственность: если вы неправильно используете небезопасный код, могут возникнуть проблемы из-за небезопасности памяти, такой как разыменование нулевого указателя.

Другой reason Rust имеет небезопасную альтернативу заключается в том, что базовый компьютерный аппарат по своей природе небезопасен. Если Rust не позволял бы вам выполнять небезопасные операции, вы не могли бы выполнить определенные задачи. Rust должен позволить вам выполнять низкоуровневую системную программирование, например, непосредственно взаимодействовать с операционной системой или даже писать свою собственную операционную систему. Работа с низкоуровневым системным программированием является одной из целей языка. Давайте исследуем, что мы можем сделать с unsafe Rust и как это сделать.
