# Разыменование сырого указателя

В разделе "Проматывающиеся ссылки" мы упоминали, что компилятор гарантирует, что ссылки всегда действительны. В unsafe Rust есть два новых типа, называемых _сырыми указателями_, которые похожи на ссылки. Как и в случае с ссылками, сырой указатель может быть неизменяемым или изменяемым и записывается соответственно как `*const T` и `*mut T`. Звездочка не является оператором разыменования; это часть имени типа. В контексте сырых указателей _неизменяемым_ означает, что после разыменования указатель нельзя напрямую присвоить.

В отличие от ссылок и умных указателей, сырой указатель:

- Может игнорировать правила заимствования, имея как неизменяемый, так и изменяемый указатель или несколько изменяемых указателей на одну и ту же область памяти
- Не гарантируется, что указывает на действительную память
- Может быть равен нулю
- Не реализует автоматическое очищение

Отказавшись от того, чтобы Rust гарантировал эти условия, вы можете отказаться от гарантированной безопасности в обмен на большую производительность или возможность взаимодействовать с другой языковой средой или оборудованием, где гарантии Rust не действуют.

Листинг 19-1 показывает, как создать неизменяемый и изменяемый сырой указатель из ссылок.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

Листинг 19-1: Создание сырых указателей из ссылок

Заметьте, что в этом коде мы не используем ключевое слово `unsafe`. Мы можем создавать сырые указатели в безопасном коде; мы просто не можем разыменовывать сырой указатель вне небезопасного блока, как вы вскоре увидите.

Мы создали сырые указатели, используя `as` для приведения неизменяемой и изменяемой ссылки к соответствующим типам сырых указателей. Поскольку мы создали их напрямую из ссылок, гарантированных как действительных, мы знаем, что эти конкретные сырые указатели действительны, но мы не можем делать этого предположения о любом сыром указателе.

Чтобы продемонстрировать это, далее мы создадим сырой указатель, действительность которого мы не можем так уверенно определить. Листинг 19-2 показывает, как создать сырой указатель на произвольное место в памяти. Попытка использовать произвольную память имеет неопределенное поведение: может быть, там есть данные, или может быть их и нет, компилятор может оптимизировать код так, чтобы не было доступа к памяти, или программа может завершиться с ошибкой сегментации. Обычно нет никакой причины писать такой код, но это возможно.

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

Листинг 19-2: Создание сырого указателя на произвольный адрес памяти

Помните, что мы можем создавать сырые указатели в безопасном коде, но мы не можем _разыменовывать_ сырой указатель и прочитать данные, на которые он указывает. В Листинге 19-3 мы используем оператор разыменования `*` для сырого указателя, что требует небезопасного блока.

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

Листинг 19-3: Разыменование сырых указателей внутри небезопасного блока

Создание указателя не наносит вреда; только когда мы пытаемся получить доступ к значению, на которое он указывает, мы можем столкнуться с недействительным значением.

Обратите внимание также, что в Листингах 19-1 и 19-3 мы создали сырые указатели `*const i32` и `*mut i32`, которые оба указывали на одну и ту же область памяти, где хранится `num`. Если бы мы вместо этого попытались создать неизменяемую и изменяемую ссылку на `num`, код не скомпилировался бы, потому что правила владения Rust не позволяют иметь изменяемую ссылку одновременно с любой неизменяемой ссылкой. С сырыми указателями мы можем создать изменяемый и неизменяемый указатель на одну и ту же область памяти и изменить данные через изменяемый указатель, что потенциально может привести к гонке данных. Будьте осторожны!

С учетом всех этих опасностей, зачем вы когда-либо будете использовать сырые указатели? Одним из основных случаев использования является взаимодействие с кодом на C, как вы увидите в разделе "Вызов небезопасной функции или метода". Другой случай - это создание безопасных абстракций, которые не понимает проверщик заимствования. Мы представим небезопасные функции и затем рассмотрим пример безопасной абстракции, которая использует небезопасный код.
