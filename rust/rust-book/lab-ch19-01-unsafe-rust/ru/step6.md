# Использование внешних функций для вызова внешнего кода

Иногда ваш код на Rust может потребовать взаимодействия с кодом, написанным на другом языке. Для этого в Rust есть ключевое слово `extern`, которое облегчает создание и использование _Foreign Function Interface_ (FFI), который представляет собой способ программирования языка определить функции и позволить другим (иностранным) языкам программирования вызывать эти функции.

Листинг 19-8 демонстрирует, как настроить интеграцию с функцией `abs` из стандартной библиотеки C. Функции, объявленные внутри блоков `extern`, всегда небезопасны для вызова из кода на Rust. Причина заключается в том, что другие языки не налагают правила и гарантии Rust, и Rust не может проверить их, поэтому ответственность ложится на программиста обеспечить безопасность.

Имя файла: `src/main.rs`

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!(
            "Absolute value of -3 according to C: {}",
            abs(-3)
        );
    }
}
```

Листинг 19-8: Объявление и вызов внешней функции, определенной в другом языке

Внутри блока `extern "C"` мы перечисляем имена и сигнатуры внешних функций из другого языка, которые мы хотим вызвать. Часть `"C"` определяет, какой _application binary interface_ (ABI) использует внешняя функция: ABI определяет, как вызывать функцию на уровне ассемблера. ABI `"C"` - это наиболее распространенный и соответствует ABI языка программирования C.

> **Вызов функций на Rust из других языков**
>
> Мы также можем использовать `extern`, чтобы создать интерфейс, позволяющий другим языкам вызывать функции на Rust. Вместо создания целого блока `extern` мы добавляем ключевое слово `extern` и указываем ABI для использования непосредственно перед ключевым словом `fn` для соответствующей функции. Мы также должны добавить аннотацию `#[no_mangle]`, чтобы сообщить компилятору Rust не преобразовывать имя этой функции. _Преобразование имени_ - это когда компилятор изменяет имя, которое мы дали функции, на другое имя, которое содержит больше информации для других частей процесса компиляции, но менее читаемое для человека. Каждый компилятор языка программирования преобразует имена несколько по-разному, поэтому для того, чтобы функция на Rust была именуемой из других языков, мы должны отключить преобразование имен компилятора Rust.
>
> В следующем примере мы делаем функцию `call_from_c` доступной из кода на C, после того, как она скомпилирована в динамическую библиотеку и связана из C:
>
>     #[no_mangle]
>     pub extern "C" fn call_from_c() {
>         println!("Just called a Rust function from C!");
>     }
>
> Это использование `extern` не требует `unsafe`.
