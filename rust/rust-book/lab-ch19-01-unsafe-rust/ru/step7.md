# Доступ к изменяемой статической переменной или ее изменение

В этой книге мы еще не говорили о глобальных переменных, которые Rust поддерживает, но могут быть проблематичными в контексте правил владения Rust. Если два потока обращаются к одной и той же изменяемой глобальной переменной, это может привести к гонке данных.

В Rust глобальные переменные называются _статическими_ переменными. Листинг 19-9 показывает пример объявления и использования статической переменной со строковым срезом в качестве значения.

Имя файла: `src/main.rs`

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}
```

Листинг 19-9: Определение и использование неизменяемой статической переменной

Статические переменные похожи на константы, о которых мы говорили в разделе "Константы". Имена статических переменных по соглашению записываются в стиле `SCREAMING_SNAKE_CASE`. Статические переменные могут хранить только ссылки с временем жизни `'static`, что означает, что Rust-компилятор может определить время жизни, и нам не нужно явно его аннотировать. Доступ к неизменяемой статической переменной безопасен.

Некоторое тонкое отличие между константами и неизменяемыми статическими переменными заключается в том, что значения в статической переменной имеют фиксированный адрес в памяти. Использование значения всегда будет обращаться к тем же данным. В то же время константы могут дублировать свои данные при каждом использовании. Еще одно отличие заключается в том, что статические переменные могут быть изменяемыми. Доступ к и изменение изменяемой статической переменной _небезопасны_. Листинг 19-10 показывает, как объявить, получить доступ к и изменить изменяемую статическую переменную под названием `COUNTER`.

Имя файла: `src/main.rs`

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}
```

Листинг 19-10: Чтение из или запись в изменяемую статическую переменную - это небезопасно.

Как и в случае с обычными переменными, мы указываем изменяемость с помощью ключевого слова `mut`. Любой код, который читает или записывает из `COUNTER`, должен находиться внутри небезопасного блока. Этот код компилируется и выводит `COUNTER: 3`, как мы ожидаем, потому что это однопоточный код. Если несколько потоков обращаются к `COUNTER`, это, скорее всего, приведет к гонке данных.

При наличии изменяемой данных, доступной глобально，很难确保不存在数据竞争，这就是为什么 Rust 认为可变静态变量是不安全的原因。只要有可能，最好使用我们在第 16 章中讨论的并发技术和线程安全的智能指针，这样编译器就能检查不同线程对数据的访问是否安全。
