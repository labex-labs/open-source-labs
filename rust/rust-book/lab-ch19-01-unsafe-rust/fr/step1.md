# Unsafe Rust

Tout le code que nous avons discuté jusqu'à présent a bénéficié des garanties de sécurité mémoire de Rust imposées à la compilation. Cependant, Rust a un second langage caché en son sein qui ne impose pas ces garanties de sécurité mémoire : il s'agit du _Rust non sécurisé_ et fonctionne comme le Rust classique, mais nous donne des super-pouvoirs supplémentaires.

Le Rust non sécurisé existe parce que, par nature, l'analyse statique est conservatrice. Lorsque le compilateur tente de déterminer si le code respecte les garanties, il est préférable qu'il rejette certains programmes valides plutôt qu'il n'accepte certains programmes invalides. Bien que le code _puisse_ être correct, si le compilateur Rust n'a pas suffisamment d'informations pour être sûr, il rejettera le code. Dans ces cas, vous pouvez utiliser du code non sécurisé pour dire au compilateur : "Fiez-vous à moi, je sais ce que je fais." Soyez toutefois prévenu que vous utilisez le Rust non sécurisé à vos propres risques : si vous utilisez le code non sécurisé incorrectement, des problèmes peuvent survenir en raison de l'insécurité mémoire, comme la déréférencement d'un pointeur nul.

Une autre raison pour laquelle Rust a une alter ego non sécurisée est que le matériel informatique sous-jacent est intrinsèquement non sécurisé. Si Rust ne vous permettait pas d'effectuer des opérations non sécurisées, vous ne pourriez pas effectuer certaines tâches. Rust doit vous permettre de faire de la programmation système de bas niveau, comme interagir directement avec le système d'exploitation ou même écrire votre propre système d'exploitation. Travailler avec la programmation système de bas niveau est l'un des objectifs du langage. Explorons ce que nous pouvons faire avec le Rust non sécurisé et comment le faire.
