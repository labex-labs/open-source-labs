# 可変静的変数へのアクセスまたは変更

この本では、まだグローバル変数について話していません。Rustはグローバル変数をサポートしていますが、Rustの所有権規則とともに問題があります。2つのスレッドが同じ可変グローバル変数にアクセスしている場合、データレースが発生する可能性があります。

Rustでは、グローバル変数は「静的」変数と呼ばれます。リスト19-9は、文字列をスライスとして値に持つ静的変数の宣言と使用の例を示しています。

ファイル名: `src/main.rs`

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}
```

リスト19-9：不変静的変数の定義と使用

静的変数は、「定数」の項で議論した定数と似ています。静的変数の名前は、慣例により`SCREAMING_SNAKE_CASE`になっています。静的変数は、`'static`寿命の参照のみを格納できます。これは、Rustコンパイラが寿命を把握できるため、明示的に注釈を付ける必要はありません。不変静的変数へのアクセスは安全です。

定数と不変静的変数の微妙な違いは、静的変数の値がメモリ内の固定アドレスを持つことです。値を使用すると、常に同じデータにアクセスされます。一方、定数は使用するたびにデータを複製することができます。もう1つの違いは、静的変数が可変であることができることです。可変静的変数へのアクセスと変更は「不健全」です。リスト19-10は、`COUNTER`という名前の可変静的変数を宣言、アクセス、変更する方法を示しています。

ファイル名: `src/main.rs`

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}
```

リスト19-10：可変静的変数への読み書きは不健全です。

通常の変数と同様に、`mut`キーワードを使用して可変性を指定します。`COUNTER`から読み書きするすべてのコードは、`unsafe`ブロック内にある必要があります。このコードはコンパイルされ、予想通り`COUNTER: 3`が表示されます。なぜなら、これは単一スレッドであるからです。複数のスレッドが`COUNTER`にアクセスすると、おそらくデータレースが発生します。

グローバルにアクセス可能な可変データでは、データレースがないことを確認するのは難しいです。これが、Rustが可変静的変数を不健全と見なす理由です。可能な限り、第16章で議論した並列処理技術とスレッドセーフなスマートポインタを使用することが好ましいです。そうすることで、コンパイラが異なるスレッドからのデータアクセスが安全に行われることを確認します。
