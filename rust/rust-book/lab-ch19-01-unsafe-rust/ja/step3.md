# 生のポインタを参照する

「浮動参照」の項で、コンパイラが参照が常に有効であることを保証することを述べました。unsafe Rustには、参照に似た2つの新しい型である「生のポインタ」があります。参照と同様に、生のポインタは不変または可変で、それぞれ`*const T`と`*mut T`として書かれます。アスタリスクは参照解除演算子ではなく、型名の一部です。生のポインタのコンテキストでは、「不変」とは、ポインタが参照解除された後に直接代入できないことを意味します。

参照やスマートポインタとは異なり、生のポインタは：

- 不変ポインタと可変ポインタの両方、または同じ場所に対する複数の可変ポインタを持つことで、借用規則を無視することができます。
- 有効なメモリを指すことが保証されていません。
- ヌルを指すことが許されます。
- 自動的なクリーンアップを実装していません。

Rustがこれらの保証を強制することを選ばないことで、保証されたセーフティを捨てて、より高いパフォーマンスや、Rustの保証が適用されない別の言語やハードウェアとのインターフェイス能力を得ることができます。

リスト19-1は、参照から不変と可変の生のポインタを作成する方法を示しています。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

リスト19-1：参照から生のポインタを作成する

このコードに`unsafe`キーワードが含まれていないことに注意してください。私たちは安全なコードで生のポインタを作成することができます。ただし、後ほど見るように、unsafeブロックの外で生のポインタを参照解除することはできません。

私たちは`as`を使って不変参照と可変参照をそれぞれ対応する生のポインタ型にキャストすることで生のポインタを作成しました。これらは参照から直接作成されており、有効であることが保証されているため、これらの特定の生のポインタは有効であることがわかります。ただし、任意の生のポインタについてはそのような仮定をすることはできません。

これを示すために、次に有効性が確実ではない生のポインタを作成します。リスト19-2は、メモリ内の任意の場所に生のポインタを作成する方法を示しています。任意のメモリを使用することは未定義です。そのアドレスにデータがあるかもしれませんし、ないかもしれません。コンパイラはコードを最適化してメモリアクセスを行わなくするかもしれません。または、プログラムはセグメンテーションフォールトで終了するかもしれません。通常、このようなコードを書く理由はあまりありませんが、可能です。

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

リスト19-2：任意のメモリアドレスに生のポインタを作成する

思い出してください。私たちは安全なコードで生のポインタを作成することができますが、生のポインタを参照解除して指されているデータを読むことはできません。リスト19-3では、`unsafe`ブロックが必要な生のポインタに参照解除演算子`*`を使用しています。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

リスト19-3：`unsafe`ブロック内で生のポインタを参照解除する

ポインタを作成すること自体は害はありません。そのポインタが指す値にアクセスしようとするときに、無効な値と対処することになるかもしれません。

また、リスト19-1と19-3では、`num`が格納されている同じメモリ場所を指す`*const i32`と`*mut i32`の生のポインタを作成しました。代わりに`num`に対して不変参照と可変参照を作成しようとすると、コードはコンパイルされません。なぜなら、Rustの所有権規則は、不変参照が存在する間に可変参照を許さないからです。生のポインタを使えば、同じ場所に対して可変ポインタと不変ポインタを作成し、可変ポインタを通じてデータを変更することができ、データレースが発生する可能性があります。注意してください！

これらのすべての危険があるのに、なぜ生のポインタを使うのでしょうか？主な使い道の1つは、Cコードとのインターフェイスを行う場合です。「不健全な関数またはメソッドを呼び出す」で見るように。もう1つのケースは、借用チェッカーが理解できない安全な抽象化を構築する場合です。不健全な関数を紹介した後、不健全なコードを使用する安全な抽象化の例を見てみましょう。
