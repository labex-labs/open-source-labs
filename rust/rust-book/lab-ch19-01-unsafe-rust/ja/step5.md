# 不健全なコードに対する安全な抽象化の作成

関数に不健全なコードが含まれているからといって、その関数全体を不健全としてマークする必要はありません。実際、不健全なコードを安全な関数にラップすることは一般的な抽象化です。例として、標準ライブラリの`split_at_mut`関数を見てみましょう。この関数にはいくつかの不健全なコードが必要です。その実装方法を調べてみましょう。この安全なメソッドは可変スライスに定義されています。このメソッドは1つのスライスを取り、引数として与えられたインデックスでスライスを分割することで2つにします。リスト19-4は`split_at_mut`を使用する方法を示しています。

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

リスト19-4：安全な`split_at_mut`関数の使用

この関数を、安全なRustのみを使って実装することはできません。リスト19-5のような試みはコンパイルされません。簡単のために、`split_at_mut`を関数として実装し、`i32`値のスライスに対してのみ、ジェネリック型`T`ではなく実装します。

```rust
fn split_at_mut(
    values: &mut [i32],
    mid: usize,
) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

リスト19-5：安全なRustのみを使った`split_at_mut`の試みの実装

この関数はまず、スライスの合計長を取得します。次に、引数として与えられたインデックスがスライス内にあるかどうかをチェックすることで、そのインデックスが長さ以下であることをアサートします。このアサーションは、スライスを分割するために長さより大きいインデックスを渡すと、関数がそのインデックスを使用しようとする前にパニックすることを意味します。

次に、タプルで2つの可変スライスを返します。1つは元のスライスの先頭から`mid`インデックスまでで、もう1つは`mid`からスライスの末尾までです。

リスト19-5のコードをコンパイルしようとすると、エラーが発生します。

```bash
error[E0499]: cannot borrow `*values` as mutable more than once at a time
 --> src/main.rs:9:31
  |
2 |     values: &mut [i32],
  |             - let's call the lifetime of this reference `'1`
...
9 |     (&mut values[..mid], &mut values[mid..])
  |     --------------------------^^^^^^--------
  |     |     |                   |
  |     |     |                   second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*values` is borrowed for `'1`
```

Rustの借用チェッカーは、スライスの異なる部分を借用していることがわかりません。それは、同じスライスから2回借用していることのみを知っています。スライスの異なる部分を借用すること自体は基本的に問題ありません。なぜなら、2つのスライスは重複していないからです。しかし、Rustはこれを知るほど賢くありません。コードが問題ないことを知っていても、Rustが知らない場合、不健全なコードを使う時が来ます。

リスト19-6は、`split_at_mut`の実装を動作させるために、`unsafe`ブロック、生のポインタ、および不健全な関数へのいくつかの呼び出しをどのように使うかを示しています。

```rust
use std::slice;

fn split_at_mut(
    values: &mut [i32],
    mid: usize,
) -> (&mut [i32], &mut [i32]) {
  1 let len = values.len();
  2 let ptr = values.as_mut_ptr();

  3 assert!(mid <= len);

  4 unsafe {
        (
          5 slice::from_raw_parts_mut(ptr, mid),
          6 slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
```

リスト19-6：`split_at_mut`関数の実装における不健全なコードの使用

「スライス型」の項で思い出してください。スライスは、あるデータへのポインタと、スライスの長さで構成されています。私たちは`len`メソッドを使ってスライスの長さを取得し\[1\]、`as_mut_ptr`メソッドを使ってスライスの生のポインタにアクセスします\[2\]。この場合、`i32`値の可変スライスを持っているため、`as_mut_ptr`は`*mut i32`型の生のポインタを返します。これを変数`ptr`に格納しました。

`mid`インデックスがスライス内にあることをアサートし続けます\[3\]。次に、不健全なコードに入ります\[4\]。`slice::from_raw_parts_mut`関数は、生のポインタと長さを取り、スライスを作成します。これを使って、`ptr`から始まり、`mid`個の要素からなるスライスを作成します\[5\]。次に、`mid`を引数として`ptr`に対して`add`メソッドを呼び出して、`mid`から始まる生のポインタを取得します。そして、そのポインタと`mid`以降の残りの要素数を長さとして使ってスライスを作成します\[6\]。

`slice::from_raw_parts_mut`関数は不健全です。なぜなら、生のポインタを取り、このポインタが有効であることを信頼しなければならないからです。生のポインタの`add`メソッドも不健全です。なぜなら、オフセット位置も有効なポインタであることを信頼しなければならないからです。したがって、`slice::from_raw_parts_mut`と`add`への呼び出しの周りに`unsafe`ブロックを置かなければなりませんでした。そうしないと、それらを呼び出すことができませんでした。コードを見て、`mid`が`len`以下でなければならないことをアサートすることで、`unsafe`ブロック内で使用されるすべての生のポインタが、スライス内のデータへの有効なポインタであることがわかります。これは、`unsafe`の許容可能で適切な使用例です。

結果となる`split_at_mut`関数を`unsafe`としてマークする必要はなく、安全なRustからこの関数を呼び出すことができます。この関数は、不健全なコードに対する安全な抽象化を作成しました。この関数の実装は、不健全なコードを安全な方法で使用しています。なぜなら、この関数がアクセスできるデータからの有効なポインタのみを作成するからです。

対照的に、リスト19-7の`slice::from_raw_parts_mut`の使用は、スライスが使用されるときにおそらくクラッシュします。このコードは、任意のメモリ位置を取り、10,000個の要素からなるスライスを作成します。

```rust
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let values: &[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
```

リスト19-7：任意のメモリ位置からスライスを作成する

この任意の位置のメモリを所有していないため、このコードが作成するスライスが有効な`i32`値を含んでいることは保証されていません。`values`を有効なスライスとして使用しようとすると、未定義の動作が発生します。
