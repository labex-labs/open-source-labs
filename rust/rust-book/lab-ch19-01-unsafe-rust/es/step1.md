# Rust inseguro

Todo el código que hemos discutido hasta ahora ha tenido las garantías de seguridad de memoria de Rust aplicadas en tiempo de compilación. Sin embargo, Rust tiene un segundo lenguaje escondido dentro de él que no aplica estas garantías de seguridad de memoria: se llama _Rust inseguro_ y funciona exactamente como Rust regular, pero nos otorga poderes adicionales.

Rust inseguro existe porque, por naturaleza, el análisis estático es conservador. Cuando el compilador intenta determinar si el código cumple con las garantías, es mejor que rechace algunos programas válidos que que acepte algunos programas no válidos. Aunque el código _podría_ estar bien, si el compilador de Rust no tiene suficiente información para estar seguro, rechazará el código. En estos casos, puedes usar código inseguro para decirle al compilador: "Confía en mí, sé lo que estoy haciendo". Sin embargo, ten en cuenta que usas Rust inseguro bajo tu propio riesgo: si usas código inseguro incorrectamente, pueden surgir problemas debido a la inseguridad de la memoria, como la dereferenciación de un puntero nulo.

Otra razón por la que Rust tiene una alter ego insegura es que el hardware informático subyacente es inherentemente inseguro. Si Rust no te permitiera realizar operaciones inseguras, no podrías realizar ciertas tareas. Rust necesita permitirte realizar programación de sistemas de bajo nivel, como interactuar directamente con el sistema operativo o incluso escribir tu propio sistema operativo. Trabajar con programación de sistemas de bajo nivel es uno de los objetivos del lenguaje. Vamos a explorar lo que podemos hacer con Rust inseguro y cómo hacerlo.
