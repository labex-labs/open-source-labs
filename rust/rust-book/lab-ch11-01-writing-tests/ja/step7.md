# テストでの `Result<T, E>` の使用

これまでのテストは、失敗するとすべてパニックします。また、`Result<T, E>` を使ったテストも書くことができます！ここに、リスト11-1のテストを書き直して、`Result<T, E>` を使ってパニックする代わりに `Err` を返すようにしたものです。

ファイル名: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

`it_works` 関数の返り値の型が今は `Result<(), String>` になっています。関数の本体では、`assert_eq!` マクロを呼び出す代わりに、テストが合格したときに `Ok(())` を返し、テストが失敗したときに `String` を含む `Err` を返します。

テストを書いて `Result<T, E>` を返すようにすることで、テストの本体で疑問符演算子を使うことができます。これは、その中のどの操作が `Err` 変数を返した場合にテストが失敗するようなテストを書く便利な方法です。

`Result<T, E>` を使ったテストには、`#[should_panic]` 注釈を使うことはできません。操作が `Err` 変数を返すことをアサートするには、`Result<T, E>` 値に疑問符演算子を使わないでください。代わりに、`assert!(value.is_err())` を使ってください。

これで、いくつかのテストの書き方を知ったので、テストを実行したときに何が起こっているか見て、`cargo test` で使えるさまざまなオプションを探ってみましょう。
