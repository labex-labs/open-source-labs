# Использование Result\<T, E\> в тестах

Наши тесты до сих пор все вызывают панику, когда они не проходят. Мы также можем писать тесты, которые используют `Result<T, E>`! Вот тест из Листинга 11-1, переписанный для использования `Result<T, E>` и возврата `Err` вместо вызова паники:

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
```

Функция `it_works` теперь имеет тип возврата `Result<(), String>`. В теле функции вместо вызова макроса `assert_eq!` мы возвращаем `Ok(())`, когда тест проходит, и `Err` с `String` внутри, когда тест не проходит.

Писание тестов так, чтобы они возвращали `Result<T, E>`, позволяет использовать оператор вопроса в теле тестов, что может быть удобным способом написания тестов, которые должны не пройти, если любая операция внутри них возвращает вариант `Err`.

Вы не можете использовать аннотацию `#[should_panic]` для тестов, которые используют `Result<T, E>`. Чтобы проверить, что операция возвращает вариант `Err`, _не_ используйте оператор вопроса для значения `Result<T, E>`. Вместо этого используйте `assert!(value.is_err())`.

Теперь, когда вы знаете несколько способов писать тесты, давайте посмотрим, что происходит, когда мы запускаем наши тесты, и исследуем разные параметры, которые мы можем использовать с `cargo test`.
