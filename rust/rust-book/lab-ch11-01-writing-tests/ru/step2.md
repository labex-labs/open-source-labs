# Структура тестовой функции

В самом простом случае тест в Rust — это функция, помеченная атрибутом `test`. Атрибуты — это метаданные о частях кода Rust; примером является атрибут `derive`, который мы использовали с структурами в главе 5. Чтобы превратить функцию в тестовую функцию, добавьте `#[test]` на строке перед `fn`. Когда вы запускаете свои тесты с помощью команды `cargo test`, Rust создает бинарный файл тестового исполнителя, который запускает помеченные функции и сообщает, пройден ли каждый тестовый метод или нет.

Когда мы создаем новый библиотечный проект с помощью Cargo, для нас автоматически генерируется тестовый модуль с тестовой функцией внутри. Этот модуль дает вам шаблон для написания тестов, чтобы вы не приходили каждый раз искать точную структуру и синтаксис при создании нового проекта. Вы можете добавить столько дополнительных тестовых функций и столько тестовых модулей, сколько вам нужно!

Мы рассмотрим некоторые аспекты работы тестов, экспериментируя с шаблонным тестом, прежде чем на самом деле протестировать какой-либо код. Затем мы напишем несколько реальных тестов, которые вызовут какой-то код, который мы написали, и проверим, что его поведение корректно.

Создадим новый библиотечный проект под названием `adder`, который будет складывать два числа:

```bash
$ cargo new adder --lib
Created library $(adder) project
$ cd adder
```

Содержимое файла `src/lib.rs` в библиотеке `adder` должно выглядеть, как показано в Листинге 11-1.

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
  1 #[test]
    fn it_works() {
        let result = 2 + 2;
      2 assert_eq!(result, 4);
    }
}
```

Листинг 11-1: Автоматически сгенерированный тестовый модуль и функция при использовании `cargo new`

На данный момент暂且 игнорируем первые две строки и сосредоточимся на функции. Обратите внимание на аннотацию `#[test]` \[1\]: этот атрибут указывает, что это тестовая функция, поэтому тестовый исполнитель знает, что нужно рассматривать эту функцию как тест. В модуле `tests` могут быть и другие не тестовые функции, которые помогают настроить общие сценарии или выполнять общие операции, поэтому мы всегда должны указывать, какие функции являются тестами.

Тело примера функции использует макрос `assert_eq!` \[2\], чтобы проверить, что `result`, содержащий результат сложения 2 и 2, равен 4. Эта проверка служит примером формата для типичного теста. Запустим его, чтобы убедиться, что этот тест пройден.

Команда `cargo test` запускает все тесты в нашем проекте, как показано в Листинге 11-2.

```bash
[object Object]
```

Листинг 11-2: Вывод при запуске автоматически сгенерированного теста

Cargo скомпилировал и запустил тест. Мы видим строку `running 1 test` \[1\]. Следующая строка показывает имя сгенерированной тестовой функции, называемой `it_works`, и то, что результат выполнения этого теста — `ok` \[2\]. Общая сводка `test result: ok.` \[3\] означает, что все тесты пройдены, а часть, которая говорит `1 passed; 0 failed`, показывает количество пройденных или не пройденных тестов.

Возможно, пометить тест как игнорируемый, чтобы он не запускался в определенном случае; мы поговорим об этом в разделе "Игнорирование некоторых тестов, если не требуется специально". Поскольку мы этого не сделали здесь, сводка показывает `0 ignored`. Мы также можем передать аргумент команде `cargo test`, чтобы запустить только тесты, имена которых соответствуют строке; это называется _фильтрацией_, и мы поговорим об этом в разделе "Запуск части тестов по имени". Здесь мы не фильтровали тесты, которые запускаются, поэтому в конце сводки показывается `0 filtered out`.

Статистика `0 measured` относится к бенчмарк-тестам, которые измеряют производительность. Бенчмарк-тесты на момент написания доступны только в nightly-версии Rust. См. документацию по бенчмарк-тестам по адресу *https://doc.rust-lang.org/unstable-book/library-features/test.html*, чтобы узнать больше.

Следующая часть вывода теста, начиная с `Doc-tests adder` \[4\], относится к результатам любых тестов по документации. У нас еще нет тестов по документации, но Rust может компилировать любые примеры кода, которые появляются в нашей API-документации. Эта функция помогает поддерживать синхронизацию между вашими документами и кодом! Мы поговорим о том, как писать тесты по документации, в разделе "Комментарии по документации как тесты". На данный момент мы暂且 игнорируем вывод `Doc-tests`.

Давайте начнем настраивать тест под свои нужды. Во - первых, измените имя функции `it_works` на другое, например, `exploration`, вот так:

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
```

Затем снова запустите `cargo test`. Теперь вывод показывает `exploration` вместо `it_works`:

    running 1 test
    test tests::exploration... ok

    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

Теперь добавим еще один тест, но на этот раз создадим тест, который не пройдет! Тесты не проходят, когда что - то в тестовой функции вызывает панику. Каждый тест запускается в отдельном потоке, и когда главный поток видит, что тестовый поток завершился с ошибкой, тест помечается как не пройденный. В главе 9 мы говорили, что самый простой способ вызвать панику — это вызвать макрос `panic!`. Введите новый тест в виде функции с именем `another`, чтобы файл `src/lib.rs` выглядел, как показано в Листинге 11-3.

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}
```

Листинг 11-3: Добавление второго теста, который не пройдет, потому что мы вызываем макрос `panic!`

Запустите тесты снова с помощью `cargo test`. Вывод должен выглядеть, как показано в Листинге 11-4, где показано, что наш тест `exploration` пройден, а `another` не пройден.

    running 2 tests
    test tests::exploration... ok
    1 test tests::another... FAILED

    2 failures:

    ---- tests::another stdout ----
    thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
    note: run with `RUST_BACKTRACE=1` environment variable to display
    a backtrace

    3 failures:
        tests::another

    4 test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

    error: test failed, to rerun pass '--lib'

Листинг 11-4: Результаты теста, когда один тест пройден, а другой не пройден

Вместо `ok` строка `test tests::another` показывает `FAILED` \[1\]. Между отдельными результатами и сводкой появляются два новых раздела: первый \[2\] показывает подробную причину неудачи каждого теста. В этом случае мы получаем подробности, что `another` не пройден, потому что он `panicked at 'Make this test fail'` на строке 10 в файле `src/lib.rs`. Следующий раздел \[3\] перечисляет только имена всех не пройденных тестов, что полезно, когда есть много тестов и много подробного вывода о неудачных тестах. Мы можем использовать имя не пройденного теста, чтобы запустить только этот тест, чтобы更容易 отлаживать его; мы поговорим больше о способах запуска тестов в разделе "Управление запуском тестов".

Строка сводки отображается в конце \[4\]: в целом, наш результат теста — `FAILED`. У нас был один пройденный тест и один не пройденный тест.

Теперь, когда вы видели, как выглядят результаты тестов в разных сценариях, давайте рассмотрим некоторые макросы, кроме `panic!`, которые полезны в тестах.
