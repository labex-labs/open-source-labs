# Тестирование равенства с помощью макросов `assert_eq!` и `assert_ne!`

Одним из распространенных способов проверки функциональности является тестирование равенства между результатом проверяемого кода и значением, которое вы ожидаете, что вернет код. Вы могли бы сделать это, используя макрос `assert!` и передавая ему выражение с использованием оператора `==`. Однако это настолько распространенный тест, что стандартная библиотека предоставляет пару макросов — `assert_eq!` и `assert_ne!` — для более удобного выполнения этого теста. Эти макросы сравнивают два аргумента на равенство или неравенство соответственно. Они также выведут два значения, если утверждение не пройдет, что делает легче понять, _почему_ тест не прошел; наоборот, макрос `assert!` только показывает, что он получил значение `false` для выражения `==`, не выводя значения, которые привели к значению `false`.

В Листинге 11-7 мы пишем функцию под названием `add_two`, которая добавляет `2` к своему параметру, а затем тестируем эту функцию с использованием макроса `assert_eq!`.

Имя файла: `src/lib.rs`

```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
```

Листинг 11-7: Тестирование функции `add_two` с использованием макроса `assert_eq!`

Проверим, что тест пройдет!

    running 1 test
    test tests::it_adds_two... ok

    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

Мы передаем `4` в качестве аргумента в `assert_eq!`, которое равно результату вызова `add_two(2)`. Строка для этого теста выглядит так: `test tests::it_adds_two... ok`, и текст `ok` показывает, что наш тест прошел!

Давайте внесем ошибку в наш код, чтобы увидеть, как выглядит `assert_eq!`, когда тест не проходит. Изменим реализацию функции `add_two` так, чтобы она вместо этого добавляла `3`:

```rust
pub fn add_two(a: i32) -> i32 {
    a + 3
}
```

Запустим тесты снова:

    running 1 test
    test tests::it_adds_two... FAILED

    failures:

    ---- tests::it_adds_two stdout ----
    1 thread 'main' panicked at 'assertion failed: `(left == right)`
    2   left: `4`,
    3  right: `5`', src/lib.rs:11:9
    note: run with `RUST_BACKTRACE=1` environment variable to display
    a backtrace

    failures:
        tests::it_adds_two

    test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0
    filtered out; finished in 0.00s

Наши тесты обнаружили ошибку! Тест `it_adds_two` не прошел, и сообщение говорит нам, что не пройденное утверждение было `assertion failed: `(left == right)\``\[1\] и какие значения были`left`\[2\] и`right`\[3\]. Это сообщение помогает нам начать отладку: аргумент`left`был`4`, а аргумент `right`, где мы вызывали `add_two(2)`, был `5`. Вы можете представить, насколько это будет полезно, когда у нас много тестов.

Обратите внимание, что в некоторых языках и фреймворках тестирования параметры функций для проверки равенства называются `expected` и `actual`, и порядок, в котором мы указываем аргументы, имеет значение. Однако в Rust они называются `left` и `right`, и порядок, в котором мы указываем ожидаемое значение и значение, которое генерирует код, не имеет значения. Мы могли бы записать утверждение в этом тесте как `assert_eq!(add_two(2), 4)`, что бы привело к тому же сообщению об ошибке, которое показывает `assertion failed: `(left == right)\``.

Макрос `assert_ne!` пройдет, если два значения, которые мы передаем ему, не равны, и не пройдет, если они равны. Этот макрос наиболее полезен в случаях, когда мы не знаем, какое значение _будет_, но мы знаем, что значение _не должно_ быть. Например, если мы тестируем функцию, которая гарантированно изменяет свой ввод каким-то образом, но способ изменения ввода зависит от дня недели, когда мы запускаем наши тесты, лучше всего утверждение может быть, что выход функции не равен входу.

Под капотом макросы `assert_eq!` и `assert_ne!` используют операторы `==` и `!=` соответственно. Когда утверждения не проходят, эти макросы выводят свои аргументы с использованием отладочной форматирования, что означает, что сравниваемые значения должны реализовывать трейты `PartialEq` и `Debug`. Все примитивные типы и большинство типов стандартной библиотеки реализуют эти трейты. Для структур и перечислений, которые вы определяете сами, вам нужно реализовать `PartialEq`, чтобы проверить равенство этих типов. Также вам нужно реализовать `Debug`, чтобы вывести значения, когда утверждение не проходит. Поскольку оба трейта являются трейтами, которые можно получить автоматически, как упоминалось в Листинге 5-12, это обычно так же просто, как добавить аннотацию `#[derive(PartialEq, Debug)]` к определению вашей структуры или перечисления. См. Приложение C для более подробной информации о этих и других трейтах, которые можно получить автоматически.
