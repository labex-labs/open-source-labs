# Evitando Ciclos de Referencia Usando Weak`<T>`{=html}

Hasta ahora, hemos demostrado que llamar a `Rc::clone` aumenta el `strong_count` de una instancia `Rc<T>`, y una instancia `Rc<T>` solo se limpia si su `strong_count` es 0. También puedes crear una _referencia débil_ al valor dentro de una instancia `Rc<T>` llamando a `Rc::downgrade` y pasando una referencia a la `Rc<T>`. Las referencias fuertes son cómo puedes compartir la propiedad de una instancia `Rc<T>`. Las referencias débiles no expresan una relación de propiedad, y su recuento no afecta a cuando se limpia una instancia `Rc<T>`. No causarán un ciclo de referencia porque cualquier ciclo que involucre algunas referencias débiles se romperá una vez que el recuento de referencias fuertes de los valores involucrados sea 0.

Cuando llamas a `Rc::downgrade`, obtienes un puntero inteligente del tipo `Weak<T>`. En lugar de aumentar el `strong_count` en la instancia `Rc<T>` en 1, llamar a `Rc::downgrade` aumenta el `weak_count` en 1. El tipo `Rc<T>` utiliza `weak_count` para llevar un registro de cuántas referencias `Weak<T>` existen, similar a `strong_count`. La diferencia es que el `weak_count` no necesita ser 0 para que la instancia `Rc<T>` se limpie.

Debido a que el valor al que se refiere `Weak<T>` podría haber sido eliminado, para hacer algo con el valor al que apunta un `Weak<T>` debes asegurarte de que el valor todavía existe. Haz esto llamando al método `upgrade` en una instancia `Weak<T>`, que devolverá un `Option<Rc<T>>`. Obtendrás un resultado de `Some` si el valor `Rc<T>` todavía no ha sido eliminado y un resultado de `None` si el valor `Rc<T>` ha sido eliminado. Debido a que `upgrade` devuelve un `Option<Rc<T>>`, Rust asegurará que se manejen los casos `Some` y `None`, y no habrá un puntero inválido.

Como ejemplo, en lugar de usar una lista cuyos elementos solo conocen sobre el siguiente elemento, crearemos un árbol cuyos elementos conocen sobre sus elementos hijos _y_ sus elementos padres.
