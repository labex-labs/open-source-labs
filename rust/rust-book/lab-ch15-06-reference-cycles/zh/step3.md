# 使用 `Weak<T>` 防止引用循环

到目前为止，我们已经证明调用 `Rc::clone` 会增加 `Rc<T>` 实例的 `strong_count`，并且只有当 `Rc<T>` 实例的 `strong_count` 为 0 时才会被清理。你还可以通过调用 `Rc::downgrade` 并传递对 `Rc<T>` 的引用来创建对 `Rc<T>` 实例中值的 _弱引用_。强引用是你共享 `Rc<T>` 实例所有权的方式。弱引用不表示所有权关系，并且它们的计数不会影响 `Rc<T>` 实例何时被清理。它们不会导致引用循环，因为一旦涉及的值的强引用计数为 0，任何涉及一些弱引用的循环都会被打破。

当你调用 `Rc::downgrade` 时，你会得到一个 `Weak<T>` 类型的智能指针。调用 `Rc::downgrade` 不会使 `Rc<T>` 实例的 `strong_count` 增加 1，而是使 `weak_count` 增加 1。`Rc<T>` 类型使用 `weak_count` 来跟踪存在多少个 `Weak<T>` 引用，类似于 `strong_count`。不同之处在于，对于 `Rc<T>` 实例被清理，`weak_count` 不需要为 0。

因为 `Weak<T>` 引用的值可能已经被释放，所以要对 `Weak<T>` 指向的值进行任何操作，你必须确保该值仍然存在。通过在 `Weak<T>` 实例上调用 `upgrade` 方法来做到这一点，该方法将返回一个 `Option<Rc<T>>`。如果 `Rc<T>` 值尚未被释放，你将得到 `Some` 结果；如果 `Rc<T>` 值已经被释放，你将得到 `None` 结果。因为 `upgrade` 返回一个 `Option<Rc<T>>`，Rust 将确保处理 `Some` 情况和 `None` 情况，并且不会有无效指针。

例如，我们将创建一个树，而不是使用其元素只知道下一个元素的列表，这个树的元素既知道它们的子元素，也知道它们的父元素。
