# Weak`<T>`を使った参照サイクルの防止

これまでのところ、`Rc::clone`を呼び出すと`Rc<T>`インスタンスの`strong_count`が増加すること、そして`Rc<T>`インスタンスは`strong_count`が 0 になるときだけクリーンアップされることを示してきました。また、`Rc<T>`インスタンス内の値に対する _弱参照_ を作成することもできます。それは、`Rc::downgrade`を呼び出して`Rc<T>`への参照を渡すことで行います。強参照は、`Rc<T>`インスタンスの所有権を共有する方法です。弱参照は所有権関係を表しておらず、そのカウントは`Rc<T>`インスタンスがクリーンアップされるタイミングに影響を与えません。弱参照が含まれるサイクルは、関係する値の強参照カウントが 0 になるときに破棄されるため、参照サイクルを引き起こすことはありません。

`Rc::downgrade`を呼び出すと、`Weak<T>`型のスマートポインタが得られます。`Rc::clone`を呼び出すと`Rc<T>`インスタンスの`strong_count`が 1 増えるのとは異なり、`Rc::downgrade`を呼び出すと`weak_count`が 1 増えます。`Rc<T>`型は、`strong_count`と同様に、存在する`Weak<T>`参照の数を追跡するために`weak_count`を使用します。違いは、`Rc<T>`インスタンスがクリーンアップされるためには`weak_count`が 0 になる必要はないということです。

`Weak<T>`が参照する値は既に破棄されている可能性があるため、`Weak<T>`が指し示す値を何かするには、まずその値がまだ存在することを確認する必要があります。これは、`Weak<T>`インスタンスの`upgrade`メソッドを呼び出すことで行います。これにより`Option<Rc<T>>`が返されます。`Rc<T>`値がまだ破棄されていなければ`Some`の結果が得られ、`Rc<T>`値が破棄されていれば`None`の結果が得られます。`upgrade`が`Option<Rc<T>>`を返すため、Rust は`Some`の場合と`None`の場合を処理し、無効なポインタになることはありません。

例として、項目が次の項目だけを知るリストではなく、項目が子項目 _と_ 親項目を知る木を作成します。
