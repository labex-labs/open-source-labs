# 参照サイクルの作成

参照サイクルがどのように発生するか、およびそれを防止する方法を見てみましょう。まずは、リスト15-25に示す`List`列挙体の定義と`tail`メソッドから始めます。

ファイル名: `src/main.rs`

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
  1 Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
  2 fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}
```

リスト15-25: `RefCell<T>`を保持するコンスリストの定義。これにより、`Cons`バリアントが参照する値を変更できるようになります。

ここでは、リスト15-5の`List`定義の別のバリエーションを使用しています。`Cons`バリアントの2番目の要素は、今や`RefCell<Rc<List>>`になっています\[1\]。これは、リスト15-24のように`i32`値を変更できるようにするのではなく、`Cons`バリアントが指し示す`List`値を変更したいという意味です。また、`tail`メソッドも追加しています\[2\]。これにより、`Cons`バリアントがある場合に2番目の項目にアクセスするのが便利になります。

リスト15-26では、リスト15-25の定義を使用する`main`関数を追加しています。このコードは、`a`にリストを作成し、`b`に`a`のリストを指すリストを作成します。その後、`a`のリストを`b`に指すように変更して、参照サイクルを作成します。このプロセスのさまざまなポイントでの参照カウントを表示するために`println!`文があります。

ファイル名: `src/main.rs`

```rust
fn main() {
  1 let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

  2 let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!(
        "a rc count after b creation = {}",
        Rc::strong_count(&a)
    );
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

  3 if let Some(link) = a.tail() {
      4 *link.borrow_mut() = Rc::clone(&b);
    }

    println!(
        "b rc count after changing a = {}",
        Rc::strong_count(&b)
    );
    println!(
        "a rc count after changing a = {}",
        Rc::strong_count(&a)
    );

    // 次の行をコメントアウト解除して、サイクルがあることを確認します。
    // スタックがオーバーフローします。
    // println!("a next item = {:?}", a.tail());
}
```

リスト15-26: 互いに指す2つの`List`値の参照サイクルの作成

まず、変数`a`に`5, Nil`の初期リストを持つ`Rc<List>`インスタンスを作成します\[1\]。次に、変数`b`に`10`の値を持ち、`a`のリストを指す別の`List`値を持つ`Rc<List>`インスタンスを作成します\[2\]。

`a`を変更して、`Nil`ではなく`b`を指すようにして、サイクルを作成します。これは、`tail`メソッドを使用して`a`の`RefCell<Rc<List>>`への参照を取得し、それを変数`link`に入れることで行います\[3\]。その後、`RefCell<Rc<List>>`の`borrow_mut`メソッドを使用して、内部の値を`Nil`値を持つ`Rc<List>`から`b`の`Rc<List>`に変更します\[4\]。

このコードを実行して、最後の`println!`を一時的にコメントアウトしておくと、次の出力が得られます。

    a initial rc count = 1
    a next item = Some(RefCell { value: Nil })
    a rc count after b creation = 2
    b initial rc count = 1
    b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
    b rc count after changing a = 2
    a rc count after changing a = 2

`a`のリストを`b`に指すように変更した後、`a`と`b`の`Rc<List>`インスタンスの参照カウントはともに2になります。`main`の終わりで、Rustは変数`b`を破棄します。これにより、`b`の`Rc<List>`インスタンスの参照カウントは2から1に減少します。この時点で、`Rc<List>`がヒープ上に持っているメモリは破棄されません。なぜなら、その参照カウントは1であり、0ではないからです。次に、Rustは`a`を破棄します。これにより、`a`の`Rc<List>`インスタンスの参照カウントも2から1に減少します。このインスタンスのメモリも破棄できません。なぜなら、他の`Rc<List>`インスタンスがまだそれを参照しているからです。リストに割り当てられたメモリは、永遠に回収されないままになります。この参照サイクルを視覚化するために、図15-4に図を作成しました。

図15-4: 互いに指すリスト`a`と`b`の参照サイクル

最後の`println!`をコメントアウト解除してプログラムを実行すると、Rustは`a`が`b`を指し、`b`が`a`を指すようなサイクルを表示しようとします。そして、スタックがオーバーフローするまで続けます。

この例で参照サイクルを作成した場合の結果は、現実世界のプログラムと比較するとあまり深刻ではありません。参照サイクルを作成した直後に、プログラムは終了します。ただし、もっと複雑なプログラムがサイクル内で大量のメモリを割り当て、長時間保持している場合、プログラムは必要以上のメモリを使用し、システムを圧倒して利用可能なメモリを枯渇させる可能性があります。

参照サイクルを作成することは簡単ではありませんが、不可能でもありません。`RefCell<T>`値が`Rc<T>`値を含んでいたり、内部可変性と参照カウントを持つ型の類似したネストされた組み合わせがある場合、サイクルを作成しないようにする必要があります。Rustがそれをキャッチすることを依存することはできません。参照サイクルを作成することは、プログラムの論理バグになります。自動テスト、コードレビュー、その他のソフトウェア開発の慣行を使って、それを最小限に抑える必要があります。

参照サイクルを回避する別の解決策は、データ構造を再編成することです。そうすることで、一部の参照は所有権を表し、一部の参照は所有権を表さなくなります。結果として、所有権関係と非所有権関係から構成されるサイクルができるようになり、値が破棄されるかどうかを影響するのは所有権関係だけになります。リスト15-25では、常に`Cons`バリアントがそのリストを所有するようにしたいので、データ構造を再編成することはできません。親ノードと子ノードで構成されるグラフを使った例を見て、非所有権関係が参照サイクルを防止する適切な方法である場合を見てみましょう。
