# Prevenindo Ciclos de Referência Usando Weak`<T>`{=html}

Até agora, demonstramos que chamar `Rc::clone` aumenta o `strong_count` de uma instância `Rc<T>`, e uma instância `Rc<T>` só é limpa se seu `strong_count` for 0. Você também pode criar uma _referência fraca_ (weak reference) ao valor dentro de uma instância `Rc<T>` chamando `Rc::downgrade` e passando uma referência ao `Rc<T>`. Referências fortes (strong references) são como você pode compartilhar a propriedade de uma instância `Rc<T>`. Referências fracas não expressam uma relação de propriedade, e sua contagem não afeta quando uma instância `Rc<T>` é limpa. Elas não causarão um ciclo de referência porque qualquer ciclo envolvendo algumas referências fracas será interrompido assim que a contagem de referência forte (strong reference count) dos valores envolvidos for 0.

Quando você chama `Rc::downgrade`, você obtém um ponteiro inteligente do tipo `Weak<T>`. Em vez de aumentar o `strong_count` na instância `Rc<T>` em 1, chamar `Rc::downgrade` aumenta o `weak_count` em 1. O tipo `Rc<T>` usa `weak_count` para controlar quantos referências `Weak<T>` existem, semelhante ao `strong_count`. A diferença é que o `weak_count` não precisa ser 0 para que a instância `Rc<T>` seja limpa.

Como o valor ao qual `Weak<T>` se refere pode ter sido descartado, para fazer qualquer coisa com o valor que um `Weak<T>` está apontando, você deve garantir que o valor ainda exista. Faça isso chamando o método `upgrade` em uma instância `Weak<T>`, que retornará um `Option<Rc<T>>`. Você obterá um resultado de `Some` se o valor `Rc<T>` ainda não tiver sido descartado e um resultado de `None` se o valor `Rc<T>` tiver sido descartado. Como `upgrade` retorna um `Option<Rc<T>>`, o Rust garantirá que os casos `Some` e `None` sejam tratados, e não haverá um ponteiro inválido.

Como exemplo, em vez de usar uma lista cujos itens só conhecem o próximo item, criaremos uma árvore cujos itens conhecem seus itens filhos _e_ seus itens pai.
