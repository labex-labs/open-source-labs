# Визуализация изменений strong_count и weak_count

Рассмотрим, как значения `strong_count` и `weak_count` экземпляров `Rc<Node>` изменяются, создав новую внутреннюю область видимости и передав создание `branch` в эту область. Таким образом, мы можем увидеть, что происходит при создании `branch` и затем при его удалении при выходе из области видимости. Изменения показаны в Listing 15-29.

Filename: `src/main.rs`

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

  1 println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

  2 {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

      3 println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

      4 println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
  5 }

  6 println!(
        "leaf parent = {:?}",
        leaf.parent.borrow().upgrade()
    );
  7 println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}
```

Listing 15-29: Создание `branch` в внутренней области видимости и проверка счетчиков сильных и слабых ссылок

После создания `leaf` его `Rc<Node>` имеет счетчик сильных ссылок равный 1 и счетчик слабых ссылок равный 0 \[1\]. В внутренней области видимости \[2\] мы создаем `branch` и связываем его с `leaf`, при этом когда мы выводим счетчики \[3\], `Rc<Node>` в `branch` будет иметь счетчик сильных ссылок равный 1 и счетчик слабых ссылок равный 1 (для `leaf.parent`, которое ссылается на `branch` с помощью `Weak<Node>`). Когда мы выводим счетчики в `leaf` \[4\], мы увидим, что он будет иметь счетчик сильных ссылок равный 2, потому что `branch` теперь имеет копию `Rc<Node>` из `leaf`, хранящуюся в `branch.children`, но все еще будет иметь счетчик слабых ссылок равный 0.

Когда внутренняя область видимости заканчивается \[5\], `branch` выходит из области видимости, и счетчик сильных ссылок `Rc<Node>` уменьшается до 0, поэтому его `Node` удаляется. Счетчик слабых ссылок равный 1 из `leaf.parent` не влияет на то, удаляется ли `Node` или нет, поэтому мы не имеем утечек памяти!

Если мы попытаемся обратиться к родителю `leaf` после окончания области видимости, мы снова получим `None` \[6\]. В конце программы \[7\], `Rc<Node>` в `leaf` имеет счетчик сильных ссылок равный 1 и счетчик слабых ссылок равный 0, потому что переменная `leaf` снова является единственной ссылкой на `Rc<Node>`.

Вся логика управления счетчиками и удалением значений встроена в `Rc<T>` и `Weak<T>` и их реализации трейта `Drop`. Задав, что отношение от дочернего к родительскому узлу должно быть слабой ссылкой `Weak<T>` в определении `Node`, вы можете иметь родительские узлы, которые ссылаются на дочерние узлы и наоборот, не создавая при этом цикл ссылок и утечек памяти.
