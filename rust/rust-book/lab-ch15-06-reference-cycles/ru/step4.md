# Создание структуры данных дерева: Узел с дочерними узлами

Для начала построим дерево с узлами, которые знают о своих дочерних узлах. Создадим структуру под названием `Node`, которая будет содержать свое значение `i32` и ссылки на значения своих дочерних узлов `Node`:

Filename: `src/main.rs`

```rust
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
```

Мы хотим, чтобы `Node` владел своими дочерними узлами, и мы хотим поделиться этой владением с переменными, чтобы можно было напрямую обращаться к каждому `Node` в дереве. Для этого мы определяем элементы `Vec<T>` как значения типа `Rc<Node>`. Также мы хотим изменять, какие узлы являются дочерними для другого узла, поэтому в `children` у нас есть `RefCell<T>` вокруг `Vec<Rc<Node>>`.

Далее мы будем использовать наше определение структуры и создать один экземпляр `Node` под названием `leaf` со значением `3` и без дочерних узлов, и другой экземпляр под названием `branch` со значением `5` и `leaf` в качестве одного из своих дочерних узлов, как показано в Listing 15-27.

Filename: `src/main.rs`

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```

Listing 15-27: Создание узла `leaf` без дочерних узлов и узла `branch` с `leaf` в качестве одного из своих дочерних узлов

Мы копируем `Rc<Node>` в `leaf` и сохраняем его в `branch`, что означает, что `Node` в `leaf` теперь имеет двух владельцев: `leaf` и `branch`. Мы можем добраться от `branch` до `leaf` через `branch.children`, но нет способа добраться от `leaf` до `branch`. Причина в том, что `leaf` не имеет ссылки на `branch` и не знает, что они связаны. Мы хотим, чтобы `leaf` знал, что `branch` является его родителем. Мы это сделаем далее.
