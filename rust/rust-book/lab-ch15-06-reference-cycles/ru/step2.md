# Создание цикла ссылок

Рассмотрим, как может возникнуть цикл ссылок и как предотвратить его, начиная с определения перечисления `List` и метода `tail` в Listing 15-25.

Filename: `src/main.rs`

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
  1 Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
  2 fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}
```

Listing 15-25: Определение связного списка, содержащего `RefCell<T>`, чтобы мы могли изменить то, на что ссылается вариант `Cons`

Мы используем другую вариацию определения `List` из Listing 15-5. Второй элемент в варианте `Cons` теперь `RefCell<Rc<List>>` \[1\], что означает, что вместо того, чтобы иметь возможность изменять значение `i32`, как мы делали в Listing 15-24, мы хотим изменить значение `List`, на которое указывает вариант `Cons`. Мы также добавляем метод `tail` \[2\], чтобы было удобно получить доступ ко второму элементу, если у нас есть вариант `Cons`.

В Listing 15-26 мы добавляем функцию `main`, которая использует определения из Listing 15-25. Этот код создает список в `a` и список в `b`, который ссылается на список в `a`. Затем он изменяет список в `a`, чтобы он ссылался на `b`, создавая цикл ссылок. Вместе с этим есть инструкции `println!`, которые показывают, какие счетчики ссылок находятся в различных точках этого процесса.

Filename: `src/main.rs`

```rust
fn main() {
  1 let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

  2 let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!(
        "a rc count after b creation = {}",
        Rc::strong_count(&a)
    );
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

  3 if let Some(link) = a.tail() {
      4 *link.borrow_mut() = Rc::clone(&b);
    }

    println!(
        "b rc count after changing a = {}",
        Rc::strong_count(&b)
    );
    println!(
        "a rc count after changing a = {}",
        Rc::strong_count(&a)
    );

    // Раскомментируйте следующую строку, чтобы увидеть, что у нас есть цикл;
    // это переполнит стек
    // println!("a next item = {:?}", a.tail());
}
```

Listing 15-26: Создание цикла ссылок между двумя значениями `List`, которые ссылаются друг на друга

Мы создаем экземпляр `Rc<List>`, содержащий значение `List` в переменной `a` с начальным списком `5, Nil` \[1\]. Затем мы создаем экземпляр `Rc<List>`, содержащий другое значение `List` в переменной `b`, которое содержит значение `10` и ссылается на список в `a` \[2\].

Мы изменяем `a`, чтобы оно ссылалось на `b` вместо `Nil`, создавая цикл. Мы это делаем, используя метод `tail`, чтобы получить ссылку на `RefCell<Rc<List>>` в `a`, которую мы помещаем в переменную `link` \[3\]. Затем мы используем метод `borrow_mut` на `RefCell<Rc<List>>`, чтобы изменить значение внутри с `Rc<List>`, содержащего значение `Nil`, на `Rc<List>` в `b` \[4\].

Когда мы запускаем этот код, оставляя последнюю инструкцию `println!` закомментированной на данный момент, мы получим такой вывод:

    a initial rc count = 1
    a next item = Some(RefCell { value: Nil })
    a rc count after b creation = 2
    b initial rc count = 1
    b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
    b rc count after changing a = 2
    a rc count after changing a = 2

Счетчик ссылок экземпляров `Rc<List>` в `a` и `b` становится равным 2 после того, как мы изменили список в `a`, чтобы он ссылался на `b`. В конце функции `main` Rust удаляет переменную `b`, что уменьшает счетчик ссылок экземпляра `Rc<List>` в `b` с 2 до 1. Память, которая хранится в `Rc<List>` на куче, не будет удалена в этот момент, потому что ее счетчик ссылок равен 1, а не 0. Затем Rust удаляет `a`, что также уменьшает счетчик ссылок экземпляра `Rc<List>` в `a` с 2 до 1. Память этого экземпляра также не может быть удалена, потому что другой экземпляр `Rc<List>` по-прежнему ссылается на нее. Память, выделенная для списка, останется неосвобождаемой навсегда. Чтобы визуализировать этот цикл ссылок, мы создали диаграмму в Figure 15-4.

Figure 15-4: Цикл ссылок между списками `a` и `b`, которые ссылаются друг на друга

Если вы раскомментируете последнюю инструкцию `println!` и запустите программу, Rust попытается вывести этот цикл, в котором `a` ссылается на `b`, которая ссылается на `a` и так далее, пока не переполнит стек.

Сравнивая с реальной программой, последствия создания цикла ссылок в этом примере не очень страшны: сразу после создания цикла ссылок программа завершается. Однако, если более сложная программа выделяла много памяти в цикле и держала ее долгое время, программа использовала бы больше памяти, чем ей нужно, и могла бы перегрузить систему, заставив ее закончить доступную память.

Создание циклов ссылок не легко, но и не невозможно. Если у вас есть значения `RefCell<T>`, содержащие значения `Rc<T>`, или аналогичные вложенные комбинации типов с внутренней изменяемостью и подсчетом ссылок, вы должны убедиться, что вы не создаете циклы; вы не можете полагаться на Rust, чтобы их обнаружил. Создание цикла ссылок будет ошибкой в логике вашей программы, которую вы должны минимизировать с помощью автоматических тестов, код-ревью и других методов разработки программного обеспечения.

Другой способ избежать циклов ссылок - это переорганизация ваших структур данных так, чтобы некоторые ссылки выражают владение, а некоторые - нет. Таким образом, вы можете иметь циклы, состоящие из некоторых отношений владения и некоторых отношений не владения, и только отношения владения влияют на то, может ли значение быть удалено. В Listing 15-25 мы всегда хотим, чтобы варианты `Cons` владели своим списком, поэтому невозможно переорганизовать структуру данных. Рассмотрим пример, используя графы, состоящие из родительских и дочерних узлов, чтобы понять, когда отношения не владения являются подходящим способом предотвращения циклов ссылок.
