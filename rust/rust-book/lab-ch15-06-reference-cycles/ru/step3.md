# Предотвращение циклов ссылок с использованием Weak`<T>`

До сих пор мы показали, что вызов `Rc::clone` увеличивает `strong_count` экземпляра `Rc<T>`, и экземпляр `Rc<T>` очищается только в том случае, если его `strong_count` равен 0. Также можно создать _слабую ссылку_ на значение внутри экземпляра `Rc<T>`, вызвав `Rc::downgrade` и передав ссылку на `Rc<T>`. Сильные ссылки - это то, как вы можете делиться владением экземпляром `Rc<T>`. Слабые ссылки не выражают отношение владения, и их счетчик не влияет на то, когда экземпляр `Rc<T>` будет очищен. Они не создадут цикл ссылок, потому что любой цикл, включающий некоторые слабые ссылки, будет разорван, как только счетчик сильных ссылок на связанные значения станет равным 0.

Когда вы вызываете `Rc::downgrade`, вы получаете умный указатель типа `Weak<T>`. Вместо того чтобы увеличить `strong_count` в экземпляре `Rc<T>` на 1, вызов `Rc::downgrade` увеличивает `weak_count` на 1. Тип `Rc<T>` использует `weak_count`, чтобы отслеживать, сколько существует ссылок `Weak<T>`, аналогично `strong_count`. Разница в том, что `weak_count` не должен быть равен 0 для того, чтобы экземпляр `Rc<T>` был очищен.

Поскольку значение, на которое ссылается `Weak<T>`, может быть уже удалено, чтобы сделать что-либо с значением, на которое указывает `Weak<T>`, вы должны убедиться, что значение по-прежнему существует. Это можно сделать, вызвав метод `upgrade` на экземпляре `Weak<T>`, который вернет `Option<Rc<T>>`. Вы получите результат `Some`, если значение `Rc<T>` еще не было удалено, и результат `None`, если значение `Rc<T>` было удалено. Поскольку `upgrade` возвращает `Option<Rc<T>>`, Rust обеспечит обработку случаев `Some` и `None`, и не будет недействительного указателя.

В качестве примера, вместо использования списка, элементы которого знают только о следующем элементе, мы создадим дерево, элементы которого знают о своих дочерних элементах _и_ своих родительских элементах.
