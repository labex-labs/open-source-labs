# Добавление ссылки от дочернего узла к его родителю

Чтобы дочерний узел был aware о своем родителе, нам нужно добавить поле `parent` в определение нашей структуры `Node`. Проблема заключается в том, какой тип должен быть у `parent`. Мы знаем, что он не может содержать `Rc<T>`, потому что это создаст цикл ссылок, когда `leaf.parent` будет ссылаться на `branch`, а `branch.children` будет ссылаться на `leaf`, что приведет к тому, что их значения `strong_count` никогда не станут равными 0.

С другой стороны, родительский узел должен владеть своими дочерними узлами: если родительский узел удаляется, его дочерние узлы также должны быть удалены. Однако дочерний узел не должен владеть своим родителем: если мы удалим дочерний узел, родитель по-прежнему должен существовать. Именно для таких случаев нужны слабые ссылки!

Поэтому вместо `Rc<T>` мы сделаем тип `parent` использовать `Weak<T>`, конкретно `RefCell<Weak<Node>>`. Теперь наше определение структуры `Node` выглядит так:

Filename: `src/main.rs`

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
```

Узел сможет ссылаться на свой родительский узел, но не будет владеть им. В Listing 15-28 мы обновляем `main`, чтобы использовать это новое определение, так что узел `leaf` будет иметь способ ссылаться на своего родителя, `branch`.

Filename: `src/main.rs`

```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
      1 parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

  2 println!(
        "leaf parent = {:?}",
        leaf.parent.borrow().upgrade()
    );

    let branch = Rc::new(Node {
        value: 5,
      3 parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

  4 *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

  5 println!(
        "leaf parent = {:?}",
        leaf.parent.borrow().upgrade()
    );
}
```

Listing 15-28: Узел `leaf` с слабой ссылкой на своего родительский узел, `branch`

Создание узла `leaf` похоже на Listing 15-27, за исключением поля `parent`: `leaf` изначально не имеет родителя, поэтому мы создаем новую, пустую ссылку-экземпляр `Weak<Node>` \[1\].

В этот момент, когда мы пытаемся получить ссылку на родителя `leaf` с использованием метода `upgrade`, мы получаем значение `None`. Мы видим это в выводе из первого `println!`-выражения \[2\]:

```rust
leaf parent = None
```

Когда мы создаем узел `branch`, он также будет иметь новую ссылку `Weak<Node>` в поле `parent` \[3\], потому что `branch` не имеет родительского узла. Мы по-прежнему имеем `leaf` в качестве одного из дочерних узлов `branch`. Как только у нас есть экземпляр `Node` в `branch`, мы можем изменить `leaf`, чтобы дать ему слабую ссылку `Weak<Node>` на своего родителя \[4\]. Мы используем метод `borrow_mut` на `RefCell<Weak<Node>>` в поле `parent` `leaf`, а затем используем функцию `Rc::downgrade`, чтобы создать слабую ссылку `Weak<Node>` на `branch` из `Rc<Node>` в `branch`.

Когда мы снова выводим родителя `leaf` \[5\], на этот раз мы получим вариант `Some`, содержащий `branch`: теперь `leaf` может обращаться к своему родителю! Когда мы выводим `leaf`, мы также избавляемся от цикла, который в конечном итоге приводил к переполнению стека, как это было в Listing 15-26; слабые ссылки `Weak<Node>` выводятся как `(Weak)`:

    leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
    children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
    children: RefCell { value: [] } }] } })

Отсутствие бесконечного вывода показывает, что этот код не создал цикл ссылок. Мы также можем убедиться в этом, посмотрев на значения, которые мы получаем при вызове `Rc::strong_count` и `Rc::weak_count`.
