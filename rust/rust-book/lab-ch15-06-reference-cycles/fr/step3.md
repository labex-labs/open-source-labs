# Prévention des cycles de référence en utilisant Weak`<T>`

Jusqu'à présent, nous avons démontré que l'appel de `Rc::clone` augmente le `strong_count` d'une instance `Rc<T>`, et qu'une instance `Rc<T>` n'est nettoyée que si son `strong_count` est égal à 0. Vous pouvez également créer une _référence faible_ à la valeur contenue dans une instance `Rc<T>` en appelant `Rc::downgrade` et en passant une référence à l'`Rc<T>`. Les références fortes sont le moyen de partager la propriété d'une instance `Rc<T>`. Les références faibles n'expriment pas de relation de propriété, et leur comptage n'affecte pas le moment où une instance `Rc<T>` est nettoyée. Elles ne causeront pas de cycle de référence car tout cycle impliquant des références faibles sera rompu une fois que le comptage de références fortes des valeurs impliquées est égal à 0.

Lorsque vous appelez `Rc::downgrade`, vous obtenez un pointeur intelligent du type `Weak<T>`. Au lieu d'augmenter le `strong_count` dans l'instance `Rc<T>` de 1, l'appel de `Rc::downgrade` augmente le `weak_count` de 1. Le type `Rc<T>` utilise `weak_count` pour suivre combien de références `Weak<T>` existent, de manière similaire à `strong_count`. La différence est que le `weak_count` n'a pas besoin d'être égal à 0 pour que l'instance `Rc<T>` soit nettoyée.

Parce que la valeur que référence `Weak<T>` peut avoir été supprimée, pour faire quoi que ce soit avec la valeur vers laquelle pointe un `Weak<T>`, vous devez vous assurer que la valeur existe toujours. Faites-le en appelant la méthode `upgrade` sur une instance `Weak<T>`, qui retournera un `Option<Rc<T>>`. Vous obtiendrez un résultat `Some` si la valeur `Rc<T>` n'a pas encore été supprimée et un résultat `None` si la valeur `Rc<T>` a été supprimée. Parce que `upgrade` retourne un `Option<Rc<T>>`, Rust s'assurera que le cas `Some` et le cas `None` sont gérés, et qu'il n'y aura pas de pointeur invalide.

En tant qu'exemple, au lieu d'utiliser une liste dont les éléments ne connaissent que l'élément suivant, nous allons créer un arbre dont les éléments connaissent leurs éléments enfants _et_ leurs éléments parents.
