# Vermeiden von Referenzzyklen mit Weak`<T>`{=html}

Bisher haben wir gezeigt, dass das Aufrufen von `Rc::clone` die `strong_count` einer `Rc<T>`-Instanz erhöht und dass eine `Rc<T>`-Instanz nur dann bereinigt wird, wenn ihre `strong_count` 0 ist. Sie können auch eine _schwache Referenz_ auf den Wert innerhalb einer `Rc<T>`-Instanz erstellen, indem Sie `Rc::downgrade` aufrufen und eine Referenz auf die `Rc<T>` übergeben. Starke Referenzen sind die Art, wie Sie die Eigentumsverteilung einer `Rc<T>`-Instanz teilen können. Schwache Referenzen drücken keine Eigentumsbeziehung aus, und ihre Anzahl hat keinen Einfluss darauf, wann eine `Rc<T>`-Instanz bereinigt wird. Sie verursachen keinen Referenzzyklus, da jeder Zyklus, der einige schwache Referenzen umfasst, abgebrochen wird, sobald die starke Referenzzählung der beteiligten Werte 0 ist.

Wenn Sie `Rc::downgrade` aufrufen, erhalten Sie einen Smart-Pointer vom Typ `Weak<T>`. Anstatt die `strong_count` in der `Rc<T>`-Instanz um 1 zu erhöhen, erhöht das Aufrufen von `Rc::downgrade` die `weak_count` um 1. Der `Rc<T>`-Typ verwendet die `weak_count`, um zu verfolgen, wie viele `Weak<T>`-Referenzen existieren, ähnlich wie die `strong_count`. Der Unterschied ist, dass die `weak_count` nicht 0 sein muss, damit die `Rc<T>`-Instanz bereinigt wird.

Da der Wert, auf den `Weak<T>` verweist, möglicherweise bereits gelöscht wurde, müssen Sie sicherstellen, dass der Wert noch existiert, um etwas mit dem Wert zu tun, auf den eine `Weak<T>` zeigt. Dies tun Sie, indem Sie die `upgrade`-Methode auf einer `Weak<T>`-Instanz aufrufen, die ein `Option<Rc<T>>` zurückgibt. Sie erhalten ein Ergebnis von `Some`, wenn der `Rc<T>`-Wert noch nicht gelöscht wurde, und ein Ergebnis von `None`, wenn der `Rc<T>`-Wert gelöscht wurde. Da `upgrade` ein `Option<Rc<T>>` zurückgibt, wird Rust sicherstellen, dass der `Some`-Fall und der `None`-Fall behandelt werden und dass es keinen ungültigen Zeiger gibt.

Als Beispiel werden wir statt einer Liste, deren Elemente nur über das nächste Element wissen, einen Baum erstellen, dessen Elemente über ihre Kind-Elemente _und_ ihre Eltern-Elemente wissen.
