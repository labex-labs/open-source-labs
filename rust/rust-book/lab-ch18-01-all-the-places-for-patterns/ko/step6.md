# let (let) 문

이 장 이전에는 `match`와 `if let`에서만 패턴을 사용하는 것을 명시적으로 논의했지만, 사실 `let` 문을 포함하여 다른 곳에서도 패턴을 사용했습니다. 예를 들어, `let`을 사용한 이 간단한 변수 할당을 생각해 보십시오.

```rust
let x = 5;
```

이와 같이 `let` 문을 사용할 때마다 패턴을 사용한 것입니다. 더 공식적으로, `let` 문은 다음과 같습니다.

```rust
let PATTERN = EXPRESSION;
```

`PATTERN` 슬롯에 변수 이름이 있는 `let x = 5;`와 같은 문에서 변수 이름은 특히 단순한 형태의 패턴입니다. Rust 는 표현식을 패턴과 비교하고 발견된 모든 이름을 할당합니다. 따라서 `let x = 5;` 예제에서 `x`는 "여기에 일치하는 것을 변수 `x`에 바인딩하라"는 의미의 패턴입니다. 이름 `x`가 전체 패턴이므로 이 패턴은 효과적으로 "모든 값을 변수 `x`에 바인딩하라"는 의미입니다.

`let`의 패턴 매칭 측면을 더 명확하게 보려면 Listing 18-4 를 고려하십시오. 이 코드는 `let`과 함께 패턴을 사용하여 튜플을 destructure 합니다.

```rust
let (x, y, z) = (1, 2, 3);
```

Listing 18-4: 튜플을 destructure 하고 세 개의 변수를 한 번에 생성하기 위해 패턴 사용

여기서 우리는 튜플을 패턴과 일치시킵니다. Rust 는 값 `(1, 2, 3)`을 패턴 `(x, y, z)`와 비교하고 값과 패턴이 일치하는지 확인합니다. 즉, 두 요소의 수가 동일한지 확인합니다. 따라서 Rust 는 `1`을 `x`에, `2`를 `y`에, `3`을 `z`에 바인딩합니다. 이 튜플 패턴을 세 개의 개별 변수 패턴을 중첩하는 것으로 생각할 수 있습니다.

패턴의 요소 수가 튜플의 요소 수와 일치하지 않으면 전체 유형이 일치하지 않아 컴파일러 오류가 발생합니다. 예를 들어, Listing 18-5 는 세 개의 요소가 있는 튜플을 두 개의 변수로 destructure 하려는 시도를 보여주며, 이는 작동하지 않습니다.

```rust
let (x, y) = (1, 2, 3);
```

Listing 18-5: 튜플의 요소 수와 일치하지 않는 변수를 가진 패턴을 잘못 구성

이 코드를 컴파일하려고 하면 다음과 같은 유형 오류가 발생합니다.

```bash
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer},
{integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
```

오류를 수정하려면 "패턴에서 값 무시하기"에서 보듯이 `_` 또는 `..`를 사용하여 튜플의 하나 이상의 값을 무시할 수 있습니다. 문제가 패턴에 변수가 너무 많은 경우, 해결책은 변수 수를 튜플의 요소 수와 같게 하여 유형이 일치하도록 변수를 제거하는 것입니다.
