# 関数のパラメータ

関数のパラメータもパターンにすることができます。型 `i32` の名前が `x` の1つのパラメータを持つ `foo` という名前の関数を宣言するリスト18-6のコードは、これまでに見たものと似ているはずです。

```rust
fn foo(x: i32) {
    // code goes here
}
```

リスト18-6: パラメータにパターンを使用する関数のシグネチャ

`x` の部分はパターンです！`let` と同じように、関数の引数のタプルをパターンに一致させることができます。リスト18-7は、タプルを関数に渡す際にその値を分割します。

ファイル名: `src/main.rs`

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

リスト18-7: タプルを分解するパラメータを持つ関数

このコードは `Current location: (3, 5)` を表示します。値 `&(3, 5)` はパターン `&(x, y)` に一致するため、`x` は値 `3` で、`y` は値 `5` です。

クロージャのパラメータリストでも、第13章で説明したように関数と同じようにパターンを使用することができます。クロージャは関数に似ているためです。

この時点で、パターンを使用するいくつかの方法を見てきましたが、パターンは使用できるすべての場所で同じように機能するわけではありません。いくつかの場所では、パターンは反駁不可能でなければなりません。他の状況では、反駁可能です。次に、これらの2つの概念について説明します。
