# let 文

この章の前では、`match` と `if let` でパターンを明示的に使用することについてのみ説明してきましたが、実際には `match` や `if let` 以外の場所でもパターンを使用しています。たとえば、`let` を使った簡単な変数代入を考えてみましょう。

```rust
let x = 5;
```

このような `let` 文を使ったことがあれば、パターンを使っていたことになります。ただし、それに気付いていなかったかもしれません！もう少し形式的に言うと、`let` 文は次のようになります。

```rust
let PATTERN = EXPRESSION;
```

`let x = 5;` のような、PATTERN のスロットに変数名がある文では、変数名はパターンの特別に単純な形式にすぎません。Rust は式をパターンと比較し、見つけた名前を割り当てます。したがって、`let x = 5;` の例では、`x` は「ここで一致するものを変数 `x` にバインドする」というパターンです。名前 `x` が全体のパターンであるため、このパターンは実質的に「値が何であれ、すべてを変数 `x` にバインドする」という意味になります。

`let` のパターンマッチングの側面をもっと明確に見るために、リスト 18-4 を見てみましょう。この例では、`let` にパターンを使ってタプルを分解しています。

```rust
let (x, y, z) = (1, 2, 3);
```

リスト 18-4: パターンを使ってタプルを分解し、一度に 3 つの変数を作成する

ここでは、タプルをパターンと比較しています。Rust は値 `(1, 2, 3)` をパターン `(x, y, z)` と比較し、要素数が同じであることから値がパターンに一致することを確認します。そのため、Rust は `1` を `x` に、`2` を `y` に、`3` を `z` にバインドします。このタプルパターンは、その中に 3 つの個々の変数パターンをネストしていると考えることができます。

パターンの要素数がタプルの要素数と一致しない場合、全体の型が一致せず、コンパイラエラーが発生します。たとえば、リスト 18-5 は、3 つの要素を持つタプルを 2 つの変数に分解しようとした例で、うまくいきません。

```rust
let (x, y) = (1, 2, 3);
```

リスト 18-5: タプルの要素数と一致しない変数を持つパターンを誤って構築する

このコードをコンパイルしようとすると、次のような型エラーが発生します。

```bash
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer},
{integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
```

エラーを修正するには、「パターン内の値の無視」で見るように、`_` や `..` を使ってタプルの 1 つ以上の値を無視することができます。パターンに変数が多すぎる問題がある場合、解決策は変数を削除して型を一致させることで、変数の数がタプルの要素数と一致するようにすることです。
