# Условные выражения if let

В главе 6 мы обсуждали, как использовать выражения `if let` в основном в качестве более короткого способа записи эквивалента `match`, который соответствует только одному случаю. По желанию, `if let` может иметь соответствующий `else`, содержащий код, который нужно выполнить, если шаблон в `if let` не соответствует.

Листинг 18-1 показывает, что также можно комбинировать `if let`, `else if` и `else if let` выражения. Это дает нам больше гибкости, чем выражение `match`, в котором мы можем выразить только одно значение для сравнения с шаблонами. Кроме того, Rust не требует, чтобы условия в серии `if let`, `else if` и `else if let` сеток (`arms`) были взаимосвязаны.

Код в Листинге 18-1 определяет, какой цвет сделать фоном на основе серии проверок нескольких условий. Для этого примера мы создали переменные с жестко заданными значениями, которые настоящий программа могла бы получить из ввода пользователя.

Filename: `src/main.rs`

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

  1 if let Some(color) = favorite_color {
      2 println!(
            "Using your favorite, {color}, as the background"
        );
  3 } else if is_tuesday {
      4 println!("Tuesday is green day!");
  5 } else if let Ok(age) = age {
      6 if age > 30 {
          7 println!("Using purple as the background color");
        } else {
          8 println!("Using orange as the background color");
        }
  9 } else {
     10 println!("Using blue as the background color");
    }
}
```

Листинг 18-1: Комбинирование `if let`, `else if`, `else if let` и `else`

Если пользователь укажет любимый цвет \[1\], этот цвет используется в качестве фона \[2\]. Если любимый цвет не указан и сегодня вторник \[3\], цвет фона - зеленый \[4\]. В противном случае, если пользователь укажет свой возраст в виде строки и мы сможем успешно его преобразовать в число \[5\], цвет будет либо фиолетовый \[7\], либо оранжевый \[8\], в зависимости от значения числа \[6\]. Если ни одно из этих условий не выполняется \[9\], цвет фона - синий \[10\].

Такая условная структура позволяет нам поддерживать сложные требования. С использованием жестко заданных значений здесь этот пример выведет `Using purple as the background color`.

Вы можете видеть, что `if let` также может вводить скрытые переменные так же, как и сетки (`arms`) `match`: строка `if let Ok(age) = age` \[5\] вводит новую скрытую переменную `age`, которая содержит значение внутри варианта `Ok`. Это означает, что мы должны поместить условие `if age > 30` \[6\] внутри этого блока: мы не можем объединить эти два условия в `if let Ok(age) = age && age > 30`. Скрытая переменная `age`, с которой мы хотим сравнивать 30, недействительна до начала нового скоупа, обозначенного фигурными скобками.

Недостатком использования выражений `if let` является то, что компилятор не проверяет их на исчерпывающий характер, в то время как это делает для выражений `match`. Если мы опустим последний блок `else` \[9\] и, следовательно, упустим обработку некоторых случаев, компилятор не предупредит нас о возможной ошибке в логике.
