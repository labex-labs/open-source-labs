# `let` 语句

在本章之前，我们只明确讨论过在 `match` 和 `if let` 中使用模式，但实际上，我们在其他地方也使用过模式，包括在 `let` 语句中。例如，考虑使用 `let` 进行的这种简单变量赋值：

```rust
let x = 5;
```

每次你使用这样的 `let` 语句时，你都在使用模式，尽管你可能没有意识到这一点！更正式地说，一个 `let` 语句看起来像这样：

```rust
let PATTERN = EXPRESSION;
```

在像 `let x = 5;` 这样的语句中，模式部分是一个变量名，这个变量名只是模式的一种特别简单的形式。Rust 将表达式与模式进行比较，并为它找到的任何名字赋值。所以，在 `let x = 5;` 的例子中，`x` 是一个模式，意思是“将这里匹配到的内容绑定到变量 `x` 上”。因为名字 `x` 就是整个模式，所以这个模式实际上意味着“将任何值都绑定到变量 `x` 上”。

为了更清楚地看到 `let` 的模式匹配方面，考虑清单 18-4，它使用带有 `let` 的模式来解构一个元组。

```rust
let (x, y, z) = (1, 2, 3);
```

清单 18-4：使用模式解构元组并一次性创建三个变量

在这里，我们将一个元组与一个模式进行匹配。Rust 将值 `(1, 2, 3)` 与模式 `(x, y, z)` 进行比较，发现值与模式匹配，因为它看到两者的元素数量相同，所以 Rust 将 `1` 绑定到 `x`，`2` 绑定到 `y`，`3` 绑定到 `z`。你可以将这个元组模式看作是在其中嵌套了三个单独的变量模式。

如果模式中的元素数量与元组中的元素数量不匹配，整体类型就不匹配，我们会得到一个编译器错误。例如，清单 18-5 展示了尝试将一个有三个元素的元组解构为两个变量，这是行不通的。

```rust
let (x, y) = (1, 2, 3);
```

清单 18-5：构造一个变量与元组元素数量不匹配的模式

尝试编译这段代码会导致以下类型错误：

```bash
error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^   --------- this expression has type `({integer}, {integer},
{integer})`
  |         |
  |         expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`
```

要修复这个错误，我们可以使用 `_` 或 `..` 忽略元组中的一个或多个值，你将在“忽略模式中的值”中看到。如果问题是模式中的变量太多，解决方案是通过移除变量使类型匹配，这样变量的数量就等于元组中的元素数量。
