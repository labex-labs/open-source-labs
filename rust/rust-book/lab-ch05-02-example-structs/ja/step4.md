# 派生トレイトを使った便利な機能の追加

プログラムのデバッグ中に、`Rectangle`のインスタンスを表示して、そのすべてのフィールドの値を確認できると便利でしょう。リスト 5-11 では、これまでの章で使ってきた`println!`マクロを使ってみます。しかし、これは機能しません。

ファイル名：`src/main.rs`

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}
```

リスト 5-11: `Rectangle`インスタンスを表示しようとする

このコードをコンパイルすると、次のようなエラーが表示されます。

```bash
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

`println!`マクロは様々な種類のフォーマットを行うことができます。デフォルトでは、波括弧は`println!`に対して、`Display`と呼ばれるフォーマットを使用するように指示します。これは、直接エンドユーザに提供する出力です。これまで見てきた基本型は、デフォルトで`Display`を実装しています。なぜなら、`1`や他の基本型をユーザに表示する方法は 1 通りだからです。しかし、構造体の場合、`println!`が出力をどのようにフォーマットすべきかは明確ではありません。なぜなら、表示の可能性が多いからです。カンマを使うかどうか？波括弧を表示するかどうか？すべてのフィールドを表示するか？この曖昧さのため、Rust は私たちが何を望んでいるかを推測しようとせず、構造体には`println!`と`{}`プレースホルダとともに使用するための`Display`の実装は提供されていません。

エラーを続けて読むと、次の助けになるメッセージがあります。

    = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for
    pretty-print) instead

試してみましょう！このときの`println!`マクロの呼び出しは、`println!("rect1 is {:?}", rect1);`のようになります。波括弧の中に指定子`:?`を入れることで、`println!`に対して、`Debug`と呼ばれる出力フォーマットを使用するように指示します。`Debug`トレイトを使うことで、開発者にとって便利な方法で構造体を表示できます。これにより、コードのデバッグ中に構造体の値を確認できます。

この変更を加えてコードをコンパイルします。残念ながら、まだエラーが表示されます。

```bash
error[E0277]: `Rectangle` doesn't implement `Debug`
```

しかし、再びコンパイラは助けになるメッセージを表示します。

```rust
= help: the trait `Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` or manually implement `Debug`
```

Rust には、デバッグ情報を表示する機能が含まれていますが、構造体に対してこの機能を利用できるようにするには、明示的にオプトインする必要があります。そのためには、構造体の定義の直前に外部属性`#[derive(Debug)]`を追加します。これはリスト 5-12 に示されています。

ファイル名：`src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {:?}", rect1);
}
```

リスト 5-12: `Debug`トレイトを派生させる属性を追加し、デバッグフォーマットを使って`Rectangle`インスタンスを表示する

このとき、プログラムを実行すると、エラーは表示されず、次のような出力が表示されます。

```rust
rect1 is Rectangle { width: 30, height: 50 }
```

素敵！最も見やすい出力ではありませんが、このインスタンスのすべてのフィールドの値が表示されます。これは、デバッグ中に非常に役立ちます。より大きな構造体の場合、もう少し読みやすい出力が欲しいです。そのような場合、`println!`の文字列の中で`{:#?}`を`{:?}`の代わりに使うことができます。この例では、`{:#?}`スタイルを使うと、次のような出力になります。

    rect1 is Rectangle {
        width: 30,
        height: 50,
    }

`Debug`フォーマットを使って値を表示する別の方法は、`dbg!`マクロを使うことです。これは、式の所有権を取得します（`println!`は参照を取得するのに対して）。コード内の`dbg!`マクロの呼び出し箇所のファイルと行番号とともに、その式の結果の値を表示し、その値の所有権を返します。

> 注：`dbg!`マクロを呼び出すと、`println!`が標準出力コンソールストリーム（`stdout`）に出力するのに対して、標準エラーコンソールストリーム（`stderr`）に出力されます。「標準出力ではなく標準エラーにエラーメッセージを書き込む」で、`stderr`と`stdout`についてもっと詳しく説明します。

次の例では、`width`フィールドに割り当てられる値と、`rect1`の全体の構造体の値に興味があります。

ファイル名：`src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
      1 width: dbg!(30 * scale),
        height: 50,
    };

  2 dbg!(&rect1);
}
```

式`30 * scale`の周りに`dbg!`を入れることができます \[1\]。`dbg!`は式の値の所有権を返すので、`width`フィールドは`dbg!`を使わなかった場合と同じ値を取得します。`dbg!`が`rect1`の所有権を取得してほしくないので、次の呼び出しでは`rect1`の参照を使います \[2\]。この例の出力は次のようになります。

    [src/main.rs:10] 30 * scale = 60
    [src/main.rs:14] &rect1 = Rectangle {
        width: 60,
        height: 50,
    }

最初の出力は \[1\] で、式`30 * scale`をデバッグしているところから来ており、その結果の値は`60`です（整数に対して実装されている`Debug`フォーマットは、値のみを表示するものです）。 \[2\] の`dbg!`呼び出しは、`&rect1`の値を出力します。これは`Rectangle`構造体です。この出力は、`Rectangle`型のきれいな`Debug`フォーマットを使用しています。`dbg!`マクロは、コードが何をしているかを理解する際に非常に役立ちます！

`Debug`トレイトに加えて、Rust は`derive`属性とともに使用するための多くのトレイトを提供しており、これらはカスタム型に便利な動作を追加することができます。これらのトレイトとその動作は付録 C に記載されています。第 10 章では、これらのトレイトをカスタムの動作で実装する方法と、独自のトレイトを作成する方法について説明します。また、`derive`以外にも多くの属性があります。詳細については、*https://doc.rust-lang.org/reference/attributes.html*の Rust リファレンスの「属性」セクションを参照してください。

`area`関数は非常に特定的です。長方形の面積のみを計算します。この動作を`Rectangle`構造体にもっと密接に関連付けると便利でしょう。なぜなら、他の型では機能しないからです。次に、`area`関数を`Rectangle`型に定義された`area`メソッドに変換することで、このコードをどのようにリファクタリングできるか見てみましょう。
