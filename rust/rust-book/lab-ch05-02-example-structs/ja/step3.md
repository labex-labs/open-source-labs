# 構造体を使ったリファクタリング: 意味を追加する

データにラベルを付けることで、構造体を使って意味を追加します。全体に名前を付け、各部分にも名前を付けることで、使っているタプルを構造体に変換できます。これはリスト5-10に示されています。

ファイル名: `src/main.rs`

```rust
1 struct Rectangle {
  2 width: u32,
    height: u32,
}

fn main() {
  3 let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

4 fn area(rectangle: &Rectangle) -> u32 {
  5 rectangle.width * rectangle.height
}
```

リスト5-10: `Rectangle`構造体を定義する

ここでは、構造体を定義して`Rectangle`と名付けました \[1\]。波括弧の中で、フィールドを`width`と`height`として定義し、どちらも型`u32`です \[2\]。そして、`main`では、幅が`30`、高さが`50`の`Rectangle`の特定のインスタンスを作成しました \[3\]。

`area`関数は、今では1つのパラメータで定義されており、それを`rectangle`と名付けています。その型は、構造体`Rectangle`インスタンスの不変参照です \[4\]。第4章で述べたように、構造体の所有権を取得するのではなく、構造体を参照するようにします。このようにすることで、`main`は所有権を保持し、`rect1`を継続して使用できます。これが、関数シグネチャと関数呼び出しの場所で`&`を使う理由です。

`area`関数は、`Rectangle`インスタンスの`width`と`height`フィールドにアクセスします \[5\] (借用した構造体インスタンスのフィールドにアクセスすると、フィールド値が移動しないことに注意してください。これが、構造体の借用をよく見る理由です)。`area`の関数シグネチャは、今では私たちの意図を正確に表しています。`Rectangle`の面積を、その`width`と`height`フィールドを使って計算します。これにより、幅と高さが互いに関連していることが伝わり、値に対して記述的な名前が与えられるようになります。タプルインデックス値の`0`と`1`を使うのではなくです。これは、明確さの面で勝利です。
