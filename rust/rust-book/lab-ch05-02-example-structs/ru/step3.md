# Рефакторинг с использованием структур: добавление дополнительной смысловой нагрузки

Мы используем структуры для добавления смысла, присвоив метки данным. Мы можем преобразовать используемый кортеж в структуру, присвоив имя целой структуре и имена ее частям, как показано в Listing 5-10.

Имя файла: `src/main.rs`

```rust
1 struct Rectangle {
  2 width: u32,
    height: u32,
}

fn main() {
  3 let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

4 fn area(rectangle: &Rectangle) -> u32 {
  5 rectangle.width * rectangle.height
}
```

Listing 5-10: Определение структуры `Rectangle`

Здесь мы определили структуру и назвали ее `Rectangle` \[1\]. Внутри фигурных скобок мы определили поля `width` и `height`, оба из которых имеют тип `u32` \[2\]. Затем, в `main`, мы создали конкретный экземпляр `Rectangle`, у которого ширина равна `30`, а высота равна `50` \[3\].

Наша функция `area` теперь определена с одним параметром, который мы назвали `rectangle`, тип которого представляет собой неизменяемую ссылку на экземпляр структуры `Rectangle` \[4\]. Как упоминалось в главе 4, мы хотим взять ссылку на структуру, а не владеть ею. Таким образом, `main` сохраняет свою собственность и может продолжать использовать `rect1`, что объясняет использование `&` в сигнатуре функции и при вызове функции.

Функция `area` обращается к полям `width` и `height` экземпляра `Rectangle` \[5\] (заметьте, что доступ к полям экземпляра структуры, взятой по ссылке, не перемещает значения полей, что объясняет, почему часто используются ссылки на структуры). Наша сигнатура функции `area` теперь точно отражает то, что мы имеем в виду: вычислить площадь `Rectangle`, используя ее поля `width` и `height`. Это показывает, что ширина и высота взаимосвязаны, и дает описательные имена значениям вместо использования индексов кортежа `0` и `1`. Это является выигрышем в вопросе ясности.
