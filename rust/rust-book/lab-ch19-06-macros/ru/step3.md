# Декларативные макросы с macro_rules! для общего метапрограммирования

Самая широко используемая форма макросов в Rust - это _декларативный макрос_. Эти макросы иногда также называются "макросами по примеру", "макросами `macro_rules!`" или просто "макросами". В основе declarative макросов лежит возможность писать что-то похожее на выражение `match` в Rust. Как обсуждалось в главе 6, выражения `match` - это управляющие конструкции, которые принимают выражение, сравнивают результирующее значение выражения с шаблонами и затем запускают код, связанный с совпадающим шаблоном. Макросы также сравнивают значение с шаблонами, связанными с определенным кодом: в этом случае значение - это исходный код Rust, переданный в макрос; шаблоны сравниваются с структурой этого исходного кода; и код, связанный с каждым шаблоном, при совпадении, заменяет код, переданный в макрос. Все это происходит во время компиляции.

Для определения макроса вы используете конструкцию `macro_rules!`. Давайте рассмотрим, как использовать `macro_rules!`, изучив, как определен макрос `vec!`. В главе 8 мы обсуждали, как можно использовать макрос `vec!` для создания нового вектора с определенными значениями. Например, следующий макрос создает новый вектор, содержащий три целых числа:

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

Мы также могли бы использовать макрос `vec!` для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не могли бы использовать функцию для того же, потому что мы заранее не знаем количество или тип значений.

Листинг 19-28 показывает несколько упрощенное определение макроса `vec!`.

Filename: `src/lib.rs`

```rust
1 #[macro_export]
2 macro_rules! vec {
  3 ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
          4 $(
              5 temp_vec.push(6 $x);
            )*
          7 temp_vec
        }
    };
}
```

Листинг 19-28: Упрощенная версия определения макроса `vec!`

> Примечание: Фактическое определение макроса `vec!` в стандартной библиотеке включает код для предварительного выделения правильного количества памяти заранее. Этот код - это оптимизация, которую мы здесь не включаем, чтобы сделать пример проще.

Аннотация `#[macro_export]` \[1\] указывает, что этот макрос должен быть доступен, когда крейт, в котором определен макрос, подключается к области видимости. Без этой аннотации макрос не может быть подключен к области видимости.

Затем мы начинаем определение макроса с `macro_rules!` и имени макроса, который мы определяем, _без_ восклицательного знака \[2\]. Имя, в этом случае `vec`, за которым следуют фигурные скобки, обозначающие тело определения макроса.

Структура в теле макроса `vec!` похожа на структуру выражения `match`. Здесь у нас есть одна ветка с шаблоном `( $( $x:expr ),* )`, за которой следует `=>` и блок кода, связанный с этим шаблоном \[3\]. Если шаблон совпадает, связанный блок кода будет сгенерирован. Поскольку это единственный шаблон в этом макросе, есть только один валидный способ совпадения; любой другой шаблон вызовет ошибку. Более сложные макросы будут иметь несколько веток.

Валидный синтаксис шаблонов в определениях макросов отличается от синтаксиса шаблонов, рассмотренного в главе 18, потому что шаблоны макросов сопоставляются с структурой кода Rust, а не со значениями. Давайте разберем, что означают части шаблона в Листинге 19-28; для полного синтаксиса шаблонов макросов см. Rust Reference по адресу *https://doc.rust-lang.org/reference/macros-by-example.html*.

Сначала мы используем круглые скобки, чтобы охватить весь шаблон. Мы используем знак доллара (`$`), чтобы объявить переменную в системе макросов, которая будет содержать исходный код Rust, совпадающий с шаблоном. Знак доллара делает понятным, что это переменная макроса, в отличие от обычной переменной Rust. Затем следуют круглые скобки, которые захватывают значения, совпадающие с шаблоном внутри скобок, для использования в коде замены. Внутри `$()` находится `$x:expr`, которое совпадает с любым выражением Rust и дает выражению имя `$x`.

Запятая, следующая за `$()`, указывает, что литеральный символ-разделитель запятой может необязательно появиться после кода, совпадающего с кодом в `$()`. `*` указывает, что шаблон совпадает с нулем или более чем чем-то, что предшествует `*`.

Когда мы вызываем этот макрос с `vec![1, 2, 3];`, шаблон `$x` совпадает три раза с тремя выражениями `1`, `2` и `3`.

Теперь давайте посмотрим на шаблон в теле кода, связанном с этой веткой: `temp_vec.push()` \[5\] внутри `$()* в [4] и [7] генерируется для каждой части, которая совпадает с`$()` в шаблоне ноль или более раз в зависимости от количества совпадений шаблона. `$x`[6] заменяется на каждое совпавшее выражение. Когда мы вызываем этот макрос с`vec\[1, 2, 3\];\`, сгенерированный код, который заменяет вызов этого макроса, будет следующим:

    {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    }

Мы определили макрос, который может принимать любое количество аргументов любого типа и может сгенерировать код для создания вектора, содержащего указанные элементы.

Для получения более подробной информации о том, как писать макросы, обратитесь к онлайн-документации или другим ресурсам, таким как "The Little Book of Rust Macros" по адресу *https://veykril.github.io/tlborm*, начатый Даниэлем Кепом и продолженный Лукасом Виртом.
