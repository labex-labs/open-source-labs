# Макросы, похожие на атрибуты

Макросы, похожие на атрибуты, похожи на пользовательские макросы `derive`, но вместо генерации кода для атрибута `derive` они позволяют вам создавать новые атрибуты. Они также более гибкие: `derive` работает только для структур и перечислений; атрибуты можно применять к другим элементам, таким как функции. Вот пример использования макроса, похожего на атрибут. Предположим, у вас есть атрибут под названием `route`, который аннотирует функции при использовании веб-приложения:

```rust
#[route(GET, "/")]
fn index() {
```

Этот атрибут `#[route]` будет определен фреймворком в виде процедурного макроса. Сигнатура функции определения макроса будет выглядеть так:

    #[proc_macro_attribute]
    pub fn route(
        attr: TokenStream,
        item: TokenStream
    ) -> TokenStream {

Здесь у нас есть два параметра типа `TokenStream`. Первый - это для содержимого атрибута: часть `GET, "/"`. Второй - это тело элемента, к которому прикреплен атрибут: в этом случае `fn index() {}` и остальная часть тела функции.

Другими словами, макросы, похожие на атрибуты, работают так же, как и пользовательские макросы `derive`: вы создаете крейт с типом крейта `proc-macro` и реализуете функцию, которая генерирует код, который вы хотите!
