# Процедурные макросы для генерации кода из атрибутов

Вторая форма макросов - это процедурный макрос, который действует более похоже на функцию (и является типом процедуры). _Процедурные макросы_ принимают некоторый код в качестве входных данных, обрабатывают этот код и выводят некоторый код в качестве результата, в отличие от декларативных макросов, которые сопоставляются с шаблонами и заменяют код на другой код. Три вида процедурных макросов: пользовательские `derive`, похожие на атрибуты и похожие на функции, и все они работают похожим образом.

При создании процедурных макросов определения должны находиться в отдельном крейте с особым типом крейта. Это связано с сложными техническими причинами, которые мы надеемся устранить в будущем. В Листинге 19-29 показано, как определить процедурный макрос, где `some_attribute` - это placeholder для использования определенного вида макроса.

Filename: `src/lib.rs`

```rust
use proc_macro::TokenStream;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

Листинг 19-29: Пример определения процедурного макроса

Функция, которая определяет процедурный макрос, принимает `TokenStream` в качестве входных данных и выводит `TokenStream` в качестве результата. Тип `TokenStream` определяется крейтом `proc_macro`, который входит в Rust, и представляет последовательность токенов. Это ядро макроса: исходный код, на котором работает макрос, составляет входной `TokenStream`, а код, который макрос генерирует, является выходным `TokenStream`. Функция также имеет атрибут, который указывает, какой тип процедурного макроса мы создаем. В одном крейте мы можем иметь несколько видов процедурных макросов.

Давайте рассмотрим разные виды процедурных макросов. Мы начнем с пользовательского макроса `derive`, а затем объясним небольшие различия, которые делают другие формы различными.
