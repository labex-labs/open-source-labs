# 一般的なメタプログラミング用の `macro_rules!` を使った宣言的マクロ

Rustで最も広く使われるマクロの形式は「宣言的マクロ」です。これは、「例によるマクロ」、「`macro_rules!` マクロ」、または単に「マクロ」とも呼ばれます。その核心は、宣言的マクロがRustの `match` 式に似たものを書けるようにすることです。第6章で説明したように、`match` 式は制御構造であり、式を取り、その式の結果の値をパターンと比較し、その後、一致するパターンに関連付けられたコードを実行します。マクロもまた、特定のコードに関連付けられたパターンと値を比較します。この場合、値はマクロに渡されるリテラルのRustソースコードであり、パターンはそのソースコードの構造と比較され、各パターンに関連付けられたコードは一致したときに、マクロに渡されたコードを置き換えます。これらのすべてはコンパイル時に行われます。

マクロを定義するには、`macro_rules!` 構文を使用します。`vec!` マクロがどのように定義されているかを見て、`macro_rules!` をどのように使用するかを探りましょう。第8章では、特定の値を持つ新しいベクトルを作成するために `vec!` マクロをどのように使用できるかを説明しました。たとえば、次のマクロは3つの整数を含む新しいベクトルを作成します。

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

また、`vec!` マクロを使って、2つの整数のベクトルや5つの文字列スライスのベクトルを作成することもできます。事前に値の数や型を知らないため、同じことを関数で行うことはできません。

リスト19-28は、`vec!` マクロのわずかに簡略化された定義を示しています。

ファイル名: `src/lib.rs`

```rust
1 #[macro_export]
2 macro_rules! vec {
  3 ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
          4 $(
              5 temp_vec.push(6 $x);
            )*
          7 temp_vec
        }
    };
}
```

リスト19-28: `vec!` マクロ定義の簡略化バージョン

> 注: 標準ライブラリにおける `vec!` マクロの実際の定義には、事前に正しい量のメモリを割り当てるコードが含まれています。このコードは最適化であり、この例を簡単にするためにここには含めていません。

`#[macro_export]` アノテーション \[1\] は、マクロが定義されているクレートがスコープに入るときに、このマクロが利用可能になるようにすることを示しています。このアノテーションがないと、マクロをスコープに持ち込むことができません。

次に、マクロ定義を `macro_rules!` と定義するマクロの名前（感嘆符を付けない）で始めます \[2\]。この場合の名前は `vec` で、マクロ定義の本体を表す波括弧が続きます。

`vec!` の本体の構造は、`match` 式の構造に似ています。ここでは、`( $( $x:expr ),* )` というパターンを持つ1つのアームがあり、その後に `=>` とこのパターンに関連付けられたコードブロックが続きます \[3\]。パターンが一致すると、関連付けられたコードブロックが生成されます。このマクロにはこれが唯一のパターンなので、一致する有効な方法は1つだけで、他のパターンはエラーになります。より複雑なマクロには複数のアームがあります。

マクロ定義における有効なパターン構文は、第18章で説明したパターン構文とは異なります。なぜなら、マクロパターンは値ではなくRustコード構造と照合されるからです。リスト19-28のパターンの部分が何を意味するか見てみましょう。完全なマクロパターン構文については、*https://doc.rust-lang.org/reference/macros-by-example.html* のRustリファレンスを参照してください。

まず、全体的なパターンを囲むために一組の丸括弧を使用します。マクロシステム内の変数を宣言するには、ドル記号 (`$`) を使用します。この変数は、パターンに一致するRustコードを含みます。ドル記号は、これが通常のRust変数とは異なるマクロ変数であることを明確に示しています。次に、丸括弧のセットが続きます。これは、置換コードで使用するために、丸括弧内のパターンに一致する値をキャプチャします。`$()` の中には `$x:expr` があり、これは任意のRust式と一致し、式に `$x` という名前を付けます。

`$()` の後に続くコンマは、`$()` 内のコードに一致するコードの後に、リテラルのコンマ区切り文字が任意に現れることを示しています。`*` は、`*` の前にあるものと0回以上一致することを指定します。

このマクロを `vec![1, 2, 3];` で呼び出すと、`$x` パターンは3つの式 `1`、`2`、`3` と3回一致します。

次に、このアームに関連付けられたコードの本体のパターンを見てみましょう。`$()*` 内の `temp_vec.push()` \[5\] は、パターンが一致する回数に応じて、パターン内の `$()` と一致する各部分に対して0回以上生成されます。`$x` \[6\] は、一致した各式に置き換えられます。このマクロを `vec![1, 2, 3];` で呼び出すと、このマクロ呼び出しを置き換える生成されるコードは次のようになります。

    {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    }

任意の型の任意の数の引数を取り、指定された要素を含むベクトルを作成するコードを生成できるマクロを定義しました。

マクロを書く方法について詳しく学ぶには、オンラインドキュメントや、Daniel Keepによって始まりLukas Wirthによって続けられている *https://veykril.github.io/tlborm* の「The Little Book of Rust Macros」などの他のリソースを参照してください。
