# 属性からコードを生成するための手続き型マクロ

マクロの 2 番目の形式は手続き型マクロで、これはより関数に似た働きをします（手続きの一種です）。「手続き型マクロ」は、宣言的マクロのようにパターンと照合してコードを他のコードで置き換えるのではなく、入力としてコードを一部受け取り、そのコードに対して操作を行い、出力としてコードを生成します。3 種類の手続き型マクロは、カスタム`derive`、属性のような、および関数のようなもので、すべて同様の方法で機能します。

手続き型マクロを作成する際、定義は特別なクレートタイプを持つ独自のクレートに存在しなければなりません。これは将来的に解消したい複雑な技術的理由によるものです。リスト 19-29 では、特定のマクロ種類を使用するためのプレースホルダである`some_attribute`がある場合の手続き型マクロの定義方法を示しています。

ファイル名：`src/lib.rs`

```rust
use proc_macro::TokenStream;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

リスト 19-29: 手続き型マクロの定義の例

手続き型マクロを定義する関数は、入力として`TokenStream`を取り、出力として`TokenStream`を生成します。`TokenStream`型は、Rust に含まれる`proc_macro`クレートによって定義され、トークンのシーケンスを表します。これがマクロの核心です。マクロが操作するソースコードが入力`TokenStream`を構成し、マクロが生成するコードが出力`TokenStream`です。また、関数には、作成している手続き型マクロの種類を指定する属性が付けられています。同じクレートに複数種類の手続き型マクロを持つことができます。

さて、手続き型マクロの種類を見てみましょう。まずはカスタム`derive`マクロから始めて、他の形式が異なる小さな違いを説明します。
