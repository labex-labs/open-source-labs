# 일반적인 메타 프로그래밍을 위한 `macro_rules!`를 사용한 선언적 매크로

Rust 에서 가장 널리 사용되는 매크로 형태는 *선언적 매크로 (declarative macro)*입니다. 이는 때때로 "예제별 매크로 (macros by example)", "`macro_rules!` 매크로" 또는 단순히 "매크로"라고도 합니다. 핵심적으로 선언적 매크로는 Rust `match` 표현식과 유사한 것을 작성할 수 있게 해줍니다. 6 장에서 논의했듯이, `match` 표현식은 표현식을 가져와 표현식의 결과 값을 패턴과 비교한 다음 일치하는 패턴과 관련된 코드를 실행하는 제어 구조입니다. 매크로도 값 (value) 을 특정 코드와 관련된 패턴과 비교합니다. 이 경우 값은 매크로에 전달된 리터럴 Rust 소스 코드입니다. 패턴은 해당 소스 코드의 구조와 비교되며, 일치하는 각 패턴과 관련된 코드는 매크로에 전달된 코드를 대체합니다. 이 모든 것은 컴파일 중에 발생합니다.

매크로를 정의하려면 `macro_rules!` 구문을 사용합니다. `vec!` 매크로가 어떻게 정의되는지 살펴봄으로써 `macro_rules!`를 사용하는 방법을 살펴보겠습니다. 8 장에서는 `vec!` 매크로를 사용하여 특정 값을 가진 새로운 벡터를 만드는 방법을 다루었습니다. 예를 들어, 다음 매크로는 세 개의 정수를 포함하는 새로운 벡터를 생성합니다.

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

`vec!` 매크로를 사용하여 두 개의 정수 벡터 또는 다섯 개의 문자열 슬라이스 (string slice) 벡터를 만들 수도 있습니다. 함수를 사용하여 동일한 작업을 수행할 수는 없습니다. 왜냐하면 미리 값의 수나 유형을 알 수 없기 때문입니다.

Listing 19-28 은 `vec!` 매크로의 약간 단순화된 정의를 보여줍니다.

Filename: `src/lib.rs`

```rust
1 #[macro_export]
2 macro_rules! vec {
  3 ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
          4 $(
              5 temp_vec.push(6 $x);
            )*
          7 temp_vec
        }
    };
}
```

Listing 19-28: `vec!` 매크로 정의의 단순화된 버전

> 참고: 표준 라이브러리의 실제 `vec!` 매크로 정의에는 미리 올바른 양의 메모리를 할당하는 코드가 포함되어 있습니다. 해당 코드는 예제를 더 간단하게 만들기 위해 여기서는 포함하지 않는 최적화입니다.

`#[macro_export]` 어노테이션 \[1]은 매크로가 정의된 크레이트 (crate) 가 범위 내로 가져올 때마다 이 매크로를 사용할 수 있도록 해야 함을 나타냅니다. 이 어노테이션이 없으면 매크로를 범위 내로 가져올 수 없습니다.

그런 다음 `macro_rules!`와 정의하려는 매크로의 이름 (느낌표 없이) \[2]로 매크로 정의를 시작합니다. 이 경우 이름인 `vec` 뒤에는 매크로 정의의 본문을 나타내는 중괄호가 옵니다.

`vec!` 본문의 구조는 `match` 표현식의 구조와 유사합니다. 여기에는 패턴 `( $( $x:expr ),* )`가 있는 하나의 arm 이 있고, 그 뒤에 `=>`와 이 패턴과 관련된 코드 블록이 있습니다 \[3]. 패턴이 일치하면 관련 코드 블록이 방출됩니다. 이 매크로에 이 패턴만 있으므로 일치하는 유효한 방법은 하나뿐입니다. 다른 패턴은 오류를 발생시킵니다. 더 복잡한 매크로는 여러 arm 을 가질 것입니다.

매크로 정의의 유효한 패턴 구문은 18 장에서 다룬 패턴 구문과 다릅니다. 왜냐하면 매크로 패턴은 값 (value) 이 아닌 Rust 코드 구조와 일치하기 때문입니다. Listing 19-28 의 패턴 조각이 의미하는 바를 살펴보겠습니다. 전체 매크로 패턴 구문은 *https://doc.rust-lang.org/reference/macros-by-example.html*에서 Rust Reference 를 참조하십시오.

먼저 전체 패턴을 포함하기 위해 괄호 집합을 사용합니다. 달러 기호 (`$`) 를 사용하여 패턴과 일치하는 Rust 코드를 포함하는 매크로 시스템에서 변수를 선언합니다. 달러 기호는 이것이 일반 Rust 변수가 아닌 매크로 변수임을 명확하게 합니다. 다음은 패턴과 일치하는 값을 캡처하여 대체 코드에서 사용할 괄호 집합이 옵니다. `$()` 내에는 `$x:expr`이 있으며, 이는 모든 Rust 표현식과 일치하고 표현식에 `$x`라는 이름을 부여합니다.

`$()` 다음에 오는 쉼표는 `$()`의 코드와 일치하는 코드 다음에 리터럴 쉼표 구분 기호 문자가 선택적으로 나타날 수 있음을 나타냅니다. `*`는 패턴이 `*` 앞에 있는 모든 항목의 0 개 이상과 일치함을 지정합니다.

`vec![1, 2, 3];`으로 이 매크로를 호출하면 `$x` 패턴이 세 번 일치하여 세 개의 표현식 `1`, `2`, `3`과 일치합니다.

이제 이 arm 과 관련된 코드 본문의 패턴을 살펴보겠습니다. `$()* at [4] and [7] 내의 `temp_vec.push()`\[5]는 패턴이 일치하는 횟수에 따라 패턴에서`$()`와 일치하는 각 부분에 대해 0번 이상 생성됩니다. `$x`[6]는 일치하는 각 표현식으로 대체됩니다. `vec\[1, 2, 3\];\`으로 이 매크로를 호출하면 이 매크로 호출을 대체하는 생성된 코드는 다음과 같습니다.

    {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    }

어떤 유형의 인수를 원하는 수만큼 가져와 지정된 요소를 포함하는 벡터를 생성하는 코드를 생성할 수 있는 매크로를 정의했습니다.

매크로를 작성하는 방법에 대한 자세한 내용은 온라인 설명서 또는 Daniel Keep 가 시작하고 Lukas Wirth 가 계속한 *https://veykril.github.io/tlborm*의 "The Little Book of Rust Macros"와 같은 다른 리소스를 참조하십시오.
