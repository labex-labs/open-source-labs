# Применение внутренней изменяемости: моки-объекты

Иногда при тестировании программист использует один тип вместо другого, чтобы наблюдать за определенным поведением и проверить, правильно ли оно реализовано. Этот заменяющий тип называется _тестовым替身ом_ (test double). Представьте себе его в смысле стunts double в кино, когда человек замещается актером, чтобы выполнить особенно сложную сцену. Тестовые替身ы замещают другие типы, когда мы запускаем тесты. _Моки-объекты_ (Mock objects) — это конкретный тип тестовых替身ов, которые записывают, что происходит во время теста, чтобы вы могли проверить, были ли выполнены правильные действия.

В Rust нет объектов в том же смысле, что и в других языках, и в стандартной библиотеке Rust нет встроенной функциональности для моки-объектов, как это есть в некоторых других языках. Однако вы можете определенно создать структуру, которая будет служить тем же целям, что и моки-объект.

Вот сценарий, который мы будем тестировать: мы создадим библиотеку, которая отслеживает значение по отношению к максимальному значению и отправляет сообщения в зависимости от того, насколько близко текущее значение к максимальному. Эта библиотека, например, может быть использована для отслеживания квоты пользователя по количеству разрешенных вызовов API.

Наша библиотека будет предоставлять только функциональность отслеживания насколько близко значение к максимальному и какие сообщения должны быть отправлены в определенные моменты. Приложения, которые используют нашу библиотеку, должны обеспечить механизм отправки сообщений: приложение может поместить сообщение в приложение, отправить электронное письмо, отправить текстовое сообщение или что-то другое. Библиотека не должна знать эти детали. Все, что она нуждается в том, чтобы иметь что-то, которое реализует трейт, который мы предоставим под названием `Messenger`. Listing 15-20 показывает код библиотеки.

Имя файла: `src/lib.rs`

```rust
pub trait Messenger {
  1 fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
where
    T: Messenger,
{
    pub fn new(
        messenger: &'a T,
        max: usize
    ) -> LimitTracker<'a, T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

  2 pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max =
            self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger
               .send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
            self.messenger
               .send("Urgent: You're at 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger
               .send("Warning: You're at 75% of your quota!");
        }
    }
}
```

Listing 15-20: Библиотека для отслеживания насколько близко значение к максимальному и предупреждения при достижении определенных уровней

Одним из важных моментов этого кода является то, что трейт `Messenger` имеет один метод под названием `send`, который принимает неизменяемую ссылку на `self` и текст сообщения \[1\]. Этот трейт — это интерфейс, который должен реализовать наш моки-объект, чтобы мок мог быть использован так же, как и настоящий объект. Другой важный момент — это то, что мы хотим протестировать поведение метода `set_value` на `LimitTracker` \[2\]. Мы можем изменить то, что мы передаем в качестве параметра `value`, но `set_value` не возвращает ничего, чтобы мы могли сделать утверждения. Мы хотим быть уверены, что если мы создадим `LimitTracker` с тем, что реализует трейт `Messenger` и определенным значением для `max`, когда мы передаем разные числа для `value`, мессенджеру будет сказано отправить соответствующие сообщения.

Нам нужен моки-объект, который вместо отправки электронного письма или текстового сообщения при вызове `send` будет только отслеживать сообщения, которые ему сообщают отправить. Мы можем создать новый экземпляр моки-объекта, создать `LimitTracker`, который использует моки-объект, вызвать метод `set_value` на `LimitTracker` и затем проверить, что в моки-объекте есть сообщения, которые мы ожидаем. Listing 15-21 показывает попытку реализовать моки-объект для этого, но проверщик заимствований не позволит это сделать.

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;

  1 struct MockMessenger {
      2 sent_messages: Vec<String>,
    }

    impl MockMessenger {
      3 fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

  4 impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
          5 self.sent_messages.push(String::from(message));
        }
    }

    #[test]
  6 fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(
            &mock_messenger,
            100
        );

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

Listing 15-21: Попытка реализовать `MockMessenger`, которая не допускается проверщиком заимствований

Этот тестовый код определяет структуру `MockMessenger` \[1\], которая имеет поле `sent_messages` с `Vec` значений `String` \[2\], чтобы отслеживать сообщения, которые ей сообщают отправить. Мы также определяем связанную функцию `new` \[3\], чтобы было удобно создавать новые значения `MockMessenger`, которые начинаются с пустого списка сообщений. Затем мы реализуем трейт `Messenger` для `MockMessenger` \[4\], чтобы мы могли передать `MockMessenger` в `LimitTracker`. В определении метода `send` \[5\] мы берем сообщение, переданное в качестве параметра, и сохраняем его в списке `sent_messages` `MockMessenger`.

В тесте мы проверяем, что происходит, когда `LimitTracker` получает команду установить `value` на что-то, что больше 75 процентов от `max` значения \[6\]. Сначала мы создаем новый `MockMessenger`, который начнется с пустого списка сообщений. Затем мы создаем новый `LimitTracker` и передаем ему ссылку на новый `MockMessenger` и `max` значение `100`. Мы вызываем метод `set_value` на `LimitTracker` со значением `80`, что больше 75 процентов от 100. Затем мы утверждаем, что список сообщений, который отслеживает `MockMessenger`, должен теперь содержать одно сообщение.

Однако есть одна проблема с этим тестом, как показано здесь:

```bash
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a
`&` reference
  --> src/lib.rs:58:13
   |
2  |     fn send(&self, msg: &str);
   |             ----- help: consider changing that to be a mutable reference:
`&mut self`
...
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a
`&` reference, so the data it refers to cannot be borrowed as mutable
```

Мы не можем изменить `MockMessenger`, чтобы отслеживать сообщения, потому что метод `send` принимает неизменяемую ссылку на `self`. Мы также не можем принять предложение из текста ошибки и использовать `&mut self` вместо этого, потому что тогда сигнатура `send` не соответствовала бы сигнатуре в определении трейта `Messenger` (свободно попробуйте это и посмотрите, какую ошибку вы получите).

Это ситуация, в которой внутренняя изменяемость может помочь! Мы будем хранить `sent_messages` внутри `RefCell<T>`, и тогда метод `send` сможет изменить `sent_messages`, чтобы сохранить сообщения, которые мы увидели. Listing 15-22 показывает, как это выглядит.

Имя файла: `src/lib.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
      1 sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
              2 sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages
              3.borrow_mut()
               .push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        --snip--

        assert_eq!(
          4 mock_messenger.sent_messages.borrow().len(),
            1
        );
    }
}
```

Listing 15-22: Использование `RefCell<T>` для изменения внутреннего значения, когда внешнее значение считается неизменяемым

Поле `sent_messages` теперь имеет тип `RefCell<Vec<String>>` \[1\] вместо `Vec<String>`. В функции `new` мы создаем новый экземпляр `RefCell<Vec<String>>` вокруг пустого вектора \[2\].

Для реализации метода `send` первый параметр по-прежнему является неизменяемой ссылкой на `self`, что соответствует определению трейта. Мы вызываем `borrow_mut` на `RefCell<Vec<String>>` в `self.sent_messages` \[3\], чтобы получить изменяемую ссылку на значение внутри `RefCell<Vec<String>>`, которое является вектором. Затем мы можем вызвать `push` на изменяемую ссылку на вектор, чтобы отслеживать сообщения, отправленные во время теста.

Последнее изменение, которое мы должны сделать, — это в утверждении: чтобы увидеть, сколько элементов в внутреннем векторе, мы вызываем `borrow` на `RefCell<Vec<String>>`, чтобы получить неизменяемую ссылку на вектор \[4\].

Теперь, когда вы видели, как использовать `RefCell<T>`, давайте углубимся в то, как он работает!
