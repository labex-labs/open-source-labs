# Применение правил заимствования во время выполнения с помощью RefCell`<T>`{=html}

В отличие от `Rc<T>`, тип `RefCell<T>` представляет собой единственную собственность над данными, которые он хранит. То, что делает `RefCell<T>` различным от типа, такой как `Box<T>`? Назовите правила заимствования, которые вы узнали в главе 4:

- В любое конкретное время у вас может быть _либо_ одна изменяемая ссылка, _либо_ любое количество неизменяемых ссылок (но не оба сразу).
- Ссылки должны всегда быть действительными.

При использовании ссылок и `Box<T>` инварианты правил заимствования накладываются на этапе компиляции. При использовании `RefCell<T>` эти инварианты накладываются _во время выполнения_. При использовании ссылок, если вы нарушаете эти правила, вы получите ошибку компилятора. При использовании `RefCell<T>`, если вы нарушаете эти правила, ваша программа будет аварийно завершена и выйдете из нее.

Преимуществом проверки правил заимствования на этапе компиляции является то, что ошибки будут обнаружены раньше в процессе разработки, и это не влияет на производительность во время выполнения, так как все анализ завершается заранее. По этим причинам проверка правил заимствования на этапе компиляции является наилучшим выбором в большинстве случаев, и именно поэтому это и есть стандартный подход в Rust.

Преимуществом проверки правил заимствования во время выполнения является то, что в этом случае некоторые сценарии, которые обеспечивают безопасность памяти, могут быть допущены, в то время как компилятор их не допустил бы на этапе компиляции. Статический анализ, такой как Rust компилятор, по своей природе консервативен. Некоторые свойства кода невозможно определить путем анализа кода: наиболее известный пример — это задача остановки, которая находится за пределами этого учебника, но представляет интересный объект исследования.

Поскольку некоторые виды анализа невозможны, если Rust компилятор не может быть уверен, что код соответствует правилам владения, он может отвергнуть корректную программу; таким образом, он консервативен. Если Rust принял бы некорректную программу, пользователи не могли бы доверять гарантиям, которые дает Rust. Однако, если Rust отвергает корректную программу, программисту будет неудобство, но ничего катастрофического не произойдет. Тип `RefCell<T>` полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но компилятор не может понять и гарантировать это.

Похожий на `Rc<T>`, `RefCell<T>` предназначен только для использования в однопоточных сценариях и вы получите ошибку компиляции, если попытаетесь использовать его в многопоточном контексте. Мы поговорим о том, как получить функциональность `RefCell<T>` в многопоточной программе в главе 16.

Вот краткое изложение причин выбора `Box<T>`, `Rc<T>` или `RefCell<T>`:

- `Rc<T>` позволяет нескольким владельцам иметь доступ к тем же данным; `Box<T>` и `RefCell<T>` имеют единственного владельца.
- `Box<T>` позволяет неизменяемым или изменяемым заимствованиям, проверяемым на этапе компиляции; `Rc<T>` позволяет только неизменяемым заимствованиям, проверяемым на этапе компиляции; `RefCell<T>` позволяет неизменяемым или изменяемым заимствованиям, проверяемым во время выполнения.
- Поскольку `RefCell<T>` позволяет изменяемым заимствованиям, проверяемым во время выполнения, вы можете изменить значение внутри `RefCell<T>`, даже когда `RefCell<T>` является неизменяемым.

Изменение значения внутри неизменяемого значения — это _шаблон внутренней изменяемости_. Рассмотрим ситуацию, в которой внутренняя изменяемость полезна, и изучим, как это возможно.
