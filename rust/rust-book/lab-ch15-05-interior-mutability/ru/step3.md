# Внутренняя изменяемость: изменяемая ссылка на неизменяемое значение

В результате правил заимствования, когда у вас есть неизменяемое значение, вы не можете взять его в изменяемую ссылку. Например, этот код не скомпилируется:

Имя файла: `src/main.rs`

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

Если вы попытаетесь скомпилировать этот код, вы получите следующую ошибку:

```bash
error[E0596]: cannot borrow `x` as mutable, as it is not declared
as mutable
 --> src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable
```

Однако бывают ситуации, когда полезно, чтобы значение изменяло себя в своих методах, но казалось бы неизменным для другого кода. Код за пределами методов значения не должен был бы изменять значение. Использование `RefCell<T>` — один из способов получить возможность внутренней изменяемости, но `RefCell<T>` не полностью обходит правила заимствования: проверщик заимствований в компиляторе позволяет эту внутреннюю изменяемость, и правила заимствования проверяются во время выполнения. Если вы нарушаете правила, вы получите `panic!` вместо ошибки компилятора.

Рассмотрим практический пример, в котором мы можем использовать `RefCell<T>` для изменения неизменяемого значения и увидим, почему это полезно.
