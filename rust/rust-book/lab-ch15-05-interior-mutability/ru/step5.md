# Отслеживание заимствований во время выполнения с помощью RefCell`<T>`

При создании неизменяемых и изменяемых ссылок мы используем синтаксис `&` и `&mut` соответственно. При использовании `RefCell<T>` мы используем методы `borrow` и `borrow_mut`, которые являются частью безопасного API, принадлежащего `RefCell<T>`. Метод `borrow` возвращает умный указатель типа `Ref<T>`, а `borrow_mut` возвращает умный указатель типа `RefMut<T>`. Оба типа реализуют `Deref`, поэтому мы можем их рассматривать как обычные ссылки.

`RefCell<T>` отслеживает, сколько умных указателей `Ref<T>` и `RefMut<T>` активны в текущий момент. Каждый раз, когда мы вызываем `borrow`, `RefCell<T>` увеличивает счетчик количества активных неизменяемых заимствований. Когда значение `Ref<T>` выходит из области видимости, счетчик неизменяемых заимствований уменьшается на 1. Также как и правила заимствования на этапе компиляции, `RefCell<T>` позволяет нам иметь много неизменяемых заимствований или одно изменяемое заимствование в любое время.

Если мы попытаемся нарушить эти правила, вместо того чтобы получить ошибку компилятора, как это бывает при использовании ссылок, реализация `RefCell<T>` будет аварийно завершена во время выполнения. Listing 15-23 показывает модификацию реализации `send` из Listing 15-22. Мы特意 пытаемся создать два активных изменяемых заимствования для одной области видимости, чтобы показать, что `RefCell<T>` не позволяет нам этого делать во время выполнения.

Имя файла: `src/lib.rs`

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```

Listing 15-23: Создание двух изменяемых ссылок в одной области видимости, чтобы увидеть, что `RefCell<T>` будет аварийно завершаться

Мы создаем переменную `one_borrow` для умного указателя `RefMut<T>`, возвращаемого методом `borrow_mut`. Затем мы создаем еще одно изменяемое заимствование так же в переменной `two_borrow`. Это создает две изменяемые ссылки в одной области видимости, что не допускается. Когда мы запускаем тесты для нашей библиотеки, код из Listing 15-23 будет скомпилирован без ошибок, но тест будет провален:

    ---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'main' panicked at 'already borrowed: BorrowMutError', src/lib.rs:60:53
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

Заметим, что код аварийно завершился с сообщением `already borrowed: BorrowMutError`. Именно так `RefCell<T>` обрабатывает нарушения правил заимствования во время выполнения.

Выбор поймать ошибки заимствования во время выполнения вместо этапа компиляции, как мы сделали здесь, означает, что вы потенциально будете обнаруживать ошибки в своем коде позже в процессе разработки: возможно, не до тех пор, пока ваш код не будет развернут в продакшене. Также ваш код будет иметь небольшую штрафу по производительности во время выполнения в результате отслеживания заимствований во время выполнения вместо этапа компиляции. Однако использование `RefCell<T>` позволяет написать моки-объект, который может изменять себя, чтобы отслеживать сообщения, которые он видел, в то время как вы используете его в контексте, где допускаются только неизменяемые значения. Вы можете использовать `RefCell<T>` несмотря на его недостатки, чтобы получить больше функциональности, чем обычные ссылки предоставляют.
