# Позволение нескольким владельцам изменяемым данным с помощью Rc`<T>` и RefCell`<T>`

Одним из распространенных способов использования `RefCell<T>` является сочетание его с `Rc<T>`. Назовите, что `Rc<T>` позволяет вам иметь несколько владельцев некоторых данных, но он предоставляет только неизменяемый доступ к этим данным. Если у вас есть `Rc<T>`, который содержит `RefCell<T>`, вы можете получить значение, которое может иметь несколько владельцев _и_ которое вы можете изменять!

Например, вспомните пример списка из Listing 15-18, где мы использовали `Rc<T>`, чтобы позволить нескольким спискам делиться владением другого списка. Поскольку `Rc<T>` хранит только неизменяемые значения, мы не можем изменить любое из значений в списке, после того, как мы его создали. Добавим `RefCell<T>` для его способности изменять значения в списках. Listing 15-24 показывает, что с использованием `RefCell<T>` в определении `Cons` мы можем изменить значение, хранимое во всех списках.

Имя файла: `src/main.rs`

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
  1 let value = Rc::new(RefCell::new(5));

  2 let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

  3 *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

Listing 15-24: Использование `Rc<RefCell<i32>>` для создания `List`, который мы можем изменить

Мы создаем значение, которое является экземпляром `Rc<RefCell<i32>>`, и сохраняем его в переменной с именем `value` \[1\], чтобы мы могли позже напрямую обращаться к нему. Затем мы создаем `List` в `a` с вариантом `Cons`, который содержит `value` \[2\]. Мы должны склонировать `value`, чтобы и `a`, и `value` имели владение внутренним значением `5`, а не передавать владение из `value` в `a` или чтобы `a` заимствовало от `value`.

Мы заключаем список `a` в `Rc<T>`, чтобы когда мы создаем списки `b` и `c`, они оба могли ссылаться на `a`, как мы делали в Listing 15-18.

После того, как мы создали списки в `a`, `b` и `c`, мы хотим добавить 10 к значению в `value` \[3\]. Мы это делаем, вызвав `borrow_mut` на `value`, который использует автоматическое снятие ссылочности, о котором мы говорили в разделе "Где находится оператор -\>?" для снятия ссылочности `Rc<T>` до внутреннего значения `RefCell<T>`. Метод `borrow_mut` возвращает умный указатель `RefMut<T>`, и мы используем оператор снятия ссылочности на нем и изменяем внутреннее значение.

Когда мы выводим `a`, `b` и `c`, мы можем увидеть, что у них все есть измененное значение `15` вместо `5`:

    a after = Cons(RefCell { value: 15 }, Nil)
    b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
    c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))

Этот метод довольно элегантный! С использованием `RefCell<T>` у нас есть внешне неизменяемое значение `List`. Но мы можем использовать методы на `RefCell<T>`, которые предоставляют доступ к его внутренней изменяемости, чтобы мы могли изменить наши данные, когда это необходимо. Время выполнения проверки правил заимствования защищает нас от гонок данных, и иногда стоит потерять немного скорости ради этой гибкости в наших структурах данных. Обратите внимание, что `RefCell<T>` не работает для многопоточного кода! `Mutex<T>` — это потоко-безопасная версия `RefCell<T>`, и мы поговорим о `Mutex<T>` в главе 16.
