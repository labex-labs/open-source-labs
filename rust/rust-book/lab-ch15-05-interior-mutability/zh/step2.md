# 使用 RefCell`<T>` 在运行时强制实施借用规则

与 `Rc<T>` 不同，`RefCell<T>` 类型表示对其持有的数据的单一所有权。那么 `RefCell<T>` 与 `Box<T>` 这样的类型有何不同呢？回忆一下你在第 4 章中学到的借用规则：

- 在任何给定时间，你可以有**一个**可变引用或者任意数量的不可变引用（但不能同时拥有两者）。
- 引用必须始终有效。

对于引用和 `Box<T>`，借用规则的不变性在编译时得到强制实施。对于 `RefCell<T>`，这些不变性在**运行时**得到强制实施。对于引用，如果你违反这些规则，将会得到一个编译时错误。对于 `RefCell<T>`，如果你违反这些规则，你的程序将会恐慌并退出。

在编译时检查借用规则的优点是，错误会在开发过程中更早地被捕获，并且对运行时性能没有影响，因为所有分析都是预先完成的。出于这些原因，在大多数情况下，在编译时检查借用规则是最佳选择，这就是为什么这是 Rust 的默认方式。

而在运行时检查借用规则的优点是，这样可以允许某些内存安全的场景，而这些场景在编译时检查中是不被允许的。像 Rust 编译器这样的静态分析本质上是保守的。代码的某些属性通过分析代码是不可能检测到的：最著名的例子是停机问题，这超出了本书的范围，但却是一个值得研究的有趣话题。

因为有些分析是不可能的，如果 Rust 编译器不能确定代码符合所有权规则，它可能会拒绝一个正确的程序；从这个意义上说，它是保守的。如果 Rust 接受了一个不正确的程序，用户就无法信任 Rust 所提供的保证。然而，如果 Rust 拒绝了一个正确的程序，程序员会感到不便，但不会发生灾难性的事情。当你确定你的代码遵循借用规则但编译器无法理解并保证这一点时，`RefCell<T>` 类型就很有用了。

与 `Rc<T>` 类似，`RefCell<T>` 仅适用于单线程场景，如果你尝试在多线程上下文中使用它，将会得到一个编译时错误。我们将在第 16 章讨论如何在多线程程序中获得 `RefCell<T>` 的功能。

以下是选择 `Box<T>`、`Rc<T>` 或 `RefCell<T>` 的原因总结：

- `Rc<T>` 允许同一数据有多个所有者；`Box<T>` 和 `RefCell<T>` 有单一所有者。
- `Box<T>` 允许在编译时检查不可变或可变借用；`Rc<T>` 只允许在编译时检查不可变借用；`RefCell<T>` 允许在运行时检查不可变或可变借用。
- 因为 `RefCell<T>` 允许在运行时检查可变借用，所以即使 `RefCell<T>` 是不可变的，你也可以变异 `RefCell<T>` 内部的值。

在不可变值内部变异值就是**内部可变性**模式。让我们看一个内部可变性有用的情况，并研究它是如何实现的。
