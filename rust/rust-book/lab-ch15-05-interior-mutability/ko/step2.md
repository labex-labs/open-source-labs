# RefCell`<T>`{=html}을 사용하여 런타임에 차용 규칙 적용하기

`Rc<T>`와 달리, `RefCell<T>` 타입은 보유하고 있는 데이터에 대한 단일 소유권을 나타냅니다. 그렇다면 `RefCell<T>`이 `Box<T>`와 같은 타입과 다른 점은 무엇일까요? 4 장에서 배운 차용 규칙을 기억해 보세요.

- 주어진 시점에 _하나의_ 가변 참조 또는 여러 개의 불변 참조를 가질 수 있습니다 (둘 다는 안 됩니다).
- 참조는 항상 유효해야 합니다.

참조와 `Box<T>`를 사용하면 차용 규칙의 불변성이 컴파일 시간에 적용됩니다. `RefCell<T>`을 사용하면 이러한 불변성이 _런타임에_ 적용됩니다. 참조를 사용하는 경우 이러한 규칙을 위반하면 컴파일러 오류가 발생합니다. `RefCell<T>`을 사용하는 경우 이러한 규칙을 위반하면 프로그램이 패닉 상태가 되어 종료됩니다.

컴파일 시간에 차용 규칙을 확인하는 것의 장점은 개발 프로세스 초기에 오류를 발견할 수 있고, 모든 분석이 사전에 완료되므로 런타임 성능에 영향이 없다는 것입니다. 이러한 이유로 컴파일 시간에 차용 규칙을 확인하는 것이 대부분의 경우 최선의 선택이며, 이것이 Rust 의 기본값입니다.

대신 런타임에 차용 규칙을 확인하는 것의 장점은 컴파일 시간 검사에서 허용되지 않았을 특정 메모리 안전 시나리오를 허용한다는 것입니다. Rust 컴파일러와 같은 정적 분석은 본질적으로 보수적입니다. 코드의 일부 속성은 코드를 분석하여 감지할 수 없습니다. 가장 유명한 예는 이 책의 범위를 벗어나지만 연구할 가치가 있는 흥미로운 주제인 중지 문제 (Halting Problem) 입니다.

일부 분석이 불가능하기 때문에 Rust 컴파일러가 코드가 소유권 규칙을 준수하는지 확신할 수 없는 경우 올바른 프로그램을 거부할 수 있습니다. 이러한 방식으로 보수적입니다. Rust 가 잘못된 프로그램을 허용하면 사용자는 Rust 가 제공하는 보증을 신뢰할 수 없게 됩니다. 그러나 Rust 가 올바른 프로그램을 거부하면 프로그래머는 불편을 겪겠지만 치명적인 일은 발생하지 않습니다. `RefCell<T>` 타입은 코드가 차용 규칙을 따르지만 컴파일러가 이를 이해하고 보장할 수 없는 경우에 유용합니다.

`Rc<T>`와 마찬가지로 `RefCell<T>`는 단일 스레드 시나리오에서만 사용하도록 되어 있으며, 멀티 스레드 컨텍스트에서 사용하려고 하면 컴파일 시간 오류가 발생합니다. 16 장에서 멀티 스레드 프로그램에서 `RefCell<T>`의 기능을 얻는 방법에 대해 이야기할 것입니다.

다음은 `Box<T>`, `Rc<T>`, 또는 `RefCell<T>`를 선택해야 하는 이유에 대한 요약입니다.

- `Rc<T>`는 동일한 데이터의 여러 소유자를 가능하게 합니다. `Box<T>`와 `RefCell<T>`는 단일 소유자를 갖습니다.
- `Box<T>`는 컴파일 시간에 확인되는 불변 또는 가변 차용을 허용합니다. `Rc<T>`는 컴파일 시간에 확인되는 불변 차용만 허용합니다. `RefCell<T>`는 런타임에 확인되는 불변 또는 가변 차용을 허용합니다.
- `RefCell<T>`은 런타임에 확인되는 가변 차용을 허용하므로 `RefCell<T>`이 불변인 경우에도 `RefCell<T>` 내부의 값을 변경할 수 있습니다.

불변 값 내부의 값을 변경하는 것이 _내부 가변성 (interior mutability)_ 패턴입니다. 내부 가변성이 유용한 상황을 살펴보고 어떻게 가능한지 살펴보겠습니다.
