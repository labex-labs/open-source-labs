# 内部可変性：不変値への可変借用

借用規則の結果、不変値を持っている場合、それを可変的に借用することはできません。たとえば、このコードはコンパイルされません。

ファイル名：`src/main.rs`

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

このコードをコンパイルしようとすると、次のエラーが表示されます。

```bash
error[E0596]: cannot borrow `x` as mutable, as it is not declared
as mutable
 --> src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &mut x;
  |             ^^^^^^ cannot borrow as mutable
```

ただし、値がそのメソッド内で自身を変更することが役立つ場合でも、他のコードには不変であるように見える状況があります。値のメソッドの外のコードは、値を変更することはできません。`RefCell<T>` を使用することは、内部可変性を持つ能力を得るための1つの方法ですが、`RefCell<T>` は借用規則を完全に回避するわけではありません。コンパイラの借用チェッカーはこの内部可変性を許可し、借用規則は実行時にチェックされます。規則に違反すると、コンパイラエラーではなく `panic!` が発生します。

`RefCell<T>` を使って不変値を変更する実際の例を見てみましょう。そして、それがなぜ役立つのかを理解しましょう。
