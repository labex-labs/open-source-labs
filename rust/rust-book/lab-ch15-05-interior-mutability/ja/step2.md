# RefCell`<T>` を使って実行時に借用規則を強制する

`Rc<T>` とは異なり、`RefCell<T>` 型は保持するデータの単一所有権を表します。では、`RefCell<T>` が `Box<T>` のような型とどのように異なるのでしょうか。第 4 章で学んだ借用規則を思い出してみてください。

- 任意の時点で、可変参照を 1 つまたは不変参照を複数持つことができます（両方はできません）。
- 参照は常に有効でなければなりません。

参照と `Box<T>` では、借用規則の不変性はコンパイル時に強制されます。`RefCell<T>` では、これらの不変性は実行時に強制されます。参照の場合、これらの規則を破るとコンパイラエラーが発生します。`RefCell<T>` の場合、これらの規則を破ると、プログラムはパニックになり、終了します。

コンパイル時に借用規則をチェックする利点は、開発プロセスでエラーを早期にキャッチできることであり、すべての分析が事前に完了するため、実行時のパフォーマンスに影響がないことです。これらの理由から、コンパイル時に借用規則をチェックすることは、ほとんどの場合で最善の選択であり、これが Rust のデフォルトである理由です。

代わりに実行時に借用規則をチェックする利点は、コンパイル時のチェックで禁止されていた場合でも、特定のメモリセーフなシナリオが許可されることです。Rust コンパイラのような静的分析は、本質的に保守的です。コードの一部のプロパティは、コードを分析することで検出することができません。最も有名な例は停止問題であり、本書の範囲を超えていますが、研究する興味深いトピックです。

一部の分析が不可能なため、Rust コンパイラがコードが所有権規則に準拠していることを確信できない場合、正しいプログラムを拒否する可能性があります。このように、保守的なのです。Rust が不正なプログラムを受け入れる場合、ユーザーは Rust が提供する保証を信頼できなくなります。ただし、Rust が正しいプログラムを拒否する場合、プログラマーは不便になりますが、何ら災害的なことは起こりません。`RefCell<T>` 型は、コードが借用規則に従っていることを確信しているが、コンパイラが理解して保証できない場合に便利です。

`Rc<T>` と同様に、`RefCell<T>` は単一スレッドのシナリオでのみ使用でき、マルチスレッドコンテキストで使用しようとするとコンパイル時エラーが発生します。第 16 章で、マルチスレッドプログラムで `RefCell<T>` の機能を得る方法について説明します。

以下は、`Box<T>`、`Rc<T>`、または `RefCell<T>` を選ぶ理由のまとめです。

- `Rc<T>` は同じデータの複数の所有者を可能にします。`Box<T>` と `RefCell<T>` は単一の所有者を持ちます。
- `Box<T>` はコンパイル時にチェックされる不変または可変借用を許可します。`Rc<T>` はコンパイル時にチェックされる不変借用のみを許可します。`RefCell<T>` は実行時にチェックされる不変または可変借用を許可します。
- `RefCell<T>` は実行時にチェックされる可変借用を許可するため、`RefCell<T>` が不変である場合でも、`RefCell<T>` 内の値を変更できます。

不変値の中の値を変更することは、**内部可変性** パターンです。内部可変性が役立つ状況を見て、それがどのように可能かを調べてみましょう。
