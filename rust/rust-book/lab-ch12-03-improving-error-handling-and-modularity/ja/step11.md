# run 関数からのエラーの返却

残りのプログラムロジックを`run`関数に分離することで、エラーハンドリングを改善することができます。これは、リスト 12-9 で`Config::build`を行ったようにです。何か問題が起こったときに`expect`を呼び出すことでプログラムをパニックにさせる代わりに、`run`関数はエラーが発生したときに`Result<T, E>`を返します。これにより、エラー処理をユーザーにとって親切な方法で`main`にさらに統合することができます。リスト 12-12 には、`run`のシグネチャと本体に対して行う必要がある変更を示しています。

ファイル名：`src/main.rs`

```rust
1 use std::error::Error;

--snip--

2 fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)3?;

    println!("With text:\n{contents}");

  4 Ok(())
}
```

リスト 12-12: `Result`を返すように`run`関数を変更する

ここでは 3 つの大きな変更を行っています。まず、`run`関数の返却型を`Result<(), Box<dyn Error>>`に変更しました\[2\]。この関数は以前、ユニット型`()`を返していましたが、`Ok`の場合に返される値としてこれを維持しています。

エラー型については、トレイトオブジェクト`Box<dyn Error>`を使用しました（トップの`use`文で`std::error::Error`をスコープ内に持ち込んでいます\[1\]）。第 17 章でトレイトオブジェクトについて説明します。今のところ、`Box<dyn Error>`は関数が`Error`トレイトを実装する型を返すことを意味するだけで、返り値がどのような特定の型であるかを指定する必要はありません。これにより、異なるエラーケースで異なる型のエラー値を返す柔軟性が得られます。`dyn`キーワードは「動的」の略です。

第二に、第 9 章で説明したように、`expect`の呼び出しを`?`演算子に置き換えました\[3\]。エラーが発生したときに`panic!`する代わりに、`?`は呼び出し元が処理するために現在の関数からエラー値を返します。

第三に、`run`関数は成功した場合に`Ok`値を返します\[4\]。シグネチャで`run`関数の成功型を`()`と宣言しているため、ユニット型の値を`Ok`値でラップする必要があります。この`Ok(())`構文は最初は少々奇妙に見えるかもしれませんが、このように`()`を使用するのは、副作用のためだけに`run`を呼び出していることを示す慣用的な方法です。返り値は必要なものではありません。

このコードを実行すると、コンパイルは成功しますが、警告が表示されます。

    warning: unused `Result` that must be used
      --> src/main.rs:19:5
       |
    19 |     run(config);
       |     ^^^^^^^^^^^^
       |
       = note: `#[warn(unused_must_use)]` on by default
       = note: this `Result` may be an `Err` variant, which should be
    handled

Rust は、コードが`Result`値を無視しており、`Result`値がエラーが発生したことを示す可能性があることを教えてくれます。しかし、エラーが発生したかどうかを確認しておらず、コンパイラがここにエラー処理コードが必要だったはずだと思い返させてくれます！では、この問題を解決しましょう。
