# Refactoring to Improve Modularity and Error Handling

Um unser Programm zu verbessern, werden wir vier Probleme beheben, die mit der Struktur des Programms und der Art und Weise zusammenhängen, wie es potenzielle Fehler behandelt. Erstens führt unsere `main`-Funktion derzeit zwei Aufgaben aus: Sie analysiert Argumente und liest Dateien. Wenn sich unser Programm erweitert, wird die Anzahl der einzelnen Aufgaben, die die `main`-Funktion behandelt, zunehmen. Je mehr Verantwortungen eine Funktion übernimmt, desto schwieriger wird es, über sie nachzudenken, zu testen und zu ändern, ohne einen ihrer Teile zu zerstören. Es ist am besten, die Funktionalität zu trennen, sodass jede Funktion für eine Aufgabe verantwortlich ist.

Dieses Problem hängt auch mit dem zweiten Problem zusammen: Obwohl `query` und `file_path` Konfigurationsvariablen für unser Programm sind, werden Variablen wie `contents` verwendet, um die Logik des Programms auszuführen. Je länger `main` wird, desto mehr Variablen müssen wir in den Geltungsbereich bringen; je mehr Variablen wir im Geltungsbereich haben, desto schwieriger wird es, den Zweck jeder einzelnen zu verfolgen. Es ist am besten, die Konfigurationsvariablen in eine Struktur zu gruppieren, um ihren Zweck klar zu machen.

Das dritte Problem ist, dass wir `expect` verwendet haben, um eine Fehlermeldung auszugeben, wenn das Lesen der Datei fehlschlägt, aber die Fehlermeldung druckt lediglich `Should have been able to read the file`. Ein Dateizugriff kann auf verschiedene Weise fehlschlagen: Beispielsweise kann die Datei fehlen oder wir haben möglicherweise keine Berechtigung, sie zu öffnen. Im Moment würden wir unabhängig von der Situation für alles die gleiche Fehlermeldung ausgeben, was dem Benutzer keine Informationen liefern würde!

Viertens verwenden wir `expect` wiederholt, um verschiedene Fehler zu behandeln, und wenn der Benutzer unser Programm ausführt, ohne genug Argumente anzugeben, erhält er einen `index out of bounds`-Fehler von Rust, der das Problem nicht klar erklärt. Es wäre am besten, wenn all der Fehlerbehandlungs-Code an einem Ort wäre, sodass zukünftige Wartende nur an einem Ort nachschlagen müssten, wenn die Fehlerbehandlungslogik geändert werden musste. Dass all der Fehlerbehandlungs-Code an einem Ort ist, gewährleistet auch, dass wir Nachrichten ausgeben, die für unsere Endbenutzer sinnvoll sind.

Lassen Sie uns diese vier Probleme durch Umstrukturierung unseres Projekts ansprechen.
