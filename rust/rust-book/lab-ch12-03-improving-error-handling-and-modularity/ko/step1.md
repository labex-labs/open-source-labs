# 모듈성 및 오류 처리를 개선하기 위한 리팩토링

프로그램을 개선하기 위해 프로그램의 구조와 잠재적인 오류를 처리하는 방식과 관련된 네 가지 문제를 해결할 것입니다. 먼저, 현재 `main` 함수는 두 가지 작업을 수행합니다: 인수를 구문 분석하고 파일을 읽습니다. 프로그램이 커짐에 따라 `main` 함수가 처리하는 개별 작업의 수가 증가할 것입니다. 함수가 책임을 얻을수록 추론하기가 더 어려워지고, 테스트하기가 더 어려워지며, 구성 요소 중 하나를 손상시키지 않고 변경하기가 더 어려워집니다. 각 함수가 하나의 작업을 담당하도록 기능을 분리하는 것이 가장 좋습니다.

이 문제는 두 번째 문제와도 관련이 있습니다. `query`와 `file_path`는 프로그램의 구성 변수이지만, `contents`와 같은 변수는 프로그램의 로직을 수행하는 데 사용됩니다. `main`이 길어질수록 범위 내에 더 많은 변수를 가져와야 합니다. 범위 내에 변수가 많을수록 각 변수의 목적을 추적하기가 더 어려워집니다. 구성 변수를 하나의 구조로 그룹화하여 그 목적을 명확하게 하는 것이 가장 좋습니다.

세 번째 문제는 파일 읽기에 실패했을 때 오류 메시지를 출력하기 위해 `expect`를 사용했지만, 오류 메시지는 단순히 `Should have been able to read the file`을 출력한다는 것입니다. 파일을 읽는 것은 여러 가지 방식으로 실패할 수 있습니다. 예를 들어, 파일이 없거나 파일을 열 권한이 없을 수 있습니다. 현재 상황에 관계없이 모든 것에 대해 동일한 오류 메시지를 출력하므로 사용자에게 어떤 정보도 제공하지 않습니다!

네 번째로, 서로 다른 오류를 처리하기 위해 `expect`를 반복적으로 사용하며, 사용자가 충분한 인수를 지정하지 않고 프로그램을 실행하면 문제점을 명확하게 설명하지 않는 Rust 의 `index out of bounds` 오류가 발생합니다. 모든 오류 처리 코드가 한 곳에 있으면 향후 유지 관리자가 오류 처리 로직을 변경해야 할 경우 코드를 참조할 곳이 하나만 있으므로 가장 좋습니다. 모든 오류 처리 코드를 한 곳에 두면 최종 사용자에게 의미 있는 메시지를 출력할 수 있습니다.

프로젝트를 리팩토링하여 이 네 가지 문제를 해결해 보겠습니다.
