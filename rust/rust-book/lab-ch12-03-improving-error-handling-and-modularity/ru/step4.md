# Grouping Configuration Values

Мы можем сделать еще один маленький шаг для дальнейшего улучшения функции `parse_config`. В настоящее время мы возвращаем кортеж, но затем сразу снова разбиваем этот кортеж на отдельные части. Это признак того, что возможно, у нас еще нет правильной абстракции.

Еще один показатель, который свидетельствует о том, что есть возможность для улучшения, — это часть `config` в `parse_config`, которая подразумевает, что два значения, которые мы возвращаем, связаны и являются частью одного значения конфигурации. Мы в настоящее время не передаем это значение в структуре данных, кроме того, как группируя два значения в кортеж; вместо этого мы поместим два значения в одну структуру и дадим каждому полю структуры осмысленное имя. Это упростит будущим разработчикам этого кода понять, как разные значения связаны друг с другом и каково их назначение.

Listing 12-6 показывает улучшения функции `parse_config`.

Filename: `src/main.rs`

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

  1 let config = parse_config(&args);

    println!("Searching for {}", 2 config.query);
    println!("In file {}", 3 config.file_path);

    let contents = fs::read_to_string(4 config.file_path)
       .expect("Should have been able to read the file");

    --snip--
}

5 struct Config {
    query: String,
    file_path: String,
}

6 fn parse_config(args: &[String]) -> Config {
  7 let query = args[1].clone();
  8 let file_path = args[2].clone();

    Config { query, file_path }
}
```

Listing 12-6: Refactoring `parse_config` to return an instance of a `Config` struct

Мы добавили структуру под названием `Config`, определенную с полями `query` и `file_path` \[5\]. Сигнатура `parse_config` теперь указывает, что она возвращает значение `Config` \[6\]. В теле `parse_config`, где мы раньше возвращали срезы строк, которые ссылались на значения `String` в `args`, мы теперь определяем `Config`, чтобы содержать собственные значения `String`. Переменная `args` в `main` является владельцем значений аргументов и позволяет только функции `parse_config` их заимствовать, что означает, что мы нарушим правила заимствования Rust, если `Config` попытается взять владение значениями в `args`.

Существует несколько способов управления данными `String`; самый простой, хотя и несколько неэффективный, путь — вызвать метод `clone` на значениях \[7\] \[8\]. Это создаст полную копию данных для экземпляра `Config` для его владения, что требует больше времени и памяти, чем хранение ссылки на данные строки. Однако клонирование данных также делает наш код очень простым, потому что мы не должны управлять временем жизни ссылок; в этом случае потеря немного производительности ради упрощения — это целесообразный компромисс.

> **The Trade-Offs of Using clone**
>
> Среди многих Rustaceans есть тенденция избегать использования `clone` для решения проблем с владением, из-за его издержек во время выполнения. В главе 13 вы узнаете, как использовать более эффективные методы в этом типе ситуаций. Но на данный момент можно скопировать несколько строк, чтобы продолжить продвигаться вперед, потому что вы создадите эти копии только один раз, и ваш путь к файлу и строка запроса очень маленькие. Лучше иметь рабощую программу, которая немного неэффективна, чем пытаться сверхоптимизировать код с первого раза. Чем более опытным вы становитесь в Rust, тем легче начать с наиболее эффективного решения, но на данный момент вполне приемлемо вызывать `clone`.

Мы обновили `main`, чтобы он поместил экземпляр `Config`, возвращаемый `parse_config`, в переменную с именем `config` \[1\], и мы обновили код, который ранее использовал отдельные переменные `query` и `file_path`, так чтобы он теперь использовал поля на структуре `Config` вместо них \[2\] \[3\] \[4\].

Теперь наш код более явно сообщает, что `query` и `file_path` связаны и что их назначение — настроить, как будет работать программа. Любой код, который использует эти значения, знает, где их найти в экземпляре `config` в полях, названных по их назначению.
