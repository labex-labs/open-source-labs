# Calling Config::build and Handling Errors

Для обработки ошибочного случая и вывода пользователь-friendly сообщения нам нужно обновить `main`, чтобы обработать `Result`, возвращаемое `Config::build`, как показано в Listing 12-10. Мы также возьмем на себя ответственность выхода из командной строки с ненулевым кодом ошибки вместо `panic!` и вместо этого реализуем ее вручную. Ненулевой статус выхода - это соглашение, которое сигнализирует процессу, вызвавшему нашу программу, что программа завершилась с ошибкой.

Filename: `src/main.rs`

```rust
1 use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

  2 let config = Config::build(&args).3 unwrap_or_else(|4 err| {
      5 println!("Problem parsing arguments: {err}");
      6 process::exit(1);
    });

    --snip--
```

Listing 12-10: Exiting with an error code if building a `Config` fails

В этом списке мы использовали метод, о котором мы еще не говорили в деталях: `unwrap_or_else`, который определен для `Result<T, E>` стандартной библиотекой \[2\]. Использование `unwrap_or_else` позволяет нам определить некоторую пользовательскую обработку ошибок, отличную от `panic!`. Если `Result` - это значение `Ok`, поведение этого метода похоже на `unwrap`: он возвращает внутреннее значение, которое оборачивается в `Ok`. Однако, если значение - это `Err`, этот метод вызывает код в _замыкании_, которое представляет собой анонимную функцию, которую мы определяем и передаем в качестве аргумента в `unwrap_or_else` \[3\]. Мы рассмотрим замыкания более подробно в главе 13. На данный момент вам просто нужно знать, что `unwrap_or_else` передаст внутреннее значение `Err`, которое в этом случае - это статическая строка `"not enough arguments"`, которую мы добавили в Listing 12-9, в наше замыкание в аргументе `err`, который находится между вертикальными полосами \[4\]. Код в замыкании может затем использовать значение `err` при выполнении.

Мы добавили новую строку `use`, чтобы импортировать `process` из стандартной библиотеки в область видимости \[1\]. Код в замыкании, который будет выполняться в случае ошибки, состоит всего из двух строк: мы выводим значение `err` \[5\], а затем вызываем `process::exit` \[6\]. Функция `process::exit` немедленно остановит программу и вернет число, которое было передано в качестве кода статуса выхода. Это похоже на обработку, основанную на `panic!`, которую мы использовали в Listing 12-8, но теперь мы не получаем все дополнительный вывод. Попробуем:

```bash
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
```

Отлично! Этот вывод намного дружелюбнее для наших пользователей.
