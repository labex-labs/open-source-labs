# Returning Errors from the run Function

После того, как оставшаяся логика программы была разделена на функцию `run`, мы можем улучшить обработку ошибок, как мы это сделали с `Config::build` в Listing 12-9. Вместо того, чтобы программа завершалась с ошибкой при вызове `expect`, функция `run` будет возвращать `Result<T, E>`, когда что-то идет не так. Это позволит нам дальнейше сосредоточить логику обработки ошибок в `main` в user-friendly-стиле. Listing 12-12 показывает изменения, которые нам нужно внести в сигнатуру и тело `run`.

Filename: `src/main.rs`

```rust
1 use std::error::Error;

--snip--

2 fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.file_path)3?;

    println!("With text:\n{contents}");

  4 Ok(())
}
```

Listing 12-12: Changing the `run` function to return `Result`

Мы внесли три важных изменения здесь. Во-первых, мы изменили возвращаемый тип функции `run` на `Result<(), Box<dyn Error>>` \[2\]. Эта функция ранее возвращала единичный тип, `()`, и мы сохраняем его в качестве значения, возвращаемого в случае `Ok`.

Для типа ошибки мы использовали _объект-примесь_ `Box<dyn Error>` (и мы импортировали `std::error::Error` в область видимости с помощью `use` в начале файла \[1\]). Мы рассмотрим объекты-примеси в главе 17. На данный момент просто запомните, что `Box<dyn Error>` означает, что функция будет возвращать тип, реализующий трейт `Error`, но мы не обязаны указывать, какой конкретный тип будет значением возврата. Это дает нам гибкость при возврате значений ошибок, которые могут быть разных типов в разных случаях ошибок. Ключевое слово `dyn` - это сокращение от _dynamic_.

Во-вторых, мы удалили вызов `expect` в пользу оператора `?` \[3\], как мы обсуждали в главе 9. Вместо того, чтобы завершаться с ошибкой при ошибке, `?` вернет значение ошибки из текущей функции для обработки вызывающим кодом.

В-третьих, функция `run` теперь возвращает значение `Ok` в случае успеха \[4\]. Мы объявили тип успеха функции `run` как `()` в сигнатуре, что означает, что мы должны обернуть значение единичного типа в значение `Ok`. Синтаксис `Ok(())` может показаться немного странным вначале, но использование `()` именно так - это идиоматичный способ указать, что мы вызываем `run` только для его побочных эффектов; она не возвращает значение, которое нам нужно.

Когда вы запустите этот код, он скомпилируется, но будет показывать предупреждение:

    warning: unused `Result` that must be used
      --> src/main.rs:19:5
       |
    19 |     run(config);
       |     ^^^^^^^^^^^^
       |
       = note: `#[warn(unused_must_use)]` on by default
       = note: this `Result` may be an `Err` variant, which should be
    handled

Rust сообщает нам, что наш код игнорирует значение `Result`, и значение `Result` может указывать на то, что произошла ошибка. Но мы не проверяем, было ли ошибка или нет, и компилятор напоминает нам, что мы, вероятно, хотели здесь написать некоторый код обработки ошибок! Давайте исправим эту проблему сейчас.
