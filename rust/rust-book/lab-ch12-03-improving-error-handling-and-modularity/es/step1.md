# Refactoring para Mejorar la Modularidad y el Manejo de Errores

Para mejorar nuestro programa, solucionaremos cuatro problemas relacionados con la estructura del programa y cómo maneja errores potenciales. Primero, nuestra función `main` ahora realiza dos tareas: analiza los argumentos y lee archivos. A medida que nuestro programa crece, el número de tareas separadas que la función `main` maneja aumentará. A medida que una función adquiere responsabilidades, se vuelve más difícil de razonar, más difícil de probar y más difícil de cambiar sin romper una de sus partes. Es mejor separar la funcionalidad para que cada función sea responsable de una tarea.

Este problema también está relacionado con el segundo problema: aunque `query` y `file_path` son variables de configuración para nuestro programa, variables como `contents` se utilizan para realizar la lógica del programa. A medida que `main` se vuelva más larga, necesitaremos traer más variables al ámbito; entre más variables tengamos en el ámbito, más difícil será mantener un seguimiento del propósito de cada una. Es mejor agrupar las variables de configuración en una estructura para que su propósito quede claro.

El tercer problema es que hemos utilizado `expect` para imprimir un mensaje de error cuando falla la lectura del archivo, pero el mensaje de error solo imprime `Should have been able to read the file`. La lectura de un archivo puede fallar de varias maneras: por ejemplo, el archivo podría faltar, o es posible que no tengamos permiso para abrirlos. En este momento, independientemente de la situación, imprimiríamos el mismo mensaje de error para todo, lo que no daría ninguna información al usuario.

En cuarto lugar, usamos `expect` repetidamente para manejar diferentes errores, y si el usuario ejecuta nuestro programa sin especificar suficientes argumentos, obtendrá un error de `índice fuera de los límites` de Rust que no explica claramente el problema. Lo mejor sería que todo el código de manejo de errores estuviera en un solo lugar para que los futuros mantenedores tuvieran solo un lugar donde consultar el código si la lógica de manejo de errores necesitara cambiar. Tener todo el código de manejo de errores en un solo lugar también garantizará que estemos imprimiendo mensajes que serán significativos para nuestros usuarios finales.

Vamos a abordar estos cuatro problemas refactorizando nuestro proyecto.
