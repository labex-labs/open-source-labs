# Refactoring to Improve Modularity and Error Handling

Pour améliorer notre programme, nous allons corriger quatre problèmes liés à la structure du programme et à la manière dont il gère les erreurs potentielles. Tout d'abord, notre fonction `main` effectue actuellement deux tâches : elle analyse les arguments et lit les fichiers. Au fur et à mesure que notre programme grandit, le nombre de tâches distinctes que la fonction `main` gère augmentera. Lorsqu'une fonction prend plus de responsabilités, il devient plus difficile de raisonner sur elle, plus difficile à tester et plus difficile à modifier sans casser l'une de ses parties. Il est préférable de séparer les fonctionnalités de sorte que chaque fonction soit responsable d'une seule tâche.

Ce problème est également lié au second problème : bien que `query` et `file_path` soient des variables de configuration pour notre programme, des variables telles que `contents` sont utilisées pour exécuter la logique du programme. Plus `main` devient longue, plus de variables devront être portées dans la portée ; plus de variables nous avons dans la portée, plus il sera difficile de suivre le but de chacune d'entre elles. Il est préférable de regrouper les variables de configuration dans une seule structure pour clarifier leur but.

Le troisième problème est que nous avons utilisé `expect` pour afficher un message d'erreur lorsque la lecture du fichier échoue, mais le message d'erreur affiche simplement `Should have been able to read the file`. La lecture d'un fichier peut échouer de plusieurs manières : par exemple, le fichier peut être manquant, ou nous n'aurons peut-être pas les autorisations pour l'ouvrir. En l'état, indépendamment de la situation, nous afficherions le même message d'erreur pour tout, ce qui ne donnerait aucun renseignement à l'utilisateur!

Quatrièmement, nous utilisons `expect` de manière répétée pour gérer différents types d'erreurs, et si l'utilisateur exécute notre programme sans spécifier suffisamment d'arguments, il recevra une erreur `index out of bounds` de Rust qui n'explique pas clairement le problème. Il serait préférable que tout le code de gestion des erreurs soit réuni en un seul endroit afin que les futurs maintaineurs n'aient qu'un seul endroit où consulter le code si la logique de gestion des erreurs devait être modifiée. Rassembler tout le code de gestion des erreurs en un seul endroit garantira également que nous affichons des messages qui seront significatifs pour nos utilisateurs finaux.

Essayons de résoudre ces quatre problèmes en refactorisant notre projet.
