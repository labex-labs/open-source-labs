# Associated Types

_Associated types_ связывают тип-заполнитель с треитом таким образом, чтобы определения методов трейта могли использовать эти типы-заполнители в своих сигнатурах. Реализатор трейта будет указывать конкретный тип, который будет использоваться вместо типа-заполнителя для конкретной реализации. Таким образом, мы можем определить трейт, который использует некоторые типы, не зная точно, какие именно типы это будут, пока трейт не будет реализован.

Мы описывали большинство продвинутых функций в этом разделе как редко используемых. Associated types находятся где-то посередине: они используются реже, чем функции, описанные в остальной части книги, но чаще, чем многие другие функции, обсуждаемые в этом разделе.

Одним примером трейта с ассоциированным типом является трейт `Iterator`, предоставляемый стандартной библиотекой. Ассоциированный тип называется `Item` и представляет собой тип значений, по которым итерируется тип, реализующий трейт `Iterator`. Определение трейта `Iterator` показано в Listing 19-12.

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

Listing 19-12: Определение трейта `Iterator`, имеющего ассоциированный тип `Item`

Тип `Item` является заполнителем, и определение метода `next` показывает, что он будет возвращать значения типа `Option<Self::Item>`. Реализаторы трейта `Iterator` будут указывать конкретный тип для `Item`, и метод `next` будет возвращать `Option`, содержащий значение этого конкретного типа.

Associated types могут показаться похожим на обобщения, в том смысле, что вторые позволяют нам определить функцию без указания типов, которые она может обрабатывать. Чтобы рассмотреть разницу между двумя концепциями, мы рассмотрим реализацию трейта `Iterator` для типа `Counter`, который задает тип `Item` как `u32`:

Filename: `src/lib.rs`

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        --snip--
```

Этот синтаксис похож на синтаксис обобщений. Почему же не определить трейт `Iterator` с использованием обобщений, как показано в Listing 19-13?

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

Listing 19-13: Гипотетическое определение трейта `Iterator` с использованием обобщений

Разница заключается в том, что при использовании обобщений, как в Listing 19-13, мы должны аннотировать типы в каждой реализации; так как мы также можем реализовать `Iterator<``String``> для Counter` или для любого другого типа, у нас может быть несколько реализаций `Iterator` для `Counter`. Другими словами, когда у трейта есть обобщенный параметр, его можно реализовать для типа несколько раз, меняя конкретные типы обобщенных типовых параметров каждый раз. Когда мы используем метод `next` для `Counter`, мы должны указать аннотации типов, чтобы указать, какую реализацию `Iterator` мы хотим использовать.

При использовании ассоциированных типов мы не должны аннотировать типы, потому что мы не можем реализовать трейт для типа несколько раз. В Listing 19-12 с определением, которое использует ассоциированные типы, мы можем выбрать, какой будет тип `Item` только один раз, потому что может быть только одна реализация `Iterator для Counter`. Мы не должны указывать, что мы хотим итератор значений `u32` везде, где мы вызываем `next` для `Counter`.

Ассоциированные типы также становятся частью контракта трейта: реализаторы трейта должны предоставить тип, чтобы заменить тип-заполнитель ассоциированного типа. Ассоциированные типы часто имеют имя, которое описывает, как тип будет использоваться, и документирование ассоциированного типа в API-документации - хороший практика.
