# Использование шаблона newtype для реализации внешних трейтов

В разделе "Реализация трейта для типа" мы упоминали правило сироты, согласно которому мы можем реализовать трейт для типа только в том случае, если либо трейт, либо тип, или оба они локальны для нашего пакета. С помощью _шаблона newtype_ можно обойти это ограничение, который заключается в создании нового типа в кортежной структуре. (Мы рассматривали кортежные структуры в разделе "Использование кортежных структур без именованных полей для создания различных типов".) Кортежная структура будет иметь одно поле и будет тонкой оберткой вокруг типа, для которого мы хотим реализовать трейт. Затем обертка типа будет локальной для нашего пакета, и мы сможем реализовать трейт для обертки. _Newtype_ - это термин, который произошел от языка программирования Haskell. Использование этого шаблона не влечет за собой штраф в производительности времени выполнения, и обертка типа удаляется на этапе компиляции.

В качестве примера допустим, что мы хотим реализовать `Display` для `Vec<T>`, что правило сироты не позволяет сделать напрямую, так как трейт `Display` и тип `Vec<T>` определены вне нашего пакета. Мы можем создать структуру `Wrapper`, которая будет содержать экземпляр `Vec<T>`; затем мы сможем реализовать `Display` для `Wrapper` и использовать значение `Vec<T>`, как показано в Listing 19-23.

Filename: `src/main.rs`

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![
        String::from("hello"),
        String::from("world"),
    ]);
    println!("w = {w}");
}
```

Listing 19-23: Создание типа `Wrapper` вокруг `Vec<String>` для реализации `Display`

Реализация `Display` использует `self.0` для доступа к внутреннему `Vec<T>`, так как `Wrapper` - это кортежная структура, а `Vec<T>` - это элемент с индексом 0 в кортеже. Затем мы можем использовать функциональность типа `Display` для `Wrapper`.

Недостатком использования этой техники является то, что `Wrapper` - это новый тип, поэтому у него нет методов значения, которое он хранит. Мы должны были бы реализовать все методы `Vec<T>` непосредственно для `Wrapper`, чтобы методы делегировали `self.0`, что позволило бы нам обращаться с `Wrapper` точно так же, как с `Vec<T>`. Если мы хотели, чтобы новый тип имел все методы внутреннего типа, то реализация трейта `Deref` для `Wrapper` для возврата внутреннего типа была бы решением (мы обсуждали реализацию трейта `Deref` в разделе "Работа с умными указателями как с обычными ссылками с помощью Deref"). Если мы не хотели, чтобы тип `Wrapper` имел все методы внутреннего типа - например, чтобы ограничить поведение типа `Wrapper` - мы должны были бы реализовать только те методы, которые мы действительно хотим, вручную.

Этот шаблон newtype также полезен даже в том случае, если не涉及 трейтов. Переключимся на другие аспекты и рассмотрим некоторые более продвинутые способы взаимодействия с типовой системой Rust.
