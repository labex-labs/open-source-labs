# Default Generic Type Parameters and Operator Overloading

Когда мы используем обобщенные типовые параметры, мы можем указать по умолчанию конкретный тип для обобщенного типа. Это устраняет необходимость у реализаторов трейта указывать конкретный тип, если по умолчанию подходит. Вы указываете тип по умолчанию при объявлении обобщенного типа с использованием синтаксиса `<`PlaceholderType`=`ConcreteType`>`.

Отличный пример ситуации, когда эта техника полезна, - это _перегрузка операторов_, при которой вы настраиваете поведение оператора (например, `+`) в определенных ситуациях.

Rust не позволяет создавать собственные операторы или перегружать произвольные операторы. Однако вы можете перегрузить операции и соответствующие трейты, перечисленные в `std::ops`, реализовав трейты, связанные с оператором. Например, в Listing 19-14 мы перегружаем оператор `+` для сложения двух экземпляров `Point`. Мы это делаем, реализовав трейт `Add` для структуры `Point`.

Filename: `src/main.rs`

```rust
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
```

Listing 19-14: Реализация трейта `Add` для перегрузки оператора `+` для экземпляров `Point`

Метод `add` складывает значения `x` двух экземпляров `Point` и значения `y` двух экземпляров `Point` для создания нового `Point`. Трейт `Add` имеет ассоциированный тип с именем `Output`, который определяет тип, возвращаемый методом `add`.

Обобщенный тип по умолчанию в этом коде находится внутри трейта `Add`. Вот его определение:

    trait Add<Rhs=Self> {
        type Output;

        fn add(self, rhs: Rhs) -> Self::Output;
    }

Этот код, вероятно, будет выглядеть знакомым: трейт с одним методом и ассоциированным типом. Новая часть - это `Rhs=Self`: этот синтаксис называется _параметрами типа по умолчанию_. Обобщенный тип параметр `Rhs` (краткая форма от "right-hand side") определяет тип параметра `rhs` в методе `add`. Если мы не укажем конкретный тип для `Rhs` при реализации трейта `Add`, тип `Rhs` будет по умолчанию равен `Self`, который будет типом, для которого мы реализуем `Add`.

Когда мы реализовывали `Add` для `Point`, мы использовали значение по умолчанию для `Rhs`, потому что мы хотели сложить два экземпляра `Point`. Посмотрим на пример реализации трейта `Add`, где мы хотим настроить тип `Rhs` вместо использования значения по умолчанию.

У нас есть две структуры, `Millimeters` и `Meters`, хранящие значения в разных единицах измерения. Эта тонкая обертка существующего типа в другой структуре называется _шаблоном newtype_, о котором мы говорим более подробно в разделе "Using the Newtype Pattern to Implement External Traits on External Types". Мы хотим добавить значения в миллиметрах к значениям в метрах и чтобы реализация `Add` корректно выполняла преобразование. Мы можем реализовать `Add` для `Millimeters` с `Meters` в качестве `Rhs`, как показано в Listing 19-15.

Filename: `src/lib.rs`

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

Listing 19-15: Реализация трейта `Add` для `Millimeters` для сложения `Millimeters` и `Meters`

Для сложения `Millimeters` и `Meters` мы указываем `impl Add<Meters>` для установки значения параметра типа `Rhs` вместо использования значения по умолчанию `Self`.

Вы будете использовать параметры типа по умолчанию в двух основных случаях:

1.  Чтобы расширить тип без изменения существующего кода
2.  Чтобы позволить настройке в определенных случаях, которые большинство пользователей не будут использовать

Стандартная библиотека `Add` - это пример второго случая: обычно вы будете добавлять два похожих типа, но трейт `Add` позволяет настроить поведение за пределами этого. Использование параметра типа по умолчанию в определении трейта `Add` означает, что вы не должны указывать дополнительный параметр в большинстве случаев. Другими словами, не требуется немного boilerplate кода, что делает использование трейта проще.

Первый случай похож на второй, но наоборот: если вы хотите добавить параметр типа к существующему трейту, вы можете задать ему значение по умолчанию, чтобы позволить расширить функциональность трейта без изменения существующего кода реализации.
