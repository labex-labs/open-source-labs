# 外部のトレイトを実装するためのニュータイプパターンの使用

「型に対するトレイトの実装」の項で、トレイトまたは型のどちらか一方、または両方が私たちのクレートにローカルである場合にのみ、型に対してトレイトを実装することが許されるという孤立則に言及しました。この制限を回避する方法として、*ニュータイプパターン*を使用することができます。これは、タプル構造体で新しい型を作成することを含みます。（「名前付きフィールドなしのタプル構造体を使用して異なる型を作成する」の項でタプル構造体について説明しました。）タプル構造体は1つのフィールドを持ち、トレイトを実装したい型を薄くラップします。そして、ラッパー型は私たちのクレートにローカルであり、ラッパーに対してトレイトを実装することができます。「ニュータイプ」は、Haskellプログラミング言語に由来する用語です。このパターンを使用することによる実行時のパフォーマンスペナルティはありませんし、ラッパー型はコンパイル時に省略されます。

例として、`Display`を`Vec<T>`に実装したいとしましょう。孤立則により、直接実装することができません。なぜなら、`Display`トレイトと`Vec<T>`型は私たちのクレートの外で定義されているからです。`Vec<T>`のインスタンスを保持する`Wrapper`構造体を作成することができます。そして、`Wrapper`に対して`Display`を実装して、`Vec<T>`値を使用することができます。リスト19-23を参照してください。

ファイル名：`src/main.rs`

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![
        String::from("hello"),
        String::from("world"),
    ]);
    println!("w = {w}");
}
```

リスト19-23：`Display`を実装するための`Vec<String>`の周りに`Wrapper`型を作成する

`Display`の実装では、`Wrapper`はタプル構造体であり、`Vec<T>`はタプルのインデックス0の項目であるため、`self.0`を使用して内部の`Vec<T>`にアクセスします。そして、`Wrapper`に対して`Display`型の機能を使用することができます。

この技術の欠点は、`Wrapper`は新しい型であるため、保持している値のメソッドを持っていないことです。`Wrapper`に直接`Vec<T>`のすべてのメソッドを実装して、メソッドが`self.0`に委譲するようにする必要があります。これにより、`Wrapper`をまるで`Vec<T>`のように扱うことができます。新しい型が内部型が持つすべてのメソッドを持つことを望む場合、内部型を返すために`Wrapper`に`Deref`トレイトを実装するのが解決策になります（「Derefを使ってスマートポインタを通常の参照のように扱う」の項で`Deref`トレイトの実装について説明しました）。`Wrapper`型が内部型のすべてのメソッドを持つことを望まない場合、たとえば`Wrapper`型の動作を制限する場合、必要なメソッドのみを手動で実装する必要があります。

このニュータイプパターンは、トレイトが関係しない場合でも役立ちます。焦点を切り替えて、Rustの型システムと対話するいくつかの高度な方法を見てみましょう。
