# 関連型

**関連型**は、型のプレースホルダをトレイトと結び付けるもので、トレイトメソッドの定義ではこれらのプレースホルダ型をシグネチャに使用できます。トレイトの実装者は、特定の実装においてプレースホルダ型の代わりに使用する具体的な型を指定します。このようにして、トレイトが実装されるまで、それがどのような型であるかを正確に知る必要なく、いくつかの型を使用するトレイトを定義することができます。

この章で説明したほとんどの高度な機能は、ほとんど必要ないと説明してきました。関連型は中間的な位置にあります：この本の残りの部分で説明される機能よりも頻繁には使用されませんが、この章で議論される他の多くの機能よりも一般的に使用されます。

関連型を持つトレイトの 1 つの例は、標準ライブラリが提供する`Iterator`トレイトです。関連型は`Item`と呼ばれ、`Iterator`トレイトを実装する型が反復処理する値の型を表します。`Iterator`トレイトの定義は、リスト 19-12 に示すとおりです。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

リスト 19-12：関連型`Item`を持つ`Iterator`トレイトの定義

型`Item`はプレースホルダであり、`next`メソッドの定義は、それが`Option<Self::Item>`型の値を返すことを示しています。`Iterator`トレイトの実装者は、`Item`の具体的な型を指定し、`next`メソッドはその具体的な型の値を含む`Option`を返します。

関連型は、ジェネリクスと似た概念のように見えるかもしれません。後者は、どのような型を処理できるかを指定することなく関数を定義できるためです。この 2 つの概念の違いを調べるために、`Item`型が`u32`であることを指定する`Counter`という名前の型に対する`Iterator`トレイトの実装を見てみましょう：

ファイル名：`src/lib.rs`

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        --snip--
```

この構文はジェネリクスのそれと似ています。では、なぜリスト 19-13 に示すようにジェネリクスを使って`Iterator`トレイトを定義しないのでしょうか？

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

リスト 19-13：ジェネリクスを使った`Iterator`トレイトの仮想的な定義

違いは、リスト 19-13 のようにジェネリクスを使用する場合、各実装で型を注釈する必要があることです。なぜなら、`Counter`に対して`Iterator<String>`を実装することもできるし、他の任意の型に対しても実装できるため、`Counter`に対する`Iterator`の複数の実装が可能になるからです。言い換えると、トレイトにジェネリックパラメータがある場合、それはある型に対して複数回実装でき、そのたびにジェネリック型パラメータの具体的な型を変更できます。`Counter`で`next`メソッドを使用する場合、使用したい`Iterator`の実装を示すために型注釈を提供する必要があります。

関連型を使用すると、型を注釈する必要がなくなります。なぜなら、ある型に対してトレイトを複数回実装することはできないからです。関連型を使用する定義のリスト 19-12 では、`Item`の型をどのようにするかを一度だけ選ぶことができます。なぜなら、`Counter`に対する`impl Iterator`は 1 つだけであるからです。`Counter`で`next`を呼び出す場所すべてで、`u32`値の反復子を必要とすることを指定する必要はありません。

関連型はまた、トレイトの契約の一部にもなります。トレイトの実装者は、関連型のプレースホルダに代わる型を提供する必要があります。関連型は、その型がどのように使用されるかを表す名前を持つことが多く、API ドキュメントにおいて関連型を文書化するのは良い慣例です。
