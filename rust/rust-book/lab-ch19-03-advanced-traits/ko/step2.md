# 연관 타입 (Associated Types)

*연관 타입*은 타입 플레이스홀더 (type placeholder) 를 트레이트와 연결하여 트레이트 메서드 정의가 이러한 플레이스홀더 타입을 시그니처에서 사용할 수 있도록 합니다. 트레이트를 구현하는 사람은 특정 구현에 대해 플레이스홀더 타입 대신 사용할 구체적인 타입을 지정합니다. 이러한 방식으로, 트레이트가 구현될 때까지 정확히 어떤 타입인지 알 필요 없이 일부 타입을 사용하는 트레이트를 정의할 수 있습니다.

이 장에서 설명하는 대부분의 고급 기능은 거의 필요하지 않다고 설명했습니다. 연관 타입은 중간 정도에 위치합니다. 책의 나머지 부분에서 설명하는 기능보다 드물게 사용되지만, 이 장에서 논의하는 다른 많은 기능보다는 더 일반적으로 사용됩니다.

연관 타입을 가진 트레이트의 한 예는 표준 라이브러리가 제공하는 `Iterator` 트레이트입니다. 연관 타입은 `Item`이라는 이름으로 지정되며, `Iterator` 트레이트를 구현하는 타입이 반복하는 값의 타입을 나타냅니다. `Iterator` 트레이트의 정의는 Listing 19-12 에 나와 있습니다.

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

Listing 19-12: 연관 타입 `Item`을 가진 `Iterator` 트레이트의 정의

`Item` 타입은 플레이스홀더이며, `next` 메서드의 정의는 `Option<Self::Item>` 타입의 값을 반환함을 보여줍니다. `Iterator` 트레이트를 구현하는 사람은 `Item`에 대한 구체적인 타입을 지정하며, `next` 메서드는 해당 구체적인 타입의 값을 포함하는 `Option`을 반환합니다.

연관 타입은 제네릭 (generics) 과 유사한 개념처럼 보일 수 있습니다. 제네릭은 처리할 수 있는 타입을 지정하지 않고 함수를 정의할 수 있도록 해주기 때문입니다. 두 개념의 차이점을 살펴보기 위해, `Item` 타입을 `u32`로 지정하는 `Counter` 타입에 대한 `Iterator` 트레이트의 구현을 살펴보겠습니다.

Filename: `src/lib.rs`

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        --snip--
```

이 구문은 제네릭의 구문과 유사해 보입니다. 그렇다면 Listing 19-13 과 같이 제네릭을 사용하여 `Iterator` 트레이트를 정의하지 않는 이유는 무엇일까요?

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

Listing 19-13: 제네릭을 사용하는 `Iterator` 트레이트의 가상 정의

차이점은 Listing 19-13 과 같이 제네릭을 사용할 때 각 구현에서 타입을 주석 처리해야 한다는 것입니다. `Iterator<``String``> for Counter` 또는 다른 모든 타입을 구현할 수 있으므로, `Counter`에 대한 `Iterator`의 여러 구현을 가질 수 있습니다. 즉, 트레이트에 제네릭 매개변수가 있는 경우, 제네릭 타입 매개변수의 구체적인 타입을 매번 변경하면서 여러 번 타입에 대해 구현할 수 있습니다. `Counter`에서 `next` 메서드를 사용할 때, 어떤 `Iterator` 구현을 사용하고 싶은지 나타내기 위해 타입 주석을 제공해야 합니다.

연관 타입을 사용하면 여러 번 타입에 대해 트레이트를 구현할 수 없으므로 타입을 주석 처리할 필요가 없습니다. 연관 타입을 사용하는 정의인 Listing 19-12 에서, `Item`의 타입을 한 번만 선택할 수 있습니다. `impl Iterator for Counter`는 하나만 있을 수 있기 때문입니다. `Counter`에서 `next`를 호출할 때마다 `u32` 값의 이터레이터를 원한다고 지정할 필요가 없습니다.

연관 타입은 또한 트레이트의 계약의 일부가 됩니다. 트레이트를 구현하는 사람은 연관 타입 플레이스홀더를 대신할 타입을 제공해야 합니다. 연관 타입은 종종 타입이 어떻게 사용될지 설명하는 이름을 가지며, API 문서에서 연관 타입을 문서화하는 것은 좋은 관행입니다.
