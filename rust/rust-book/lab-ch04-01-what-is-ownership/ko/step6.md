# 변수와 데이터의 상호 작용: Move

Rust 에서는 여러 변수가 동일한 데이터와 다양한 방식으로 상호 작용할 수 있습니다. 목록 4-2 에서 정수를 사용하여 예제를 살펴보겠습니다.

```rust
let x = 5;
let y = x;
```

목록 4-2: 변수 `x`의 정수 값을 `y`에 할당

이것이 무엇을 하는지 추측할 수 있습니다. "값 `5`를 `x`에 바인딩하고, `x`의 값을 복사하여 `y`에 바인딩합니다." 이제 `x`와 `y`라는 두 개의 변수가 있으며 둘 다 `5`입니다. 정수는 알려진 고정 크기를 가진 간단한 값이므로 실제로 이렇게 작동하며, 이 두 개의 `5` 값은 스택에 푸시됩니다.

이제 `String` 버전을 살펴보겠습니다.

```rust
let s1 = String::from("hello");
let s2 = s1;
```

이것은 매우 유사해 보이므로 작동 방식도 동일하다고 가정할 수 있습니다. 즉, 두 번째 줄은 `s1`의 값을 복사하여 `s2`에 바인딩합니다. 그러나 이것이 정확히 일어나는 일은 아닙니다.

`String`이 내부적으로 어떻게 작동하는지 보려면 그림 4-1 을 참조하십시오. `String`은 왼쪽에 표시된 세 부분으로 구성됩니다. 문자열의 내용을 담고 있는 메모리에 대한 포인터, 길이, 용량입니다. 이 데이터 그룹은 스택에 저장됩니다. 오른쪽에 있는 것은 내용을 담고 있는 힙의 메모리입니다.

그림 4-1: `s1`에 바인딩된 값 `"hello"`를 담고 있는 `String`의 메모리 표현

길이는 `String`의 내용이 현재 사용하고 있는 메모리의 양 (바이트) 입니다. 용량은 `String`이 할당자로부터 받은 총 메모리 양 (바이트) 입니다. 길이와 용량의 차이는 중요하지만, 이 맥락에서는 중요하지 않으므로 지금은 용량을 무시해도 괜찮습니다.

`s1`을 `s2`에 할당하면 `String` 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이 및 용량을 복사합니다. 포인터가 참조하는 힙의 데이터는 복사하지 않습니다. 즉, 메모리의 데이터 표현은 그림 4-2 와 같습니다.

그림 4-2: `s1`의 포인터, 길이 및 용량의 복사본을 가진 변수 `s2`의 메모리 표현

표현은 Rust 가 힙 데이터도 복사하는 경우 메모리가 어떻게 보일지 보여주는 그림 4-3 과 _같지 않습니다_. Rust 가 이렇게 하면 힙의 데이터가 클 경우 `s2 = s1` 연산이 런타임 성능 측면에서 매우 비쌀 수 있습니다.

그림 4-3: Rust 가 힙 데이터도 복사하는 경우 `s2 = s1`이 수행할 수 있는 또 다른 가능성

앞서 변수가 범위를 벗어날 때 Rust 가 자동으로 `drop` 함수를 호출하고 해당 변수에 대한 힙 메모리를 정리한다고 말했습니다. 그러나 그림 4-2 는 두 데이터 포인터가 동일한 위치를 가리키고 있음을 보여줍니다. 이것은 문제입니다. `s2`와 `s1`이 범위를 벗어나면 둘 다 동일한 메모리를 해제하려고 시도합니다. 이것은 _이중 해제 (double free)_ 오류라고 하며, 이전에 언급한 메모리 안전성 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상이 발생할 수 있으며, 이는 잠재적으로 보안 취약점으로 이어질 수 있습니다.

메모리 안전성을 보장하기 위해 `let s2 = s1;` 줄 이후에 Rust 는 `s1`이 더 이상 유효하지 않다고 간주합니다. 따라서 Rust 는 `s1`이 범위를 벗어날 때 아무것도 해제할 필요가 없습니다. `s2`가 생성된 후 `s1`을 사용하려고 하면 어떻게 되는지 확인하십시오. 작동하지 않습니다.

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```

Rust 가 무효화된 참조를 사용하는 것을 방지하므로 다음과 같은 오류가 발생합니다.

```bash
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which
 does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
```

다른 언어를 사용하면서 *얕은 복사 (shallow copy)*와 *깊은 복사 (deep copy)*라는 용어를 들어본 적이 있다면, 데이터를 복사하지 않고 포인터, 길이 및 용량을 복사하는 개념은 얕은 복사를 만드는 것처럼 들릴 것입니다. 그러나 Rust 는 첫 번째 변수도 무효화하므로 얕은 복사라고 하는 대신 *move(이동)*라고 합니다. 이 예제에서는 `s1`이 `s2`로 *이동 (moved)*되었다고 말합니다. 따라서 실제로 일어나는 일은 그림 4-4 에 나와 있습니다.

그림 4-4: `s1`이 무효화된 후 메모리 표현

그것이 우리의 문제를 해결합니다! `s2`만 유효하므로, 범위를 벗어날 때 혼자 메모리를 해제하고 완료됩니다.

또한, 이것에 의해 암시되는 설계 선택이 있습니다. Rust 는 데이터의 "깊은" 복사본을 자동으로 생성하지 않습니다. 따라서 _자동_ 복사는 런타임 성능 측면에서 저렴하다고 가정할 수 있습니다.
