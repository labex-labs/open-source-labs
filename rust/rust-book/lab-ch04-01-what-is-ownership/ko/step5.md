# 메모리와 할당

문자열 리터럴의 경우, 컴파일 시간에 내용을 알고 있으므로 텍스트는 최종 실행 파일에 직접 하드 코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 그러나 이러한 속성은 문자열 리터럴의 불변성에서만 비롯됩니다. 불행히도, 컴파일 시간에 크기를 알 수 없고 프로그램 실행 중에 크기가 변경될 수 있는 각 텍스트 조각에 대해 메모리 덩어리를 바이너리에 넣을 수는 없습니다.

`String` 타입의 경우, 변경 가능하고 확장 가능한 텍스트를 지원하기 위해 컴파일 시간에 알 수 없는 힙에 메모리 양을 할당하여 내용을 저장해야 합니다. 즉, 다음을 의미합니다.

- 메모리는 런타임에 메모리 할당자로부터 요청되어야 합니다.
- `String`을 다 사용했을 때 이 메모리를 할당자에게 반환하는 방법이 필요합니다.

첫 번째 부분은 우리가 수행합니다. `String::from`을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이것은 프로그래밍 언어에서 거의 보편적입니다.

그러나 두 번째 부분은 다릅니다. *가비지 수집기 (GC)*가 있는 언어에서 GC 는 더 이상 사용되지 않는 메모리를 추적하고 정리하며, 우리는 그것에 대해 생각할 필요가 없습니다. GC 가 없는 대부분의 언어에서는 메모리가 더 이상 사용되지 않는 시점을 식별하고 명시적으로 해제하는 코드를 호출하는 것이 우리의 책임입니다. 이를 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 하면 변수가 유효하지 않게 됩니다. 두 번 하면 그것 또한 버그입니다. 정확히 하나의 `allocate`와 정확히 하나의 `free`를 쌍으로 묶어야 합니다.

Rust 는 다른 경로를 따릅니다. 소유하고 있는 변수가 범위를 벗어나면 메모리가 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 `String`을 사용하는 목록 4-1 의 범위 예제 버전입니다.

    {
        let s = String::from("hello"); // s는 이 시점부터 유효합니다.

        // s로 작업 수행
    }                                  // 이 범위가 종료되었고 s는 더 이상 유효하지 않습니다.

`String`이 할당자에게 필요한 메모리를 반환할 수 있는 자연스러운 지점이 있습니다. `s`가 범위를 벗어날 때입니다. 변수가 범위를 벗어나면 Rust 는 우리를 위해 특수 함수를 호출합니다. 이 함수는 `drop`이라고 하며, `String`의 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳입니다. Rust 는 닫는 중괄호에서 자동으로 `drop`을 호출합니다.

> 참고: C++ 에서 항목의 수명이 끝날 때 리소스를 할당 해제하는 이 패턴을 _Resource Acquisition Is Initialization_ *(RAII)*라고 부르기도 합니다. RAII 패턴을 사용해 본 적이 있다면 Rust 의 `drop` 함수가 익숙할 것입니다.

이 패턴은 Rust 코드가 작성되는 방식에 큰 영향을 미칩니다. 지금은 간단해 보일 수 있지만, 힙에 할당한 데이터를 여러 변수가 사용하려는 더 복잡한 상황에서는 코드의 동작이 예상치 못한 결과로 이어질 수 있습니다. 이제 이러한 몇 가지 상황을 살펴보겠습니다.
