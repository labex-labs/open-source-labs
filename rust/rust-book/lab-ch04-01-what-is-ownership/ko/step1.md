# 소유권이란 무엇인가?

*소유권 (Ownership)*은 Rust 프로그램이 메모리를 관리하는 방식을 제어하는 규칙 집합입니다. 모든 프로그램은 실행 중에 컴퓨터의 메모리를 사용하는 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행되는 동안 더 이상 사용하지 않는 메모리를 정기적으로 찾는 가비지 컬렉션 (garbage collection) 이 있습니다. 다른 언어에서는 프로그래머가 메모리를 명시적으로 할당하고 해제해야 합니다. Rust 는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 확인하는 규칙 집합을 가진 소유권 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램이 컴파일되지 않습니다. 소유권의 어떤 기능도 프로그램이 실행되는 동안 속도를 늦추지 않습니다.

소유권은 많은 프로그래머에게 새로운 개념이므로 익숙해지는 데 시간이 걸립니다. 좋은 소식은 Rust 와 소유권 시스템의 규칙에 익숙해질수록 안전하고 효율적인 코드를 자연스럽게 개발하는 것이 더 쉬워진다는 것입니다. 계속 노력하세요!

소유권을 이해하면 Rust 를 특별하게 만드는 기능을 이해하는 데 탄탄한 기반을 갖게 됩니다. 이 장에서는 매우 일반적인 데이터 구조인 문자열을 중심으로 몇 가지 예제를 통해 소유권을 배우게 됩니다.

> **스택 (Stack) 과 힙 (Heap)**
>
> 많은 프로그래밍 언어에서는 스택과 힙에 대해 자주 생각할 필요가 없습니다. 그러나 Rust 와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지 여부가 언어의 동작 방식과 특정 결정을 내려야 하는 이유에 영향을 미칩니다. 소유권의 일부는 이 장의 뒷부분에서 스택과 힙과 관련하여 설명되므로, 이에 대한 간략한 설명을 미리 준비합니다.
>
> 스택과 힙은 모두 런타임에 코드에서 사용할 수 있는 메모리의 일부이지만, 서로 다른 방식으로 구성됩니다. 스택은 값을 얻는 순서대로 저장하고 반대 순서로 값을 제거합니다. 이를 *후입선출 (last in, first out)*이라고 합니다. 접시 더미를 생각해 보세요. 접시를 더 추가할 때는 더미 위에 놓고, 접시가 필요할 때는 맨 위에서 하나를 꺼냅니다. 중간이나 바닥에서 접시를 추가하거나 제거하는 것은 잘 작동하지 않습니다! 데이터를 추가하는 것을 *스택에 푸시 (pushing onto the stack)*라고 하고, 데이터를 제거하는 것을 *스택에서 팝 (popping off the stack)*이라고 합니다. 스택에 저장된 모든 데이터는 알려진 고정된 크기를 가져야 합니다. 컴파일 시간에 알 수 없는 크기 또는 변경될 수 있는 크기의 데이터는 대신 힙에 저장해야 합니다.
>
> 힙은 덜 조직적입니다. 힙에 데이터를 넣을 때 특정 공간을 요청합니다. 메모리 할당자 (memory allocator) 는 힙에서 충분히 큰 빈 공간을 찾아 사용 중으로 표시하고 해당 위치의 주소인 *포인터 (pointer)*를 반환합니다. 이 프로세스를 *힙에 할당 (allocating on the heap)*이라고 하며, 때로는 단순히 *할당 (allocating)*이라고 줄여서 표현하기도 합니다 (스택에 값을 푸시하는 것은 할당으로 간주되지 않습니다). 힙에 대한 포인터는 알려진 고정된 크기이므로 스택에 포인터를 저장할 수 있지만, 실제 데이터를 원하는 경우 포인터를 따라가야 합니다. 식당에 앉아 있는 것을 생각해 보세요. 입장할 때 그룹의 인원수를 말하면 호스트가 모두에게 맞는 빈 테이블을 찾아 그곳으로 안내합니다. 그룹의 누군가가 늦게 오면 어디에 앉았는지 물어 찾아갈 수 있습니다.
>
> 스택에 푸시하는 것은 힙에 할당하는 것보다 빠릅니다. 할당자는 새 데이터를 저장할 공간을 찾을 필요가 없기 때문입니다. 해당 위치는 항상 스택의 맨 위에 있습니다. 이에 비해 힙에 공간을 할당하는 것은 할당자가 먼저 데이터를 저장할 충분한 공간을 찾아야 하고 다음 할당을 준비하기 위해 부기 (bookkeeping) 를 수행해야 하므로 더 많은 작업이 필요합니다.
>
> 힙의 데이터에 액세스하는 것은 스택의 데이터에 액세스하는 것보다 느립니다. 포인터를 따라가야 하기 때문입니다. 최신 프로세서는 메모리에서 덜 이동할수록 더 빠릅니다. 비유를 계속하면, 여러 테이블에서 주문을 받는 식당의 서버를 생각해 보세요. 한 테이블에서 모든 주문을 받은 다음 다음 테이블로 이동하는 것이 가장 효율적입니다. 테이블 A 에서 주문을 받고, 테이블 B 에서 주문을 받고, 다시 A 에서 주문을 받고, 다시 B 에서 주문을 받는 것은 훨씬 더 느린 프로세스입니다. 마찬가지로, 프로세서는 (스택에서와 같이) 다른 데이터에 가까운 데이터에서 작업하는 것이 (힙에서와 같이) 더 멀리 있는 데이터에서 작업하는 것보다 더 잘 수행할 수 있습니다.
>
> 코드에서 함수를 호출하면 함수에 전달된 값 (잠재적으로 힙의 데이터에 대한 포인터 포함) 과 함수의 지역 변수가 스택에 푸시됩니다. 함수가 끝나면 해당 값은 스택에서 팝됩니다.
>
> 코드의 어떤 부분이 힙의 어떤 데이터를 사용하고 있는지 추적하고, 힙의 중복 데이터 양을 최소화하고, 공간이 부족하지 않도록 사용하지 않는 힙의 데이터를 정리하는 것은 모두 소유권이 해결하는 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요가 없지만, 소유권의 주요 목적이 힙 데이터를 관리하는 것임을 알면 소유권이 작동하는 방식을 설명하는 데 도움이 될 수 있습니다.
