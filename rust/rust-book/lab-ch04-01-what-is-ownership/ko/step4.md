# String 타입

소유권 규칙을 설명하기 위해 "데이터 타입"에서 다룬 것보다 더 복잡한 데이터 타입이 필요합니다. 이전에 다룬 타입은 알려진 크기이며, 스택에 저장될 수 있고, 해당 범위가 끝나면 스택에서 제거될 수 있으며, 코드의 다른 부분이 다른 범위에서 동일한 값을 사용해야 하는 경우 빠르고 쉽게 복사하여 새롭고 독립적인 인스턴스를 만들 수 있습니다. 그러나 힙에 저장된 데이터를 살펴보고 Rust 가 해당 데이터를 정리해야 할 시기를 어떻게 아는지 탐구하고 싶으며, `String` 타입이 좋은 예입니다.

소유권과 관련된 `String`의 부분에 집중하겠습니다. 이러한 측면은 표준 라이브러리에서 제공되든 사용자가 생성하든 다른 복잡한 데이터 타입에도 적용됩니다. 8 장에서 `String`에 대해 더 자세히 논의하겠습니다.

우리는 이미 문자열 리터럴을 보았으며, 여기서 문자열 값은 프로그램에 하드 코딩되어 있습니다. 문자열 리터럴은 편리하지만 텍스트를 사용하려는 모든 상황에 적합하지 않습니다. 한 가지 이유는 불변성 때문입니다. 또 다른 이유는 코드를 작성할 때 모든 문자열 값을 알 수 없기 때문입니다. 예를 들어 사용자 입력을 받아 저장하려면 어떻게 해야 할까요? 이러한 상황을 위해 Rust 에는 두 번째 문자열 타입인 `String`이 있습니다. 이 타입은 힙에 할당된 데이터를 관리하므로 컴파일 시간에 알 수 없는 양의 텍스트를 저장할 수 있습니다. 다음과 같이 `from` 함수를 사용하여 문자열 리터럴에서 `String`을 만들 수 있습니다.

```rust
let s = String::from("hello");
```

이중 콜론 `::` 연산자를 사용하면 `string_from`과 같은 이름을 사용하는 대신 이 특정 `from` 함수를 `String` 타입 아래에 네임스페이스할 수 있습니다. "메서드 구문"에서 이 구문에 대해 더 자세히 논의하고, "모듈 트리에서 항목을 참조하기 위한 경로"에서 모듈을 사용한 네임스페이싱에 대해 이야기할 때 더 자세히 다루겠습니다.

이러한 종류의 문자열은 *변경*될 수 있습니다.

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 은 리터럴을 String 에 추가합니다.

println!("{s}"); // This will print `hello, world!`
```

그렇다면 여기서 차이점은 무엇일까요? `String`은 변경할 수 있지만 리터럴은 변경할 수 없는 이유는 무엇일까요? 차이점은 이 두 타입이 메모리를 처리하는 방식에 있습니다.
