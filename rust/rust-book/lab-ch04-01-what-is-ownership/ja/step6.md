# ムーブによる変数とデータの相互作用

Rust では、複数の変数が同じデータと異なる方法で相互作用することができます。リスト 4-2 の整数を使った例を見てみましょう。

```rust
let x = 5;
let y = x;
```

リスト 4-2: 変数`x`の整数値を`y`に代入する

これが何をしているかはおそらく想像がつきます。「値`5`を`x`にバインドし、次に`x`の値をコピーして`y`にバインドする」です。これで、`x`と`y`の 2 つの変数ができ、両方とも`5`に等しくなります。これが実際に起こっていることです。なぜなら、整数は既知の固定サイズの単純な値であり、これら 2 つの`5`の値はスタックにプッシュされるからです。

次に、`String`のバージョンを見てみましょう。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

これは非常に似ているので、同じように動作すると仮定してもいいかもしれません。つまり、2 行目は`s1`の値をコピーして`s2`にバインドするでしょう。しかし、実際にはそうはなりません。

`String`が内部でどのように動作しているかを見るには、図 4-1 を見てください。`String`は、左側に示されている 3 つの部分で構成されています。文字列の内容を保持するメモリへのポインタ、長さ、および容量です。このデータのグループはスタックに格納されます。右側は、内容を保持するヒープ上のメモリです。

図 4-1: 値`"hello"`が`s1`にバインドされた`String`のメモリ内の表現

長さは、`String`の内容が現在使用しているメモリのバイト数です。容量は、`String`が割り当てプログラムから受け取ったメモリの合計量です。長さと容量の違いは重要ですが、この文脈ではそうではありません。だから今は、容量を無視して大丈夫です。

`s1`を`s2`に代入すると、`String`データがコピーされます。つまり、スタック上のポインタ、長さ、および容量がコピーされます。ポインタが参照するヒープ上のデータはコピーされません。言い換えると、メモリ内のデータ表現は図 4-2 のようになります。

図 4-2: `s1`のポインタ、長さ、および容量のコピーを持つ変数`s2`のメモリ内の表現

この表現は、もし Rust がヒープデータもコピーする場合のメモリの見え方である図 4-3 のようにはなりません。もし Rust がこれを行った場合、ヒープ上のデータが大きい場合、実行時のパフォーマンスの面で`s2 = s1`の操作は非常に高価になる可能性があります。

図 4-3: Rust がヒープデータもコピーする場合の`s2 = s1`の別の可能性

以前、変数がスコープ外になると、Rust は自動的に`drop`関数を呼び出し、その変数のヒープメモリをクリーンアップすると述べました。しかし、図 4-2 には両方のデータポインタが同じ場所を指していることが示されています。これは問題です。`s2`と`s1`がスコープ外になると、両方とも同じメモリを解放しようとします。これは「二重解放」エラーと呼ばれ、以前に述べたメモリセーフティバグの 1 つです。メモリを 2 回解放すると、メモリ破損につながり、潜在的にセキュリティ脆弱性につながる可能性があります。

メモリセーフティを保証するために、`let s2 = s1;`の行の後、Rust は`s1`をもはや有効でないと見なします。したがって、`s1`がスコープ外になるとき、Rust は何も解放する必要はありません。`s2`を作成した後に`s1`を使用しようとするとどうなるか見てみましょう。うまくいきません。

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```

無効化された参照を使用しようとしているため、次のようなエラーが表示されます。

```bash
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which
 does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
```

他の言語で作業しているときに「シャローコピー」と「ディープコピー」という用語を聞いたことがあるなら、データをコピーせずにポインタ、長さ、および容量をコピーする概念は、シャローコピーを作るように聞こえるかもしれません。しかし、Rust はまた最初の変数も無効化するので、シャローコピーと呼ばれる代わりに、これは「ムーブ」と呼ばれます。この例では、`s1`が`s2`に「ムーブ」されたと言います。ですから、実際に起こることは図 4-4 に示されています。

図 4-4: `s1`が無効化された後のメモリ内の表現

問題が解決しました！有効なのは`s2`だけであるため、スコープ外になると、それだけがメモリを解放し、終了です。

さらに、これによって暗黙的になされる設計の選択があります。Rust は決して自動的にデータの「ディープ」コピーを作成しません。したがって、実行時のパフォーマンスの面では、任意の「自動的」コピーは安価であると想定できます。
