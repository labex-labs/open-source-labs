# ムーブによる変数とデータの相互作用

Rustでは、複数の変数が同じデータと異なる方法で相互作用することができます。リスト4-2の整数を使った例を見てみましょう。

```rust
let x = 5;
let y = x;
```

リスト4-2: 変数`x`の整数値を`y`に代入する

これが何をしているかはおそらく想像がつきます。「値`5`を`x`にバインドし、次に`x`の値をコピーして`y`にバインドする」です。これで、`x`と`y`の2つの変数ができ、両方とも`5`に等しくなります。これが実際に起こっていることです。なぜなら、整数は既知の固定サイズの単純な値であり、これら2つの`5`の値はスタックにプッシュされるからです。

次に、`String`のバージョンを見てみましょう。

```rust
let s1 = String::from("hello");
let s2 = s1;
```

これは非常に似ているので、同じように動作すると仮定してもいいかもしれません。つまり、2行目は`s1`の値をコピーして`s2`にバインドするでしょう。しかし、実際にはそうはなりません。

`String`が内部でどのように動作しているかを見るには、図4-1を見てください。`String`は、左側に示されている3つの部分で構成されています。文字列の内容を保持するメモリへのポインタ、長さ、および容量です。このデータのグループはスタックに格納されます。右側は、内容を保持するヒープ上のメモリです。

図4-1: 値`"hello"`が`s1`にバインドされた`String`のメモリ内の表現

長さは、`String`の内容が現在使用しているメモリのバイト数です。容量は、`String`が割り当てプログラムから受け取ったメモリの合計量です。長さと容量の違いは重要ですが、この文脈ではそうではありません。だから今は、容量を無視して大丈夫です。

`s1`を`s2`に代入すると、`String`データがコピーされます。つまり、スタック上のポインタ、長さ、および容量がコピーされます。ポインタが参照するヒープ上のデータはコピーされません。言い換えると、メモリ内のデータ表現は図4-2のようになります。

図4-2: `s1`のポインタ、長さ、および容量のコピーを持つ変数`s2`のメモリ内の表現

この表現は、もしRustがヒープデータもコピーする場合のメモリの見え方である図4-3のようにはなりません。もしRustがこれを行った場合、ヒープ上のデータが大きい場合、実行時のパフォーマンスの面で`s2 = s1`の操作は非常に高価になる可能性があります。

図4-3: Rustがヒープデータもコピーする場合の`s2 = s1`の別の可能性

以前、変数がスコープ外になると、Rustは自動的に`drop`関数を呼び出し、その変数のヒープメモリをクリーンアップすると述べました。しかし、図4-2には両方のデータポインタが同じ場所を指していることが示されています。これは問題です。`s2`と`s1`がスコープ外になると、両方とも同じメモリを解放しようとします。これは「二重解放」エラーと呼ばれ、以前に述べたメモリセーフティバグの1つです。メモリを2回解放すると、メモリ破損につながり、潜在的にセキュリティ脆弱性につながる可能性があります。

メモリセーフティを保証するために、`let s2 = s1;`の行の後、Rustは`s1`をもはや有効でないと見なします。したがって、`s1`がスコープ外になるとき、Rustは何も解放する必要はありません。`s2`を作成した後に`s1`を使用しようとするとどうなるか見てみましょう。うまくいきません。

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```

無効化された参照を使用しようとしているため、次のようなエラーが表示されます。

```bash
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which
 does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
```

他の言語で作業しているときに「シャローコピー」と「ディープコピー」という用語を聞いたことがあるなら、データをコピーせずにポインタ、長さ、および容量をコピーする概念は、シャローコピーを作るように聞こえるかもしれません。しかし、Rustはまた最初の変数も無効化するので、シャローコピーと呼ばれる代わりに、これは「ムーブ」と呼ばれます。この例では、`s1`が`s2`に「ムーブ」されたと言います。ですから、実際に起こることは図4-4に示されています。

図4-4: `s1`が無効化された後のメモリ内の表現

問題が解決しました！ 有効なのは`s2`だけであるため、スコープ外になると、それだけがメモリを解放し、終了です。

さらに、これによって暗黙的になされる設計の選択があります。Rustは決して自動的にデータの「ディープ」コピーを作成しません。したがって、実行時のパフォーマンスの面では、任意の「自動的」コピーは安価であると想定できます。
