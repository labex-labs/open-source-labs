# メモリと割り当て

文字列リテラルの場合、コンパイル時に内容がわかっているため、テキストは直接最終実行可能ファイルにハードコードされます。これが文字列リテラルが高速かつ効率的である理由です。しかし、これらの特性は文字列リテラルの不変性によるものだけです。残念ながら、コンパイル時にサイズが未知で、プログラムを実行している間にサイズが変化する可能性のある各テキストに対して、バイナリにメモリのブロブを入れることはできません。

`String`型の場合、可変で拡張可能なテキストをサポートするために、コンパイル時に未知の量のメモリをヒープに割り当てて、内容を保持する必要があります。これはつまり、次のことを意味します。

- メモリは実行時にメモリ割り当てプログラムから要求する必要があります。
- `String`が終了したときに、このメモリを割り当てプログラムに返す方法が必要です。

最初の部分は私たちが行います。`String::from`を呼び出すと、その実装が必要なメモリを要求します。これは、プログラミング言語においてほぼ普遍的です。

ただし、2 番目の部分は異なります。「ガベージコレクタ (GC)」を持つ言語では、GC が使用されなくなったメモリを追跡してクリーンアップします。そのため、私たちはそれについて考える必要はありません。GC がないほとんどの言語では、メモリがもはや使用されなくなったタイミングを特定し、要求するときと同じように、明示的に解放するためのコードを呼び出すのが私たちの責任です。これを正しく行うことは、歴史的には難しいプログラミング問題でした。忘れると、メモリを無駄にします。やりすぎると、無効な変数になります。2 回やると、バグにもなります。`allocate`を 1 回だけ、`free`を 1 回だけ正確に対応付ける必要があります。

Rust は別の方法を採用しています。所有権を持つ変数がスコープ外になると、メモリは自動的に返されます。次は、文字列リテラルの代わりに`String`を使った、リスト 4-1 のスコープの例のバージョンです。

    {
        let s = String::from("hello"); // sはこの時点以降有効です

        // sを使って何かをする
    }                                  // このスコープはもう終了し、sはもはや有効ではありません

私たちが`String`が必要とするメモリを割り当てプログラムに返す自然な時点があります。それは、`s`がスコープ外になるときです。変数がスコープ外になると、Rust は私たちのために特別な関数を呼び出します。この関数は`drop`と呼ばれ、`String`の作者がメモリを返すコードを記述できる場所です。Rust は、閉じ括弧のところで自動的に`drop`を呼び出します。

> 注：C++ では、項目の寿命の終わりにリソースを解放するこのパターンは、時々「リソース獲得は初期化 (RAII)」と呼ばれます。RAII パターンを使ったことがあれば、Rust の`drop`関数はおそらくお馴染みでしょう。

このパターンは、Rust コードの書き方に大きな影響を与えます。今は簡単に見えるかもしれませんが、ヒープ上に割り当てたデータを複数の変数が使用するようになるより複雑な状況では、コードの動作が予期しない場合があります。では、そうした状況のいくつかを見ていきましょう。
