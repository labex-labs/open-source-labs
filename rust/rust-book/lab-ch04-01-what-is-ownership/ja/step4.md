# String 型

所有権のルールを説明するために、「データ型」で扱ったものよりも複雑なデータ型が必要です。以前扱った型は既知のサイズで、スタックに格納でき、スコープが終了するとスタックからポップされ、コードの別の部分が異なるスコープで同じ値を使用する必要がある場合には、新しい独立したインスタンスを迅速かつ簡単にコピーできます。しかし、ヒープに格納されるデータを見て、Rust がそのデータをクリーンアップするタイミングをどのように知っているかを調べたいと思います。そして、`String`型はその良い例です。

私たちは、所有権に関係する`String`の部分に集中します。これらの側面は、標準ライブラリによって提供されるか、あなたによって作成されるかに関係なく、他の複雑なデータ型にも当てはまります。第 8 章で`String`についてもっと深く議論します。

私たちは既に文字列リテラルを見てきました。文字列リテラルでは、文字列の値がプログラムにハードコードされています。文字列リテラルは便利ですが、テキストを使用したいすべての状況に適しているわけではありません。その理由の 1 つは、それらが不変であることです。もう 1 つの理由は、コードを書くときにすべての文字列値を知ることができないことです。たとえば、ユーザー入力を受け取って格納したい場合どうでしょうか。これらの状況のために、Rust には 2 番目の文字列型である`String`があります。この型は、ヒープ上に割り当てられたデータを管理しており、コンパイル時に未知の量のテキストを格納できるようになっています。次のように、`from`関数を使って文字列リテラルから`String`を作成できます。

```rust
let s = String::from("hello");
```

ダブルコロン`::`演算子を使うことで、この特定の`from`関数を`String`型の名前空間に配置できます。`string_from`のような何らかの名前を使うのではなくです。「メソッド構文」でこの構文についてもっと議論し、「モジュールツリー内の項目を参照するためのパス」でモジュールを使った名前空間について話すときにも再度触れます。

この種の文字列は「変更可能」です。

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() は文字列を String に追加します

println!("{s}"); // これは`hello, world!`を表示します
```

では、ここでの違いは何でしょうか？なぜ`String`は変更可能で、リテラルはそうでないのでしょうか？違いは、これら 2 つの型がメモリを扱う方法にあります。
