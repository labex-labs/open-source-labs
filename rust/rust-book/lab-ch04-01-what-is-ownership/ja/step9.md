# 所有権と関数

値を関数に渡す仕組みは、変数に値を代入する場合と似ています。変数を関数に渡すと、代入の場合と同じように、ムーブまたはコピーされます。リスト4-3には、変数がスコープ内に入り、スコープ外に出る場所を示す注釈付きの例があります。

    // src/main.rs
    fn main() {
        let s = String::from("hello");  // sがスコープ内に入ります

        takes_ownership(s);             // sの値が関数にムーブされます...
                                        //... そしてここではもはや有効ではありません

        let x = 5;                      // xがスコープ内に入ります

        makes_copy(x);                  // xが関数にムーブされるでしょうが、
                                        // i32はCopyなので、その後もxを使用しても大丈夫です

    } // ここでは、xがスコープ外に出た後、sがスコープ外に出ます。ただし、sの値がムーブされているため、
      // 特別なことは何も起こりません

    fn takes_ownership(some_string: String) { // some_stringがスコープ内に入ります
        println!("{some_string}");
    } // ここでは、some_stringがスコープ外に出て、`drop`が呼び出されます。バックアップ
      // メモリが解放されます

    fn makes_copy(some_integer: i32) { // some_integerがスコープ内に入ります
        println!("{some_integer}");
    } // ここでは、some_integerがスコープ外に出ます。特別なことは何も起こりません

リスト4-3: 所有権とスコープが注釈付けされた関数

`takes_ownership`の呼び出しの後に`s`を使用しようとすると、Rustはコンパイル時エラーを投げます。これらの静的チェックは、私たちを間違いから守ってくれます。`main`に`s`と`x`を使用するコードを追加して、どこで使用できるか、所有権のルールがどこでそれを阻止するかを確認してみてください。
