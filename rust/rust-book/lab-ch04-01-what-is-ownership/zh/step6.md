# 通过移动来与变量和数据交互

在 Rust 中，多个变量可以以不同的方式与相同的数据进行交互。让我们来看一个清单 4-2 中使用整数的示例。

```rust
let x = 5;
let y = x;
```

清单 4-2：将变量 `x` 的整数值赋给 `y`

我们可能可以猜到这在做什么：“将值 `5` 绑定到 `x`；然后复制 `x` 中的值并将其绑定到 `y`。” 现在我们有了两个变量 `x` 和 `y`，它们都等于 `5`。这确实就是发生的事情，因为整数是简单的值，具有已知的固定大小，并且这两个 `5` 值被压入栈中。

现在让我们看看 `String` 版本：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

这看起来非常相似，所以我们可能会认为它的工作方式是相同的：也就是说，第二行会复制 `s1` 中的值并将其绑定到 `s2`。但实际情况并非完全如此。

看看图 4-1 来了解 `String` 在底层是如何工作的。一个 `String` 由三部分组成，如左边所示：一个指向存储字符串内容的内存的指针、一个长度和一个容量。这组数据存储在栈上。右边是堆上存储内容的内存。

图 4-1：存储值为 `"hello"` 且绑定到 `s1` 的 `String` 在内存中的表示

长度是 `String` 的内容当前使用的字节数。容量是 `String` 从分配器获得的总字节数。长度和容量之间的差异很重要，但在这种情况下并不重要，所以目前可以忽略容量。

当我们将 `s1` 赋给 `s2` 时，`String` 数据被复制，这意味着我们复制了栈上的指针、长度和容量。我们并没有复制指针所指向的堆上的数据。换句话说，内存中的数据表示看起来像图 4-2。

图 4-2：变量 `s2` 的内存表示，它具有 `s1` 的指针、长度和容量的副本

这种表示 **不像** 图 4-3，如果 Rust 也复制堆上的数据，内存看起来会是那样。如果 Rust 这样做，那么如果堆上的数据很大，`s2 = s1` 操作在运行时性能方面可能会非常昂贵。

图 4-3：如果 Rust 也复制堆上的数据，`s2 = s1` 可能的另一种情况

之前我们说过，当一个变量超出作用域时，Rust 会自动调用 `drop` 函数并清理该变量的堆内存。但是图 4-2 显示两个数据指针都指向同一个位置。这是个问题：当 `s2` 和 `s1` 超出作用域时，它们都会尝试释放相同的内存。这被称为 **双重释放** 错误，是我们之前提到的内存安全漏洞之一。两次释放内存可能会导致内存损坏，这可能会潜在地导致安全漏洞。

为了确保内存安全，在 `let s2 = s1;` 这一行之后，Rust 认为 `s1` 不再有效。因此，当 `s1` 超出作用域时，Rust 不需要释放任何东西。看看在创建 `s2` 之后尝试使用 `s1` 会发生什么；它不起作用：

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!");
```

你会得到这样一个错误，因为 Rust 阻止你使用无效的引用：

```bash
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which
 does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{s1}, world!");
  |                ^^ value borrowed here after move
```

如果你在使用其他语言时听说过术语 **浅拷贝** 和 **深拷贝**，那么只复制指针、长度和容量而不复制数据的概念可能听起来像是在进行浅拷贝。但因为 Rust 也会使第一个变量无效，所以它不被称为浅拷贝，而是被称为 **移动**。在这个例子中，我们会说 `s1` 被 **移动** 到了 `s2` 中。所以，实际发生的情况如图 4-4 所示。

图 4-4：`s1` 无效后的内存表示

这样就解决了我们的问题！只有 `s2` 有效，当它超出作用域时，只有它会释放内存，这样就完成了。

此外，这里还隐含了一个设计选择：Rust 永远不会自动为你的数据创建“深”拷贝。因此，任何 **自动** 复制在运行时性能方面都可以被认为是低成本的。
