# O que é Ownership?

_Ownership_ (propriedade) é um conjunto de regras que governam como um programa Rust gerencia a memória. Todos os programas precisam gerenciar a forma como usam a memória de um computador durante a execução. Algumas linguagens possuem _garbage collection_ (coleta de lixo) que procura regularmente por memória não mais utilizada enquanto o programa é executado; em outras linguagens, o programador deve alocar e liberar explicitamente a memória. Rust usa uma terceira abordagem: a memória é gerenciada por meio de um sistema de _ownership_ com um conjunto de regras que o compilador verifica. Se alguma das regras for violada, o programa não compilará. Nenhum dos recursos de _ownership_ irá diminuir a velocidade do seu programa durante a execução.

Como _ownership_ é um conceito novo para muitos programadores, leva algum tempo para se acostumar. A boa notícia é que quanto mais experiente você se tornar com Rust e as regras do sistema de _ownership_, mais fácil será desenvolver naturalmente um código seguro e eficiente. Continue!

Quando você entender _ownership_, terá uma base sólida para entender os recursos que tornam Rust único. Neste capítulo, você aprenderá _ownership_ trabalhando com alguns exemplos que se concentram em uma estrutura de dados muito comum: _strings_ (cadeias de caracteres).

> **A Stack e o Heap**
>
> Muitas linguagens de programação não exigem que você pense na _stack_ (pilha) e no _heap_ (montão) com muita frequência. Mas em uma linguagem de programação de sistemas como Rust, se um valor está na _stack_ ou no _heap_ afeta como a linguagem se comporta e por que você tem que tomar certas decisões. Partes do _ownership_ serão descritas em relação à _stack_ e ao _heap_ mais tarde neste capítulo, então aqui está uma breve explicação em preparação.
>
> Tanto a _stack_ quanto o _heap_ são partes da memória disponíveis para seu código usar em tempo de execução, mas são estruturadas de maneiras diferentes. A _stack_ armazena valores na ordem em que os recebe e remove os valores na ordem inversa. Isso é conhecido como _last in, first out_ (último a entrar, primeiro a sair). Pense em uma pilha de pratos: quando você adiciona mais pratos, você os coloca no topo da pilha e, quando precisa de um prato, você pega um do topo. Adicionar ou remover pratos do meio ou do fundo não funcionaria tão bem! Adicionar dados é chamado de _pushing onto the stack_ (empurrando para a pilha) e remover dados é chamado de _popping off the stack_ (removendo da pilha). Todos os dados armazenados na _stack_ devem ter um tamanho conhecido e fixo. Dados com um tamanho desconhecido em tempo de compilação ou um tamanho que pode mudar devem ser armazenados no _heap_ em vez disso.
>
> O _heap_ é menos organizado: quando você coloca dados no _heap_, você solicita uma certa quantidade de espaço. O _memory allocator_ (alocador de memória) encontra um espaço vazio no _heap_ que é grande o suficiente, o marca como em uso e retorna um _pointer_ (ponteiro), que é o endereço daquele local. Esse processo é chamado de _allocating on the heap_ (alocando no heap) e às vezes é abreviado como apenas _allocating_ (alocar) (empurrar valores para a _stack_ não é considerado alocação). Como o ponteiro para o _heap_ tem um tamanho conhecido e fixo, você pode armazenar o ponteiro na _stack_, mas quando você quer os dados reais, você deve seguir o ponteiro. Pense em estar sentado em um restaurante. Quando você entra, você informa o número de pessoas em seu grupo, e o anfitrião encontra uma mesa vazia que cabe em todos e o leva até lá. Se alguém do seu grupo chegar atrasado, ele pode perguntar onde você está sentado para encontrá-lo.
>
> Empurrar para a _stack_ é mais rápido do que alocar no _heap_ porque o alocador nunca precisa procurar um lugar para armazenar novos dados; esse local está sempre no topo da _stack_. Comparativamente, alocar espaço no _heap_ requer mais trabalho porque o alocador deve primeiro encontrar um espaço grande o suficiente para conter os dados e, em seguida, realizar a contabilidade para se preparar para a próxima alocação.
>
> Acessar dados no _heap_ é mais lento do que acessar dados na _stack_ porque você tem que seguir um ponteiro para chegar lá. Processadores contemporâneos são mais rápidos se pularem menos na memória. Continuando a analogia, considere um garçom em um restaurante recebendo pedidos de muitas mesas. É mais eficiente obter todos os pedidos em uma mesa antes de passar para a próxima mesa. Pegar um pedido da mesa A, depois um pedido da mesa B, depois um da A novamente e depois um da B novamente seria um processo muito mais lento. Da mesma forma, um processador pode fazer seu trabalho melhor se trabalhar com dados que estão próximos de outros dados (como está na _stack_) em vez de mais distantes (como pode estar no _heap_).
>
> Quando seu código chama uma função, os valores passados para a função (incluindo, potencialmente, ponteiros para dados no _heap_) e as variáveis locais da função são empurrados para a _stack_. Quando a função termina, esses valores são removidos da _stack_.
>
> Manter o controle de quais partes do código estão usando quais dados no _heap_, minimizar a quantidade de dados duplicados no _heap_ e limpar dados não utilizados no _heap_ para que você não fique sem espaço são todos problemas que o _ownership_ aborda. Depois de entender o _ownership_, você não precisará pensar na _stack_ e no _heap_ com muita frequência, mas saber que o principal objetivo do _ownership_ é gerenciar dados do _heap_ pode ajudar a explicar por que ele funciona da maneira que funciona.
