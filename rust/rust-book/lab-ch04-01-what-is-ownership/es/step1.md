# ¿Qué es la propiedad?

La **propiedad** es un conjunto de reglas que gobiernan cómo un programa de Rust gestiona la memoria. Todos los programas deben manejar la forma en que utilizan la memoria de un computador mientras se ejecutan. Algunos lenguajes tienen recolección de basura que busca regularmente la memoria que ya no se está utilizando mientras el programa se ejecuta; en otros lenguajes, el programador debe asignar y liberar explícitamente la memoria. Rust utiliza un tercer enfoque: la memoria se gestiona a través de un sistema de propiedad con un conjunto de reglas que el compilador verifica. Si se viola alguna de las reglas, el programa no se compilará. Ninguna de las características de la propiedad ralentizará su programa mientras se está ejecutando.

Debido a que la propiedad es un concepto nuevo para muchos programadores,确实需要一些时间来适应。好消息是，你对 Rust 和所有权系统的规则越有经验，就会发现自然地编写安全高效的代码就越容易。坚持下去！

Cuando comprenda la propiedad, tendrá una base sólida para entender las características que hacen a Rust único. En este capítulo, aprenderá sobre la propiedad trabajando a través de algunos ejemplos que se centran en una estructura de datos muy común: las cadenas.

> **La pila y el montón**
>
> Muchos lenguajes de programación no requieren que pienses muy a menudo en la pila y el montón. Pero en un lenguaje de programación de sistemas como Rust, si un valor está en la pila o en el montón afecta a cómo se comporta el lenguaje y por qué debes tomar ciertas decisiones. Partes de la propiedad se describirán en relación con la pila y el montón más adelante en este capítulo, por lo que aquí hay una breve explicación como preparación.
>
> Tanto la pila como el montón son partes de la memoria disponible para su código para utilizar en tiempo de ejecución, pero están estructurados de diferentes maneras. La pila almacena los valores en el orden en que los obtiene y elimina los valores en el orden inverso. Esto se conoce como _último en, primer out_. Piensa en una pila de platos: cuando agregas más platos, los pones en la cima de la pila, y cuando necesitas un plato, lo tomas de la cima. Agregar o quitar platos del medio o del fondo no funcionaría tan bien. Agregar datos se llama _apilar en la pila_, y quitar datos se llama _desapilar de la pila_. Todos los datos almacenados en la pila deben tener un tamaño conocido y fijo. Los datos con un tamaño desconocido en tiempo de compilación o un tamaño que puede cambiar deben almacenarse en el montón en su lugar.
>
> El montón está menos organizado: cuando pones datos en el montón, solicitas una cierta cantidad de espacio. El asignador de memoria encuentra un lugar vacío en el montón que sea lo suficientemente grande, lo marca como en uso y devuelve un _apuntador_, que es la dirección de esa ubicación. Este proceso se llama _asignar en el montón_ y a veces se abrevia simplemente como _asignar_ (apilar valores en la pila no se considera asignar). Debido a que el apuntador al montón es de un tamaño conocido y fijo, puedes almacenar el apuntador en la pila, pero cuando quieres los datos reales, debes seguir el apuntador. Piensa en sentarte en un restaurante. Cuando entras, dices el número de personas en tu grupo, y el host encuentra una mesa vacía que cabe a todos y te lleva allí. Si alguien de tu grupo llega tarde, pueden preguntar donde te has sentado para encontrarte.
>
> Apilar en la pila es más rápido que asignar en el montón porque el asignador nunca tiene que buscar un lugar para almacenar nuevos datos; esa ubicación siempre está en la cima de la pila. Comparativamente, asignar espacio en el montón requiere más trabajo porque el asignador debe primero encontrar un espacio lo suficientemente grande para almacenar los datos y luego realizar contabilidad para prepararse para la próxima asignación.
>
> Acceder a datos en el montón es más lento que acceder a datos en la pila porque debes seguir un apuntador para llegar allí. Los procesadores modernos son más rápidos si saltan menos en la memoria. Continuando la analogía, considera a un servidor en un restaurante tomando pedidos de muchas mesas. Es más eficiente obtener todos los pedidos de una mesa antes de pasar a la siguiente. Tomar un pedido de la mesa A, luego un pedido de la mesa B, luego uno de A nuevamente y luego uno de B nuevamente sería un proceso mucho más lento. Del mismo modo, un procesador puede hacer su trabajo mejor si trabaja con datos que están cerca de otros datos (como en la pila) en lugar de más lejos (como puede ser en el montón).
>
> Cuando su código llama a una función, los valores pasados a la función (incluyendo, potencialmente, apuntadores a datos en el montón) y las variables locales de la función se apilan en la pila. Cuando la función termina, esos valores se desapilan de la pila.
>
> Mantener un seguimiento de qué partes del código están utilizando qué datos en el montón, minimizar la cantidad de datos duplicados en el montón y limpiar los datos no utilizados en el montón para que no se te acabe el espacio son todos problemas que la propiedad aborda. Una vez que comprenda la propiedad, no tendrá que pensar muy a menudo en la pila y el montón, pero saber que el propósito principal de la propiedad es administrar datos del montón puede ayudar a explicar por qué funciona de la manera en que lo hace.
