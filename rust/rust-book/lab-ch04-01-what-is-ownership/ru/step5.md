# Память и выделение памяти

В случае с литералом строки мы знаем содержимое на этапе компиляции, поэтому текст жестко закодирован непосредственно в конечный исполняемый файл. Именно поэтому литералы строки быстры и эффективны. Но эти свойства обусловлены только неизменяемостью литерала строки. К сожалению, мы не можем поместить кусок памяти в бинарник для каждого куска текста, размер которого неизвестен на этапе компиляции и который может изменяться во время выполнения программы.

В случае с типом `String`, чтобы поддерживать изменяемый и расширяемый кусок текста, нам нужно выделить определенный объем памяти в куче, неизвестный на этапе компиляции, чтобы хранить содержимое. Это означает, что:

- Память должна быть запрошена у аллокатора памяти во время выполнения.
- Нам нужно иметь способ вернуть эту память аллокатору, когда мы закончим с нашей `String`.

Первая часть делается нами: когда мы вызываем `String::from`, его реализация запрашивает необходимую память. Это практически общепринято в языках программирования.

Однако вторая часть отличается. В языках с _сборщиком мусора (GC)_ сборщик следит за памятью и очищает память, которая больше не используется, и мы не должны об этом думать. Во многих языках без сборщика мусора наша задача — определить, когда память больше не используется, и вызвать код для явного освобождения ее, так же, как мы делали при запросе памяти. Правильное выполнение этой задачи всегда представляло собой сложную проблему программирования. Если мы забываем, мы будем тратить память. Если мы освобождаем память слишком рано, у нас будет недопустимая переменная. Если мы освобождаем память дважды, это также является ошибкой. Мы должны точно сопоставить один вызов `allocate` с одним вызовом `free`.

Rust выбирает другой путь: память автоматически возвращается, как только переменная, которая владеет этой памятью, выходит за пределы области видимости. Вот версия нашего примера с областью видимости из листинга 4-1, где вместо литерала строки используется `String`:

    {
        let s = String::from("hello"); // s действительна начиная с этой точки

        // работаем с s
    }                                  // эта область видимости теперь завершена, и s больше не
                                       // действительна

Есть естественная точка, в которой мы можем вернуть память, необходимую нашей `String`, аллокатору: когда `s` выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Rust вызывает для нас специальную функцию. Эта функция называется `drop`, и именно здесь автор `String` может поместить код для возврата памяти. Rust автоматически вызывает `drop` при закрывающей фигурной скобке.

> Примечание: В C++ этот паттерн освобождения ресурсов в конце жизни объекта иногда называется _Resource Acquisition Is Initialization_ _(RAII)_. Функция `drop` в Rust будет вам знакома, если вы использовали паттерны RAII.

Этот паттерн оказывает глубокий влияния на то, как пишется код на Rust. Сейчас это может показаться простым, но поведение кода может быть непредвиденным в более сложных ситуациях, когда мы хотим, чтобы несколько переменных использовали данные, выделенные нами в куче. Теперь давайте рассмотрим некоторые из таких ситуаций.
