# Только стековые данные: Copy

Есть еще один аспект, о котором мы еще не говорили. Этот код с целыми числами (часть которого была показана в листинге 4-2) работает и является допустимым:

```rust
let x = 5;
let y = x;

println!("x = {x}, y = {y}");
```

Но этот код, казалось бы, противоречит тому, что мы только что узнали: у нас нет вызова `clone`, но `x` по-прежнему действителен и не был передан в `y`.

Причина в том, что типы, такие как целые числа, которые имеют известный размер на этапе компиляции, хранятся полностью на стеке, поэтому копии фактических значений можно быстро создать. Это означает, что нет никакой причины, по которой мы бы хотели запретить `x` быть действительным после создания переменной `y`. Другими словами, здесь нет разницы между глубокой и поверхностной копированием, поэтому вызов `clone` не сделает ничего другого, чем обычная поверхностная копия, и мы можем его опустить.

Rust имеет специальную аннотацию, называемую трейт `Copy`, который мы можем применить к типам, хранящимся на стеке, как это делается с целыми числами (мы поговорим больше о трейтах в главе 10). Если тип реализует трейт `Copy`, переменные, которые его используют, не перемещаются, а просто копируются тривиально, оставаясь действительными после присвоения другой переменной.

Rust не позволит нам аннотировать тип с `Copy`, если этот тип, или любая его часть, реализовала трейт `Drop`. Если для типа требуется что-то особое при выходе значения за пределы области видимости, и мы добавляем аннотацию `Copy` к этому типу, мы получим ошибку на этапе компиляции. Чтобы узнать, как добавить аннотацию `Copy` к своему типу для реализации трейта, см. раздел "Производимые трейты".

Так, какие типы реализуют трейт `Copy`? Вы можете проверить документацию по заданному типу, чтобы убедиться, но, как правило, любая группа простых скалярных значений может реализовать `Copy`, и ничего, что требует выделения памяти или является какой-то формой ресурса, не может реализовать `Copy`. Вот некоторые из типов, которые реализуют `Copy`:

- Все целочисленные типы, такие как `u32`.
- Логический тип, `bool`, со значениями `true` и `false`.
- Все типы с плавающей точкой, такие как `f64`.
- Тип символов, `char`.
- Кортежи, если они содержат только типы, которые также реализуют `Copy`. Например, `(i32, i32)` реализует `Copy`, но `(i32, String)` не реализует его.
