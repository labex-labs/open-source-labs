# Владение и функции

Механика передачи значения в функцию похожа на механику присвоения значения переменной. Передача переменной в функцию может привести к перемещению или копированию, так же, как и при присвоении. В листинге 4-3 приведен пример с некоторыми аннотациями, показывающими, когда переменные входят и выходят из области видимости.

    // src/main.rs
    fn main() {
        let s = String::from("hello");  // s входит в область видимости

        takes_ownership(s);             // значение s перемещается в функцию...
                                        //... и таким образом здесь больше не действителен

        let x = 5;                      // x входит в область видимости

        makes_copy(x);                  // x было бы передано в функцию,
                                        // но i32 реализует Copy, поэтому можно
                                        // по-прежнему использовать x после этого

    } // Здесь x выходит из области видимости, а затем s. Однако, поскольку
      // значение s было перемещено, ничего особенного не происходит

    fn takes_ownership(some_string: String) { // some_string входит в область видимости
        println!("{some_string}");
    } // Здесь some_string выходит из области видимости и вызывается `drop`.
      // Освобождается память, на которой хранится строка

    fn makes_copy(some_integer: i32) { // some_integer входит в область видимости
        println!("{some_integer}");
    } // Здесь some_integer выходит из области видимости. Ничего особенного не происходит

Листинг 4-3: Функции с указанным владением и областью видимости

Если мы бы попытались использовать `s` после вызова `takes_ownership`, Rust бы выдал ошибку на этапе компиляции. Эти статические проверки защищают нас от ошибок. Попробуйте добавить в `main` код, который использует `s` и `x`, чтобы понять, где можно их использовать, а где правила владения не позволяют это сделать.
