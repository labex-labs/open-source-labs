# Что такое владение?

_Владение_ — это набор правил, которые определяют, как программа на Rust управляет памятью. Все программы должны управлять тем, как используют память компьютера во время выполнения. Некоторые языки имеют сборку мусора, которая регулярно ищет неиспользуемую память во время выполнения программы; в других языках программист должен явно выделять и освобождать память. Rust использует третий подход: память управляется с помощью системы владения с набором правил, которые проверяет компилятор. Если нарушены какие-либо из правил, программа не скомпилируется. Ни одна из особенностей владения не замедлит вашу программу во время ее выполнения.

Поскольку владение представляет собой новую концепцию для многих программистов, нужно некоторое время, чтобы привыкнуть к ней. Хорошая новость заключается в том, что чем более опытным вы становитесь в Rust и правилах системы владения, тем легче вам будет естественно разрабатывать безопасный и эффективный код. Не останавливайтесь!

Когда вы поймете владение, у вас будет твердая основа для понимания особенностей, которые делают Rust уникальным. В этом разделе вы узнаете о владении, работая с примерами, которые сосредоточены на очень распространенной структуре данных: строках.

> **Стек и кучу**
>
> Многие языки программирования не требуют часто думать о стеке и куче. Но в языке системного программирования, таких как Rust, то, находится ли значение на стеке или в куче, влияет на то, как behaves язык, и почему вам приходится принимать определенные решения. Части владения будут описаны в отношении стека и кучи позже в этом разделе, поэтому здесь дана краткая поясняющая информация в подготовку.
>
> Стек и кучу — это части памяти, доступные вашему коду для использования во время выполнения, но они структурированы по-разному. Стек хранит значения в том порядке, в котором получает их, и удаляет значения в обратном порядке. Это называется _последним пришел, первым ушел_. Представьте себе стопку тарелок: когда вы добавляете новые тарелки, вы кладете их сверху, а когда вам нужна тарелка, вы берете ее сверху. Добавление или удаление тарелок из середины или снизу не будет работать так хорошо! Добавление данных называется _заталкиванием на стек_, а удаление данных — _выталкиванием со стека_. Все данные, хранящиеся на стеке, должны иметь известный, фиксированный размер. Данные с неизвестным размером на этапе компиляции или размером, который может изменяться, должны быть хранится в куче.
>
> Куча менее организована: когда вы кладете данные в кучу, вы запрашиваете определенный объем памяти. А llocator памяти находит свободное место в куче, которое достаточно большое, помечает его как занятое и возвращает _указатель_, который является адресом этого места. Этот процесс называется _выделением памяти в куче_ и иногда сокращается просто до _выделения_ (заталкивание значений на стек не считается выделением). Поскольку указатель на кучу имеет известный, фиксированный размер, вы можете хранить указатель на стеке, но когда вы хотите получить фактические данные, вам нужно следовать за указателем. Представьте, что вы сидите в ресторане. Когда вы зашли, вы сообщаете количество человек в своей группе, и хозяин находит свободное столик, который вмещает всех вас, и проводит вас туда. Если кто-то из вашей группы приходит поздно, он может спросить, где вас посадили, чтобы вас найти.
>
> Заталкивание на стек происходит быстрее, чем выделение памяти в куче, потому что llocator памяти никогда не должен искать место для хранения новых данных; это место всегда находится в вершине стека. Сравнительно, выделение памяти в куче требует большего количества работы, потому что llocator памяти должен сначала найти достаточно большое место для хранения данных, а затем провести бухгалтерские процедуры для подготовки к следующему выделению.
>
> Доступ к данным в куче происходит медленнее, чем доступ к данным на стеке, потому что вам нужно следовать за указателем, чтобы добраться до них. Современные процессоры работают быстрее, если они прыгают меньше по памяти. Продолжая аналогию, представьте, что официант в ресторане берет заказы у многих столов. Самым эффективным будет получить все заказы с одного стола, прежде чем переходить к следующему столу. Взять заказ с стола А, затем заказ с стола B, затем снова с A, а затем снова с B, будет гораздо медленнее. По той же причине процессор может лучше выполнять свою работу, если работает с данными, которые находятся близко к другим данным (как это на стеке), а не дальше (как это может быть в куче).
>
> Когда ваш код вызывает функцию, значения, передаваемые в функцию (в том числе, возможно, указатели на данные в куче) и локальные переменные функции помещаются на стек. Когда функция завершается, эти значения выталкиваются со стека.
>
> Отслеживание того, какие части кода используют какие данные в куче, минимизация количества дублирующихся данных в куче и очистка неиспользуемых данных в куче, чтобы вы не исчерпали память, — все это проблемы, которые решает владение. Как только вы поймете владение, вам не нужно часто думать о стеке и куче, но знание того, что главная цель владения — управление данными в куче, может помочь объяснить, почему оно работает так, как работает.
