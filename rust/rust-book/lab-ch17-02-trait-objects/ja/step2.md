# 共通の振る舞いを定義するトレイト

`gui` に持たせたい振る舞いを実装するには、`Draw` という名前のトレイトを定義します。このトレイトには `draw` という名前の 1 つのメソッドがあります。そして、_トレイトオブジェクト_ を持つベクターを定義することができます。トレイトオブジェクトは、指定したトレイトを実装する型のインスタンスと、実行時にその型のトレイトメソッドを検索するために使用されるテーブルの両方を指します。トレイトオブジェクトは、`&` 参照や `Box<T>` スマートポインタなどのある種のポインタを指定し、その後 `dyn` キーワードを指定し、その後関連するトレイトを指定することで作成します。（「動的にサイズ指定される型と Sized トレイト」で、トレイトオブジェクトがポインタを使用する必要がある理由について説明します。）トレイトオブジェクトを使用してジェネリック型または具体的な型の代わりに使用することができます。トレイトオブジェクトを使用する場所では、Rust の型システムがコンパイル時にそのコンテキストで使用されるすべての値がトレイトオブジェクトのトレイトを実装することを保証します。したがって、コンパイル時にすべての可能な型を知る必要はありません。

Rust では、他の言語のオブジェクトと区別するために、構造体や列挙型を「オブジェクト」と呼ぶことは控えていることを述べてきました。構造体または列挙型では、構造体フィールドのデータと `impl` ブロックの振る舞いが分離されていますが、他の言語では、データと振る舞いが 1 つの概念にまとめられたものが多く、オブジェクトと呼ばれます。ただし、トレイトオブジェクトは、データと振る舞いを組み合わせた点で、他の言語のオブジェクトに似ています。ただし、トレイトオブジェクトは、トレイトオブジェクトにデータを追加することはできませんという点で、従来のオブジェクトとは異なります。トレイトオブジェクトは、他の言語のオブジェクトほど一般的に有用ではありません。その主な目的は、共通の振る舞いに対する抽象化を可能にすることです。

リスト 17-3 は、`draw` という名前の 1 つのメソッドを持つ `Draw` という名前のトレイトを定義する方法を示しています。

ファイル名：`src/lib.rs`

```rust
pub trait Draw {
    fn draw(&self);
}
```

リスト 17-3: `Draw` トレイトの定義

この構文は、第 10 章でトレイトを定義する方法についての議論からおなじみのものです。次に新しい構文が登場します。リスト 17-4 は、`components` という名前のベクターを保持する `Screen` という名前の構造体を定義しています。このベクターは `Box<dyn Draw>` 型で、これはトレイトオブジェクトです。つまり、`Box` 内の `Draw` トレイトを実装する任意の型の代用となります。

ファイル名：`src/lib.rs`

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

リスト 17-4: `Draw` トレイトを実装するトレイトオブジェクトのベクターを保持する `components` フィールドを持つ `Screen` 構造体の定義

`Screen` 構造体では、リスト 17-5 に示すように、`components` それぞれに対して `draw` メソッドを呼び出す `run` メソッドを定義します。

ファイル名：`src/lib.rs`

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

リスト 17-5: 各コンポーネントに対して `draw` メソッドを呼び出す `Screen` の `run` メソッド

これは、トレイト境界付きのジェネリック型パラメータを使用する構造体を定義する場合とは異なる動作をします。ジェネリック型パラメータは、1 回に 1 つの具体的な型でのみ置き換えることができますが、トレイトオブジェクトは、実行時にトレイトオブジェクトを埋めるために複数の具体的な型を許容します。たとえば、リスト 17-6 のように、ジェネリック型とトレイト境界を使用して `Screen` 構造体を定義することができます。

ファイル名：`src/lib.rs`

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

リスト 17-6: ジェネリックとトレイト境界を使用した `Screen` 構造体とその `run` メソッドの代替実装

これにより、`Button` 型のコンポーネントのリストまたは `TextField` 型のコンポーネントのリストを持つ `Screen` インスタンスに制限されます。同じ型のコレクションのみを持つ場合、ジェネリックとトレイト境界を使用する方が好ましいです。なぜなら、定義はコンパイル時にモノモーフィック化されて具体的な型を使用するようになるからです。

一方、トレイトオブジェクトを使用するメソッドでは、1 つの `Screen` インスタンスには、`Box<Button>` と `Box<TextField>` を含む `Vec<T>` を保持できます。これがどのように機能するか見てみましょう。その後、実行時のパフォーマンスの影響について説明します。
