# 異なる型の値を許容するトレイトオブジェクトの使用方法

第8章では、ベクターの1つの制限として、1つの型の要素のみを格納できることを述べました。リスト8-9では、整数、浮動小数点数、文字列などを保持するための変数を持つ `SpreadsheetCell` 列挙型を定義することで回避策を考えました。これにより、各セルに異なる型のデータを格納し、セルの行を表すベクターを保持することができました。これは、コードをコンパイルするときに知っている固定の型のセットで交換可能な項目を扱う場合には、非常に良い解決策です。

ただし、場合によっては、ライブラリのユーザーに特定の状況で有効な型のセットを拡張できるようにしたい場合があります。これをどのように実現できるかを示すために、グラフィカルユーザーインターフェイス (GUI) ツールの例を作成します。このツールは、項目のリストを反復処理し、それぞれに `draw` メソッドを呼び出して画面に描画するもので、GUIツールの一般的な手法です。`gui` という名前のライブラリクレートを作成し、GUIライブラリの構造を含めます。このクレートには、`Button` や `TextField` など、人々が使用できるいくつかの型が含まれる場合があります。さらに、`gui` のユーザーは、描画できる独自の型を作成したいでしょう。たとえば、あるプログラマーは `Image` を追加し、別のプログラマーは `SelectBox` を追加するかもしれません。

この例では、完全なGUIライブラリを実装することはできませんが、各部品がどのように組み合わされるかを示します。ライブラリを書くときには、他のプログラマーが作成したいすべての型を知り、定義することはできません。しかし、`gui` は多くの異なる型の値を追跡する必要があり、これらの異なる型の値それぞれに対して `draw` メソッドを呼び出す必要があります。`draw` メソッドを呼び出したときに正確に何が起こるかは知る必要はありません。ただ、その値にそのメソッドがあり、私たちが呼び出せることがわかっていれば十分です。

継承を持つ言語でこれを行うには、`Component` という名前のクラスを定義し、その上に `draw` メソッドを持たせます。他のクラス、たとえば `Button`、`Image`、`SelectBox` は、`Component` から継承し、それにより `draw` メソッドを継承します。それぞれが独自のカスタム動作を定義するために `draw` メソッドをオーバーライドすることができますが、フレームワークはすべての型を `Component` インスタンスとして扱い、それらに対して `draw` を呼び出すことができます。しかし、Rustには継承がないため、`gui` ライブラリを構造化して、ユーザーが新しい型で拡張できるようにする別の方法が必要です。
