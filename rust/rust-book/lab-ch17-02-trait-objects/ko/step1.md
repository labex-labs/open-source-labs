# 다양한 타입의 값을 허용하는 트레이트 객체 사용하기

8 장에서 벡터의 한계 중 하나는 단일 타입의 요소만 저장할 수 있다는 점을 언급했습니다. Listing 8-9 에서 정수, 부동 소수점 숫자, 텍스트를 저장하는 변형을 가진 `SpreadsheetCell` 열거형을 정의하여 이 문제를 해결했습니다. 이는 각 셀에 서로 다른 타입의 데이터를 저장할 수 있었고, 여전히 셀 행을 나타내는 벡터를 가질 수 있다는 것을 의미했습니다. 이는 교환 가능한 항목이 코드가 컴파일될 때 알고 있는 고정된 타입 집합일 때 완벽하게 좋은 해결책입니다.

그러나 때로는 라이브러리 사용자가 특정 상황에서 유효한 타입 집합을 확장할 수 있도록 하고 싶을 수 있습니다. 이를 어떻게 달성할 수 있는지 보여주기 위해, 항목 목록을 반복하고 각 항목에 대해 `draw` 메서드를 호출하여 화면에 그리는 예시 그래픽 사용자 인터페이스 (GUI) 도구를 만들 것입니다. 이는 GUI 도구에서 흔히 사용되는 기술입니다. `gui`라는 라이브러리 크레이트를 생성하여 GUI 라이브러리의 구조를 포함시킬 것입니다. 이 크레이트는 `Button` 또는 `TextField`와 같이 사람들이 사용할 수 있는 몇 가지 타입을 포함할 수 있습니다. 또한, `gui` 사용자는 그릴 수 있는 자체 타입을 만들고 싶어할 것입니다. 예를 들어, 한 프로그래머는 `Image`를 추가하고 다른 프로그래머는 `SelectBox`를 추가할 수 있습니다.

이 예제에서는 완전한 GUI 라이브러리를 구현하지 않지만, 구성 요소가 어떻게 함께 연결되는지 보여줄 것입니다. 라이브러리를 작성할 당시에는 다른 프로그래머가 만들 수 있는 모든 타입을 알 수 없고 정의할 수도 없습니다. 하지만 `gui`가 서로 다른 타입의 많은 값을 추적해야 하고, 이러한 서로 다른 타입의 각 값에 대해 `draw` 메서드를 호출해야 한다는 것을 알고 있습니다. `draw` 메서드를 호출할 때 정확히 어떤 일이 일어날지는 알 필요가 없지만, 해당 값에 우리가 호출할 수 있는 해당 메서드가 있다는 것만 알면 됩니다.

상속이 있는 언어에서 이를 수행하려면 `draw`라는 메서드를 가진 `Component`라는 클래스를 정의할 수 있습니다. `Button`, `Image`, `SelectBox`와 같은 다른 클래스는 `Component`에서 상속받아 `draw` 메서드를 상속받습니다. 각 클래스는 사용자 정의 동작을 정의하기 위해 `draw` 메서드를 재정의할 수 있지만, 프레임워크는 모든 타입을 `Component` 인스턴스인 것처럼 처리하고 해당 인스턴스에서 `draw`를 호출할 수 있습니다. 그러나 Rust 에는 상속이 없으므로 사용자가 새로운 타입으로 확장할 수 있도록 `gui` 라이브러리를 구성하는 다른 방법이 필요합니다.
