# 트레이트 객체는 동적 디스패치를 수행합니다

"제네릭을 사용하는 코드의 성능"에서 제네릭에 트레이트 바운드를 사용할 때 컴파일러가 수행하는 단형화 (monomorphization) 프로세스에 대한 논의를 기억하십시오. 컴파일러는 제네릭 타입 매개변수 대신 사용하는 각 구체적인 타입에 대해 함수와 메서드의 비제네릭 구현을 생성합니다. 단형화의 결과로 생성된 코드는 컴파일 시간에 어떤 메서드를 호출하는지 컴파일러가 알고 있는 _정적 디스패치_(static dispatch) 를 수행합니다. 이는 컴파일 시간에 어떤 메서드를 호출하는지 컴파일러가 알 수 없는 _동적 디스패치_(dynamic dispatch) 와 반대됩니다. 동적 디스패치의 경우, 컴파일러는 런타임에 어떤 메서드를 호출할지 알아낼 코드를 내보냅니다.

트레이트 객체를 사용할 때 Rust 는 동적 디스패치를 사용해야 합니다. 컴파일러는 트레이트 객체를 사용하는 코드와 함께 사용될 수 있는 모든 타입을 알지 못하므로, 어떤 타입에서 구현된 어떤 메서드를 호출해야 하는지 알 수 없습니다. 대신, 런타임에 Rust 는 트레이트 객체 내부의 포인터를 사용하여 어떤 메서드를 호출해야 하는지 알 수 있습니다. 이 조회는 정적 디스패치에서는 발생하지 않는 런타임 비용을 발생시킵니다. 동적 디스패치는 또한 컴파일러가 메서드의 코드를 인라인하도록 선택하는 것을 방지하여 일부 최적화를 방지합니다. 그러나 Listing 17-5 에서 작성한 코드에서 추가적인 유연성을 얻었고 Listing 17-9 에서 지원할 수 있었으므로, 이는 고려해야 할 트레이드 오프입니다.
