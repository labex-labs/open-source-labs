# Using Trait Objects That Allow for Values of Different Types

Dans le chapitre 8, nous avons mentionné qu'une limitation des vecteurs est qu'ils ne peuvent stocker que des éléments d'un seul type. Nous avons créé un contournement dans la liste 8-9 où nous avons défini une énumération `SpreadsheetCell` qui avait des variantes pour stocker des entiers, des flottants et du texte. Cela signifie que nous pouvions stocker différents types de données dans chaque cellule et toujours avoir un vecteur représentant une ligne de cellules. C'est une solution parfaitement valable lorsque nos éléments interchangeables sont un ensemble fixe de types que nous connaissons au moment de la compilation de notre code.

Cependant, parfois, nous voulons que l'utilisateur de notre bibliothèque soit capable d'étendre l'ensemble des types valides dans une situation donnée. Pour montrer comment nous pourrions y arriver, nous allons créer un exemple d'outil d'interface graphique utilisateur (GUI) qui parcourt une liste d'éléments, appelant une méthode `draw` sur chacun d'entre eux pour l'afficher à l'écran - une technique courante pour les outils GUI. Nous allons créer une boîte crânienne de bibliothèque appelée `gui` qui contient la structure d'une bibliothèque GUI. Cette boîte crânienne pourrait inclure certains types pour que les gens puissent les utiliser, tels que `Button` ou `TextField`. En outre, les utilisateurs de `gui` voudront créer leurs propres types qui peuvent être dessinés : par exemple, un programmeur pourrait ajouter une `Image` et un autre pourrait ajouter un `SelectBox`.

Nous ne mettrons pas en œuvre une bibliothèque GUI complète pour cet exemple, mais nous montrerons comment les pièces s'assembleraient. Au moment de la rédaction de la bibliothèque, nous ne pouvons pas connaître et définir tous les types que d'autres programmeurs pourraient vouloir créer. Mais nous savons que `gui` doit suivre de nombreux valeurs de différents types, et qu'il doit appeler une méthode `draw` sur chacune de ces valeurs de types différents. Il n'a pas besoin de savoir exactement ce qui se passera lorsque nous appellerons la méthode `draw`, juste que la valeur aura cette méthode disponible pour que nous puissions l'appeler.

Pour le faire dans un langage avec héritage, nous pourrions définir une classe nommée `Component` qui aurait une méthode nommée `draw`. Les autres classes, telles que `Button`, `Image` et `SelectBox`, hérite de `Component` et héritent donc de la méthode `draw`. Elles pourraient chacune remplacer la méthode `draw` pour définir leur comportement personnalisé, mais le cadre pourrait traiter tous les types comme s'ils étaient des instances de `Component` et appeler `draw` sur eux. Mais parce que Rust n'a pas d'héritage, nous avons besoin d'une autre manière de structurer la bibliothèque `gui` pour permettre aux utilisateurs de l'étendre avec de nouveaux types.
