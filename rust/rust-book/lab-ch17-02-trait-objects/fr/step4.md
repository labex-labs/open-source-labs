# Les objets de trait effectuent un appel de fonction dynamique

Rappelez-vous dans "Performance of Code Using Generics" notre discussion sur le processus de monomorphisation effectué par le compilateur lorsque nous utilisons des contraintes de trait sur des types génériques : le compilateur génère des implémentations non génériques de fonctions et de méthodes pour chaque type concret que nous utilisons à la place d'un paramètre de type générique. Le code résultant de la monomorphisation effectue un _appel de fonction statique_, c'est-à-dire que le compilateur sait quelle méthode vous appelez à la compilation. Cela est opposé à l'_appel de fonction dynamique_, qui est lorsque le compilateur ne peut pas savoir à la compilation quelle méthode vous appelez. Dans les cas d'appel de fonction dynamique, le compilateur émet du code qui déterminera à l'exécution quelle méthode appeler.

Lorsque nous utilisons des objets de trait, Rust doit utiliser un appel de fonction dynamique. Le compilateur ne connaît pas tous les types qui pourraient être utilisés avec le code qui utilise des objets de trait, donc il ne sait pas quelle méthode implémentée sur quel type appeler. Au lieu de cela, à l'exécution, Rust utilise les pointeurs à l'intérieur de l'objet de trait pour savoir quelle méthode appeler. Cette recherche entraîne une surcharge d'exécution qui n'est pas présente avec l'appel de fonction statique. L'appel de fonction dynamique empêche également le compilateur de choisir d'inliner le code d'une méthode, ce qui empêche à son tour certaines optimisations. Cependant, nous avons obtenu une flexibilité supplémentaire dans le code que nous avons écrit dans la liste 17-5 et avons pu prendre en charge dans la liste 17-9, il s'agit donc d'un compromis à considérer.
