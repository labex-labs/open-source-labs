# Usando Objetos de Trato que Permiten Valores de Diferentes Tipos

En el Capítulo 8, mencionamos que una limitación de los vectores es que solo pueden almacenar elementos de un solo tipo. Creamos un arreglo en la Lista 8-9 donde definimos un enum `SpreadsheetCell` que tenía variantes para almacenar enteros, flotantes y texto. Esto significa que podíamos almacenar diferentes tipos de datos en cada celda y todavía tener un vector que representara una fila de celdas. Esta es una solución perfectamente buena cuando nuestros elementos intercambiables son un conjunto fijo de tipos que conocemos cuando nuestro código se compila.

Sin embargo, a veces queremos que el usuario de nuestra biblioteca sea capaz de extender el conjunto de tipos que son válidos en una situación particular. Para mostrar cómo podríamos lograr esto, crearemos un ejemplo de herramienta de interfaz gráfica de usuario (GUI) que itera a través de una lista de elementos, llamando a un método `draw` en cada uno para dibujarlo en la pantalla, una técnica común para herramientas GUI. Crearemos un crat de biblioteca llamado `gui` que contiene la estructura de una biblioteca GUI. Este crat podría incluir algunos tipos para que las personas los usen, como `Button` o `TextField`. Además, los usuarios de `gui` querrán crear sus propios tipos que se pueden dibujar: por ejemplo, un programador podría agregar una `Image` y otro podría agregar un `SelectBox`.

No implementaremos una biblioteca GUI de pleno funcionamiento para este ejemplo, pero mostraremos cómo se encajarían las piezas. Al momento de escribir la biblioteca, no podemos conocer y definir todos los tipos que otros programadores podrían querer crear. Pero sí sabemos que `gui` necesita llevar un registro de muchos valores de diferentes tipos, y necesita llamar a un método `draw` en cada uno de estos valores de diferentes tipos. No necesita saber exactamente lo que pasará cuando llamamos al método `draw`, solo que el valor tendrá ese método disponible para que lo llamemos.

Para hacer esto en un lenguaje con herencia, podríamos definir una clase llamada `Component` que tenga un método llamado `draw` en ella. Las otras clases, como `Button`, `Image` y `SelectBox`, heredarían de `Component` y, por lo tanto, heredarían el método `draw`. Podrían cada una sobrescribir el método `draw` para definir su comportamiento personalizado, pero el marco podría tratar a todos los tipos como si fueran instancias de `Component` y llamar a `draw` en ellos. Pero como Rust no tiene herencia, necesitamos otra forma de estructurar la biblioteca `gui` para permitir que los usuarios la extiendan con nuevos tipos.
