# Los Objetos de Trato Realizan el Despacho Dinámico

Recuerde en "Rendimiento del Código que Utiliza Genéricos" nuestra discusión sobre el proceso de monomorfización realizado por el compilador cuando usamos límites de trato en genéricos: el compilador genera implementaciones no genéricas de funciones y métodos para cada tipo concreto que usamos en lugar de un parámetro de tipo genérico. El código que resulta de la monomorfización está realizando _despacho estático_, que es cuando el compilador sabe qué método está llamando en tiempo de compilación. Esto se opone al _despacho dinámico_, que es cuando el compilador no puede decir en tiempo de compilación qué método está llamando. En casos de despacho dinámico, el compilador emite código que en tiempo de ejecución determinará qué método llamar.

Cuando usamos objetos de trato, Rust debe usar despacho dinámico. El compilador no conoce todos los tipos que podrían usarse con el código que está usando objetos de trato, por lo que no sabe qué método implementado en qué tipo llamar. En cambio, en tiempo de ejecución, Rust utiliza los punteros dentro del objeto de trato para saber qué método llamar. Esta búsqueda implica un costo en tiempo de ejecución que no ocurre con el despacho estático. El despacho dinámico también impide que el compilador elija insertar en línea el código de un método, lo que a su vez impide algunas optimizaciones. Sin embargo, obtuvimos una flexibilidad adicional en el código que escribimos en la Lista 17-5 y pudimos admitir en la Lista 17-9, por lo que es un trato que considerar.
