# Использование объектов-примесей, которые допускают значения разных типов

В главе 8 мы упоминали, что одним ограничением векторов является то, что они могут хранить элементы только одного типа. Мы создали обходную схему в листинге 8-9, где определили перечисление `SpreadsheetCell`, которое имело варианты для хранения целых чисел, вещественных чисел и текста. Это значило, что мы могли хранить разные типы данных в каждой ячейке и по-прежнему иметь вектор, представляющий строку ячеек. Это вполне хорошее решение, когда наши взаимозаменяемые элементы представляют собой фиксированный набор типов, которые мы знаем при компиляции нашего кода.

Однако иногда мы хотим, чтобы пользователь нашей библиотеки мог расширять набор типов, которые допустимы в определенной ситуации. Чтобы показать, как мы можем это достичь, мы создадим пример графического интерфейса пользователя (GUI) инструмента, который перебирает список элементов и вызывает метод `draw` для каждого из них, чтобы нарисовать его на экране - это распространенная техника для GUI инструментов. Мы создадим библиотечный крейт под названием `gui`, который содержит структуру GUI библиотеки. Этот крейт может включать некоторые типы для использования пользователями, такие как `Button` или `TextField`. Кроме того, пользователи `gui` захотят создать свои собственные типы, которые могут быть нарисованы: например, один программист может добавить `Image`, а другой - `SelectBox`.

Мы не реализуем полноценную GUI библиотеку для этого примера, но покажем, как части будут взаимодействовать друг с другом. При написании библиотеки мы не можем знать и определить все типы, которые могут создать другие программисты. Но мы знаем, что `gui` должен отслеживать множество значений разных типов и вызывать метод `draw` для каждого из этих значений разных типов. Мы не нуждаемся в точном знании того, что произойдет при вызове метода `draw`, просто нужно, чтобы значение имело этот метод, доступный для вызова.

Чтобы сделать это на языке с наследованием, мы могли бы определить класс под названием `Component`, у которого есть метод под названием `draw`. Другие классы, такие как `Button`, `Image` и `SelectBox`, бы наследовали от `Component` и таким образом наследовали метод `draw`. Они могли бы каждый переопределить метод `draw`, чтобы определить свою собственную поведенческую логику, но фреймворк мог бы рассматривать все типы как экземпляры `Component` и вызывать `draw` для них. Но поскольку Rust не имеет наследования, нам нужно другой способ структурирования библиотеки `gui`, чтобы позволить пользователям расширять ее новыми типами.
