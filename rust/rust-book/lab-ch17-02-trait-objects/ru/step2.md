# Определение примеси для общего поведения

Для реализации поведения, которое мы хотим, чтобы `gui` имело, мы определим примесь под названием `Draw`, которая будет иметь один метод под названием `draw`. Затем мы можем определить вектор, который принимает _объект-примесь_. Объект-примесь указывает на как экземпляр типа, реализующего нашу заданную примесь, так и на таблицу, используемую для поиска методов примеси для этого типа во время выполнения. Мы создаем объект-примесь, указав какой-то тип указателя, такой как `&` ссылка или умный указатель `Box<T>`, затем ключевое слово `dyn`, а затем указывая соответствующую примесь. (Мы поговорим о причине, по которой объекты-примеси должны использовать указатель в разделе "Динамически размерные типы и примесь Sized".) Мы можем использовать объекты-примеси вместо обобщенного или конкретного типа. В любом месте, где мы используем объект-примесь, типовая система Rust обеспечит во время компиляции то, что любое значение, используемое в этом контексте, будет реализовывать примесь объекта-примеси. Следовательно, нам не нужно знать все возможные типы при компиляции.

Мы упоминали, что в Rust мы стараемся не называть структуры и перечисления "объектами", чтобы отличать их от объектов других языков. В структуре или перечислении данные в полях структуры и поведение в блоках `impl` разделены, в то время как в других языках данные и поведение, объединенные в один концепт, часто помечаются как объект. Однако объекты-примеси _более похожи_ на объекты в других языках в том смысле, что они объединяют данные и поведение. Но объекты-примеси отличаются от традиционных объектов тем, что мы не можем добавить данные к объекту-примеси. Объекты-примеси не так широко используются, как объекты в других языках: их конкретная цель - это позволить абстрагироваться от общего поведения.

Листинг 17-3 показывает, как определить примесь под названием `Draw` с одним методом под названием `draw`.

Имя файла: `src/lib.rs`

```rust
pub trait Draw {
    fn draw(&self);
}
```

Листинг 17-3: Определение примеси `Draw`

Этот синтаксис должен быть вам знакомым из наших обсуждений о том, как определить примеси в главе 10. Далее идет новый синтаксис: Листинг 17-4 определяет структуру под названием `Screen`, которая содержит вектор под названием `components`. Этот вектор имеет тип `Box<dyn Draw>`, который является объектом-примесью; это替身 для любого типа внутри `Box`, который реализует примесь `Draw`.

Имя файла: `src/lib.rs`

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

Листинг 17-4: Определение структуры `Screen` с полем `components`, содержащим вектор объектов-примесей, реализующих примесь `Draw`

Для структуры `Screen` мы определим метод под названием `run`, который вызовет метод `draw` для каждого из ее `components`, как показано в Листинге 17-5.

Имя файла: `src/lib.rs`

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

Листинг 17-5: Метод `run` на `Screen`, который вызывает метод `draw` для каждого компонента

Это работает по-разному, чем определение структуры, которая использует обобщенный тип параметр с ограничениями примесей. Обобщенный тип параметр может быть заменен только одним конкретным типом за раз, в то время как объекты-примеси позволяют нескольким конкретным типам заполнить объект-примесь во время выполнения. Например, мы могли бы определить структуру `Screen` с использованием обобщенного типа и ограничения примеси, как в Листинге 17-6.

Имя файла: `src/lib.rs`

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

Листинг 17-6: Альтернативная реализация структуры `Screen` и ее метода `run` с использованием обобщений и ограничений примесей

Это ограничивает нас экземпляром `Screen`, который имеет список компонентов одного типа `Button` или одного типа `TextField`. Если у вас будут только однородные коллекции, то использование обобщений и ограничений примесей предпочтительнее, потому что определения будут мономорфизованы во время компиляции для использования конкретных типов.

С другой стороны, с методом, использующим объекты-примеси, один экземпляр `Screen` может содержать `Vec<T>`, который содержит `Box<Button>` и `Box<TextField>`. Посмотрим, как это работает, а затем поговорим о последствиях производительности во время выполнения.
