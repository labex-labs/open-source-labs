# Объекты-примеси выполняют динамическую диспетчеризацию

Помните, в разделе "Производительность кода с использованием обобщений" наше обсуждение о процессе мономорфизования, выполняемом компилятором, когда мы используем ограничения примесей для обобщений: компилятор генерирует необобщенные реализации функций и методов для каждого конкретного типа, который мы используем вместо параметра типа-обобщения. Код, полученный в результате мономорфизования, выполняет _статическую диспетчеризацию_, то есть когда компилятор знает, какой метод вы вызываете во время компиляции. Это противоположно _динамической диспетчеризации_, которая происходит, когда компилятор не может определить во время компиляции, какой метод вы вызываете. В случаях динамической диспетчеризации компилятор генерирует код, который во время выполнения определит, какой метод вызвать.

Когда мы используем объекты-примеси, Rust должен использовать динамическую диспетчеризацию. Компилятор не знает все типы, которые могут использоваться с кодом, использующим объекты-примеси, поэтому он не знает, какой метод, реализованный для какого типа, вызвать. Вместо этого во время выполнения Rust использует указатели внутри объекта-примеси, чтобы знать, какой метод вызвать. Эта процедура поиска несет издержки во время выполнения, которые не возникают при статической диспетчеризации.Динамическая диспетчеризация также препятствует компилятору вставлять код метода inline, что в свою очередь препятствует некоторым оптимизациям. Однако мы получили дополнительную гибкость в коде, который мы написали в Листинге 17-5 и смогли поддержать в Листинге 17-9, поэтому это - компромисс, который стоит рассмотреть.
