# Objetos Trait Executam Dispatch Dinâmico

Lembre-se em "Desempenho do Código Usando Genéricos" de nossa discussão sobre o processo de monomorfização realizado pelo compilador quando usamos limites de trait em genéricos: o compilador gera implementações não genéricas de funções e métodos para cada tipo concreto que usamos no lugar de um parâmetro de tipo genérico. O código que resulta da monomorfização está fazendo _dispatch estático_, que é quando o compilador sabe qual método você está chamando em tempo de compilação. Isso se opõe ao _dispatch dinâmico_, que é quando o compilador não pode dizer em tempo de compilação qual método você está chamando. Em casos de dispatch dinâmico, o compilador emite código que, em tempo de execução, descobrirá qual método chamar.

Quando usamos objetos trait, o Rust deve usar dispatch dinâmico. O compilador não conhece todos os tipos que podem ser usados com o código que está usando objetos trait, então ele não sabe qual método implementado em qual tipo chamar. Em vez disso, em tempo de execução, o Rust usa os ponteiros dentro do objeto trait para saber qual método chamar. Essa pesquisa incorre em um custo de tempo de execução que não ocorre com o dispatch estático. O dispatch dinâmico também impede que o compilador escolha embutir o código de um método, o que, por sua vez, impede algumas otimizações. No entanto, obtivemos flexibilidade extra no código que escrevemos no Listing 17-5 e fomos capazes de suportar no Listing 17-9, então é uma troca a ser considerada.
