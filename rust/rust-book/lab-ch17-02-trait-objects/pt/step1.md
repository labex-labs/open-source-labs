# Usando Objetos Trait que Permitem Valores de Diferentes Tipos

No Capítulo 8, mencionamos que uma limitação dos vetores é que eles podem armazenar elementos de apenas um tipo. Criamos uma solução alternativa no Listing 8-9, onde definimos um enum `SpreadsheetCell` que tinha variantes para armazenar inteiros, floats e texto. Isso significava que podíamos armazenar diferentes tipos de dados em cada célula e ainda ter um vetor que representava uma linha de células. Esta é uma solução perfeitamente boa quando nossos itens intercambiáveis são um conjunto fixo de tipos que conhecemos quando nosso código é compilado.

No entanto, às vezes queremos que o usuário da nossa biblioteca possa estender o conjunto de tipos que são válidos em uma situação específica. Para mostrar como podemos conseguir isso, criaremos um exemplo de ferramenta de interface gráfica do usuário (GUI) que itera por uma lista de itens, chamando um método `draw` em cada um para desenhá-lo na tela - uma técnica comum para ferramentas GUI. Criaremos uma crate de biblioteca chamada `gui` que contém a estrutura de uma biblioteca GUI. Esta crate pode incluir alguns tipos para as pessoas usarem, como `Button` ou `TextField`. Além disso, os usuários de `gui` desejarão criar seus próprios tipos que podem ser desenhados: por exemplo, um programador pode adicionar uma `Image` e outro pode adicionar uma `SelectBox`.

Não implementaremos uma biblioteca GUI completa para este exemplo, mas mostraremos como as peças se encaixariam. No momento da escrita da biblioteca, não podemos saber e definir todos os tipos que outros programadores podem querer criar. Mas sabemos que `gui` precisa manter o controle de muitos valores de diferentes tipos e precisa chamar um método `draw` em cada um desses valores de tipos diferentes. Não precisa saber exatamente o que acontecerá quando chamarmos o método `draw`, apenas que o valor terá esse método disponível para que possamos chamá-lo.

Para fazer isso em uma linguagem com herança, poderíamos definir uma classe chamada `Component` que tem um método chamado `draw`. As outras classes, como `Button`, `Image` e `SelectBox`, herdariam de `Component` e, portanto, herdariam o método `draw`. Cada uma delas poderia substituir o método `draw` para definir seu comportamento personalizado, mas o framework poderia tratar todos os tipos como se fossem instâncias de `Component` e chamar `draw` neles. Mas como o Rust não tem herança, precisamos de outra maneira de estruturar a biblioteca `gui` para permitir que os usuários a estendam com novos tipos.
