# Trait-Objekte führen dynamische Verteilung durch

Denken Sie sich in "Performance of Code Using Generics" unsere Diskussion über den Prozess der Monomorphisierung, den der Compiler durchführt, wenn wir Trait-Bounds auf Generics verwenden: Der Compiler generiert nongenerische Implementierungen von Funktionen und Methoden für jeden konkreten Typ, den wir anstelle eines generischen Typparameters verwenden. Der Code, der aus der Monomorphisierung resultiert, führt eine _statische Verteilung_ durch, das heißt, der Compiler weiß zu Compile-Zeit, welche Methode Sie aufrufen. Dies steht im Gegensatz zur _dynamischen Verteilung_, bei der der Compiler zu Compile-Zeit nicht wissen kann, welche Methode Sie aufrufen. Bei dynamischer Verteilung emittiert der Compiler Code, der zur Laufzeit herausfinden wird, welche Methode aufgerufen werden soll.

Wenn wir Trait-Objekte verwenden, muss Rust dynamische Verteilung verwenden. Der Compiler kennt nicht alle Typen, die mit dem Code verwendet werden können, der Trait-Objekte verwendet, daher weiß er nicht, welche Methode auf welchem Typ implementiert werden soll, um aufzurufen. Stattdessen verwendet Rust zur Laufzeit die Pointer innerhalb des Trait-Objekts, um zu wissen, welche Methode aufzurufen. Dieser Lookup verursacht einen Laufzeitaufwand, der nicht bei statischer Verteilung auftritt. Die dynamische Verteilung verhindert auch, dass der Compiler die Möglichkeit hat, den Code einer Methode einzuschließen, was wiederum einige Optimierungen verhindert. Wir haben jedoch in unserem in Listing 17-5 geschriebenen Code zusätzliche Flexibilität erhalten und in Listing 17-9 unterstützen können, daher ist dies ein Kompromiss, den man berücksichtigen muss.
