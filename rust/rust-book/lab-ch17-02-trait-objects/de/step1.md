# Verwenden von Trait-Objekten, die Werte unterschiedlicher Typen zulassen

Im Kapitel 8 haben wir erwähnt, dass eine Einschränkung von Vektoren darin besteht, dass sie nur Elemente eines einzigen Typs speichern können. Wir haben in Listing 8-9 eine Lösung gefunden, indem wir eine `SpreadsheetCell`-Enumeration definiert haben, die Varianten für die Speicherung von ganzen Zahlen, Gleitkommazahlen und Text hatte. Dies bedeutete, dass wir verschiedene Datentypen in jeder Zelle speichern konnten und trotzdem einen Vektor hatten, der eine Zeile von Zellen repräsentierte. Dies ist eine ausgezeichnete Lösung, wenn unsere austauschbaren Elemente eine feste Menge von Typen sind, die wir kennen, wenn unser Code kompiliert wird.

Manchmal möchten wir jedoch, dass der Benutzer unserer Bibliothek die Menge der in einer bestimmten Situation gültigen Typen erweitern kann. Um zu zeigen, wie wir dies erreichen könnten, werden wir ein Beispiel für ein grafisches Benutzeroberflächen (GUI)-Tool erstellen, das durch eine Liste von Elementen iteriert und für jedes Element eine `draw`-Methode aufruft, um es auf dem Bildschirm zu zeichnen - eine häufige Technik für GUI-Tools. Wir werden eine Bibliothekskiste namens `gui` erstellen, die die Struktur einer GUI-Bibliothek enthält. Diese Kiste könnte einige Typen für die Benutzer enthalten, wie `Button` oder `TextField`. Darüber hinaus werden die Benutzer von `gui` gerne eigene Typen erstellen, die gezeichnet werden können: Beispielsweise könnte ein Programmierer ein `Image` hinzufügen und ein anderer ein `SelectBox`.

Wir werden für dieses Beispiel keine vollwertige GUI-Bibliothek implementieren, sondern zeigen, wie die Teile zusammenpassen würden. Zu dem Zeitpunkt, zu dem wir die Bibliothek schreiben, können wir nicht alle Typen kennen und definieren, die andere Programmierer möglicherweise erstellen möchten. Wir wissen jedoch, dass `gui` viele Werte unterschiedlicher Typen verfolgen muss und für jeden dieser unterschiedlich typisierten Werte eine `draw`-Methode aufrufen muss. Es muss nicht genau wissen, was passieren wird, wenn wir die `draw`-Methode aufrufen, sondern nur, dass der Wert diese Methode zur Verfügung hat, die wir aufrufen können.

Um dies in einer Sprache mit Vererbung zu tun, könnten wir eine Klasse namens `Component` definieren, die eine Methode namens `draw` hat. Die anderen Klassen, wie `Button`, `Image` und `SelectBox`, würden von `Component` erben und somit die `draw`-Methode erben. Sie könnten jede die `draw`-Methode überschreiben, um ihr benutzerdefiniertes Verhalten zu definieren, aber das Framework könnte alle Typen so behandeln, als wären sie `Component`-Instanzen, und `draw` auf ihnen aufrufen. Da Rust jedoch keine Vererbung hat, brauchen wir eine andere Möglichkeit, die `gui`-Bibliothek zu strukturieren, um Benutzern die Möglichkeit zu geben, sie mit neuen Typen zu erweitern.
