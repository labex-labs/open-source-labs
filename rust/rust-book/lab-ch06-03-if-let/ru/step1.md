# Концизный контрольный поток с if let

Синтаксис `if let` позволяет вам комбинировать `if` и `let` в менее избыточном виде для обработки значений, соответствующих одному шаблону, игнорируя остальные. Рассмотрим программу в Listing 6-6, которая сопоставляет значение `Option<u8>` в переменной `config_max`, но хочет выполнить код только если значение является вариантом `Some`.

```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {max}"),
    _ => (),
}
```

Listing 6-6: `match`, который заботится только о выполнении кода, когда значение равно `Some`

Если значение равно `Some`, мы выводим значение в варианте `Some`, связав значение с переменной `max` в шаблоне. Мы не хотим ничего делать с значением `None`. Чтобы удовлетворить выражение `match`, мы должны добавить `_ => ()` после обработки только одного варианта, что является раздражающим шаблонным кодом для добавления.

Вместо этого мы могли бы написать это короче, используя `if let`. Следующий код работает так же, как `match` в Listing 6-6:

```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {max}");
}
```

Синтаксис `if let` принимает шаблон и выражение, разделенные знаком равно. Он работает так же, как `match`, где выражение передается в `match`, а шаблон является его первым ветвлением. В этом случае шаблон — это `Some(max)`, и `max` связывается с значением внутри `Some`. Затем мы можем использовать `max` в теле блока `if let` так же, как мы использовали `max` в соответствующем ветвлении `match`. Код в блоке `if let` не выполняется, если значение не соответствует шаблону.

Использование `if let` означает меньше набираемых символов, меньше отступов и меньше шаблонного кода. Однако вы теряете полноту проверки, которую обеспечивает `match`. Выбор между `match` и `if let` зависит от того, что вы делаете в конкретной ситуации и того, является ли получение краткости приемлемой компромиссной стороной при потере полноты проверки.

Другими словами, вы можете думать о `if let` как о сахарном синтаксисе для `match`, который выполняет код, когда значение соответствует одному шаблону, а затем игнорирует все остальные значения.

Мы можем включить `else` в `if let`. Блок кода, связанный с `else`, совпадает с блоком кода, который был бы связан с ветвлением `_` в выражении `match`, которое эквивалентно `if let` и `else`. Назовем вспомнить определение перечисления `Coin` в Listing 6-4, где вариант `Quarter` также содержал значение `UsState`. Если мы хотели подсчитывать все монеты, кроме четверок, и при этом сообщать о статусе четверок, мы могли бы сделать это с помощью выражения `match`, вот так:

```rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
```

Или мы могли бы использовать выражение `if let` и `else`, вот так:

```rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

Если у вас есть ситуация, в которой логика вашей программы слишком избыточна, чтобы выражать ее с помощью `match`, помните, что `if let` также находится в вашем арсенале Rust.
