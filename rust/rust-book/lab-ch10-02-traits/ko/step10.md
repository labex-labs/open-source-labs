# 트레이트 바운드를 사용하여 조건부로 메서드 구현하기

제네릭 타입 매개변수를 사용하는 `impl` 블록과 함께 트레이트 바운드를 사용하면, 지정된 트레이트를 구현하는 타입에 대해 조건부로 메서드를 구현할 수 있습니다. 예를 들어, Listing 10-15 의 `Pair<T>` 타입은 항상 `new` 함수를 구현하여 `Pair<T>`의 새 인스턴스를 반환합니다 ("메서드 정의하기"에서 `Self`가 `impl` 블록의 타입에 대한 타입 별칭임을 기억하세요. 이 경우 `Pair<T>`입니다). 그러나 다음 `impl` 블록에서 `Pair<T>`는 내부 타입 `T`가 비교를 가능하게 하는 `PartialOrd` 트레이트 _및_ 출력을 가능하게 하는 `Display` 트레이트를 구현하는 경우에만 `cmp_display` 메서드를 구현합니다.

파일 이름: `src/lib.rs`

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

Listing 10-15: 트레이트 바운드에 따라 제네릭 타입에 메서드를 조건부로 구현하기

또한 다른 트레이트를 구현하는 모든 타입에 대해 트레이트를 조건부로 구현할 수 있습니다. 트레이트 바운드를 만족하는 모든 타입에 대한 트레이트의 구현을 *블랭킷 구현 (blanket implementations)*이라고 하며, Rust 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어, 표준 라이브러리는 `Display` 트레이트를 구현하는 모든 타입에 대해 `ToString` 트레이트를 구현합니다. 표준 라이브러리의 `impl` 블록은 이 코드와 유사합니다.

```rust
impl<T: Display> ToString for T {
    --snip--
}
```

표준 라이브러리에 이 블랭킷 구현이 있기 때문에, `Display` 트레이트를 구현하는 모든 타입에 대해 `ToString` 트레이트에 의해 정의된 `to_string` 메서드를 호출할 수 있습니다. 예를 들어, 정수가 `Display`를 구현하므로 정수를 해당 `String` 값으로 변환할 수 있습니다.

```rust
let s = 3.to_string();
```

블랭킷 구현은 "구현자 (Implementors)" 섹션의 트레이트 문서에 나타납니다.

트레이트와 트레이트 바운드를 사용하면 제네릭 타입 매개변수를 사용하여 중복을 줄이는 코드를 작성할 수 있을 뿐만 아니라, 제네릭 타입이 특정 동작을 갖도록 컴파일러에 지정할 수 있습니다. 그러면 컴파일러는 트레이트 바운드 정보를 사용하여 코드와 함께 사용되는 모든 구체적인 타입이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적으로 타입이 지정된 언어에서는 메서드를 정의하지 않은 타입에 대해 메서드를 호출하면 런타임에 오류가 발생합니다. 그러나 Rust 는 이러한 오류를 컴파일 시간에 이동하므로 코드를 실행하기 전에 문제를 해결해야 합니다. 또한 컴파일 시간에 이미 확인했기 때문에 런타임에 동작을 확인하는 코드를 작성할 필요가 없습니다. 이렇게 하면 제네릭의 유연성을 포기하지 않고 성능을 향상시킬 수 있습니다.
