# Яснее ограничений трейта с использованием предложений where

Использование слишком большого количества ограничений трейта имеет свои недостатки. Каждый обобщенный тип имеет свои собственные ограничения трейта, поэтому функции с несколькими обобщенными типами параметров могут содержать много информации о ограничениях трейта между именем функции и ее списком параметров, что делает сигнатуру функции трудно читаемой.出于这个原因，Rust 有另一种语法，用于在函数签名后的 `where` 子句中指定 trait 约束。因此，与其这样写：

```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

我们可以使用 `where` 子句，如下所示：

```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
```

此函数的签名不那么杂乱：函数名、参数列表和返回类型靠得很近，类似于没有很多 trait 约束的函数。
