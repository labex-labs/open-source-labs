# Использование ограничений трейта для условного реализации методов

С использованием ограничения трейта с блоком `impl`, который использует обобщенные типы параметров, мы можем условно реализовывать методы для типов, которые реализуют указанные трейты. Например, тип `Pair<T>` в Listing 10-15 всегда реализует функцию `new`, чтобы вернуть новый экземпляр `Pair<T>` (помните из раздела "Определение методов", что `Self` является псевдонимом типа для типа блока `impl`, который в этом случае - `Pair<T>`). Но в следующем блоке `impl` `Pair<T>` реализует метод `cmp_display` только если его внутренний тип `T` реализует трейт `PartialOrd`, который позволяет сравнивать, _и_ трейт `Display`, который позволяет печатать.

Имя файла: `src/lib.rs`

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

Listing 10-15: Условная реализация методов для обобщенного типа в зависимости от ограничений трейта

Мы также можем условно реализовать трейт для любого типа, который реализует другой трейт. Реализации трейта для любого типа, удовлетворяющего ограничениям трейта, называются _общими реализациями_ и широко используются в стандартной библиотеке Rust. Например, стандартная библиотека реализует трейт `ToString` для любого типа, который реализует трейт `Display`. Блок `impl` в стандартной библиотеке выглядит подобно этому коду:

```rust
impl<T: Display> ToString for T {
    --snip--
}
```

Поскольку стандартная библиотека имеет такую общую реализацию, мы можем вызвать метод `to_string`, определенный трейтом `ToString`, для любого типа, который реализует трейт `Display`. Например, мы можем преобразовать целые числа в соответствующие значения `String` так, потому что целые числа реализуют `Display`:

```rust
let s = 3.to_string();
```

Общие реализации появляются в документации по трейту в разделе "Реализаторы".

Трейты и ограничения трейта позволяют нам писать код, который использует обобщенные типы параметров для уменьшения дублирования, но также указывает компилятору, что мы хотим, чтобы обобщенный тип имел определенное поведение. Компилятор может затем использовать информацию о ограничениях трейта, чтобы проверить, что все конкретные типы, используемые в нашем коде, предоставляют правильное поведение. В динамически типизированных языках мы бы получили ошибку во время выполнения, если бы вызвали метод для типа, который не определял этот метод. Но Rust перемещает эти ошибки в этап компиляции, так что мы вынуждены исправить проблемы, прежде чем наша программа сможет запуститься. Кроме того, мы не должны писать код, который бы проверял поведение во время выполнения, потому что мы уже проверили это на этапе компиляции. Это повышает производительность, не жертвуя гибкостью обобщений.
