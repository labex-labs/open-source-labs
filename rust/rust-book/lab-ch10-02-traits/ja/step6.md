# トレイト境界構文

`impl Trait` 構文は単純なケースでは機能しますが、実際には「トレイト境界」と呼ばれる長い形式のシンタックスシュガーです。このようになります。

```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

この長い形式は、前のセクションの例と同等ですが、もっと冗長です。ジェネリック型パラメータの宣言とともに、コロンの後と角括弧の中にトレイト境界を置きます。

`impl Trait` 構文は便利で、単純なケースではより簡潔なコードになりますが、より完全なトレイト境界構文は、他のケースでより複雑さを表現することができます。たとえば、`Summary` を実装する2つのパラメータを持つことができます。`impl Trait` 構文を使った場合、このようになります。

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

この関数が `item1` と `item2` に異なる型を許す（両方の型が `Summary` を実装している限り）場合、`impl Trait` を使用するのが適切です。ただし、両方のパラメータが同じ型であることを強制したい場合は、次のようにトレイト境界を使用する必要があります。

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

`item1` と `item2` のパラメータの型として指定されたジェネリック型 `T` は、関数を制約します。つまり、`item1` と `item2` の引数として渡される値の具体的な型は同じでなければなりません。
