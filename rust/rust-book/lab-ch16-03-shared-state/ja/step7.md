# RefCell`<T>`{=html}/Rc`<T>`{=html}と Mutex`<T>`{=html}/Arc`<T>`{=html}の類似点

`counter`は不変ですが、その中の値に対して可変参照を取得できることに気付いたかもしれません。これは、`Mutex<T>`が`Cell`ファミリと同じように内部可変性を提供することを意味します。第 15 章で`RefCell<T>`を使って`Rc<T>`内の内容を変更できるようにしたのと同じように、`Mutex<T>`を使って`Arc<T>`内の内容を変更します。

注目すべきもう一つの点は、`Mutex<T>`を使うとき、Rust はあらゆる種類の論理エラーからあなたを守ってくれないことです。第 15 章で思い出してください。`Rc<T>`を使うと、2 つの`Rc<T>`値が互いを参照する参照サイクルを作成するリスクがあり、メモリリークにつながります。同様に、`Mutex<T>`は _死鎖_ を作成するリスクがあります。これは、操作が 2 つのリソースをロックする必要があり、2 つのスレッドがそれぞれ 1 つのロックを取得しており、お互いを永遠に待たせる場合に発生します。死鎖に興味がある場合は、死鎖を発生させる Rust プログラムを作成してみてください。その後、任意の言語のミューテックスの死鎖軽減戦略を調べ、Rust でそれらを実装してみてください。`Mutex<T>`と`MutexGuard`の標準ライブラリ API ドキュメントには有用な情報があります。

この章は、`Send`と`Sync`トレイトと、カスタム型でそれらをどのように使うかについて話すことで締めくくります。
