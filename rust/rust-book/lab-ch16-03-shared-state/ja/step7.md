# RefCell`<T>`{=html}/Rc`<T>`{=html}とMutex`<T>`{=html}/Arc`<T>`{=html}の類似点

`counter`は不変ですが、その中の値に対して可変参照を取得できることに気付いたかもしれません。これは、`Mutex<T>`が`Cell`ファミリと同じように内部可変性を提供することを意味します。第15章で`RefCell<T>`を使って`Rc<T>`内の内容を変更できるようにしたのと同じように、`Mutex<T>`を使って`Arc<T>`内の内容を変更します。

注目すべきもう一つの点は、`Mutex<T>`を使うとき、Rustはあらゆる種類の論理エラーからあなたを守ってくれないことです。第15章で思い出してください。`Rc<T>`を使うと、2つの`Rc<T>`値が互いを参照する参照サイクルを作成するリスクがあり、メモリリークにつながります。同様に、`Mutex<T>`は _死鎖_ を作成するリスクがあります。これは、操作が2つのリソースをロックする必要があり、2つのスレッドがそれぞれ1つのロックを取得しており、お互いを永遠に待たせる場合に発生します。死鎖に興味がある場合は、死鎖を発生させるRustプログラムを作成してみてください。その後、任意の言語のミューテックスの死鎖軽減戦略を調べ、Rustでそれらを実装してみてください。`Mutex<T>`と`MutexGuard`の標準ライブラリAPIドキュメントには有用な情報があります。

この章は、`Send`と`Sync`トレイトと、カスタム型でそれらをどのように使うかについて話すことで締めくくります。
