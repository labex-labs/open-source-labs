# Arc`<T>`を使った原子的参照カウント{=html}

幸いなことに、`Arc<T>`は並列状況で安全に使える`Rc<T>`のような型です。「a」は「atomic」を表し、つまりそれは「原子的に参照カウントされる」型です。アトミックは並列処理のプリミティブの一種で、ここでは詳細を説明しません。詳細については、`std::sync::atomic`の標準ライブラリドキュメントを参照してください。この時点では、アトミックが基本型のように動作するがスレッド間で共有するのが安全であることだけを知っておけば十分です。

それでは、なぜすべての基本型がアトミックでないのか、またなぜ標準ライブラリの型がデフォルトで`Arc<T>`を使って実装されていないのか疑問に思うかもしれません。その理由は、スレッドセーフにすると性能ペナルティが伴うためで、本当に必要な場合にのみ支払いたいものです。単一のスレッド内で値に対して操作を行っているだけの場合、アトミックが提供する保証を強制する必要がなければ、コードが高速に実行できます。

例に戻りましょう。`Arc<T>`と`Rc<T>`は同じAPIを持っているので、`use`行、`new`の呼び出し、および`clone`の呼び出しを変更することでプログラムを修正します。リスト16-15のコードはついにコンパイルされて実行されます。

ファイル名: `src/main.rs`

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

リスト16-15: `Arc<T>`を使って`Mutex<T>`をラップし、複数のスレッド間で所有権を共有できるようにする

このコードは次のように表示されます：

```rust
Result: 10
```

成功です！0から10まで数えました。これはあまり印象的ではないかもしれませんが、`Mutex<T>`とスレッドセーフについてたくさん学ぶことができました。また、このプログラムの構造を使って、カウンターをインクリメントするだけよりも複雑な操作を行うこともできます。この戦略を使えば、計算を独立した部分に分割し、それらの部分をスレッド間で分割し、そして各スレッドがその部分で最終結果を更新するように`Mutex<T>`を使うことができます。

単純な数値演算を行っている場合、標準ライブラリの`std::sync::atomic`モジュールが提供する`Mutex<T>`型よりも単純な型があります。これらの型は、基本型に対する安全な並列アトミックアクセスを提供します。この例では、`Mutex<T>`と基本型を使って、`Mutex<T>`の動作方法に集中できるようにしました。
