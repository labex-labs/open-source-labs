# Mutex`<T>`の API

ミューテックスを使う方法の例として、まず単一スレッドコンテキストでミューテックスを使ってみましょう。リスト 16-12 に示すようにです。

ファイル名：`src/main.rs`

```rust
use std::sync::Mutex;

fn main() {
  1 let m = Mutex::new(5);

    {
      2 let mut num = m.lock().unwrap();
      3 *num = 6;
  4 }

  5 println!("m = {:?}", m);
}
```

リスト 16-12: 単一スレッドコンテキストでの`Mutex<T>`の API を単純化するために調べる

多くの型と同様に、関連付けられた関数`new`を使って`Mutex<T>`を作成します\[1\]。ミューテックス内のデータにアクセスするには、`lock`メソッドを使ってロックを取得します\[2\]。この呼び出しは現在のスレッドをブロックし、ロックを手に入れるまで何も作業を行えなくなります。

もしロックを保持している別のスレッドがパニックになった場合、`lock`の呼び出しは失敗します。その場合、誰もロックを取得できなくなりますので、その状況にあるときは`unwrap`を選択してこのスレッドをパニックにさせます。

ロックを取得した後、この場合`num`と名付けられた返り値を、内部のデータへの可変参照として扱うことができます。型システムにより、`m`の値を使う前にロックを取得することが保証されます。`m`の型は`Mutex<i32>`で、`i32`ではありませんので、`i32`の値を使うためには必ず`lock`を呼び出さなければなりません。忘れることはできません。そうでなければ型システムが内部の`i32`にアクセスさせません。

おそらく想像できる通り、`Mutex<T>`はスマートポインタです。より正確には、`lock`の呼び出しは`MutexGuard`と呼ばれるスマートポインタを返し、`unwrap`の呼び出しで処理した`LockResult`にラップされています。`MutexGuard`スマートポインタは`Deref`を実装して内部データを指し、また`Drop`実装も持ち、`MutexGuard`がスコープ外になるとき（これは内部スコープの終わりで起こります）自動的にロックを解放します\[4\]。その結果、ロックを解放することを忘れて他のスレッドがミューテックスを使えなくなるというリスクはありません。なぜならロックの解放は自動的に行われるからです。

ロックを解放した後、ミューテックスの値を表示して、内部の`i32`を`6`に変更できたことがわかります\[5\]。
