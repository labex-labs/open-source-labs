# Similitudes entre RefCell`<T>`{=html}/Rc`<T>`{=html} et Mutex`<T>`{=html}/Arc`<T>`{=html}

Vous avez peut-être remarqué que `counter` est immuable mais que nous pouvions obtenir une référence mutable à la valeur qu'elle contient ; cela signifie que `Mutex<T>` offre une mutabilité interne, comme la famille `Cell`. De la même manière que nous avons utilisé `RefCell<T>` au chapitre 15 pour pouvoir modifier le contenu à l'intérieur d'un `Rc<T>`, nous utilisons `Mutex<T>` pour modifier le contenu à l'intérieur d'un `Arc<T>`.

Un autre détail à noter est que Rust ne peut pas vous protéger contre tous les types d'erreurs logiques lorsque vous utilisez `Mutex<T>`. Rappelez-vous au chapitre 15 que l'utilisation de `Rc<T>` présentait le risque de créer des cycles de référence, où deux valeurs `Rc<T>` se réfèrent l'une à l'autre, entraînant des fuites mémoire. De manière similaire, `Mutex<T>` présente le risque de créer des _verrouillages mortels_. Ceux-ci se produisent lorsqu'une opération doit verrouiller deux ressources et que deux threads ont chacun acquis l'un des verrous, les rendant ainsi à l'attente l'un de l'autre à l'infini. Si vous êtes intéressé par les verrouillages mortels, essayez de créer un programme Rust qui présente un verrouillage mortel ; puis recherchez des stratégies de réduction des verrouillages pour les mutexes dans n'importe quelle langue et essayez de les implémenter en Rust. La documentation de l'API de la bibliothèque standard pour `Mutex<T>` et `MutexGuard` offre des informations utiles.

Nous terminerons ce chapitre en parlant des traits `Send` et `Sync` et de la manière dont nous pouvons les utiliser avec des types personnalisés.
