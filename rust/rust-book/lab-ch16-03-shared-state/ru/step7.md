# Похожие черты между RefCell`<T>`{=html}/Rc`<T>`{=html} и Mutex`<T>`{=html}/Arc`<T>`{=html}

Вы, возможно, заметили, что `counter` является неизменяемым, но мы можем получить изменяемую ссылку на значение внутри него; это означает, что `Mutex<T>` обеспечивает внутреннюю изменяемость, как это делает семейство `Cell`. Таким же образом, как мы использовали `RefCell<T>` в главе 15, чтобы иметь возможность изменять содержимое внутри `Rc<T>`, мы используем `Mutex<T>` для изменения содержимого внутри `Arc<T>`.

Еще один важный момент - Rust не может защитить вас от всех типов ошибок в логике, когда вы используете `Mutex<T>`. Помните, что в главе 15 использование `Rc<T>` было связано с риском создания циклов ссылок, когда два значения `Rc<T>` ссылаются друг на друга, что приводит к утечке памяти. Аналогично, `Mutex<T>` имеет риск создания _зависающих блокировок_. Это происходит, когда операция требует блокировки двух ресурсов, и два потока каждый получили одну из блокировок, заставляя их ждать друг друга навсегда. Если вы заинтересованы в зависаниях, попробуйте создать программу на Rust, которая имеет зависание; затем изучите стратегии минимизации зависаний для мьютексов на любом языке и попробуйте реализовать их на Rust. API-документация стандартной библиотеки для `Mutex<T>` и `MutexGuard` содержит полезную информацию.

Мы завершим эту главу, поговорив о трейтах `Send` и `Sync` и том, как мы можем их использовать с пользовательскими типами.
