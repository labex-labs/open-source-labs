# Обмен Mutex`<T>` между несколькими потоками

Теперь попробуем поделиться значением между несколькими потоками с использованием `Mutex<T>`. Мы запустим 10 потоков и попросим каждый из них увеличить значение счетчика на 1, так что счетчик изменится от 0 до 10. Пример в Listing 16-13 будет иметь ошибку компиляции, и мы будем использовать эту ошибку, чтобы лучше понять, как использовать `Mutex<T>` и как Rust помогает нам использовать его правильно.

Filename: `src/main.rs`

```rust
use std::sync::Mutex;
use std::thread;

fn main() {
  1 let counter = Mutex::new(0);
    let mut handles = vec![];

  2 for _ in 0..10 {
      3 let handle = thread::spawn(move || {
          4 let mut num = counter.lock().unwrap();

          5 *num += 1;
        });
      6 handles.push(handle);
    }

    for handle in handles {
      7 handle.join().unwrap();
    }

  8 println!("Result: {}", *counter.lock().unwrap());
}
```

Listing 16-13: Десять потоков, каждый из которых увеличивает счетчик, защищенный `Mutex<T>`

Мы создаем переменную `counter`, которая хранит `i32` внутри `Mutex<T>` \[1\], как мы это делали в Listing 16-12. Затем мы создаем 10 потоков, перебирая диапазон чисел \[2\]. Мы используем `thread::spawn` и даем всем потокам ту же замыкание: замыкание, которое перемещает счетчик в поток \[3\], получает блокировку на `Mutex<T>`, вызвав метод `lock` \[4\], а затем увеличивает на 1 значение в мьютексе \[5\]. Когда поток закончит выполнять свое замыкание, `num` выйдет из области видимости и освободит блокировку, чтобы другой поток мог ее получить.

В главном потоке мы собираем все дескрипторы присоединения \[6\]. Затем, как мы это делали в Listing 16-2, мы вызываем `join` для каждого дескриптора, чтобы убедиться, что все потоки завершились \[7\]. В этот момент главный поток получит блокировку и выведет результат этой программы \[8\].

Мы暗示или, что этот пример не скомпилируется. Теперь выясним, почему!

```bash
error[E0382]: use of moved value: `counter`
  --> src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex<i32>`, which
does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here,
in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure
```

Сообщение об ошибке говорит, что значение `counter` было перемещено на предыдущей итерации цикла. Rust сообщает нам, что мы не можем передать владение блокировкой `counter` в несколько потоков. Исправим ошибку компиляции с использованием метода множественной собственности, который мы обсуждали в главе 15.
