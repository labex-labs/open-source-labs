# API Mutex`<T>`

В качестве примера использования мьютекса давайте начнем с его использования в однопоточном контексте, как показано в Listing 16-12.

Filename: `src/main.rs`

```rust
use std::sync::Mutex;

fn main() {
  1 let m = Mutex::new(5);

    {
      2 let mut num = m.lock().unwrap();
      3 *num = 6;
  4 }

  5 println!("m = {:?}", m);
}
```

Listing 16-12: Исследование API `Mutex<T>` в однопоточном контексте для простоты

Как и в случае с многими типами, мы создаем `Mutex<T>` с использованием ассоциированной функции `new` \[1\]. Чтобы получить доступ к данным внутри мьютекса, мы используем метод `lock` для получения блокировки \[2\]. Этот вызов заблокирует текущий поток, так что он не сможет выполнять никаких операций, пока не будет轮到 его получить блокировку.

Вызов `lock` завершится неудачей, если другой поток, удерживающий блокировку, вызовет панику. В этом случае никто никогда не сможет получить блокировку, поэтому мы решили использовать `unwrap` и заставить этот поток вызвать панику, если мы попадаем в такую ситуацию.

После того, как мы получили блокировку, мы можем рассматривать возвращаемое значение, названное `num` в этом случае, как изменяемую ссылку на данные внутри. Типовая система гарантирует, что мы получаем блокировку перед использованием значения в `m`. Тип `m` - `Mutex<i32>`, а не `i32`, поэтому мы _должны_ вызвать `lock`, чтобы иметь возможность использовать значение `i32`. Мы не можем забыть; типовая система не позволит нам получить доступ к внутреннему `i32` иначе.

Как вы, вероятно, догадываетесь, `Mutex<T>` - это умный указатель. Более точно, вызов `lock` _возвращает_ умный указатель, называемый `MutexGuard`, обернутый в `LockResult`, который мы обработали вызовом `unwrap`. Умный указатель `MutexGuard` реализует `Deref`, чтобы указывать на наши внутренние данные; умный указатель также имеет реализацию `Drop`, которая автоматически освобождает блокировку, когда `MutexGuard` выходит из области видимости, что происходит в конце внутренней области видимости \[4\]. Таким образом, мы не рискуем забыть освободить блокировку и заблокировать мьютекс для использования другими потоками, потому что освобождение блокировки происходит автоматически.

После освобождения блокировки мы можем вывести значение мьютекса и убедиться, что мы смогли изменить внутреннее `i32` на `6` \[5\].
