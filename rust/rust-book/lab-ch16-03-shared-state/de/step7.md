# Ähnlichkeiten zwischen RefCell`<T>`{=html}/Rc`<T>`{=html} und Mutex`<T>`{=html}/Arc`<T>`{=html}

Sie haben vielleicht bemerkt, dass `counter` unveränderlich ist, aber wir konnten auf einen mutablen Verweis auf den darin enthaltenen Wert zugreifen; dies bedeutet, dass `Mutex<T>` wie die `Cell`-Familie innere Veränderbarkeit bietet. Auf die gleiche Weise wie wir in Kapitel 15 `RefCell<T>` verwendet haben, um die Inhalte innerhalb eines `Rc<T>` zu verändern, verwenden wir `Mutex<T>`, um die Inhalte innerhalb eines `Arc<T>` zu verändern.

Ein weiterer Detail, das zu beachten ist, ist, dass Rust Sie nicht vor allen Arten von logischen Fehlern schützen kann, wenn Sie `Mutex<T>` verwenden. Denken Sie sich zurück an Kapitel 15, bei dem das Verwenden von `Rc<T>` mit dem Risiko verbunden war, Referenzzirkel zu erzeugen, bei denen zwei `Rc<T>`-Werte aufeinander verweisen und dadurch Speicherlecks verursachen. Ähnlich hat `Mutex<T>` das Risiko, _Deadlocks_ zu erzeugen. Dies tritt auf, wenn eine Operation zwei Ressourcen sperren muss und zwei Threads jeweils einen der Locks erworben haben, was dazu führt, dass sie sich für immer aufeinander warten. Wenn Sie an Deadlocks interessiert sind, versuchen Sie, ein Rust-Programm zu erstellen, das einen Deadlock hat; dann recherchieren Sie Deadlock-Minderungsstrategien für Mutexe in jeder Sprache und versuchen Sie, sie in Rust umzusetzen. Die Standardbibliothek-APIDokumentation für `Mutex<T>` und `MutexGuard` bietet nützliche Informationen.

Wir werden dieses Kapitel abschließen, indem wir über die `Send`- und `Sync`-Traits und wie wir sie mit benutzerdefinierten Typen verwenden können, sprechen.
