# Mutex`<T>`의 API

뮤텍스를 사용하는 방법의 예로, Listing 16-12 에 표시된 것처럼 단일 스레드 컨텍스트에서 뮤텍스를 사용하는 것부터 시작해 보겠습니다.

파일 이름: `src/main.rs`

```rust
use std::sync::Mutex;

fn main() {
  1 let m = Mutex::new(5);

    {
      2 let mut num = m.lock().unwrap();
      3 *num = 6;
  4 }

  5 println!("m = {:?}", m);
}
```

Listing 16-12: 단순화를 위해 단일 스레드 컨텍스트에서 `Mutex<T>`의 API 탐색

많은 타입과 마찬가지로, 연관 함수 `new`를 사용하여 `Mutex<T>`를 생성합니다 \[1\]. 뮤텍스 내부의 데이터에 접근하기 위해, `lock` 메서드를 사용하여 락을 획득합니다 \[2\]. 이 호출은 현재 스레드가 락을 가질 차례가 될 때까지 어떤 작업도 수행할 수 없도록 차단합니다.

락을 가지고 있는 다른 스레드가 패닉 (panic) 상태가 되면 `lock` 호출이 실패할 수 있습니다. 이 경우, 아무도 락을 얻을 수 없으므로, 우리는 `unwrap`을 선택하여 해당 상황에서 이 스레드가 패닉하도록 했습니다.

락을 획득한 후, 이 경우 `num`이라고 명명된 반환 값을 내부 데이터에 대한 가변 참조로 취급할 수 있습니다. 타입 시스템은 `m`의 값을 사용하기 전에 락을 획득하도록 보장합니다. `m`의 타입은 `i32`가 아닌 `Mutex<i32>`이므로, `i32` 값을 사용하려면 반드시 `lock`을 호출해야 합니다. 잊을 수 없습니다; 그렇지 않으면 타입 시스템이 내부 `i32`에 접근하는 것을 허용하지 않습니다.

예상할 수 있듯이, `Mutex<T>`는 스마트 포인터입니다. 더 정확하게 말하면, `lock` 호출은 `unwrap` 호출로 처리한 `LockResult`로 래핑된 `MutexGuard`라는 스마트 포인터를 *반환*합니다. `MutexGuard` 스마트 포인터는 내부 데이터를 가리키도록 `Deref`를 구현합니다. 또한 스마트 포인터는 `MutexGuard`가 스코프를 벗어날 때 자동으로 락을 해제하는 `Drop` 구현을 가지고 있으며, 이는 내부 스코프의 끝에서 발생합니다 \[4\]. 결과적으로, 락 해제가 자동으로 발생하므로 락을 해제하는 것을 잊어 다른 스레드가 뮤텍스를 사용하지 못하도록 차단할 위험이 없습니다.

락을 해제한 후, 뮤텍스 값을 출력하여 내부 `i32`를 `6`으로 변경할 수 있었음을 확인할 수 있습니다 \[5\].
