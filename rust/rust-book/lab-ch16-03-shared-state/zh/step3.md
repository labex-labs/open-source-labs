# Mutex`<T>` 的 API

作为如何使用互斥锁的一个示例，让我们先在单线程环境中使用互斥锁，如清单 16 - 12 所示。

文件名：`src/main.rs`

```rust
use std::sync::Mutex;

fn main() {
  1 let m = Mutex::new(5);

    {
      2 let mut num = m.lock().unwrap();
      3 *num = 6;
  4 }

  5 println!("m = {:?}", m);
}
```

清单 16 - 12：为简单起见，在单线程环境中探索 `Mutex<T>` 的 API

和许多类型一样，我们使用关联函数 `new` 创建一个 `Mutex<T>`\[1\]。要访问互斥锁内部的数据，我们使用 `lock` 方法来获取锁\[2\]。这个调用会阻塞当前线程，这样在轮到我们获取锁之前它就不能做任何工作。

如果持有锁的另一个线程恐慌（panic），对 `lock` 的调用将会失败。在那种情况下，将永远没有人能够获取到锁，所以我们选择调用 `unwrap`，如果处于那种情况就让这个线程恐慌。

在我们获取锁之后，我们可以将返回值（在这种情况下名为 `num`）当作对内部数据的可变引用。类型系统确保我们在使用 `m` 中的值之前获取锁。`m` 的类型是 `Mutex<i32>`，而不是 `i32`，所以我们 _必须_ 调用 `lock` 才能使用 `i32` 值。我们不会忘记；否则类型系统不会让我们访问内部的 `i32`。

正如你可能猜测的那样，`Mutex<T>` 是一个智能指针。更准确地说，对 `lock` 的调用 _返回_ 一个名为 `MutexGuard` 的智能指针，它被包装在一个 `LockResult` 中，我们通过调用 `unwrap` 来处理它。`MutexGuard` 智能指针实现了 `Deref` 来指向我们的内部数据；这个智能指针也有一个 `Drop` 实现，当 `MutexGuard` 超出作用域时（在内部作用域结束时发生）会自动释放锁\[4\]。因此，我们不会有忘记释放锁并阻止其他线程使用互斥锁的风险，因为锁的释放是自动发生的。

在释放锁之后，我们可以打印互斥锁的值，并看到我们能够将内部的 `i32` 改为 `6`\[5\]。
