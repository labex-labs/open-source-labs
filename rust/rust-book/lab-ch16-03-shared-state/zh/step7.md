# RefCell`<T>`{=html}/Rc`<T>`{=html} 与 Mutex`<T>`{=html}/Arc`<T>`{=html} 之间的相似之处

你可能已经注意到，`counter` 是不可变的，但我们可以获取到其内部值的可变引用；这意味着 `Mutex<T>` 像 `Cell` 家族一样提供了内部可变性。就像我们在第 15 章中使用 `RefCell<T>` 来允许我们修改 `Rc<T>` 内部的内容一样，我们使用 `Mutex<T>` 来修改 `Arc<T>` 内部的内容。

另一个需要注意的细节是，当你使用 `Mutex<T>` 时，Rust 无法保护你免受所有类型的逻辑错误。回想一下第 15 章，使用 `Rc<T>` 存在创建引用循环的风险，即两个 `Rc<T>` 值相互引用，从而导致内存泄漏。类似地，`Mutex<T>` 存在产生 _死锁_ 的风险。当一个操作需要锁定两个资源，而两个线程各自获取了其中一个锁，导致它们永远相互等待时，就会发生死锁。如果你对死锁感兴趣，可以尝试创建一个有死锁的 Rust 程序；然后研究任何语言中互斥锁的死锁缓解策略，并尝试在 Rust 中实现它们。`Mutex<T>` 和 `MutexGuard` 的标准库 API 文档提供了有用的信息。

我们将通过讨论 `Send` 和 `Sync` 特性以及如何将它们与自定义类型一起使用来结束本章。
