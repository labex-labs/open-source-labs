# パニックによる回復不可能なエラー

時には、コードで不都合なことが起こり、何もできない場合があります。このような場合、Rustには`panic!`マクロがあります。実際にパニックを引き起こす方法は2つあります。コードがパニックを引き起こすアクションを実行すること（たとえば、配列の範囲外を参照すること）、または明示的に`panic!`マクロを呼び出すことです。どちらの場合も、プログラムでパニックが発生します。デフォルトでは、これらのパニックは失敗メッセージを表示し、アンワインドしてスタックをクリーンアップし、終了します。環境変数を使うことで、パニックが発生したときにRustに呼び出しスタックを表示させて、パニックの原因を特定しやすくすることもできます。

> **パニックに応じてスタックをアンワインドするか、中断するか**
>
> デフォルトでは、パニックが発生するとプログラムは _アンワインド_ を開始します。これは、Rustがスタックを逆に辿り、遭遇した各関数からデータをクリーンアップすることを意味します。ただし、逆に辿ってクリーンアップするのは大変な作業です。そのため、Rustでは、即座に _中断_ するという代替策を選択できます。これにより、クリーンアップせずにプログラムが終了します。
>
> その後、プログラムが使用していたメモリのクリーンアップはオペレーティングシステムに委ねられます。プロジェクトで生成されるバイナリをできるだけ小さくする必要がある場合、`Cargo.toml`ファイルの適切な`[profile]`セクションに`panic = 'abort'`を追加することで、パニック時にアンワインドから中断に切り替えることができます。たとえば、リリースモードでパニック時に中断するようにするには、次のように追加します：
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

簡単なプログラムで`panic!`を呼び出してみましょう。

ファイル名：`src/main.rs`

```rust
fn main() {
    panic!("crash and burn");
}
```

プログラムを実行すると、次のような出力が表示されます：

    thread 'main' panicked at 'crash and burn', src/main.rs:2:5
    note: run with `RUST_BACKTRACE=1` environment variable to display
    a backtrace

`panic!`への呼び出しにより、最後の2行に含まれるエラーメッセージが表示されます。最初の行は、パニックメッセージと、パニックが発生したソースコード内の場所を示しています。_src/main.rs:2:5_ は、`src/main.rs`ファイルの2行目、5文字目を示しています。

この場合、示された行はコードの一部であり、その行に移動すると、`panic!`マクロの呼び出しが見えます。他の場合、`panic!`の呼び出しはコードが呼び出すコードの中にある場合があり、エラーメッセージで報告されるファイル名と行番号は、`panic!`マクロが呼び出された他人のコードの場所であり、最終的に`panic!`の呼び出しにつながる自分たちのコードの行ではありません。

`panic!`の呼び出し元の関数のバックトレースを使って、問題の原因となっているコードの部分を特定することができます。`panic!`のバックトレースの使い方を理解するために、もう1つの例を見てみましょう。`panic!`の呼び出しが、コードのバグによりライブラリから発生する場合、つまり、マクロを直接呼び出すのではなく、コードがライブラリを呼び出すことで発生する場合を見てみましょう。リスト9-1には、ベクトル内の有効なインデックスの範囲外のインデックスにアクセスしようとするコードがあります。

ファイル名：`src/main.rs`

```rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
```

リスト9-1：ベクトルの末尾を超えて要素にアクセスしようとすると、`panic!`の呼び出しが発生します

ここでは、ベクトルの100番目の要素にアクセスしようとしています（インデックスは0から始まるため、インデックス99です）が、ベクトルには要素が3つだけあります。この場合、Rustはパニックを起こします。`[]`を使って要素を返すはずですが、無効なインデックスを渡すと、Rustが返す正しい要素はありません。

Cでは、データ構造の末尾を超えて読み取ろうとすると未定義の動作になります。データ構造内のその要素に対応するメモリの場所にあるものが何であれ取得されるかもしれませんが、そのメモリはその構造に属していない場合があります。これは _バッファオーバーリード_ と呼ばれ、攻撃者がデータ構造の後に格納されている許可されていないデータを読み取るようにインデックスを操作できる場合、セキュリティ脆弱性につながる可能性があります。

このような脆弱性からプログラムを保護するために、存在しないインデックスの要素を読み取ろうとすると、Rustは実行を停止して続行しないようにします。試してみましょう：

    thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
    99', src/main.rs:4:5
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

このエラーは、`main.rs`の4行目を指しており、そこで`index`にアクセスしようとしています。

`note:`行は、エラーの原因となったことの正確なバックトレースを取得するために、`RUST_BACKTRACE`環境変数を設定できることを教えてくれます。 _バックトレース_ は、この時点までに呼び出されたすべての関数のリストです。Rustのバックトレースは他の言語と同じように機能します。バックトレースを読むキーは、トップから読み始め、自分たちが書いたファイルが見えるまで読み続けることです。そこが問題の発生元です。その場所より上の行は、自分たちのコードが呼び出したコードです。その場所より下の行は、自分たちのコードを呼び出したコードです。これらの前後の行には、コアRustコード、標準ライブラリコード、または使用しているクレートが含まれる場合があります。`RUST_BACKTRACE`環境変数を`0`以外の任意の値に設定して、バックトレースを取得してみましょう。リスト9-2には、見られる出力に似たものが表示されます。

```bash
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', src/main.rs:4:5
stack backtrace:
0: rust_begin_unwind
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std
/src/panicking.rs:584:5
1: core::panicking::panic_fmt
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core
/src/panicking.rs:142:14
2: core::panicking::panic_bounds_check
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core
/src/panicking.rs:84:5
3: < usize as core::slice::index::SliceIndex < [T] >> ::index
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core
/src/slice/index.rs:242:10
4: core::slice::index:: core::ops::index::Index [T] < impl < I > for > ::index
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core
/src/slice/index.rs:18:9
5: < alloc::vec::Vec < T,A > as core::ops::index::Index < I >> ::index
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc
/src/vec/mod.rs:2591:9
6: panic::main
at./src/main.rs:4:5
7: core::ops::function::FnOnce::call_once
at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core
/src/ops/function.rs:248:5
note: Some details are omitted, run with $(RUST_BACKTRACE=full) for a verbose
backtrace.
```

リスト9-2：環境変数`RUST_BACKTRACE`が設定されているときに表示される`panic!`の呼び出しによって生成されるバックトレース

たくさんの出力があります！見る出力は、オペレーティングシステムやRustのバージョンによって異なる場合があります。この情報を持つバックトレースを取得するには、デバッグシンボルを有効にする必要があります。ここでは、`--release`フラグを付けずに`cargo build`または`cargo run`を使用すると、デフォルトでデバッグシンボルが有効になります。

リスト9-2の出力では、バックトレースの6行目が、問題の原因となっているプロジェクト内の行を指しています。`src/main.rs`の4行目です。プログラムがパニックを起こさないようにするには、最初に自分たちが書いたファイルを言及する最初の行で指される場所から調査を始める必要があります。リスト9-1では、意図的にパニックを起こすコードを書いていましたが、パニックを修正する方法は、ベクトルインデックスの範囲外の要素を要求しないことです。将来、コードがパニックを起こした場合、コードがどの値でどのアクションを実行してパニックを引き起こしているか、そして代わりにコードが何をすべきかを把握する必要があります。

「パニックするかしないか」では、`panic!`を使うべきかどうか、またはエラー条件を処理するために使うべきかどうかについて戻ります。次に、`Result`を使ってエラーから回復する方法を見てみましょう。
