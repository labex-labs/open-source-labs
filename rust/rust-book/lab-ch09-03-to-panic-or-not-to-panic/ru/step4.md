# Руководства по обработке ошибок

Рекомендуется вызывать панику в коде, если код может оказаться в неправильном состоянии. В этом контексте _неправильным состоянием_ является то, когда какое-то предположение, гарантия, договоренность или инвариант нарушен, например, когда некорректные значения, противоречащие значения или отсутствующие значения передаются в ваш код - плюс одно или несколько следующих:

- Неправильное состояние является неожиданным, в отличие от того, что может偶尔 случиться, например, когда пользователь вводит данные в неправильном формате.
- Ваш код после этого должен полагаться на то, что не находится в этом неправильном состоянии, а не проверять проблему на каждом шаге.
- Нет хорошего способа закодировать эту информацию в типах, которые вы используете. Мы рассмотрим пример того, о чем мы говорим, в разделе "Кодирование состояний и поведения в виде типов".

Если кто-то вызывает ваш код и передает значения, которые не имеют смысла, лучше вернуть ошибку, если это возможно, чтобы пользователь библиотеки мог решить, что хочет сделать в этом случае. Однако, в случаях, когда продолжение может быть небезопасным или вредным, лучшим выбором может быть вызов `panic!` и предупреждение пользователя библиотеки о ошибке в их коде, чтобы они могли исправить ее во время разработки. Аналогично, `panic!` часто является подходящим, если вы вызываете внешний код, который находится вне вашего контроля, и он возвращает неправильное состояние, которое вы не можете исправить.

Однако, когда ошибка ожидается, более подходящим является возвращение `Result`, чем вызов `panic!`. Например, парсер может получить неправильно сформированные данные или HTTP-запрос может вернуть статус, который означает, что вы достигли лимита скорости. В таких случаях возвращение `Result` указывает на то, что ошибка является ожидаемым возможностью, которую вызывающий код должен решить, как обработать.

Когда ваш код выполняет операцию, которая может поставить пользователя в опасность, если ее вызывать с использованием некорректных значений, ваш код должен сначала проверить, являются ли значения допустимыми, и вызвать панику, если значения недопустимы. Это в основном出于安全考虑：попытка выполнить операцию с некорректными данными может подвергнуть ваш код уязвимостям. Именно поэтому стандартная библиотека вызовет `panic!`, если вы попытаетесь осуществить доступ к памяти за пределами допустимых границ: попытка доступа к памяти, которая не принадлежит текущей структуре данных, является распространенной проблемой безопасности. Функции часто имеют _договоренности_: их поведение гарантируется только в том случае, если входные данные соответствуют определенным требованиям. Взрыв при нарушении договора имеет смысл, потому что нарушение договора всегда указывает на ошибку стороны вызывающего кода, и это не那种 ошибка, которую вы хотите, чтобы вызывающий код должен явно обрабатывать. Фактически, для вызывающего кода нет合理的 способа восстановиться; вызывающие _программисты_ должны исправить код. Договоренности для функции, особенно в том случае, если нарушение приведет к панике, должны быть описаны в API-документации для функции.

Однако, наличие большого количества проверок ошибок во всех ваших функциях будет избыточным и раздражающим. К счастью, вы можете использовать типовую систему Rust (и таким образом проверку типов, выполняемую компилятором) для того, чтобы сделать многие из проверок за вас. Если ваша функция имеет определенный тип в качестве параметра, вы можете продолжить логику вашего кода, зная, что компилятор уже гарантировал, что у вас есть допустимое значение. Например, если у вас есть тип, а не `Option`, ваша программа ожидает, что будет _что-то_, а не _ничего_. Ваш код не должен обрабатывать два случая для вариантов `Some` и `None`: у него будет только один случай для определенного наличия значения. Код, пытающий передать ничего в вашу функцию, даже не скомпилируется, поэтому ваша функция не должна проверять этот случай во время выполнения. Другими словами, использование незнакового целочисленного типа, такого как `u32`, гарантирует, что параметр никогда не будет отрицательным.
