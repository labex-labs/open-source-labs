# Ситуации, в которых у вас есть больше информации, чем у компилятора

Также будет приемлемым вызвать `unwrap` или `expect`, когда у вас есть другая логика, которая гарантирует, что значение `Result` будет иметь вариант `Ok`, но компилятор не понимает эту логику. У вас по-прежнему будет значение `Result`, которое нужно обработать: любая операция, которую вы вызываете, по-прежнему может завершиться с ошибкой в общем случае, хотя это логически невозможно в вашей конкретной ситуации. Если вы можете убедиться путем ручного просмотра кода, что вы никогда не получите вариант `Err`, вполне допустимо вызвать `unwrap`, и лучше всего документировать причину, по которой вы думаете, что никогда не получите вариант `Err` в тексте `expect`. Вот пример:

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
 .parse()
 .expect("Hardcoded IP address should be valid");
```

Мы создаем экземпляр `IpAddr`, разбирая жестко закодированную строку. Мы видим, что `127.0.0.1` является допустимым IP-адресом, поэтому здесь можно использовать `expect`. Однако наличие жестко закодированной допустимой строки не изменяет тип возвращаемого значения метода `parse`: мы по-прежнему получаем значение `Result`, и компилятор по-прежнему заставит нас обрабатывать `Result` так, будто вариант `Err` возможен, потому что компилятор недостаточно умный, чтобы понять, что эта строка всегда является допустимым IP-адресом. Если строка с IP-адресом была введена пользователем, а не жестко закодирована в программе, и поэтому имела возможность ошибиться, мы, конечно, захотели бы обработать `Result` более надежно. Указание о том, что этот IP-адрес жестко закодирован, понапрямую заставит нас изменить `expect` на более надежный код обработки ошибок, если в будущем мы захотим получить IP-адрес из какого-то другого источника.
