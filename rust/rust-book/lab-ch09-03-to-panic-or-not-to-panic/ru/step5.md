# Создание пользовательских типов для проверки

Давайте продвинемся дальше в использовании типовой системы Rust для обеспечения наличия допустимого значения и рассмотрим создание пользовательского типа для проверки. Назовем пример из главы 2 с игрой в угадывание числа, в котором наш код просил пользователя угадать число от 1 до 100. Мы никогда не проверяли, находится ли предположение пользователя в этом диапазоне, прежде чем сравнивать его с нашим секретным числом; мы только проверяли, что предположение положительное. В этом случае последствия не были очень серьезными: наша выдача "Слишком большое" или "Слишком маленькое" все равно была правильной. Но это было бы полезным расширением, чтобы направить пользователя к допустимым предположениям и иметь разное поведение, когда пользователь угадывает число за пределами диапазона, а когда, например, вводит буквы.

Одним из способов этого является разбор предположения как `i32` вместо только `u32`, чтобы допустить потенциально отрицательные числа, а затем добавить проверку на то, что число находится в диапазоне, вот так:

Имя файла: `src/main.rs`

```rust
loop {
    --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
        --snip--
}
```

`if`-выражение проверяет, находится ли наше значение за пределами диапазона, сообщает пользователю о проблеме и вызывает `continue`, чтобы начать следующую итерацию цикла и попросить ввести новое предположение. После `if`-выражения мы можем продолжить сравнения между `guess` и секретным числом, зная, что `guess` находится между 1 и 100.

Однако, это не идеальное решение: если было абсолютно критично, чтобы программа работала только с значениями между 1 и 100, и у нее было много функций с этим требованием, то наличие такой проверки в каждой функции было бы утомительно (и, возможно, повлиялось бы на производительность).

Вместо этого мы можем создать новый тип и поместить проверки в функцию для создания экземпляра этого типа, вместо того чтобы повторять проверки повсюду. Таким образом, функциям безопасно использовать новый тип в своих сигнатурах и с уверенностью использовать значения, которые они получают. Список 9-13 показывает один из способов определить тип `Guess`, который создаст экземпляр `Guess` только в том случае, если функция `new` получит значение между 1 и 100.

Имя файла: `src/lib.rs`

```rust
1 pub struct Guess {
    value: i32,
}

impl Guess {
  2 pub fn new(value: i32) -> Guess {
      3 if value < 1 || value > 100 {
          4 panic!(
                "Guess value must be between 1 and 100, got {}.",
                value
            );
        }

      5 Guess { value }
    }

  6 pub fn value(&self) -> i32 {
        self.value
    }
}
```

Список 9-13: Тип `Guess`, который будет продолжать работу только с значениями между 1 и 100

Во - первых, мы определяем структуру `Guess`, которая имеет поле `value`, которое хранит `i32` \[1\]. Именно здесь будет храниться число.

Затем мы реализуем связанную функцию `new` для `Guess`, которая создает экземпляры значений `Guess` \[2\]. Функция `new` определена так, чтобы иметь один параметр `value` типа `i32` и возвращать `Guess`. Код в теле функции `new` проверяет `value`, чтобы убедиться, что оно находится между 1 и 100 \[3\]. Если `value` не проходит этот тест, мы вызываем `panic!` \[4\], что предупредит программиста, который пишет вызывающий код, что у него есть ошибка, которую нужно исправить, потому что создание `Guess` с `value` за пределами этого диапазона нарушает договоренность, на которую relies `Guess::new`. Условия, при которых `Guess::new` может вызвать панику, должны быть обсуждены в его публичном API - документе; мы рассмотрим соглашения по документированию, указывающие на возможность `panic!` в API - документе, которое вы создадите в главе 14. Если `value` проходит тест, мы создаем новый `Guess` с его полем `value`, установленным в параметр `value`, и возвращаем `Guess` \[5\].

Далее, мы реализуем метод `value`, который заимствует `self`, не имеет других параметров и возвращает `i32` \[6\]. Такой метод иногда называют _геттером_, потому что его цель - получить некоторые данные из своих полей и вернуть их. Этот публичный метод необходим, потому что поле `value` структуры `Guess` является приватным. Важно, чтобы поле `value` было приватным, чтобы код, использующий структуру `Guess`, не имел возможности напрямую установить `value`: код вне модуля _должен_ использовать функцию `Guess::new` для создания экземпляра `Guess`, тем самым обеспечивая, что никаким образом `Guess` не может иметь `value`, которое не было проверено условиями в функции `Guess::new`.

Функция, которая имеет параметр или возвращает только числа между 1 и 100, могла бы объявить в своей сигнатуре, что она принимает или возвращает `Guess` вместо `i32` и не нуждается в дополнительных проверках в своем теле.
