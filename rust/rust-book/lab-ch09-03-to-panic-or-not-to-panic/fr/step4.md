# Guidelines for Error Handling

Il est recommandé de faire en sorte que votre code provoque une panique lorsqu'il est possible que votre code se retrouve dans un état incorrect. Dans ce contexte, un _état incorrect_ est celui où une hypothèse, une garantie, un contrat ou une invariant a été violé, par exemple lorsque des valeurs invalides, contradictoires ou manquantes sont passées à votre code - plus l'un ou plusieurs des éléments suivants :

- L'état incorrect est quelque chose d'inattendu, contrairement à quelque chose qui arrivera probablement occasionnellement, comme un utilisateur entrant des données dans le mauvais format.
- Votre code après ce point doit compter sur le fait qu'il ne soit pas dans cet état incorrect, plutôt que de vérifier le problème à chaque étape.
- Il n'y a pas de bonne manière d'encoder cette information dans les types que vous utilisez. Nous allons étudier un exemple de ce que nous voulons dire dans "Encoding States and Behavior as Types".

Si quelqu'un appelle votre code et passe des valeurs qui n'ont pas de sens, il est préférable de retourner une erreur si vous le pouvez, de sorte que l'utilisateur de la bibliothèque puisse décider de ce qu'il veut faire dans ce cas. Cependant, dans des cas où continuer pourrait être insecuritaire ou nuisible, le meilleur choix pourrait être d'appeler `panic!` et d'alerter la personne utilisant votre bibliothèque sur le bogue dans leur code afin qu'ils puissent le corriger pendant le développement. De même, `panic!` est souvent approprié si vous appelez du code externe qui est hors de votre contrôle et qu'il retourne un état invalide que vous n'avez aucun moyen de corriger.

Cependant, lorsque l'échec est attendu, il est plus approprié de retourner un `Result` plutôt que d'effectuer un appel à `panic!`. Des exemples incluent un analyseur qui reçoit des données malformées ou une requête HTTP qui retourne un statut indiquant que vous avez atteint une limite de taux. Dans ces cas, retourner un `Result` indique que l'échec est une possibilité attendue que le code appelant doit décider de gérer.

Lorsque votre code effectue une opération qui pourrait mettre un utilisateur à risque s'il est appelé avec des valeurs invalides, votre code devrait vérifier d'abord que les valeurs sont valides et provoquer une panique si les valeurs ne sont pas valides. Cela est principalement pour des raisons de sécurité : tenter d'opérer sur des données invalides peut exposer votre code à des vulnérabilités. C'est la principale raison pour laquelle la bibliothèque standard appellera `panic!` si vous essayez d'accéder à une mémoire en dehors des limites : tenter d'accéder à une mémoire qui n'appartient pas à la structure de données actuelle est un problème de sécurité courant. Les fonctions ont souvent des _contrats_ : leur comportement n'est garanti que si les entrées répondent à des exigences particulières. Provoquer une panique lorsqu'un contrat est violé a du sens car une violation de contrat indique toujours un bogue côté appelant, et ce n'est pas le genre d'erreur que vous voulez que le code appelant ait à gérer explicitement. En fait, il n'y a pas de manière raisonnable pour le code appelant de récupérer ; les _programmateurs_ appelants doivent corriger le code. Les contrats d'une fonction, surtout lorsqu'une violation entraînera une panique, devraient être expliqués dans la documentation API de la fonction.

Cependant, avoir de nombreux contrôles d'erreur dans toutes vos fonctions serait verbeux et ennuyeux. Heureusement, vous pouvez utiliser le système de types de Rust (et donc la vérification de type effectuée par le compilateur) pour effectuer de nombreux contrôles pour vous. Si votre fonction a un type particulier en tant que paramètre, vous pouvez poursuivre la logique de votre code en sachant que le compilateur a déjà assuré que vous avez une valeur valide. Par exemple, si vous avez un type plutôt qu'un `Option`, votre programme s'attend à avoir _quelque chose_ plutôt que _rien_. Votre code n'a donc pas à gérer deux cas pour les variantes `Some` et `None` : il n'aura qu'un cas pour avoir définitivement une valeur. Le code essayant de passer rien à votre fonction ne compilera même pas, donc votre fonction n'a pas à vérifier ce cas à l'exécution. Un autre exemple est l'utilisation d'un type entier non signé tel que `u32`, qui garantit que le paramètre n'est jamais négatif.
