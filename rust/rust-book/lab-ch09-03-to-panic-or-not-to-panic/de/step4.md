# Richtlinien für die Fehlerbehandlung

Es ist ratsam, dass dein Code in Panik gerät, wenn es möglich ist, dass dein Code in einem schlechten Zustand endet. Im Rahmen dieses Kontexts ist ein _schlechter Zustand_ gegeben, wenn eine Annahme, Garantie, Vereinbarung oder Invarianz verletzt wurde, wie wenn ungültige Werte, widersprüchliche Werte oder fehlende Werte an deinen Code übergeben werden - plus eine oder mehrere der folgenden:

- Der schlechte Zustand ist etwas, das unerwartet ist, im Gegensatz zu etwas, das gelegentlich wahrscheinlich passiert, wie wenn ein Benutzer Daten im falschen Format eingibt.
- Dein Code nach diesem Punkt muss darauf vertrauen, nicht in diesem schlechten Zustand zu sein, anstatt bei jedem Schritt nach dem Problem zu prüfen.
- Es gibt keine gute Möglichkeit, diese Information in den Typen, die du verwendest, zu kodieren. Wir werden anhand eines Beispiels erläutern, was wir damit meinen, in "Encoding States and Behavior as Types".

Wenn jemand deinen Code aufruft und ungültige Werte übergibt, ist es am besten, einen Fehler zurückzugeben, wenn du kannst, damit der Benutzer der Bibliothek entscheiden kann, was er in diesem Fall tun möchte. In Fällen jedoch, in denen das Fortfahren unsicher oder schädlich sein könnte, ist die beste Option möglicherweise, `panic!` aufzurufen und die Person, die deine Bibliothek verwendet, über das Bug in ihrem Code zu informieren, damit sie es während der Entwicklung beheben können. Ähnlich ist `panic!` oft angemessen, wenn du auf externen Code zugreifst, der außerhalb deiner Kontrolle ist und einen ungültigen Zustand zurückgibt, den du nicht beheben kannst.

Wenn jedoch ein Fehler erwartet wird, ist es passender, ein `Result` zurückzugeben, als `panic!` aufzurufen. Beispiele sind ein Parser, der fehlerhafte Daten erhält, oder ein HTTP-Anfrage, die einen Status zurückgibt, der darauf hinweist, dass du eine Rate-Limit erreicht hast. In diesen Fällen gibt das Zurückgeben eines `Result` an, dass ein Fehler eine erwartete Möglichkeit ist, die der aufrufende Code entscheiden muss, wie er damit umgehen soll.

Wenn dein Code eine Operation ausführt, die einen Benutzer bei Verwendung ungültiger Werte gefährden könnte, sollte dein Code zunächst überprüfen, ob die Werte gültig sind, und in Panik geraten, wenn die Werte ungültig sind. Dies ist hauptsächlich aus Sicherheitsgründen: Das Versuchen, auf ungültige Daten zu operieren, kann deinen Code für Schwachstellen anfällig machen. Dies ist der Hauptgrund, warum die Standardbibliothek `panic!` aufrufen wird, wenn du versuchst, auf einen Speicherbereich außerhalb der Grenzen zuzugreifen: Das Versuchen, auf Speicher zuzugreifen, der nicht zum aktuellen Datenstruktur gehört, ist ein häufiges Sicherheitsproblem. Funktionen haben oft _Vereinbarungen_: Ihr Verhalten wird nur gewährleistet, wenn die Eingaben bestimmte Anforderungen erfüllen. Wenn die Vereinbarung verletzt wird, ist es sinnvoll, in Panik zu geraten, da eine Verletzung der Vereinbarung immer einen Fehler auf der aufrufenden Seite anzeigt, und es ist keine Art von Fehler, für die du möchten, dass der aufrufende Code explizit handhaben muss. Tatsächlich gibt es keine vernünftige Möglichkeit, dass der aufrufende Code sich erholt; die aufrufenden _Programmierer_ müssen den Code beheben. Die Vereinbarungen für eine Funktion, insbesondere wenn eine Verletzung dazu führt, dass in Panik geraten wird, sollten in der API-Dokumentation für die Funktion erklärt werden.

Allerdings wäre es umständlich und lästig, in allen deinen Funktionen viele Fehlerprüfungen durchzuführen. Glücklicherweise kannst du das Typsystem von Rust (und somit die vom Compiler durchgeführte Typüberprüfung) verwenden, um viele der Prüfungen für dich durchzuführen. Wenn deine Funktion einen bestimmten Typ als Parameter hat, kannst du mit der Logik deines Codes fortfahren, indem du weißt, dass der Compiler bereits sichergestellt hat, dass du einen gültigen Wert hast. Beispielsweise, wenn du einen Typ hast, anstatt eine `Option`, erwartet dein Programm, dass es _etwas_ gibt, anstatt _nichts_. Dein Code muss dann nicht zwei Fälle für die `Some` und `None` Varianten behandeln: Es wird nur einen Fall für das definitiv vorhandene einen Wert haben. Code, der versucht, nichts an deine Funktion zu übergeben, wird nicht einmal kompilieren, sodass deine Funktion nicht prüfen muss, auf diesen Fall zur Laufzeit. Ein weiteres Beispiel ist das Verwenden eines vorzeichenlosen ganzzahligen Typs wie `u32`, das gewährleistet, dass der Parameter niemals negativ ist.
