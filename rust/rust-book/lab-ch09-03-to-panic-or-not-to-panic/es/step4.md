# Pautas para el manejo de errores

Es recomendable que tu código se bloquee cuando es posible que termine en un estado incorrecto. En este contexto, un _estado incorrecto_ es cuando se ha violado alguna suposición, garantía, contrato o invariante, como cuando se pasan valores inválidos, valores contradictorios o valores faltantes a tu código, más uno o más de los siguientes:

- El estado incorrecto es algo inesperado, en contraste con algo que probablemente sucederá ocasionalmente, como un usuario ingresando datos en un formato incorrecto.
- Tu código después de este punto debe confiar en no estar en este estado incorrecto, en lugar de comprobar el problema en cada paso.
- No hay una buena forma de codificar esta información en los tipos que utilizas. Veremos un ejemplo de lo que queremos decir en "Codificar estados y comportamiento como tipos".

Si alguien llama a tu código y pasa valores que no tienen sentido, es mejor devolver un error si es posible para que el usuario de la biblioteca pueda decidir qué hacer en ese caso. Sin embargo, en casos donde continuar podría ser inseguro o dañino, la mejor opción podría ser llamar a `panic!` y alertar a la persona que utiliza tu biblioteca sobre el error en su código para que lo pueda corregir durante el desarrollo. Del mismo modo, `panic!` a menudo es apropiado si estás llamando a código externo que está fuera de tu control y devuelve un estado inválido que no puedes corregir.

Sin embargo, cuando se espera un error, es más apropiado devolver un `Result` que hacer una llamada a `panic!`. Ejemplos incluyen un analizador que recibe datos con formato incorrecto o una solicitud HTTP que devuelve un estado que indica que has alcanzado un límite de tasa. En estos casos, devolver un `Result` indica que el error es una posibilidad esperada que el código llamador debe decidir cómo manejar.

Cuando tu código realiza una operación que podría poner a un usuario en riesgo si se llama con valores inválidos, tu código debe verificar primero que los valores son válidos y bloquear si los valores no son válidos. Esto es principalmente por razones de seguridad: intentar operar con datos inválidos puede exponer tu código a vulnerabilidades. Esta es la principal razón por la que la biblioteca estándar llamará a `panic!` si intentas acceder a memoria fuera de los límites: intentar acceder a memoria que no pertenece a la estructura de datos actual es un problema de seguridad común. Las funciones a menudo tienen _contratos_: su comportamiento solo está garantizado si las entradas cumplen con determinados requisitos. Bloquear cuando se viola el contrato tiene sentido porque una violación del contrato siempre indica un error en el código del llamador, y no es un tipo de error que quieres que el código llamador tenga que manejar explícitamente. De hecho, no hay forma razonable para que el código llamador se recupere; los _programadores_ llamantes deben corregir el código. Los contratos de una función, especialmente cuando una violación causará un bloqueo, deben explicarse en la documentación de la API de la función.

Sin embargo, tener muchas comprobaciones de errores en todas tus funciones sería verboso y molesto. Por suerte, puedes utilizar el sistema de tipos de Rust (y, por lo tanto, la comprobación de tipos realizada por el compilador) para hacer muchas de las comprobaciones por ti. Si tu función tiene un tipo particular como parámetro, puedes continuar con la lógica de tu código sabiendo que el compilador ya ha asegurado que tienes un valor válido. Por ejemplo, si tienes un tipo en lugar de una `Option`, tu programa espera tener _algo_ en lugar de _nada_. Entonces, tu código no tiene que manejar dos casos para las variantes `Some` y `None`: solo tendrá un caso para tener definitivamente un valor. El código que intenta pasar nada a tu función ni siquiera se compilará, por lo que tu función no tiene que comprobar ese caso en tiempo de ejecución. Otro ejemplo es utilizar un tipo de entero sin signo como `u32`, que garantiza que el parámetro nunca es negativo.
