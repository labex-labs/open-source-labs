# 検証用のカスタム型の作成

Rustの型システムを使って有効な値を保証するアイデアをさらに一歩進めて、検証用のカスタム型を作成してみましょう。第2章の当て推測ゲームを思い出してください。そのゲームでは、コードがユーザーに1から100の間の数字を当てるように依頼しました。秘密の数字と照合する前に、ユーザーの予想がそれらの数字の間にあることを検証したことはありませんでした。ただ、予想が正の数であることを検証しました。この場合、結果はそれほど深刻ではありませんでした。「数字が大きすぎます」または「数字が小さすぎます」という出力は依然として正しいです。しかし、ユーザーに有効な予想を導き、ユーザーが範囲外の数字を予想した場合と、例えば文字を入力した場合とで異なる動作をさせることは、便利な機能向上になります。

これを行う1つの方法は、潜在的に負の数を許可するために、`u32`ではなく`i32`として予想を解析することであり、その後、数字が範囲内であることをチェックすることです。次のようになります。

ファイル名: `src/main.rs`

```rust
loop {
    --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
        --snip--
}
```

`if`式は、値が範囲外であるかどうかをチェックし、問題をユーザーに知らせ、`continue`を呼び出してループの次の反復を開始し、別の予想を求めます。`if`式の後では、`guess`が1から100の間であることを知っているので、`guess`と秘密の数字の間の比較を続けることができます。

ただし、これは理想的な解決策ではありません。プログラムが1から100の間の値のみで動作することが絶対に重要であり、この要件を持つ関数が多数ある場合、各関数にこのようなチェックを行うのは面倒くさくなります（おそらくパフォーマンスにも影響を与えます）。

代わりに、新しい型を作成し、検証を関数に配置して、型のインスタンスを作成することができます。そうすることで、関数がシグネチャで新しい型を使用し、受け取った値を安心して使用することができます。リスト9-13は、`new`関数が1から100の間の値を受け取った場合にのみ`Guess`のインスタンスを作成する`Guess`型を定義する1つの方法を示しています。

ファイル名: `src/lib.rs`

```rust
1 pub struct Guess {
    value: i32,
}

impl Guess {
  2 pub fn new(value: i32) -> Guess {
      3 if value < 1 || value > 100 {
          4 panic!(
                "Guess value must be between 1 and 100, got {}.",
                value
            );
        }

      5 Guess { value }
    }

  6 pub fn value(&self) -> i32 {
        self.value
    }
}
```

リスト9-13: 1から100の間の値のみで動作する`Guess`型

まず、`i32`を保持する`value`というフィールドを持つ`Guess`という名前の構造体を定義します \[1\]。ここに数字が格納されます。

次に、`Guess`に対して`Guess`値のインスタンスを作成する`new`という関連付け関数を実装します \[2\]。`new`関数は、`i32`型の`value`という1つのパラメータを持ち、`Guess`を返すように定義されています。`new`関数の本体のコードは、`value`が1から100の間であることを確認するために`value`をテストします \[3\]。`value`がこのテストに合格しない場合、`panic!`を呼び出します \[4\]。これは、呼び出し元のコードを書いているプログラマーに、修正する必要のあるバグがあることを知らせます。なぜなら、この範囲外の`value`で`Guess`を作成すると、`Guess::new`が依存している契約に違反するからです。`Guess::new`がパニックする可能性のある条件については、その公開APIドキュメントで議論する必要があります。第14章で作成するAPIドキュメントにおいて`panic!`の可能性を示すドキュメント作成規約についても説明します。`value`がテストに合格した場合、`value`フィールドを`value`パラメータに設定した新しい`Guess`を作成し、`Guess`を返します \[5\]。

次に、`self`を借用し、他のパラメータを持たず、`i32`を返す`value`というメソッドを実装します \[6\]。この種のメソッドは、時には「ゲッター」と呼ばれます。なぜなら、その目的はフィールドからいくつかのデータを取得して返すことだからです。この公開メソッドは必要です。なぜなら、`Guess`構造体の`value`フィールドは非公開だからです。`value`フィールドが非公開であることが重要です。なぜなら、`Guess`構造体を使用するコードは、`value`を直接設定することが許可されないからです。モジュール外のコードは、`Guess`のインスタンスを作成するために`Guess::new`関数を必ず使用する必要があります。それにより、`Guess`が`Guess::new`関数の条件によってチェックされていない`value`を持つことがないことが保証されます。

その後、パラメータを持つか、または1から100の間の数字のみを返す関数は、そのシグネチャで`i32`ではなく`Guess`を受け取るか、または返すことを宣言でき、本体で追加のチェックを行う必要はありません。
