# コンパイラよりも多くの情報を持つ場合

`Result`が`Ok`値を持つことを保証する他のロジックがあるが、そのロジックがコンパイラに理解されない場合、`unwrap`または`expect`を呼び出すのも適切です。まだ処理する必要のある`Result`値があります。呼び出している操作は一般的に失敗する可能性がありますが、特定の状況では論理的には不可能です。コードを手動で調べることで`Err`バリアントが決して発生しないことを保証できる場合、`unwrap`を呼び出すのは完全に許容され、`expect`のテキストに`Err`バリアントが決して発生しないと考える理由を記載するのがさらに良いです。以下は例です。

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
 .parse()
 .expect("Hardcoded IP address should be valid");
```

ハードコードされた文字列を解析することで`IpAddr`インスタンスを作成しています。`127.0.0.1`が有効なIPアドレスであることがわかるので、ここで`expect`を使用しても問題ありません。ただし、ハードコードされた有効な文字列を持つことは、`parse`メソッドの戻り型を変更しません。依然として`Result`値を取得し、コンパイラは`Err`バリアントがあり得るとして`Result`を処理するように強制されます。なぜなら、コンパイラはこの文字列が常に有効なIPアドレスであることを認識できないほど賢くないからです。IPアドレス文字列がユーザーからのものであり、プログラムにハードコードされていない場合、したがって失敗の可能性がある場合、もっと堅牢な方法で`Result`を処理する必要があります。このIPアドレスがハードコードされているという仮定を述べることで、将来的に他のソースからIPアドレスを取得する必要がある場合に、`expect`をより良いエラーハンドリングコードに変更するよう促されます。
