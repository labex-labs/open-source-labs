# エラーハンドリングのガイドライン

コードが不適切な状態になる可能性がある場合、コードをパニックさせることが望ましいです。この文脈において、「不適切な状態」とは、いくつかの仮定、保証、契約、または不変条件が破られた場合です。たとえば、無効な値、矛盾する値、または欠損値がコードに渡された場合などです。さらに、以下の 1 つ以上が当てはまります。

- 不適切な状態は、予期しないものであり、ユーザーが間違った形式でデータを入力するような、たまに起こり得ることとは対照的です。
- この時点以降のコードは、この不適切な状態になっていないことを前提として動作する必要があり、各ステップで問題をチェックする代わりに、それを前提として動作する必要があります。
- この情報を使用する型にエンコードする良い方法がありません。「型としての状態と動作のエンコード」で意味することの例を通して説明します。

誰かがコードを呼び出して、意味のない値を渡した場合、できる限りエラーを返す方が良いです。そうすることで、ライブラリのユーザーがその場合に何をしたいかを決定できます。ただし、続行することが不安定または有害な場合、最善の選択は`panic!`を呼び出して、ライブラリを使用している人にコードのバグを知らせることで、開発中に修正できるようにすることです。同様に、コントロールできない外部コードを呼び出して、修正できない無効な状態を返す場合、`panic!`を使用するのが適切なことが多いです。

ただし、失敗が予想される場合、`panic!`を呼び出すよりも`Result`を返す方が適切です。例としては、不正な形式のデータが与えられたパーサーや、レート制限に達したことを示すステータスを返す HTTP リクエストなどが挙げられます。これらの場合、`Result`を返すことは、失敗が予想される可能性であり、呼び出し元のコードがどのように処理するかを決定する必要があることを示しています。

コードが無効な値を使用して呼び出された場合にユーザーにリスクを与える操作を行う場合、コードはまず値が有効であることを検証し、値が無効な場合はパニックする必要があります。これは主にセキュリティ上の理由です。無効なデータで操作を試みると、コードが脆弱性にさらされる可能性があります。これが、標準ライブラリが境界外のメモリアクセスを試みた場合に`panic!`を呼び出す主な理由です。現在のデータ構造に属さないメモリをアクセスしようとすることは、一般的なセキュリティ問題です。関数には多くの場合「契約」があります。入力が特定の要件を満たす場合にのみ、その動作が保証されます。契約が破られたときにパニックするのは理にかなっています。なぜなら、契約の違反は常に呼び出し元側のバグを示しており、呼び出し元のコードが明示的に処理する必要のあるエラーの種類ではないからです。実際、呼び出し元のコードが回復する合理的な方法はありません。呼び出し元の「プログラマー」がコードを修正する必要があります。関数の契約、特に違反がパニックを引き起こす場合、関数の API ドキュメントに説明する必要があります。

ただし、すべての関数に多数のエラーチェックを行うと、冗長で面倒くさくなります。幸いなことに、Rust の型システム（したがってコンパイラによる型チェック）を使用して、多くのチェックを自動的に行うことができます。関数に特定の型のパラメータがある場合、コンパイラが既に有効な値を持っていることを確認しているので、コードのロジックを進めることができます。たとえば、`Option`ではなく特定の型を持っている場合、プログラムは「何か」を期待しています。そのため、コードは`Some`と`None`のバリアントの 2 つのケースを処理する必要がなくなります。値が必ずある 1 つのケースのみを持つことになります。関数に何も渡そうとするコードはコンパイルされません。したがって、関数は実行時にそのケースをチェックする必要がありません。もう 1 つの例は、`u32`のような符号なし整数型を使用することです。これにより、パラメータが負にならないことが保証されます。
