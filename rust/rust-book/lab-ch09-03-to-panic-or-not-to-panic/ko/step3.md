# 컴파일러보다 더 많은 정보를 가지고 있는 경우

`Result`가 `Ok` 값을 갖도록 보장하는 다른 로직이 있지만, 해당 로직을 컴파일러가 이해하지 못하는 경우에도 `unwrap` 또는 `expect`를 호출하는 것이 적절합니다. 여전히 처리해야 할 `Result` 값이 있습니다. 호출하는 작업은 특정 상황에서는 논리적으로 불가능하더라도 일반적으로 실패할 가능성이 여전히 있습니다. 코드를 수동으로 검사하여 `Err` 변형이 절대 없을 것이라고 확신할 수 있다면 `unwrap`을 호출하는 것이 완벽하게 허용되며, `expect` 텍스트에서 `Err` 변형이 절대 없을 것이라고 생각하는 이유를 문서화하는 것이 훨씬 좋습니다. 다음은 예시입니다.

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
    .parse()
    .expect("Hardcoded IP address should be valid");
```

하드코딩된 문자열을 구문 분석하여 `IpAddr` 인스턴스를 생성하고 있습니다. `127.0.0.1`이 유효한 IP 주소임을 알 수 있으므로 여기에서 `expect`를 사용하는 것이 허용됩니다. 그러나 하드코딩된 유효한 문자열을 사용해도 `parse` 메서드의 반환 유형은 변경되지 않습니다. 여전히 `Result` 값을 얻으며, 컴파일러는 이 문자열이 항상 유효한 IP 주소임을 알 만큼 똑똑하지 않기 때문에 `Err` 변형이 가능성이 있는 것처럼 `Result`를 처리하도록 강제합니다. IP 주소 문자열이 프로그램에 하드코딩된 것이 아니라 사용자로부터 제공되어 실패할 가능성이 있는 경우, `Result`를 더 강력한 방식으로 처리하는 것이 확실히 좋습니다. 이 IP 주소가 하드코딩되었다는 가정을 언급하면, 향후 다른 소스에서 IP 주소를 가져와야 하는 경우 `expect`를 더 나은 오류 처리 코드로 변경하도록 유도할 것입니다.
