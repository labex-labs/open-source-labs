# 오류 처리에 대한 지침

코드가 잘못된 상태가 될 수 있는 경우 코드가 패닉하도록 하는 것이 좋습니다. 이 맥락에서 *잘못된 상태*는 유효하지 않은 값, 모순된 값 또는 누락된 값이 코드에 전달되는 경우와 같이 일부 가정, 보장, 계약 또는 불변성이 깨진 경우를 의미합니다. 다음 중 하나 이상이 포함됩니다.

- 잘못된 상태는 사용자가 잘못된 형식으로 데이터를 입력하는 경우와 같이 가끔 발생할 가능성이 있는 것이 아니라 예상치 못한 것입니다.
- 이 시점 이후의 코드는 모든 단계에서 문제를 확인하는 대신 이 잘못된 상태에 있지 않다는 것에 의존해야 합니다.
- 사용하는 유형으로 이 정보를 인코딩할 좋은 방법이 없습니다. "유형으로 상태 및 동작 인코딩"에서 의미하는 바의 예시를 살펴보겠습니다.

누군가 코드를 호출하고 말이 안 되는 값을 전달하는 경우, 라이브러리 사용자가 해당 경우에 무엇을 할지 결정할 수 있도록 오류를 반환하는 것이 가장 좋습니다. 그러나 계속 진행하는 것이 안전하지 않거나 해로울 수 있는 경우, `panic!`을 호출하고 라이브러리를 사용하는 사람에게 코드의 버그를 알려 개발 중에 수정할 수 있도록 하는 것이 최선의 선택일 수 있습니다. 마찬가지로, 제어할 수 없는 외부 코드를 호출하고 수정할 방법이 없는 유효하지 않은 상태를 반환하는 경우 `panic!`이 적절한 경우가 많습니다.

그러나 실패가 예상되는 경우, `panic!` 호출을 하는 것보다 `Result`를 반환하는 것이 더 적절합니다. 예시로는 파서에 잘못된 데이터가 제공되거나 HTTP 요청이 속도 제한에 도달했음을 나타내는 상태를 반환하는 경우가 있습니다. 이러한 경우, `Result`를 반환하는 것은 실패가 호출 코드가 처리 방법을 결정해야 하는 예상 가능한 가능성임을 나타냅니다.

코드가 유효하지 않은 값을 사용하여 호출될 경우 사용자를 위험에 빠뜨릴 수 있는 작업을 수행하는 경우, 먼저 값이 유효한지 확인하고 유효하지 않은 경우 패닉해야 합니다. 이는 주로 안전을 위한 이유입니다. 유효하지 않은 데이터에 대한 작업을 시도하면 코드에 취약성이 노출될 수 있습니다. 이것이 표준 라이브러리가 범위를 벗어난 메모리 접근을 시도하는 경우 `panic!`을 호출하는 주된 이유입니다. 현재 데이터 구조에 속하지 않는 메모리에 접근하는 것은 일반적인 보안 문제입니다. 함수는 종종 *계약*을 갖습니다. 입력이 특정 요구 사항을 충족하는 경우에만 동작이 보장됩니다. 계약 위반은 항상 호출자 측의 버그를 나타내며, 호출 코드가 명시적으로 처리해야 하는 종류의 오류가 아니기 때문에 계약 위반 시 패닉하는 것이 타당합니다. 실제로 호출 코드가 복구할 합리적인 방법이 없습니다. 호출하는 *프로그래머*가 코드를 수정해야 합니다. 특히 위반 시 패닉이 발생하는 경우 함수의 계약은 함수의 API 문서에 설명되어야 합니다.

그러나 모든 함수에 많은 오류 검사를 하는 것은 장황하고 성가실 것입니다. 다행히 Rust 의 타입 시스템 (따라서 컴파일러에서 수행하는 타입 검사) 을 사용하여 많은 검사를 수행할 수 있습니다. 함수에 특정 유형이 매개변수로 있는 경우, 컴파일러가 이미 유효한 값을 가지고 있는지 확인했음을 알고 코드의 로직을 진행할 수 있습니다. 예를 들어, `Option` 대신 특정 유형이 있는 경우, 프로그램은 *nothing*이 아닌 *something*을 가질 것으로 예상합니다. 그러면 코드는 `Some` 및 `None` 변형에 대한 두 가지 경우를 처리할 필요가 없습니다. 확실히 값을 갖는 한 가지 경우만 갖게 됩니다. 함수에 아무것도 전달하려고 시도하는 코드는 컴파일조차 되지 않으므로 함수는 런타임에 해당 경우를 확인할 필요가 없습니다. 또 다른 예는 `u32`와 같은 부호 없는 정수 유형을 사용하여 매개변수가 음수가 되지 않도록 하는 것입니다.
