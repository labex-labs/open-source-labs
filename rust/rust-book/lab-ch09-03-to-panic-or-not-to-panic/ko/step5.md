# 유효성 검사를 위한 사용자 정의 타입 생성

Rust 의 타입 시스템을 사용하여 유효한 값을 갖도록 하는 아이디어를 한 단계 더 나아가 유효성 검사를 위한 사용자 정의 타입을 생성하는 것을 살펴보겠습니다. 2 장에서 코드가 사용자에게 1 에서 100 사이의 숫자를 추측하도록 요청했던 추측 게임을 기억하십시오. 비밀 번호와 비교하기 전에 사용자의 추측이 해당 숫자 사이에 있는지 확인하지 않았습니다. 추측이 양수인지 확인했을 뿐입니다. 이 경우 결과는 그다지 심각하지 않았습니다. "너무 높음" 또는 "너무 낮음"의 출력은 여전히 정확했을 것입니다. 그러나 사용자가 유효한 추측을 하도록 안내하고 사용자가 예를 들어 문자를 입력하는 경우와 범위 밖의 숫자를 추측하는 경우 다른 동작을 갖도록 하는 것이 유용할 것입니다.

이를 수행하는 한 가지 방법은 잠재적으로 음수를 허용하기 위해 추측을 `u32`가 아닌 `i32`로 구문 분석한 다음 다음과 같이 숫자가 범위 내에 있는지 확인하는 것입니다.

파일 이름: `src/main.rs`

```rust
loop {
    --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
        --snip--
}
```

`if` 표현식은 값이 범위를 벗어나는지 확인하고, 사용자에게 문제에 대해 알리고, `continue`를 호출하여 루프의 다음 반복을 시작하고 다른 추측을 요청합니다. `if` 표현식 이후에는 `guess`가 1 에서 100 사이임을 알고 `guess`와 비밀 번호 간의 비교를 진행할 수 있습니다.

그러나 이것은 이상적인 해결책이 아닙니다. 프로그램이 1 에서 100 사이의 값으로만 작동하는 것이 절대적으로 중요하고 이 요구 사항이 있는 함수가 많은 경우, 모든 함수에 이와 같은 검사를 하는 것은 지루할 것입니다 (그리고 성능에 영향을 미칠 수 있습니다).

대신, 새 유형을 만들고 모든 곳에서 유효성 검사를 반복하는 대신 유형의 인스턴스를 생성하는 함수에 유효성 검사를 넣을 수 있습니다. 그렇게 하면 함수가 시그니처에서 새 유형을 사용하고 수신하는 값을 자신 있게 사용하는 것이 안전합니다. 목록 9-13 은 `new` 함수가 1 에서 100 사이의 값을 수신하는 경우에만 `Guess`의 인스턴스를 생성하는 `Guess` 유형을 정의하는 한 가지 방법을 보여줍니다.

파일 이름: `src/lib.rs`

```rust
1 pub struct Guess {
    value: i32,
}

impl Guess {
  2 pub fn new(value: i32) -> Guess {
      3 if value < 1 || value > 100 {
          4 panic!(
                "Guess value must be between 1 and 100, got {}.",
                value
            );
        }

      5 Guess { value }
    }

  6 pub fn value(&self) -> i32 {
        self.value
    }
}
```

목록 9-13: 1 에서 100 사이의 값으로만 계속 진행되는 `Guess` 유형

먼저 `value`라는 필드를 가진 `Guess`라는 구조체를 정의합니다. 이 필드는 `i32`를 저장합니다 \[1]. 이것은 숫자가 저장될 위치입니다.

그런 다음 `Guess`에 `new`라는 연관 함수를 구현하여 `Guess` 값의 인스턴스를 생성합니다 \[2]. `new` 함수는 `i32` 유형의 `value`라는 매개변수 하나를 갖고 `Guess`를 반환하도록 정의됩니다. `new` 함수의 본문 내 코드는 `value`가 1 에서 100 사이인지 확인하기 위해 테스트합니다 \[3]. `value`가 이 테스트를 통과하지 못하면 `panic!` 호출을 합니다 \[4]. 그러면 이 범위를 벗어난 `value`로 `Guess`를 생성하면 `Guess::new`가 의존하는 계약을 위반하므로 호출 코드를 작성하는 프로그래머에게 수정해야 할 버그가 있음을 알립니다. `Guess::new`가 패닉할 수 있는 조건은 공개 API 문서에서 논의되어야 합니다. 14 장에서 생성할 API 문서에서 `panic!`의 가능성을 나타내는 문서화 규칙을 다룰 것입니다. `value`가 테스트를 통과하면 `value` 필드가 `value` 매개변수로 설정된 새 `Guess`를 생성하고 `Guess`를 반환합니다 \[5].

다음으로, `self`를 빌리고 다른 매개변수가 없으며 `i32`를 반환하는 `value`라는 메서드를 구현합니다 \[6]. 이 종류의 메서드는 때때로 *getter*라고 불립니다. 그 목적은 필드에서 일부 데이터를 가져와 반환하는 것이기 때문입니다. 이 public 메서드는 `Guess` 구조체의 `value` 필드가 private 이기 때문에 필요합니다. `value` 필드가 private 인 것은 `Guess` 구조체를 사용하는 코드가 `value`를 직접 설정할 수 없도록 하기 위해 중요합니다. 모듈 외부의 코드는 `Guess::new` 함수를 사용하여 `Guess`의 인스턴스를 _반드시_ 사용해야 하므로 `Guess::new` 함수의 조건에 의해 확인되지 않은 `value`를 갖는 `Guess`가 없도록 보장합니다.

1 에서 100 사이의 숫자만 매개변수로 갖거나 반환하는 함수는 시그니처에서 `i32` 대신 `Guess`를 사용하거나 반환한다고 선언할 수 있으며 본문에서 추가 검사를 수행할 필요가 없습니다.
