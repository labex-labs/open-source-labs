# Diretrizes para Tratamento de Erros

É aconselhável que seu código entre em pânico quando for possível que seu código possa acabar em um estado ruim. Nesse contexto, um _estado ruim_ é quando alguma suposição, garantia, contrato ou invariante foi violada, como quando valores inválidos, valores contraditórios ou valores ausentes são passados para seu código - mais um ou mais dos seguintes:

- O estado ruim é algo inesperado, em oposição a algo que provavelmente acontecerá ocasionalmente, como um usuário inserindo dados no formato errado.
- Seu código após este ponto precisa confiar em não estar nesse estado ruim, em vez de verificar o problema em cada etapa.
- Não há uma boa maneira de codificar essa informação nos tipos que você usa. Vamos trabalhar em um exemplo do que queremos dizer em "Codificando Estados e Comportamento como Tipos".

Se alguém chama seu código e passa valores que não fazem sentido, é melhor retornar um erro, se puder, para que o usuário da biblioteca possa decidir o que deseja fazer nesse caso. No entanto, em casos em que continuar pode ser inseguro ou prejudicial, a melhor escolha pode ser chamar `panic!` e alertar a pessoa que está usando sua biblioteca sobre o bug em seu código para que ela possa corrigi-lo durante o desenvolvimento. Da mesma forma, `panic!` é frequentemente apropriado se você estiver chamando código externo que está fora de seu controle e ele retornar um estado inválido que você não tem como corrigir.

No entanto, quando a falha é esperada, é mais apropriado retornar um `Result` do que fazer uma chamada `panic!`. Exemplos incluem um analisador recebendo dados malformados ou uma solicitação HTTP retornando um status que indica que você atingiu um limite de taxa. Nesses casos, retornar um `Result` indica que a falha é uma possibilidade esperada que o código de chamada deve decidir como lidar.

Quando seu código executa uma operação que pode colocar um usuário em risco se for chamada usando valores inválidos, seu código deve verificar se os valores são válidos primeiro e entrar em pânico se os valores não forem válidos. Isso é principalmente por razões de segurança: tentar operar em dados inválidos pode expor seu código a vulnerabilidades. Esta é a principal razão pela qual a biblioteca padrão chamará `panic!` se você tentar um acesso de memória fora dos limites: tentar acessar a memória que não pertence à estrutura de dados atual é um problema de segurança comum. As funções geralmente têm _contratos_: seu comportamento é garantido apenas se as entradas atenderem a requisitos específicos. Entrar em pânico quando o contrato é violado faz sentido porque uma violação de contrato sempre indica um bug do lado do chamador, e não é um tipo de erro que você deseja que o código de chamada tenha que lidar explicitamente. Na verdade, não há uma maneira razoável para o código de chamada se recuperar; os _programadores_ de chamada precisam corrigir o código. Os contratos para uma função, especialmente quando uma violação causará um pânico, devem ser explicados na documentação da API para a função.

No entanto, ter muitas verificações de erros em todas as suas funções seria verboso e irritante. Felizmente, você pode usar o sistema de tipos do Rust (e, portanto, a verificação de tipos feita pelo compilador) para fazer muitas das verificações por você. Se sua função tiver um tipo específico como parâmetro, você pode prosseguir com a lógica do seu código sabendo que o compilador já garantiu que você tem um valor válido. Por exemplo, se você tiver um tipo em vez de um `Option`, seu programa espera ter _algo_ em vez de _nada_. Seu código então não precisa lidar com dois casos para as variantes `Some` e `None`: ele terá apenas um caso para definitivamente ter um valor. O código que tenta passar nada para sua função nem compilará, então sua função não precisa verificar esse caso em tempo de execução. Outro exemplo é usar um tipo inteiro sem sinal, como `u32`, que garante que o parâmetro nunca seja negativo.
