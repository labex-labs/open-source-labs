# Сборка и запуск проекта с использованием Cargo

Теперь посмотрим, что отличается, когда мы собираем и запускаем программу "Hello, world!" с использованием Cargo! В директории `hello_cargo` введите следующую команду, чтобы собрать ваш проект:

```bash
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Эта команда создает исполняемый файл в `target/debug/hello_cargo`, а не в текущей директории. Поскольку по умолчанию сборка - это отладочная сборка, Cargo помещает бинарник в директорию с именем `debug`. Вы можете запустить исполняемый файл с помощью этой команды:

```bash
$./target/debug/hello_cargo
Hello, world!
```

Если все прошло успешно, `Hello, world!` должно быть выведено в терминал. Первый запуск `cargo build` также заставляет Cargo создать новый файл в верхнем уровне: _Cargo.lock_. Этот файл отслеживает точные версии зависимостей в вашем проекте. В этом проекте нет зависимостей, поэтому файл выглядит довольно пустым. Вы никогда не будете нужно вручную изменять этот файл; Cargo управляет его содержимым для вас.

Мы только что собрали проект с помощью `cargo build` и запустили его с помощью `./target/debug/hello_cargo`, но мы также можем использовать `cargo run`, чтобы скомпилировать код и затем запустить получившийся исполняемый файл в одной команде:

```bash
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Использование `cargo run` более удобно, чем запоминать, что нужно сначала запустить `cargo build`, а затем использовать полный путь к бинарнику, поэтому большинство разработчиков используют `cargo run`.

Заметьте, что на этот раз мы не увидели вывод, указывающий на то, что Cargo компилирует `hello_cargo`. Cargo понял, что файлы не изменились, поэтому он не произвел повторной сборки, а просто запустил бинарник. Если бы вы изменили исходный код, Cargo бы пересобрали проект перед запуском, и вы бы увидели этот вывод:

```bash
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo также предоставляет команду `cargo check`. Эта команда быстро проверяет ваш код, чтобы убедиться, что он компилируется, но не создает исполняемый файл:

```bash
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Почему бы вам не понадобился исполняемый файл? Чаще всего `cargo check` работает намного быстрее, чем `cargo build`, потому что она пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу при написании кода, использование `cargo check` ускорит процесс, позволяя вам узнать, компилируется ли ваш проект! Именно поэтому многие разработчики Rust периодически запускают `cargo check` при написании программы, чтобы убедиться, что она компилируется. Затем они запускают `cargo build`, когда готовы использовать исполняемый файл.

Подведем итог того, что мы узнали о Cargo до сих пор:

- Мы можем создать проект с помощью `cargo new`.
- Мы можем собрать проект с помощью `cargo build`.
- Мы можем собрать и запустить проект за один шаг с помощью `cargo run`.
- Мы можем собрать проект без создания бинарника для проверки ошибок с помощью `cargo check`.
- Вместо сохранения результата сборки в той же директории, что и наш код, Cargo хранит его в директории `target/debug`.

Дополнительным преимуществом использования Cargo является то, что команды одинаковые независимо от операционной системы, на которой вы работаете. Поэтому на этом этапе мы больше не будем предоставлять конкретные инструкции для Linux и macOS по сравнению с Windows.
