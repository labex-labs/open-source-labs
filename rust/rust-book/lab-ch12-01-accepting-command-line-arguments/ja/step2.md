# 引数値の読み取り

`minigrep` に渡すコマンドライン引数の値を読み取らせるには、Rustの標準ライブラリに用意されている `std::env::args` 関数が必要です。この関数は、`minigrep` に渡されたコマンドライン引数のイテレータを返します。第13章でイテレータについて十分に解説します。今のところ、イテレータに関する2つのことだけ知っておけばよいです。イテレータは一連の値を生成し、イテレータに対して `collect` メソッドを呼び出すことで、イテレータが生成するすべての要素を含むベクターなどのコレクションに変換できます。

リスト12-1のコードでは、`minigrep` プログラムが渡された任意のコマンドライン引数を読み取り、その値をベクターに収集できるようになっています。

ファイル名: `src/main.rs`

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
}
```

リスト12-1: コマンドライン引数をベクターに収集して表示する

まず、`use` 文で `std::env` モジュールをスコープ内に持ち込み、その `args` 関数を使えるようにします。`std::env::args` 関数は2つのモジュールにネストされていることに注意してください。第7章で説明したように、必要な関数が複数のモジュールにネストされている場合、私たちは関数ではなく親モジュールをスコープ内に持ち込むことにしています。これにより、`std::env` の他の関数を簡単に使えるようになります。また、`use std::env::args` を追加してから、単に `args` で関数を呼び出すよりも曖昧さが少なくなります。なぜなら、`args` は簡単に現在のモジュールで定義されている関数と間違えられるからです。

> **args関数と無効なUnicode**
>
> 任意の引数に無効なUnicodeが含まれている場合、`std::env::args` はパニックを起こします。プログラムが無効なUnicodeを含む引数を受け付ける必要がある場合は、代わりに `std::env::args_os` を使ってください。この関数は、`String` 値ではなく `OsString` 値を生成するイテレータを返します。ここでは単純さのために `std::env::args` を使っていますが、`OsString` 値はプラットフォームごとに異なり、`String` 値よりも扱いが複雑です。

`main` の最初の行では、`env::args` を呼び出し、直ちに `collect` を使ってイテレータを、イテレータが生成するすべての値を含むベクターに変換します。`collect` 関数を使って多くの種類のコレクションを作成できるので、`args` の型を明示的に指定して、文字列のベクターを取得したいことを指定します。Rustでは型を明示的に指定する必要がほとんどない場合がありますが、`collect` はコレクションの種類を推論できないため、よく型を明示的に指定する関数の1つです。

最後に、デバッグマクロを使ってベクターを表示します。まず、引数を渡さずにコードを実行してみて、次に2つの引数を渡して実行してみましょう。

```bash
$ cargo run
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
]
$ cargo run -- needle haystack
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
"needle",
"haystack",
]
```

ベクターの最初の値は `"target/debug/minigrep"` であることに注意してください。これは私たちのバイナリの名前で、Cの引数リストの動作と一致しており、プログラムが実行時に呼び出された名前を使用できるようにしています。メッセージに表示したり、コマンドラインエイリアスを使ってプログラムを呼び出した場合のプログラムの動作を変更したりするために、プログラム名にアクセスできることは頻繁に便利です。ただし、この章の目的のためには、これを無視して必要な2つの引数のみを保存します。
