# 인자 값 읽기 (Reading the Argument Values)

`minigrep`이 전달된 명령줄 인자의 값을 읽을 수 있도록 하려면, Rust 표준 라이브러리에 제공된 `std::env::args` 함수가 필요합니다. 이 함수는 `minigrep`에 전달된 명령줄 인자의 이터레이터를 반환합니다. 이터레이터에 대해서는 13 장에서 자세히 다룰 것입니다. 지금은 이터레이터에 대해 두 가지 세부 사항만 알면 됩니다: 이터레이터는 일련의 값을 생성하고, 이터레이터에서 `collect` 메서드를 호출하여 이터레이터가 생성하는 모든 요소를 포함하는 벡터와 같은 컬렉션으로 변환할 수 있습니다.

Listing 12-1 의 코드는 `minigrep` 프로그램이 전달된 모든 명령줄 인자를 읽고, 값을 벡터로 수집할 수 있도록 합니다.

파일 이름: `src/main.rs`

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
}
```

Listing 12-1: 명령줄 인자를 벡터로 수집하고 출력하기

먼저 `use` 문을 사용하여 `std::env` 모듈을 범위 내로 가져와서 해당 `args` 함수를 사용할 수 있도록 합니다. `std::env::args` 함수가 두 단계의 모듈에 중첩되어 있음을 확인하십시오. 7 장에서 논의했듯이, 원하는 함수가 둘 이상의 모듈에 중첩된 경우, 함수 대신 상위 모듈을 범위 내로 가져오도록 선택했습니다. 이렇게 하면 `std::env`의 다른 함수를 쉽게 사용할 수 있습니다. 또한 `use std::env::args`를 추가한 다음 단순히 `args`로 함수를 호출하는 것보다 모호성이 적습니다. 왜냐하면 `args`는 현재 모듈에 정의된 함수로 쉽게 오해될 수 있기 때문입니다.

> **args 함수와 유효하지 않은 유니코드 (Invalid Unicode)**
>
> `std::env::args`는 인자에 유효하지 않은 유니코드가 포함된 경우 패닉 (panic) 할 것입니다. 프로그램이 유효하지 않은 유니코드를 포함하는 인자를 받아들여야 하는 경우, 대신 `std::env::args_os`를 사용하십시오. 해당 함수는 `String` 값 대신 `OsString` 값을 생성하는 이터레이터를 반환합니다. 여기서는 단순성을 위해 `std::env::args`를 사용하도록 선택했습니다. 왜냐하면 `OsString` 값은 플랫폼마다 다르며 `String` 값보다 작업하기 더 복잡하기 때문입니다.

`main`의 첫 번째 줄에서 `env::args`를 호출하고, 즉시 `collect`를 사용하여 이터레이터를 이터레이터가 생성한 모든 값을 포함하는 벡터로 변환합니다. `collect` 함수를 사용하여 다양한 종류의 컬렉션을 만들 수 있으므로, 문자열 벡터를 원한다는 것을 명시적으로 지정하기 위해 `args`의 타입을 주석 처리합니다. Rust 에서 타입을 주석 처리하는 경우는 매우 드물지만, `collect`는 Rust 가 원하는 컬렉션의 종류를 추론할 수 없기 때문에 종종 주석 처리가 필요한 함수 중 하나입니다.

마지막으로, 디버그 매크로를 사용하여 벡터를 출력합니다. 먼저 인자 없이 코드를 실행한 다음 두 개의 인자를 사용하여 실행해 보겠습니다.

```bash
$ cargo run
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
]
$ cargo run -- needle haystack
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
"needle",
"haystack",
]
```

벡터의 첫 번째 값은 `"target/debug/minigrep"`인데, 이는 바이너리의 이름입니다. 이는 C 의 인자 목록의 동작과 일치하며, 프로그램이 실행 시 호출된 이름을 사용할 수 있도록 합니다. 메시지를 출력하거나 프로그램이 호출된 명령줄 별칭에 따라 프로그램의 동작을 변경하려는 경우 프로그램 이름에 액세스하는 것이 편리합니다. 하지만 이 장의 목적을 위해, 우리는 이를 무시하고 필요한 두 개의 인자만 저장할 것입니다.
