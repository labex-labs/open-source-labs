# Улучшение ясности кода с использованием адаптеров итераторов

Мы также можем воспользоваться итераторами в функции `search` нашего проекта по вводу-выводу, которая представлена здесь в листинге 13-21, как она была в листинге 12-19.

Имя файла: `src/lib.rs`

```rust
pub fn search<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
```

Листинг 13-21: Реализация функции `search` из листинга 12-19

Мы можем написать этот код более компактно, используя методы-адаптеры итераторов. Это также позволяет избежать использования изменяемого промежуточного вектора `results`. Функциональное программирование предпочитает минимизировать количество изменяемого состояния, чтобы сделать код более понятным. Удаление изменяемого состояния может привести к будущему улучшению, которое позволит выполнять поиск параллельно, так как нам не придётся управлять одновременным доступом к вектору `results`. Листинг 13-22 показывает это изменение.

Имя файла: `src/lib.rs`

```rust
pub fn search<'a>(
    query: &str,
    contents: &'a str,
) -> Vec<&'a str> {
    contents
     .lines()
     .filter(|line| line.contains(query))
     .collect()
}
```

Листинг 13-22: Использование методов-адаптеров итераторов в реализации функции `search`

Помните, что цель функции `search` — вернуть все строки в `contents`, которые содержат `query`. Подобно примеру с `filter` в листинге 13-16, этот код использует адаптер `filter`, чтобы оставить только те строки, для которых `line.contains(query)` возвращает `true`. Затем мы собираем соответствующие строки в другой вектор с помощью `collect`. Насколько проще! Не стесняйтесь сделать то же самое для функции `search_case_insensitive`, чтобы использовать методы итераторов.
