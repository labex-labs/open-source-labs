# マッチ制御フロー構文

Rust には、「マッチ」と呼ばれる非常に強力な制御フロー構文があり、これを使うと値を一連のパターンと比較し、一致したパターンに基づいてコードを実行できます。パターンはリテラル値、変数名、ワイルドカードなどで構成でき、18 章ではすべての種類のパターンとその機能について説明します。「マッチ」の力は、パターンの表現力と、コンパイラがすべての可能なケースを処理することを確認するという点にあります。

「マッチ」式をコイン分類機に例えると、コインは様々な大きさの穴がある軌道を伝って流れ、それぞれのコインは最初に合致する穴を通り抜けます。同じように、値は「マッチ」内の各パターンを通り、最初に値が「合致」するパターンで、その値は実行中に使用される関連するコードブロックに入ります。

コインについて言えば、「マッチ」を使って例にしましょう！未知のアメリカの硬貨を受け取り、カウント機と同じように、それがどの硬貨であるかを判断し、セントでの価値を返す関数を書けます。例を以下に示します。

```rust
1 enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
  2 match coin {
      3 Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

リスト 6-3：列挙型と、列挙型のバリアントをパターンとする「マッチ」式

`value_in_cents`関数内の「マッチ」を分解してみましょう。まず、「マッチ」キーワードの後に式を列挙します。この場合、それは値`coin`です\[2\]。これは`if`で使用される式に非常に似ていますが、大きな違いがあります。`if`の場合、式はブール値を返す必要がありますが、ここでは任意の型を返すことができます。この例での`coin`の型は、\[1\]で定義した`Coin`列挙型です。

次に「マッチ」のアームです。アームには 2 つの部分があります。パターンとコードです。ここで最初のアームは、パターンが値`Coin::Penny`で、その後にパターンと実行するコードを区切る`=>`演算子です\[3\]。この場合のコードはただの値`1`です。各アームはコンマで区切られています。

「マッチ」式が実行されると、結果の値が順に各アームのパターンと比較されます。パターンが値と一致すると、そのパターンに関連付けられたコードが実行されます。そのパターンが値と一致しない場合、実行は次のアームに続きます。コイン分類機と同じです。必要なだけのアームを持つことができます。リスト 6-3 では、「マッチ」には 4 つのアームがあります。

各アームに関連付けられたコードは式であり、一致するアーム内の式の結果の値は、全体の「マッチ」式に戻される値です。

アームのコードが短い場合、通常は波括弧を使いません。リスト 6-3 のように、各アームがただの値を返す場合です。マッチのアームで複数行のコードを実行したい場合は、波括弧を使う必要があり、その後のコンマは省略可能です。たとえば、次のコードは、メソッドが`Coin::Penny`で呼び出されるたびに「幸運な 1 セント硬貨！」と表示しますが、ブロックの最後の値`1`を返します。

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
