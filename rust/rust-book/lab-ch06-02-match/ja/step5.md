# 全てをキャッチするパターンとアンダースコア（\_）プレースホルダ

列挙型を使うことで、いくつかの特定の値に対して特別なアクションを実行することもできますが、それ以外のすべての値に対しては 1 つのデフォルトのアクションを実行します。あるゲームを実装していると想像してみましょう。サイコロを振って出た目が 3 の場合、プレイヤーは動かず、代わりに新しい素敵な帽子を手に入れます。出た目が 7 の場合、プレイヤーは素敵な帽子を失います。それ以外のすべての値の場合、プレイヤーはゲーム盤上をその数だけ移動します。ここにそのロジックを実装した`match`があります。サイコロの目はランダムな値ではなくハードコードされており、この例の範囲外なので、他のロジックは本体のない関数で表されています。

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
  1 other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

最初の 2 つのアームでは、パターンはリテラル値の`3`と`7`です。他のすべての可能な値をカバーする最後のアームでは、パターンは`other`と名付けた変数です\[1\]。`other`のアームで実行されるコードは、その変数を`move_player`関数に渡すことで使用します。

このコードはコンパイルされます。`u8`が持り得るすべての可能な値を列挙していなくてもです。なぜなら、最後のパターンが明示的に列挙されていないすべての値に一致するからです。この全てをキャッチするパターンは、`match`が網羅的である必要があるという要件を満たしています。全てをキャッチするアームは最後に置かなければならないことに注意してください。なぜなら、パターンは順に評価されるからです。全てをキャッチするアームをより前に置くと、他のアームは決して実行されなくなります。したがって、全てをキャッチするアームの後にアームを追加すると、Rust が警告します！

Rust には、全てをキャッチする必要があるが、全てをキャッチするパターンの値を使わない場合に使用できるパターンもあります。`_`は特別なパターンで、どんな値にも一致し、その値にバインドされません。これは、私たちがその値を使わないことを Rust に伝えるもので、そのため Rust は未使用の変数に関する警告を出さなくなります。

ゲームのルールを変更しましょう。今では、3 または 7 以外の目を出した場合、もう一度振る必要があります。これ以上全てをキャッチする値を使う必要がないので、コードを変更して、`other`という変数の代わりに`_`を使うことができます。

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

この例も網羅性の要件を満たしています。なぜなら、最後のアームで明示的に他のすべての値を無視しているからです。何かを忘れているわけではありません。

最後に、ゲームのルールをもう一度変更します。3 または 7 以外の目を出した場合、そのターンでは何も起こらなくなります。これを表現するには、`_`のアームに付随するコードとしてユニット値（「タプル型」で触れた空のタプル型）を使うことができます。

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

ここでは、Rust に明示的に、より前のアームのパターンに一致しない他の値を使わないこと、そしてこの場合には何のコードも実行したくないことを伝えています。

18 章では、パターンとマッチングに関するさらに多くの内容を扱います。今のところ、`match`式が少々長々しい場合に便利な`if let`構文に移ります。
