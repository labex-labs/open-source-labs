# `Option<T>` とのマッチング

前節では、`Option<T>` を使用する際に `Some` の場合の内部の `T` 値を取り出したかったのですが、`Coin` 列挙型と同じように、`match` を使って `Option<T>` を処理することもできます！コインを比較する代わりに、`Option<T>` のバリアントを比較しますが、`match` 式の動作方法は同じです。

`Option<i32>` を受け取り、内部に値があればその値に 1 を加える関数を書きたいとしましょう。内部に値がなければ、関数は `None` 値を返し、何らかの操作を行おうとしないようにします。

この関数は `match` のおかげで非常に簡単に書けます。リスト 6-5 のようになります。

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
      1 None => None,
      2 Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five); 3
let none = plus_one(None); 4
```

リスト 6-5：`Option<i32>` で `match` 式を使用する関数

`plus_one` の最初の実行をもう少し詳細に見てみましょう。`plus_one(five)` \[3\] を呼び出すと、`plus_one` の本体の変数 `x` には `Some(5)` の値が入ります。そして、それを各マッチのアームと比較します。

```rust
None => None,
```

`Some(5)` の値はパターン `None` \[1\] と一致しませんので、次のアームに進みます。

```rust
Some(i) => Some(i + 1),
```

`Some(5)` は `Some(i)` \[2\] と一致しますか？そうです、一致します！同じバリアントです。`i` は `Some` に含まれる値にバインドされるので、`i` には値 `5` が入ります。そして、マッチのアームのコードが実行されるので、`i` の値に 1 を加えて、合計 `6` を含む新しい `Some` 値を作成します。

次に、リスト 6-5 の `plus_one` の 2 番目の呼び出しを考えてみましょう。この場合、`x` は `None` \[4\] です。`match` に入り、最初のアーム \[1\] と比較します。

一致します！加える値がないので、プログラムは停止して、`=>` の右辺の `None` 値を返します。最初のアームが一致したので、他のアームは比較されません。

`match` と列挙型を組み合わせると、多くの状況で役立ちます。Rust のコードではこのパターンがよく見られます。列挙型に対して `match` し、内部のデータに変数をバインドし、それに基づいてコードを実行します。最初は少し慣れにくいかもしれませんが、慣れると、すべての言語にこれがあったらいいなと思うようになります。これは一貫してユーザーに人気があります。
