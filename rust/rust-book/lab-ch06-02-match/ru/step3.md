# Сопоставление с `Option`<T>`{=html}`

В предыдущем разделе мы хотели извлечь внутреннее значение `T` из случая `Some`, когда использовали `Option<T>`; мы также можем обрабатывать `Option<T>` с использованием `match`, как мы это делали с перечислением `Coin`! Вместо сравнения монет мы будем сравнивать варианты `Option<T>`, но принцип работы выражения `match` остается тем же.

Допустим, мы хотим написать функцию, которая принимает `Option<i32>` и, если внутри есть значение, добавляет 1 к этому значению. Если внутри нет значения, функция должна вернуть значение `None` и не пытаться выполнять никакие операции.

Эта функция очень проста в написании благодаря `match` и будет выглядеть как в Listing 6-5.

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
      1 None => None,
      2 Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five); 3
let none = plus_one(None); 4
```

Listing 6-5: Функция, которая использует выражение `match` для `Option<i32>`

Давайте более подробно рассмотрим первый вызов `plus_one`. Когда мы вызываем `plus_one(five)` \[3\], переменная `x` в теле `plus_one` будет иметь значение `Some(5)`. Затем мы сравниваем это со всеми ветвями `match`:

```rust
None => None,
```

Значение `Some(5)` не соответствует шаблону `None` \[1\], поэтому мы продолжаем до следующей ветви:

```rust
Some(i) => Some(i + 1),
```

Совпадает ли `Some(5)` с `Some(i)` \[2\]? Да, совпадает! У нас один и тот же вариант. Переменная `i` связывается с значением, содержащимся в `Some`, поэтому `i` получает значение `5`. Затем выполняется код в ветви `match`, поэтому мы добавляем 1 к значению `i` и создаем новое значение `Some` с нашим общим значением `6` внутри.

Теперь рассмотрим второй вызов `plus_one` в Listing 6-5, где `x` равно `None` \[4\]. Мы заходим в `match` и сравниваем с первой ветвью \[1\].

Она совпадает! Нет значения, к которому можно было бы добавить что-то, поэтому программа останавливается и возвращает значение `None` справа от `=>`. Поскольку первая ветвь совпала, другие ветви не сравниваются.

Комбинация `match` и перечислений полезна во многих ситуациях. Вы увидите этот паттерн очень часто в коде на Rust: сопоставление с перечислением, связывание переменной с данными внутри и затем выполнение кода на основе них. Сначала это может показаться немного запутанным, но когда вы привыкнете к нему, вы пожелаете, чтобы его было во всех языках. Это постоянно нравится пользователям.
