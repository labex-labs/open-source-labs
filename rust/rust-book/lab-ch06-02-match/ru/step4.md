# Сопоставления должны быть исчерпывающими

Есть еще один аспект `match`, о котором нам нужно поговорить: шаблоны ветвей должны охватывать все возможные случаи. Рассмотрим эту версию нашей функции `plus_one`, которая содержит ошибку и не скомпилируется:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

Мы не обработали случай `None`, поэтому этот код вызовет ошибку. К счастью, это ошибка, которую Rust умеет обнаруживать. Если мы попытаемся скомпилировать этот код, мы получим эту ошибку:

```bash
error[E0004]: non-exhaustive patterns: `None` not covered
 --> src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  note: `Option<i32>` defined here
      = note: the matched value is of type `Option<i32>`
help: ensure that all possible cases are being handled by adding
a match arm with a wildcard pattern or an explicit pattern as
shown
    |
4   ~             Some(i) => Some(i + 1),
5   ~             None => todo!(),
    |
```

Rust знает, что мы не охватили каждый возможный случай и даже знает, какой шаблон мы забыли! Сопоставления в Rust являются _исчерпывающими_: мы должны исчерпать каждую последнюю возможность, чтобы код был валидным. Особенно в случае `Option<T>`, когда Rust не позволяет нам забыть явно обработать случай `None`, он защищает нас от того, чтобы предполагать, что у нас есть значение, когда может быть `null`, тем самым сделав невозможной ошибку, обсужденную ранее.
