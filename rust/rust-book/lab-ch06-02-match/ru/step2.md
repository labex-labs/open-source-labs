# Паттерны, которые связываются с значениями

Еще один полезный признак ветвей `match` заключается в том, что они могут связываться с частями значений, которые соответствуют шаблону. Именно так мы можем извлекать значения из вариантов перечисления.

В качестве примера давайте изменим один из вариантов нашего перечисления так, чтобы он содержал внутри себя данные. С 1999 по 2008 годы в Соединенных Штатах выпускались 25-центные монеты с разными дизайнами для каждой из 50 штатов с одной стороны. Другие монеты не имели государственных дизайнов, поэтому только 25-центные монеты имеют это дополнительное значение. Мы можем добавить эту информацию в наше `enum`, изменив вариант `Quarter` так, чтобы он включал значение `UsState`, хранящееся внутри него, что мы сделали в Listing 6-4.

```rust
#[derive(Debug)] // чтобы мы могли проверить состояние через минуту
enum UsState {
    Alabama,
    Alaska,
    --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

Listing 6-4: Перечисление `Coin`, в котором вариант `Quarter` также хранит значение `UsState`

Представьте, что друг пытается собрать все 50 государственных 25-центных монет. Во время сортировки наших мелких монет по типу монеты мы также вызовем название штата, связанного с каждой 25-центной монетой, чтобы если это монета, которой у друга нет, они могли добавить ее в свою коллекцию.

В выражении `match` для этого кода мы добавляем переменную под названием `state` в шаблон, который соответствует значениям варианта `Coin::Quarter`. Когда `Coin::Quarter` совпадает, переменная `state` будет связана с значением штата этой 25-центной монеты. Затем мы можем использовать `state` в коде для этой ветви, вот так:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

Если мы вызовем `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin` будет равным `Coin::Quarter(UsState::Alaska)`. Когда мы сравниваем это значение с каждой из ветвей `match`, ни одна из них не совпадает, пока мы не дойдем до `Coin::Quarter(state)`. В этот момент связывание для `state` будет иметь значение `UsState::Alaska`. Затем мы можем использовать это связывание в выражении `println!`, таким образом извлекая внутреннее значение штата из варианта перечисления `Coin` для `Quarter`.
