# `match` 控制流结构

Rust 有一个极其强大的控制流结构，称为 `match`，它允许你将一个值与一系列模式进行比较，然后根据匹配的模式执行代码。模式可以由字面值、变量名、通配符等组成；第 18 章涵盖了所有不同类型的模式及其作用。`match` 的强大之处在于模式的表现力以及编译器会确认所有可能的情况都得到了处理。

可以将 `match` 表达式想象成一台硬币分类机：硬币沿着一条有各种大小孔洞的轨道下滑，每枚硬币会落入它遇到的第一个能容纳它的孔洞。同样地，值会在 `match` 中逐个通过每个模式，当值“适合”第一个模式时，它就会落入相关的代码块中，以便在执行期间使用。

说到硬币，让我们以硬币为例来使用 `match`！我们可以编写一个函数，它接受一枚未知的美国硬币，并以类似于计数机的方式确定它是哪种硬币，并返回其以美分为单位的价值，如清单 6-3 所示。

```rust
1 enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
  2 match coin {
      3 Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

清单 6-3：一个枚举和一个 `match` 表达式，该表达式将枚举的变体用作其模式

让我们来剖析一下 `value_in_cents` 函数中的 `match`。首先，我们列出 `match` 关键字，后面跟着一个表达式，在这个例子中是值 `coin` \[2\]。这看起来与用于 `if` 的表达式非常相似，但有一个很大的区别：对于 `if`，表达式需要返回一个布尔值，但在这里它可以返回任何类型。在这个例子中，`coin` 的类型是我们在 \[1\] 处定义的 `Coin` 枚举。

接下来是 `match` 分支。一个分支有两部分：一个模式和一些代码。这里的第一个分支的模式是值 `Coin::Penny`，然后是分隔模式和要运行的代码的 `=>` 运算符 \[3\]。在这种情况下，代码只是值 `1`。每个分支用逗号与下一个分支隔开。

当 `match` 表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果一个模式与值匹配，与该模式相关联的代码就会被执行。如果该模式与值不匹配，执行会继续到下一个分支，就像在硬币分类机中一样。我们可以根据需要拥有任意数量的分支：在清单 6-3 中，我们的 `match` 有四个分支。

与每个分支相关联的代码是一个表达式，匹配分支中表达式的结果值就是整个 `match` 表达式返回的值。

如果 `match` 分支代码很短，我们通常不使用花括号，就像清单 6-3 中每个分支只返回一个值那样。如果你想在 `match` 分支中运行多行代码，就必须使用花括号，并且分支后面的逗号是可选的。例如，以下代码在每次使用 `Coin::Penny` 调用该方法时都会打印“幸运便士！”，但仍然返回块的最后一个值 `1`：

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
