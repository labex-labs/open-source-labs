# 通配模式与 `_` 占位符

使用枚举时，我们还可以针对几个特定值采取特殊操作，而对所有其他值采取一个默认操作。想象一下我们正在实现一个游戏，如果你掷骰子掷出 3，你的玩家不会移动，而是会得到一顶新的漂亮帽子。如果你掷出 7，你的玩家会失去一顶漂亮帽子。对于所有其他值，你的玩家会在游戏板上移动相应数量的格子。下面是一个实现该逻辑的 `match`，其中骰子掷出的结果是硬编码的，而不是随机值，并且所有其他逻辑由没有函数体的函数表示，因为实际实现它们超出了本示例的范围：

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
  1 other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

对于前两个分支，模式是字面值 `3` 和 `7`。对于涵盖所有其他可能值的最后一个分支，模式是我们选择命名为 `other` 的变量 \[1\]。为 `other` 分支运行的代码通过将变量传递给 `move_player` 函数来使用该变量。

这段代码可以编译，尽管我们没有列出 `u8` 可能具有的所有可能值，因为最后一个模式将匹配所有未明确列出的值。这种通配模式满足了 `match` 必须穷举所有情况的要求。请注意，我们必须将通配分支放在最后，因为模式是按顺序求值的。如果我们将通配分支放在前面，其他分支将永远不会运行，所以如果我们在通配分支之后添加分支，Rust 会警告我们！

当我们想要一个通配模式但又不想在通配模式中使用该值时，Rust 还有一个模式可供我们使用：`_` 是一个特殊模式，它匹配任何值，但不会绑定到该值。这告诉 Rust 我们不会使用该值，所以 Rust 不会因未使用变量而警告我们。

让我们更改游戏规则：现在，如果你掷出的不是 3 或 7，你必须再次掷骰子。我们不再需要使用通配值，所以我们可以将代码更改为使用 `_` 而不是名为 `other` 的变量：

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
```

这个示例也满足穷举性要求，因为我们在最后一个分支中明确忽略了所有其他值；我们没有遗漏任何东西。

最后，我们再更改一次游戏规则，这样如果你掷出的不是 3 或 7，在你的回合中就不会发生其他任何事情。我们可以通过使用单元值（我们在“元组类型”中提到的空元组类型）作为与 `_` 分支相关联的代码来表达这一点：

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

在这里，我们明确告诉 Rust，我们不会使用任何与前面分支中的模式不匹配的其他值，并且在这种情况下我们不想运行任何代码。

关于模式和匹配，我们将在第 18 章中介绍更多内容。现在，我们将继续介绍 `if let` 语法，它在 `match` 表达式有点冗长的情况下可能会很有用。
