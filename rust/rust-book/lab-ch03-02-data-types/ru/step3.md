# Целочисленные типы

_Целое число_ (integer) — это число без дробной части. Мы использовали один целочисленный тип в главе 2, тип `u32`. Это объявление типа указывает, что связанное с ним значение должно быть беззнаковым целым числом (знаковые целочисленные типы начинаются с `i` вместо `u`), которое занимает 32 бита. В таблице 3-1 показаны встроенные целочисленные типы в Rust. Мы можем использовать любой из этих вариантов для объявления типа целочисленного значения.

Таблица 3-1: Целочисленные типы в Rust

Длина Знаковый Беззнаковый

---

8-битный `i8` `u8`
16-битный `i16` `u16`
32-битный `i32` `u32`
64-битный `i64` `u64`
128-битный `i128` `u128`
arch `isize` `usize`

Каждый вариант может быть знаковым или беззнаковым и имеет явный размер. _Знаковый_ (signed) и _беззнаковый_ (unsigned) относятся к тому, может ли число быть отрицательным — другими словами, нужно ли числу иметь знак (знаковый) или оно всегда будет положительным и, следовательно, может быть представлено без знака (беззнаковый). Это как писать числа на бумаге: когда знак имеет значение, число отображается со знаком плюс или минус; однако, когда можно предположить, что число положительное, оно отображается без знака. Знаковые числа хранятся с использованием представления в дополнительном коде (two's complement).

Каждый знаковый вариант может хранить числа от -(2^(n-1)) до 2^(n-1) - 1 включительно, где _n_ — это количество бит, которое использует этот вариант. Таким образом, `i8` может хранить числа от -(2^7) до 2^7 - 1, что равно от -128 до 127. Беззнаковые варианты могут хранить числа от 0 до 2^n - 1, поэтому `u8` может хранить числа от 0 до 2^8 - 1, что равно от 0 до 255.

Кроме того, типы `isize` и `usize` зависят от архитектуры компьютера, на котором работает ваша программа, что обозначено в таблице как "arch": 64 бита, если вы работаете на 64-битной архитектуре, и 32 бита, если вы работаете на 32-битной архитектуре.

Вы можете записывать целочисленные литералы в любой из форм, показанных в таблице 3-2. Обратите внимание, что числовые литералы, которые могут быть нескольких числовых типов, допускают суффикс типа, например `57u8`, для обозначения типа. Числовые литералы также могут использовать `_` в качестве визуального разделителя, чтобы число было легче читать, например `1_000`, которое будет иметь то же значение, что и при указании `1000`.

Таблица 3-2: Целочисленные литералы в Rust

Числовые литералы Пример

---

Десятичный `98_222`
Шестнадцатеричный `0xff`
Восьмеричный `0o77`
Двоичный `0b1111_0000`
Байт (только `u8`) `b'A'`

Итак, как узнать, какой тип целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, хорошее место для начала: целочисленные типы по умолчанию — `i32`. Основная ситуация, в которой вы будете использовать `isize` или `usize`, — это при индексировании какой-либо коллекции.

> **Переполнение целых чисел** (Integer Overflow)
>
> Допустим, у вас есть переменная типа `u8`, которая может хранить значения от 0 до 255. Если вы попытаетесь изменить переменную на значение вне этого диапазона, например, 256, произойдет _переполнение целого числа_ (integer overflow), что может привести к одному из двух вариантов поведения. При компиляции в режиме отладки Rust включает проверки переполнения целых чисел, которые заставляют вашу программу _паниковать_ (panic) во время выполнения, если это поведение происходит. Rust использует термин _паника_ (panicking), когда программа завершается с ошибкой; мы обсудим паники более подробно в разделе "Невосстановимые ошибки с panic!".
>
> При компиляции в режиме release с флагом `--release` Rust _не_ включает проверки переполнения целых чисел, которые вызывают панику. Вместо этого, если происходит переполнение, Rust выполняет _заворачивание в дополнительном коде_ (two's complement wrapping). Короче говоря, значения, превышающие максимальное значение, которое может хранить тип, "заворачиваются" до минимума значений, которые может хранить тип. В случае с `u8` значение 256 становится 0, значение 257 становится 1 и так далее. Программа не будет паниковать, но переменная будет иметь значение, которое, вероятно, не то, которое вы ожидали. Опора на поведение заворачивания при переполнении целых чисел считается ошибкой.
>
> Чтобы явно обработать возможность переполнения, вы можете использовать следующие семейства методов, предоставляемых стандартной библиотекой для примитивных числовых типов:
>
> - Заворачивание во всех режимах с методами `wrapping_*`, такими как `wrapping_add`.
> - Возврат значения `None`, если произошло переполнение, с методами `checked_*`.
> - Возврат значения и логического значения, указывающего, было ли переполнение, с методами `overflowing_*`.
> - Насыщение до минимальных или максимальных значений значения с методами `saturating_*`.
