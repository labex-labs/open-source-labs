# Целые типы

_Целое число_ - это число без дробной части. В главе 2 мы использовали один целый тип, тип `u32`. Это объявление типа указывает, что значение, с которым оно ассоциировано, должно быть неотрицательным целым числом (знаковые целые типы начинаются с `i` вместо `u`) и занимает 32 бита памяти. В таблице 3-1 показаны встроенные целые типы в Rust. Мы можем использовать любую из этих вариантов для объявления типа целочисленного значения.

Таблица 3-1: Целые типы в Rust

Размер Знаковый Незаковый

---

8-битный `i8` `u8`
16-битный `i16` `u16`
32-битный `i32` `u32`
64-битный `i64` `u64`
128-битный `i128` `u128`
архитектура `isize` `usize`

Каждый вариант может быть как знаковым, так и незнаковым и имеет явный размер. _Знаковые_ и _незнаковые_ означают, может ли число быть отрицательным - другими словами, нужно ли у числа быть знак (знаковый) или оно будет только положительным и поэтому может быть представлено без знака (незнаковый). Это похоже на запись чисел на бумаге: когда знак имеет значение, число записывается с плюс или минус знаком; однако, когда можно безопасно предположить, что число положительное, оно записывается без знака. Знаковые числа хранятся в виде дополнительной кодной записи.

Каждый знаковый вариант может хранить числа от -(2`<sup>`{=html}n - 1`</sup>`{=html}) до 2`<sup>`{=html}n - 1`</sup>`{=html} включительно, где _n_ - количество бит, которое использует этот вариант. Таким образом, `i8` может хранить числа от -(2`<sup>`{=html}7`</sup>`{=html}) до 2`<sup>`{=html}7`</sup>`{=html} - 1, то есть от -128 до 127. Незнаковые варианты могут хранить числа от 0 до 2`<sup>`{=html}n`</sup>`{=html} - 1, поэтому `u8` может хранить числа от 0 до 2`<sup>`{=html}8`</sup>`{=html} - 1, то есть от 0 до 255.

此外，`isize` и `usize` типы зависят от архитектуры компьютера, на котором запускается ваша программа, что обозначено в таблице как "архитектура": 64 бита, если вы работаете на 64-разрядной архитектуре, и 32 бита, если вы работаете на 32-разрядной архитектуре.

Вы можете записывать целые литералы в любом из форм, показанных в таблице 3-2. Обратите внимание, что литералы чисел, которые могут быть нескольких числовых типов, допускают суффикс типа, например, `57u8`, чтобы указать тип. Литералы чисел также могут использовать `_` в качестве визуального разделителя, чтобы сделать число легче читать, например, `1_000`, которое будет иметь то же значение, что и `1000`.

Таблица 3-2: Целые литералы в Rust

Литералы чисел Пример

---

Десятичные `98_222`
Шестнадцатеричные `0xff`
Восьмеричные `0o77`
Двоичные `0b1111_0000`
Байтовые (`только u8`) `b'A'`

Итак, как вы знаете, какой тип целого числа использовать? Если вы не уверены, по умолчанию в Rust обычно можно начать с: целые типы по умолчанию - это `i32`. Основная ситуация, когда вы будете использовать `isize` или `usize`, - это когда индексируете какую-то коллекцию.

> **Переполнение целых чисел**
>
> Предположим, у вас есть переменная типа `u8`, которая может хранить значения от 0 до 255. Если вы попытаетесь изменить переменную на значение за пределами этого диапазона, например, 256, произойдет _переполнение целого числа_, что может привести к одному из двух поведений. Когда вы компилируете в режиме отладки, Rust включает проверки на переполнение целых чисел, которые заставляют вашу программу _падать_ во время выполнения, если такое поведение происходит. Rust использует термин _падение_, когда программа завершается с ошибкой; мы поговорим о падениях более подробно в разделе "Невосстанавливаемые ошибки с panic!".
>
> Когда вы компилируете в режиме релиза с флагом `--release`, Rust _не_ включает проверки на переполнение целых чисел, которые вызывают падения. Вместо этого, если происходит переполнение, Rust выполняет _дополнительную кодовую запись с оберткой_. Короче говоря, значения, большие максимального значения, которое может хранить тип, "оборачиваются" до минимального значения, которое может хранить тип. В случае с `u8`, значение 256 становится 0, значение 257 становится 1 и так далее. Программа не будет падать, но переменная будет иметь значение, которое, вероятно, не будет тем, что вы ожидали. Полагаться на поведение обертки при переполнении целых чисел считается ошибкой.
>
> Чтобы явно обработать возможность переполнения, вы можете использовать эти семейства методов, предоставляемых стандартной библиотекой для примитивных числовых типов:
>
> - Обернуть в всех режимах с методами `wrapping_*`, например, `wrapping_add`.
> - Вернуть значение `None`, если произошло переполнение, с методами `checked_*`.
> - Вернуть значение и булево значение, указывающее, было ли переполнение, с методами `overflowing_*`.
> - Начать срабатывать на минимальном или максимальном значении значения с методами `saturating_*`.
