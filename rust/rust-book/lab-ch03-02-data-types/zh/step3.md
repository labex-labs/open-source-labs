# 整数类型

整数是没有小数部分的数字。在第 2 章中，我们使用了一种整数类型 `u32`。这种类型声明表示与之关联的值应该是一个无符号整数（有符号整数类型以 `i` 开头，而不是 `u`），它占用 32 位空间。表 3-1 展示了 Rust 中的内置整数类型。我们可以使用这些变体中的任何一个来声明整数值的类型。

表 3-1：Rust 中的整数类型

| 长度       | 有符号  | 无符号  |
| ---------- | ------- | ------- |
| 8 位       | `i8`    | `u8`    |
| 16 位      | `i16`   | `u16`   |
| 32 位      | `i32`   | `u32`   |
| 64 位      | `i64`   | `u64`   |
| 128 位     | `i128`  | `u128`  |
| 取决于架构 | `isize` | `usize` |

每个变体既可以是有符号的，也可以是无符号的，并且具有明确的大小。“有符号”和“无符号”指的是数字是否可能为负数——换句话说，数字是否需要带有符号（有符号），或者它是否只会是正数，因此可以不带符号表示（无符号）。这就像在纸上写数字：当符号重要时，数字会带有加号或减号；然而，当可以安全地假设数字为正数时，它就不带符号显示。有符号数字使用补码表示法存储。

每个有符号变体可以存储从 -(2`<sup>`{=html}n - 1`</sup>`{=html}) 到 2`<sup>`{=html}n - 1`</sup>`{=html} - 1（包括两端）的数字，其中 _n_ 是该变体使用的位数。所以 `i8` 可以存储从 -(2`<sup>`{=html}7`</sup>`{=html}) 到 2`<sup>`{=html}7`</sup>`{=html} - 1 的数字，即 -128 到 127。无符号变体可以存储从 0 到 2`<sup>`{=html}n`</sup>`{=html} - 1 的数字，所以 `u8` 可以存储从 0 到 2`<sup>`{=html}8`</sup>`{=html} - 1 的数字，即 0 到 255。

此外，`isize` 和 `usize` 类型取决于程序运行所在计算机的架构，在表中表示为“取决于架构”：如果是在 64 位架构上，就是 64 位；如果是在 32 位架构上，就是 32 位。

你可以使用表 3-2 中所示的任何形式编写整数字面量。请注意，可能是多种数字类型的数字字面量允许使用类型后缀，例如 `57u8` 来指定类型。数字字面量也可以使用 `_` 作为视觉分隔符，使数字更易于阅读，例如 `1_000`，它与指定 `1000` 具有相同的值。

表 3-2：Rust 中的整数字面量

| 数字字面量            | 示例          |
| --------------------- | ------------- |
| 十进制                | `98_222`      |
| 十六进制              | `0xff`        |
| 八进制                | `0o77`        |
| 二进制                | `0b1111_0000` |
| 字节（仅适用于 `u8`） | `b'A'`        |

那么如何知道该使用哪种整数类型呢？如果你不确定，Rust 的默认设置通常是一个好的起点：整数类型默认为 `i32`。你使用 `isize` 或 `usize` 的主要情况是在对某种集合进行索引时。

> **整数溢出**
>
> 假设你有一个 `u8` 类型的变量，它可以存储 0 到 255 之间的值。如果你试图将变量更改为该范围之外的值，例如 256，就会发生**整数溢出**，这可能会导致两种行为之一。当你在调试模式下编译时，Rust 会包含对整数溢出的检查，如果发生这种行为，会导致程序在运行时**恐慌**。当程序因错误而退出时，Rust 使用术语“恐慌”；我们将在“使用 `panic!` 处理不可恢复的错误”中更深入地讨论恐慌。
>
> 当你使用 `--release` 标志在发布模式下编译时，Rust 不会包含导致恐慌的整数溢出检查。相反，如果发生溢出，Rust 会执行**补码环绕**。简而言之，大于该类型所能容纳的最大值的值会“环绕”到该类型所能容纳的最小值。对于 `u8` 类型，值 256 变为 0，值 257 变为 1，依此类推。程序不会恐慌，但变量的值可能不是你期望的。依赖整数溢出的环绕行为被认为是一个错误。
>
> 为了显式处理溢出的可能性，你可以使用标准库为原始数字类型提供的这些方法家族：
>
> - 使用 `wrapping_*` 方法在所有模式下进行环绕，例如 `wrapping_add`。
> - 使用 `checked_*` 方法在发生溢出时返回 `None` 值。
> - 使用 `overflowing_*` 方法返回值以及一个指示是否发生溢出的布尔值。
> - 使用 `saturating_*` 方法在值的最小值或最大值处饱和。
