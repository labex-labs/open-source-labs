# 整数型

整数は、小数部分のない数です。第 2 章では、`u32`型という 1 つの整数型を使用しました。この型宣言は、それに関連付けられた値が符号なし整数（符号付き整数型は`i`から始まり、`u`ではありません）であり、32 ビットの空間を占めることを示しています。表 3-1 には、Rust における組み込みの整数型が示されています。整数値の型を宣言する際には、これらのどのバリアントを使っても構いません。

表 3-1：Rust における整数型

| サイズ             | 符号付き | 符号なし |
| ------------------ | -------- | -------- |
| 8 ビット           | `i8`     | `u8`     |
| 16 ビット          | `i16`    | `u16`    |
| 32 ビット          | `i32`    | `u32`    |
| 64 ビット          | `i64`    | `u64`    |
| 128 ビット         | `i128`   | `u128`   |
| アーキテクチャ固有 | `isize`  | `usize`  |

各バリアントは符号付きまたは符号なしのどちらかで、明示的なサイズを持っています。「符号付き」と「符号なし」は、数が負になる可能性があるかどうかを指します。言い換えると、数に符号を付ける必要があるか（符号付き）、それとも常に正であり、したがって符号なしで表現できるか（符号なし）を意味します。紙に数を書くのと同じです。符号が重要な場合、数にはプラス記号またはマイナス記号が付きます。ただし、数が正であると安全に仮定できる場合、符号なしで表示されます。符号付きの数は、2 の補数表現を使用して格納されます。

各符号付きバリアントは、-(2`<sup>`{=html}n - 1`</sup>`{=html}) から 2`<sup>`{=html}n - 1`</sup>`{=html} - 1 まで（`n`はそのバリアントが使用するビット数）の数を格納できます。したがって、`i8`は-(2`<sup>`{=html}7`</sup>`{=html}) から 2`<sup>`{=html}7`</sup>`{=html} - 1 までの数を格納でき、これは -128 から 127 に相当します。符号なしのバリアントは、0 から 2`<sup>`{=html}n`</sup>`{=html} - 1 までの数を格納できるため、`u8`は 0 から 2`<sup>`{=html}8`</sup>`{=html} - 1 までの数を格納でき、これは 0 から 255 に相当します。

また、`isize`型と`usize`型は、プログラムが実行されているコンピュータのアーキテクチャに依存します。これは表では「アーキテクチャ固有」と表示されています。64 ビットアーキテクチャの場合、64 ビットで、32 ビットアーキテクチャの場合、32 ビットです。

整数リテラルは、表 3-2 に示すいずれかの形式で書くことができます。複数の数値型になり得る数値リテラルには、型サフィックス（たとえば`57u8`）を指定して型を指定できます。数値リテラルでは、数を読みやすくするために`_`を視覚的な区切り文字として使用することもできます。たとえば`1_000`は、`1000`を指定した場合と同じ値になります。

表 3-2：Rust における整数リテラル

| 数値リテラル       | 例            |
| ------------------ | ------------- |
| 10 進数            | `98_222`      |
| 16 進数            | `0xff`        |
| 8 進数             | `0o77`        |
| 2 進数             | `0b1111_0000` |
| バイト（`u8`のみ） | `b'A'`        |

では、どのような整数型を使用するかをどのように判断すればよいでしょうか。もし不確かな場合は、Rust のデフォルトが一般的に良い出発点になります。整数型のデフォルトは`i32`です。`isize`または`usize`を使用する主なケースは、ある種のコレクションをインデックス付けする場合です。

> **整数オーバーフロー**
>
> 0 から 255 までの値を保持できる`u8`型の変数があるとします。この変数を 256 などの範囲外の値に変更しようとすると、「整数オーバーフロー」が発生し、2 つの動作のいずれかが起こります。デバッグモードでコンパイルする場合、Rust は整数オーバーフローのチェックを含み、このような動作が発生した場合、実行時にプログラムがパニックになります。Rust は、エラーでプログラムが終了する場合を「パニックになる」と呼んでいます。「panic! による回復不可能なエラー」で詳しく説明します。
>
> `--release`フラグを付けてリリースモードでコンパイルする場合、Rust はパニックになる整数オーバーフローのチェックを含みません。代わりに、オーバーフローが発生した場合、Rust は 2 の補数ラップアラウンドを行います。簡単に言えば、型が保持できる最大値を超える値は、型が保持できる最小値に「巻き戻され」ます。`u8`の場合、値 256 は 0 になり、値 257 は 1 になり、その他も同様です。プログラムはパニックにならず、ただし変数の値はおそらく期待していた値とは異なります。整数オーバーフローのラップアラウンド動作を依存することはエラーと考えられます。
>
> オーバーフローの可能性を明示的に処理するには、標準ライブラリがプリミティブな数値型に提供するこれらのメソッドのファミリーを使用できます。
>
> - すべてのモードで`wrapping_*`メソッド（たとえば`wrapping_add`）でラップする。
> - `checked_*`メソッドでオーバーフローが発生した場合は`None`値を返す。
> - `overflowing_*`メソッドで値とオーバーフローが発生したかどうかを示すブール値を返す。
> - `saturating_*`メソッドで値の最小値または最大値で飽和させる。
