# 整数型

*整数*とは、小数部分を持たない数値のことです。第 2 章では、`u32`型という整数型を使用しました。この型宣言は、関連付けられた値が符号なし整数（符号付き整数型は`u`ではなく`i`で始まります）であり、32 ビットの空間を占める必要があることを示しています。表 3-1 は、Rust の組み込み整数型を示しています。これらのバリアントのいずれかを使用して、整数値の型を宣言できます。

表 3-1：Rust の整数型

長さ 符号付き 符号なし

---

8 ビット `i8` `u8`
16 ビット `i16` `u16`
32 ビット `i32` `u32`
64 ビット `i64` `u64`
128 ビット `i128` `u128`
arch `isize` `usize`

各バリアントは、符号付きまたは符号なしのいずれかであり、明示的なサイズを持っています。*符号付き*と*符号なし*は、数値が負になる可能性があるかどうか、つまり、数値に符号が必要かどうか（符号付き）または常に正であり、符号なしで表現できるかどうか（符号なし）を指します。これは、紙に数字を書くようなものです。符号が重要な場合は、数字はプラス記号またはマイナス記号で示されます。ただし、数字が正であると安全に仮定できる場合は、符号なしで表示されます。符号付き数値は、2 の補数表現を使用して格納されます。

各符号付きバリアントは、-(2^(n-1)) から 2^(n-1) - 1（両端を含む）までの数値を格納できます。ここで、*n*は、そのバリアントが使用するビット数です。したがって、`i8`は-(2^7) から 2^7 - 1、つまり -128 から 127 までの数値を格納できます。符号なしバリアントは、0 から 2^n - 1 までの数値を格納できます。したがって、`u8`は 0 から 2^8 - 1、つまり 0 から 255 までの数値を格納できます。

さらに、`isize`型と`usize`型は、プログラムが実行されているコンピューターのアーキテクチャに依存します。これは、表で「arch」として示されています。64 ビットアーキテクチャの場合は 64 ビット、32 ビットアーキテクチャの場合は 32 ビットです。

整数リテラルは、表 3-2 に示す形式のいずれかで記述できます。複数の数値型が可能な数値リテラルは、型を指定するための`57u8`のような型サフィックスを使用できることに注意してください。数値リテラルは、`1_000`のように、数値を読みやすくするために視覚的な区切り文字として`_`を使用することもできます。これは、`1000`を指定した場合と同じ値になります。

表 3-2：Rust の整数リテラル

数値リテラル 例

---

10 進数 `98_222`
16 進数 `0xff`
8 進数 `0o77`
2 進数 `0b1111_0000`
バイト（`u8`のみ） `b'A'`

では、どの整数型を使用すればよいのでしょうか？わからない場合は、Rust のデフォルトが一般的に良い出発点です。整数型はデフォルトで`i32`になります。`isize`または`usize`を使用する主な状況は、何らかのコレクションにインデックスを付ける場合です。

> **整数のオーバーフロー**
>
> `u8`型の変数があり、0 から 255 までの値を保持できるとします。変数をその範囲外の値（256 など）に変更しようとすると、*整数のオーバーフロー*が発生し、2 つの動作のいずれかが発生する可能性があります。デバッグモードでコンパイルする場合、Rust は整数のオーバーフローのチェックを含み、この動作が発生した場合にプログラムが実行時に*パニック*を起こす原因となります。Rust は、プログラムがエラーで終了する場合に*パニック*という用語を使用します。「Unrecoverable Errors with panic!」でパニックについて詳しく説明します。
>
> `--release`フラグを使用してリリースモードでコンパイルする場合、Rust はパニックを引き起こす整数のオーバーフローのチェックを*含みません*。代わりに、オーバーフローが発生した場合、Rust は*2 の補数ラップ*を実行します。簡単に言うと、型が保持できる最大値を超える値は、型が保持できる最小値に「ラップアラウンド」します。`u8`の場合、値 256 は 0 になり、値 257 は 1 になります。プログラムはパニックを起こしませんが、変数は、おそらく期待していたものではない値を持つことになります。整数のオーバーフローのラップ動作に依存することは、エラーと見なされます。
>
> オーバーフローの可能性を明示的に処理するには、プリミティブ数値型に対して標準ライブラリが提供するこれらのメソッドファミリーを使用できます。
>
> - `wrapping_*`メソッド（`wrapping_add`など）を使用して、すべてのモードでラップします。
> - `checked_*`メソッドを使用して、オーバーフローがある場合は`None`値を返します。
> - `overflowing_*`メソッドを使用して、値とオーバーフローがあったかどうかを示すブール値を返します。
> - `saturating_*`メソッドを使用して、値の最小値または最大値で飽和させます。
