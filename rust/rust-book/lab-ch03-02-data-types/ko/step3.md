# 정수 타입 (Integer Types)

*정수 (integer)*는 소수 부분이 없는 숫자입니다. 우리는 2 장에서 `u32` 타입을 사용했습니다. 이 타입 선언은 관련 값이 32 비트 공간을 차지하는 부호 없는 정수 (부호 있는 정수 타입은 `u` 대신 `i`로 시작) 여야 함을 나타냅니다. 표 3-1 은 Rust 의 내장 정수 타입을 보여줍니다. 이러한 변형 중 하나를 사용하여 정수 값의 타입을 선언할 수 있습니다.

표 3-1: Rust 의 정수 타입

길이 부호 있음 (Signed) 부호 없음 (Unsigned)

---

8 비트 `i8` `u8`
16 비트 `i16` `u16`
32 비트 `i32` `u32`
64 비트 `i64` `u64`
128 비트 `i128` `u128`
arch `isize` `usize`

각 변형은 부호 있거나 부호 없을 수 있으며 명시적인 크기를 갖습니다. *부호 있음 (Signed)*과 *부호 없음 (unsigned)*은 숫자가 음수가 될 수 있는지 여부를 나타냅니다. 즉, 숫자에 부호가 있어야 하는지 (부호 있음) 또는 항상 양수이고 부호 없이 표현될 수 있는지 (부호 없음) 를 의미합니다. 종이에 숫자를 쓰는 것과 같습니다. 부호가 중요할 때는 숫자 앞에 더하기 기호 또는 빼기 기호가 표시됩니다. 그러나 숫자가 양수라고 가정해도 안전할 때는 부호 없이 표시됩니다. 부호 있는 숫자는 2 의 보수 표현을 사용하여 저장됩니다.

각 부호 있는 변형은 -(2`<sup>`{=html}n - 1`</sup>`{=html}) 부터 2`<sup>`{=html}n - 1`</sup>`{=html} - 1 까지의 숫자를 저장할 수 있으며, 여기서 *n*은 해당 변형이 사용하는 비트 수입니다. 따라서 `i8`은 -(2`<sup>`{=html}7`</sup>`{=html}) 부터 2`<sup>`{=html}7`</sup>`{=html} - 1 까지의 숫자, 즉 -128 부터 127 까지의 숫자를 저장할 수 있습니다. 부호 없는 변형은 0 부터 2`<sup>`{=html}n`</sup>`{=html} - 1 까지의 숫자를 저장할 수 있으므로 `u8`은 0 부터 2`<sup>`{=html}8`</sup>`{=html} - 1, 즉 0 부터 255 까지의 숫자를 저장할 수 있습니다.

또한 `isize` 및 `usize` 타입은 프로그램이 실행되는 컴퓨터의 아키텍처에 따라 달라지며, 표에서 "arch"로 표시됩니다. 64 비트 아키텍처를 사용하는 경우 64 비트이고 32 비트 아키텍처를 사용하는 경우 32 비트입니다.

표 3-2 에 표시된 형식으로 정수 리터럴을 작성할 수 있습니다. 여러 숫자 타입이 가능한 숫자 리터럴은 `57u8`과 같은 타입 접미사를 사용하여 타입을 지정할 수 있습니다. 숫자 리터럴은 `1_000`과 같이 숫자를 더 쉽게 읽을 수 있도록 시각적 구분 기호로 `_`를 사용할 수도 있으며, 이는 `1000`을 지정한 것과 동일한 값을 갖습니다.

표 3-2: Rust 의 정수 리터럴

숫자 리터럴 예시

---

10 진수 (Decimal) `98_222`
16 진수 (Hex) `0xff`
8 진수 (Octal) `0o77`
2 진수 (Binary) `0b1111_0000`
바이트 (Byte) (`u8`만 해당) `b'A'`

그렇다면 어떤 정수 타입을 사용해야 할까요? 확실하지 않은 경우 Rust 의 기본값이 일반적으로 시작하기에 좋은 곳입니다. 정수 타입은 기본적으로 `i32`입니다. `isize` 또는 `usize`를 사용하는 주요 상황은 어떤 종류의 컬렉션을 인덱싱할 때입니다.

> **정수 오버플로 (Integer Overflow)**
>
> 0 에서 255 사이의 값을 저장할 수 있는 `u8` 타입의 변수가 있다고 가정해 보겠습니다. 변수를 256 과 같이 해당 범위를 벗어나는 값으로 변경하려고 하면 *정수 오버플로 (integer overflow)*가 발생하며, 이는 두 가지 동작 중 하나를 초래할 수 있습니다. 디버그 모드로 컴파일하는 경우 Rust 는 이 동작이 발생하면 런타임에 프로그램이 *패닉 (panic)*을 일으키는 정수 오버플로에 대한 검사를 포함합니다. Rust 는 프로그램이 오류와 함께 종료될 때 *패닉 (panicking)*이라는 용어를 사용합니다. "Unrecoverable Errors with panic!"에서 패닉에 대해 더 자세히 논의할 것입니다.
>
> `--release` 플래그를 사용하여 릴리스 모드로 컴파일하는 경우 Rust 는 패닉을 일으키는 정수 오버플로에 대한 검사를 _포함하지 않습니다_. 대신 오버플로가 발생하면 Rust 는 *2 의 보수 래핑 (two's complement wrapping)*을 수행합니다. 간단히 말해서, 타입이 가질 수 있는 최대값보다 큰 값은 타입이 가질 수 있는 최소값으로 "감싸집니다". `u8`의 경우 값 256 은 0 이 되고, 값 257 은 1 이 되는 식입니다. 프로그램은 패닉하지 않지만 변수는 예상했던 값과 다를 수 있습니다. 정수 오버플로의 래핑 동작에 의존하는 것은 오류로 간주됩니다.
>
> 오버플로 가능성을 명시적으로 처리하려면 기본 숫자 타입에 대해 표준 라이브러리에서 제공하는 다음 메서드 패밀리를 사용할 수 있습니다.
>
> - `wrapping_*` 메서드 (예: `wrapping_add`) 를 사용하여 모든 모드에서 래핑합니다.
> - `checked_*` 메서드를 사용하여 오버플로가 있는 경우 `None` 값을 반환합니다.
> - `overflowing_*` 메서드를 사용하여 값과 오버플로가 있었는지 여부를 나타내는 부울을 반환합니다.
> - `saturating_*` 메서드를 사용하여 값의 최소 또는 최대 값으로 포화시킵니다.
