# 정수 타입

_정수 (integer)_ 는 소수 부분이 없는 숫자입니다. 2 장에서 `u32` 타입을 사용했습니다. 이 타입 선언은 관련 값이 부호 없는 정수 (부호 있는 정수 타입은 `u` 대신 `i`로 시작) 여야 하며 32 비트 공간을 차지해야 함을 나타냅니다. 표 3-1 은 Rust 의 내장 정수 타입을 보여줍니다. 이러한 변형 중 하나를 사용하여 정수 값의 타입을 선언할 수 있습니다.

표 3-1: Rust 의 정수 타입

길이 부호 있음 부호 없음

---

8 비트 `i8` `u8`
16 비트 `i16` `u16`
32 비트 `i32` `u32`
64 비트 `i64` `u64`
128 비트 `i128` `u128`
arch `isize` `usize`

각 변형은 부호 있거나 부호 없을 수 있으며 명시적인 크기를 갖습니다. _부호 있음 (Signed)_ 과 _부호 없음 (unsigned)_ 은 숫자가 음수가 될 수 있는지 여부를 나타냅니다. 즉, 숫자가 부호 (signed) 를 가져야 하는지, 아니면 항상 양수이고 부호 없이 표현할 수 있는지 (unsigned) 를 나타냅니다. 종이에 숫자를 쓰는 것과 같습니다. 부호가 중요할 때는 숫자 앞에 더하기 기호 또는 빼기 기호가 표시됩니다. 그러나 숫자가 양수라고 가정해도 안전할 때는 부호 없이 표시됩니다. 부호 있는 숫자는 2 의 보수 표현 (two's complement representation) 을 사용하여 저장됩니다.

각 부호 있는 변형은 -(2^(n-1)) 부터 2^(n-1) - 1 까지의 숫자를 저장할 수 있으며, 여기서 _n_ 은 해당 변형이 사용하는 비트 수입니다. 따라서 `i8`은 -(2^7) 부터 2^7 - 1 까지의 숫자, 즉 -128 부터 127 까지의 숫자를 저장할 수 있습니다. 부호 없는 변형은 0 부터 2^n - 1 까지의 숫자를 저장할 수 있으므로 `u8`은 0 부터 2^8 - 1 까지의 숫자, 즉 0 부터 255 까지의 숫자를 저장할 수 있습니다.

또한 `isize` 및 `usize` 타입은 프로그램이 실행되는 컴퓨터의 아키텍처에 따라 달라지며, 표에서 "arch"로 표시됩니다. 64 비트 아키텍처에서는 64 비트, 32 비트 아키텍처에서는 32 비트입니다.

표 3-2 에 표시된 형식으로 정수 리터럴을 작성할 수 있습니다. 여러 숫자 타입이 가능한 숫자 리터럴은 `57u8`과 같은 타입 접미사를 사용하여 타입을 지정할 수 있습니다. 숫자 리터럴은 `_`를 시각적 구분 기호로 사용하여 `1_000`과 같이 숫자를 더 쉽게 읽을 수 있도록 할 수도 있습니다. 이는 `1000`을 지정한 것과 동일한 값을 갖습니다.

표 3-2: Rust 의 정수 리터럴

숫자 리터럴 예시

---

10 진수 `98_222`
16 진수 `0xff`
8 진수 `0o77`
2 진수 `0b1111_0000`
바이트 (u8 만 해당) `b'A'`

그렇다면 어떤 정수 타입을 사용해야 할까요? 잘 모르겠다면 Rust 의 기본값이 일반적으로 시작하기에 좋은 곳입니다. 정수 타입은 기본적으로 `i32`입니다. `isize` 또는 `usize`를 사용하는 주요 상황은 어떤 종류의 컬렉션을 인덱싱할 때입니다.

> **정수 오버플로우 (Integer Overflow)**
>
> `u8` 타입의 변수가 0 에서 255 사이의 값을 가질 수 있다고 가정해 보겠습니다. 변수를 해당 범위를 벗어나는 값 (예: 256) 으로 변경하려고 하면 _정수 오버플로우 (integer overflow)_ 가 발생하며, 이는 두 가지 동작 중 하나로 이어질 수 있습니다. 디버그 모드로 컴파일하는 경우 Rust 는 이 동작이 발생하면 런타임에 프로그램이 _패닉 (panic)_ 되도록 하는 정수 오버플로우 검사를 포함합니다. Rust 는 프로그램이 오류와 함께 종료될 때 _패닉 (panicking)_ 이라는 용어를 사용합니다. "panic! 으로 복구할 수 없는 오류"에서 패닉에 대해 자세히 논의할 것입니다.
>
> `--release` 플래그를 사용하여 릴리스 모드로 컴파일하는 경우 Rust 는 패닉을 발생시키는 정수 오버플로우 검사를 _포함하지 않습니다_. 대신 오버플로우가 발생하면 Rust 는 _2 의 보수 래핑 (two's complement wrapping)_ 을 수행합니다. 간단히 말해서, 타입이 가질 수 있는 최대값보다 큰 값은 타입이 가질 수 있는 최소값으로 "감싸집니다 (wrap around)". `u8`의 경우 값 256 은 0 이 되고, 값 257 은 1 이 되는 식입니다. 프로그램은 패닉되지 않지만 변수는 예상했던 값과 다를 수 있습니다. 정수 오버플로우의 래핑 동작에 의존하는 것은 오류로 간주됩니다.
>
> 오버플로우 가능성을 명시적으로 처리하려면 기본 숫자 타입에 대해 표준 라이브러리에서 제공하는 다음 메서드 패밀리를 사용할 수 있습니다.
>
> - `wrapping_*` 메서드 (예: `wrapping_add`) 를 사용하여 모든 모드에서 래핑합니다.
> - `checked_*` 메서드를 사용하여 오버플로우가 있는 경우 `None` 값을 반환합니다.
> - `overflowing_*` 메서드를 사용하여 값과 오버플로우가 있었는지 여부를 나타내는 부울 값을 반환합니다.
> - `saturating_*` 메서드를 사용하여 값의 최소 또는 최대 값으로 포화시킵니다.
