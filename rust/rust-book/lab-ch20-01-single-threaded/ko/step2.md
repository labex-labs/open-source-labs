# TCP 연결 수신

웹 서버는 TCP 연결을 수신해야 하므로, 이것이 우리가 작업할 첫 번째 부분입니다. 표준 라이브러리는 이를 수행할 수 있는 `std::net` 모듈을 제공합니다. 평소와 같이 새 프로젝트를 만들어 보겠습니다.

```bash
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```

이제 `src/main.rs`에 Listing 20-1 의 코드를 입력하여 시작합니다. 이 코드는 로컬 주소 `127.0.0.1:7878`에서 들어오는 TCP 스트림을 수신합니다. 들어오는 스트림을 받으면 "Connection established!"를 출력합니다.

Filename: `src/main.rs`

```rust
use std::net::TcpListener;

fn main() {
  1 let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

  2 for stream in listener.incoming() {
      3 let stream = stream.unwrap();

      4 println!("Connection established!");
    }
}
```

Listing 20-1: 들어오는 스트림을 수신하고 스트림을 수신할 때 메시지를 출력

`TcpListener`를 사용하여 주소 `127.0.0.1:7878` \[1]에서 TCP 연결을 수신할 수 있습니다. 주소에서 콜론 앞의 부분은 컴퓨터를 나타내는 IP 주소입니다 (이것은 모든 컴퓨터에서 동일하며 작성자의 컴퓨터를 특별히 나타내는 것은 아닙니다). `7878`은 포트입니다. 우리는 이 포트를 두 가지 이유로 선택했습니다. HTTP 는 일반적으로 이 포트에서 허용되지 않으므로 서버가 컴퓨터에서 실행 중일 수 있는 다른 웹 서버와 충돌할 가능성이 낮고, 7878 은 전화 키패드에서 *rust*를 입력한 것입니다.

이 시나리오에서 `bind` 함수는 새로운 `TcpListener` 인스턴스를 반환한다는 점에서 `new` 함수와 유사하게 작동합니다. 이 함수가 `bind`라고 불리는 이유는 네트워킹에서 포트에 연결하여 수신하는 것을 "포트에 바인딩"이라고 하기 때문입니다.

`bind` 함수는 `Result<T, E>`를 반환하며, 이는 바인딩이 실패할 수 있음을 나타냅니다. 예를 들어, 포트 80 에 연결하려면 관리자 권한이 필요합니다 (비관리자는 1023 보다 높은 포트에서만 수신할 수 있음). 따라서 관리자가 아닌 상태에서 포트 80 에 연결하려고 하면 바인딩이 작동하지 않습니다. 또한, 예를 들어 프로그램의 두 인스턴스를 실행하여 두 프로그램이 동일한 포트를 수신하는 경우에도 바인딩이 작동하지 않습니다. 우리는 학습 목적으로 기본적인 서버를 작성하고 있으므로 이러한 종류의 오류를 처리하는 것에 대해 걱정하지 않을 것입니다. 대신, 오류가 발생하면 `unwrap`을 사용하여 프로그램을 중지합니다.

`TcpListener`의 `incoming` 메서드는 스트림 시퀀스 \[2] (더 구체적으로는 `TcpStream` 유형의 스트림) 를 제공하는 반복자를 반환합니다. 단일 _stream_ (스트림) 은 클라이언트와 서버 간의 열린 연결을 나타냅니다. _connection_ (연결) 은 클라이언트가 서버에 연결하고, 서버가 응답을 생성하고, 서버가 연결을 닫는 전체 요청 및 응답 프로세스의 이름입니다. 따라서 우리는 `TcpStream`에서 읽어 클라이언트가 보낸 내용을 확인한 다음, 응답을 스트림에 써서 데이터를 클라이언트에 다시 보낼 것입니다. 전반적으로 이 `for` 루프는 각 연결을 차례로 처리하고 처리할 일련의 스트림을 생성합니다.

현재로서는 스트림 처리가 스트림에 오류가 있는 경우 프로그램을 종료하기 위해 `unwrap`을 호출하는 것으로 구성됩니다 \[3]; 오류가 없으면 프로그램이 메시지를 출력합니다 \[4]. 다음 목록에서 성공적인 경우에 대한 더 많은 기능을 추가할 것입니다. 클라이언트가 서버에 연결할 때 `incoming` 메서드에서 오류를 수신할 수 있는 이유는 실제로 연결을 반복하지 않기 때문입니다. 대신, _connection attempts_ (연결 시도) 를 반복하고 있습니다. 연결은 여러 가지 이유로 성공하지 못할 수 있으며, 그 중 많은 부분이 운영 체제에 따라 다릅니다. 예를 들어, 많은 운영 체제는 지원할 수 있는 동시 열린 연결 수에 제한이 있습니다. 해당 수를 초과하는 새로운 연결 시도는 일부 열린 연결이 닫힐 때까지 오류를 생성합니다.

이 코드를 실행해 봅시다! 터미널에서 `cargo run`을 호출한 다음 웹 브라우저에서 *127.0.0.1:7878*을 로드합니다. 브라우저는 "Connection reset"과 같은 오류 메시지를 표시해야 합니다. 서버가 현재 데이터를 다시 보내지 않기 때문입니다. 그러나 터미널을 보면 브라우저가 서버에 연결될 때 출력된 여러 메시지를 볼 수 있습니다!

         Running `target/debug/hello`
    Connection established!
    Connection established!
    Connection established!

때로는 하나의 브라우저 요청에 대해 여러 메시지가 출력되는 것을 볼 수 있습니다. 그 이유는 브라우저가 페이지에 대한 요청뿐만 아니라 브라우저 탭에 나타나는 _favicon.ico_ 아이콘과 같은 다른 리소스에 대한 요청을 하기 때문일 수 있습니다.

또한 서버가 데이터를 응답하지 않기 때문에 브라우저가 서버에 여러 번 연결을 시도하는 것일 수도 있습니다. `stream`이 범위를 벗어나 루프의 끝에서 삭제되면 `drop` 구현의 일부로 연결이 닫힙니다. 브라우저는 때때로 문제가 일시적일 수 있으므로 닫힌 연결을 재시도하여 처리합니다. 중요한 요소는 TCP 연결에 대한 핸들을 성공적으로 얻었다는 것입니다!

특정 버전의 코드를 실행한 후에는 ctrl-C 를 눌러 프로그램을 중지하는 것을 잊지 마십시오. 그런 다음 각 코드 변경 사항을 만든 후 `cargo run` 명령을 호출하여 프로그램을 다시 시작하여 최신 코드를 실행하고 있는지 확인하십시오.
