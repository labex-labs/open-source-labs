# TCP接続を待ち受ける

私たちのWebサーバーはTCP接続を待ち受ける必要がありますので、それが最初に取り組む部分です。標準ライブラリにはこれを行うための`std::net`モジュールが用意されています。いつも通り新しいプロジェクトを作成しましょう：

```bash
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```

次に、`src/main.rs`にリスト20-1のコードを入力して始めましょう。このコードは、ローカルアドレス`127.0.0.1:7878`で着信するTCPストリームを待ち受けます。着信ストリームを受け取ると、`接続確立！`と表示します。

ファイル名：`src/main.rs`

```rust
use std::net::TcpListener;

fn main() {
  1 let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

  2 for stream in listener.incoming() {
      3 let stream = stream.unwrap();

      4 println!("Connection established!");
    }
}
```

リスト20-1：着信ストリームを待ち受け、ストリームを受け取ったときにメッセージを表示する

`TcpListener`を使用することで、アドレス`127.0.0.1:7878`でTCP接続を待ち受けることができます\[1\]。アドレスのコロンの前の部分は、あなたのコンピュータを表すIPアドレスです（すべてのコンピュータで同じで、特に著者のコンピュータを表すものではありません）。そして`7878`はポートです。このポートを選んだ理由は2つあります。HTTPは通常このポートでは受け付けられないため、私たちのサーバーはあなたのマシン上で実行している他のWebサーバーと競合する可能性が低く、また7878は電話で「rust」と入力すると同じです。

このシナリオでの`bind`関数は、新しい`TcpListener`インスタンスを返す点で`new`関数と同じように機能します。この関数が`bind`と呼ばれるのは、ネットワーキングにおいて、ポートに接続して待ち受けることを「ポートにバインドする」と呼ぶからです。

`bind`関数は`Result<T, E>`を返します。これはバインドに失敗する可能性があることを示しています。たとえば、ポート80に接続するには管理者特権が必要です（管理者以外は1023より高いポートのみを待ち受けることができます）。したがって、管理者でない状態でポート80に接続しようとすると、バインドは機能しません。また、たとえば私たちのプログラムの2つのインスタンスを実行して同じポートを待ち受けている場合も、バインドは機能しません。学習目的で基本的なサーバーを書いているので、このようなエラーの処理は心配しません。代わりに、エラーが発生した場合にプログラムを停止するために`unwrap`を使用します。

`TcpListener`の`incoming`メソッドは、ストリームのシーケンスを与えるイテレータを返します\[2\]（より正確には、`TcpStream`型のストリームです）。単一の「ストリーム」は、クライアントとサーバーの間の開いた接続を表します。「接続」とは、クライアントがサーバーに接続し、サーバーが応答を生成し、サーバーが接続を閉じる、完全な要求と応答のプロセスのことです。したがって、私たちは`TcpStream`から読み取ってクライアントが送信した内容を確認し、その後、応答をストリームに書き込んでクライアントにデータを送信します。全体的に、この`for`ループは各接続を順番に処理し、私たちが処理するための一連のストリームを生成します。

今のところ、私たちのストリームの処理は、ストリームにエラーがある場合に`unwrap`を呼び出してプログラムを終了することで構成されています\[3\]。エラーがない場合、プログラムはメッセージを表示します\[4\]。次のリストで成功した場合の機能を追加します。クライアントがサーバーに接続したときに`incoming`メソッドからエラーを受け取る理由は、実際には接続を反復しているわけではなく、「接続試行」を反復しているからです。接続が成功しない理由はいくつかあり、その多くはオペレーティングシステムに固有のものです。たとえば、多くのオペレーティングシステムは同時にサポートできる開いた接続の数に制限があります。その数を超える新しい接続試行は、いくつかの開いた接続が閉じられるまでエラーを生成します。

このコードを実行してみましょう！ ターミナルで`cargo run`を実行し、その後Webブラウザで*127.0.0.1:7878*を読み込みます。ブラウザには「接続がリセットされました」のようなエラーメッセージが表示されるはずです。なぜなら、サーバーは現在データを返していないからです。しかし、ターミナルを見ると、ブラウザがサーバーに接続したときに表示されたいくつかのメッセージが見えるはずです！

         Running `target/debug/hello`
    Connection established!
    Connection established!
    Connection established!

時々、1つのブラウザ要求に対して複数のメッセージが表示されることがあります。その理由は、ブラウザがページの要求だけでなく、_favicon.ico_ アイコンのような他のリソースの要求を行っている可能性があるからです。

また、サーバーがデータを返していないため、ブラウザがサーバーに何度も接続しようとしている場合もあります。`stream`がスコープ外になり、ループの終わりで破棄されるとき、接続は`drop`実装の一部として閉じられます。ブラウザは時々、問題が一時的な場合があるため、接続が閉じた場合に再接続することで対処します。重要なのは、私たちが成功裏にTCP接続のハンドルを取得したことです！

特定のバージョンのコードを実行し終えたら、ctrl-Cを押してプログラムを停止してください。その後、コードの各セットを変更した後に`cargo run`コマンドを呼び出してプログラムを再起動し、最新のコードを実行していることを確認してください。
