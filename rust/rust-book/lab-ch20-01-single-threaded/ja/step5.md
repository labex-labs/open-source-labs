# 応答を書き込む

クライアント要求に応じてデータを送信する機能を実装します。応答は次の形式をとります。

    HTTPバージョン ステータスコード 理由フレーズ CRLF
    ヘッダー CRLF
    メッセージボディ

最初の行は「ステータス行」で、応答で使用されるHTTPバージョン、要求の結果を要約する数値のステータスコード、およびステータスコードのテキスト説明を提供する理由フレーズが含まれています。CRLFシーケンスの後には、任意のヘッダー、もう1つのCRLFシーケンス、および応答の本文が続きます。

次は、HTTPバージョン1.1を使用し、ステータスコードが200、理由フレーズがOK、ヘッダーがなく、ボディがない応答の例です。

```rust
HTTP/1.1 200 OK\r\n\r\n
```

ステータスコード200は標準的な成功応答です。このテキストは、小さな成功したHTTP応答です。成功した要求に対する応答として、これをストリームに書き込みましょう！ `handle_connection`関数から、要求データを表示していた`println!`を削除し、リスト20-3のコードに置き換えます。

ファイル名：`src/main.rs`

```rust
fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
     .lines()
     .map(|result| result.unwrap())
     .take_while(|line|!line.is_empty())
     .collect();

  1 let response = "HTTP/1.1 200 OK\r\n\r\n";

  2 stream.write_all(response.3 as_bytes()).unwrap();
}
```

リスト20-3：小さな成功したHTTP応答をストリームに書き込む

最初の新しい行は、成功メッセージのデータを保持する`response`変数を定義します\[1\]。次に、`response`に対して`as_bytes`を呼び出して、文字列をバイトに変換します\[3\]。`stream`の`write_all`メソッドは`&[u8]`を取り、それらのバイトを直接接続を通じて送信します\[2\]。`write_all`操作は失敗する可能性があるため、以前と同じようにエラー結果に対して`unwrap`を使用します。再び、本番用のアプリケーションではここにエラー処理を追加する必要があります。

これらの変更を加えて、コードを実行して要求を行いましょう。ターミナルにはもはやデータを表示していないので、Cargoの出力以外には何も出力されません。Webブラウザで*127.0.0.1:7878*を読み込むと、エラーの代わりに空白のページが表示されるはずです。あなたは、HTTP要求を受け取り、応答を送信するための手動コーディングをしたばかりです！
