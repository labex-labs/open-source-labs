# 少しのリファクタリング

現在、`if`と`else`ブロックには多くの重複があります。両方ともファイルを読み取り、ファイルの内容をストリームに書き込んでいます。唯一の違いは、ステータス行とファイル名です。これらの違いを別々の`if`と`else`行に抜き出して、ステータス行とファイル名の値を変数に割り当てることで、コードをもっと簡潔にしましょう。そうすると、コードでは無条件にこれらの変数を使用してファイルを読み取り、応答を書き込むことができます。リスト 20-9 は、大きな`if`と`else`ブロックを置き換えた後の結果となるコードを示しています。

ファイル名：`src/main.rs`

```rust
--snip--

fn handle_connection(mut stream: TcpStream) {
    --snip--

    let (status_line, filename) =
        if request_line == "GET / HTTP/1.1" {
            ("HTTP/1.1 200 OK", "hello.html")
        } else {
            ("HTTP/1.1 404 NOT FOUND", "404.html")
        };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response = format!(
        "{status_line}\r\n\
         Content-Length: {length}\r\n\r\n\
         {contents}"
    );

    stream.write_all(response.as_bytes()).unwrap();
}
```

リスト 20-9：`if`と`else`ブロックをリファクタリングして、両方のケースで異なるコードのみを含むようにする

今では、`if`と`else`ブロックは、タプルでステータス行とファイル名に適切な値を返すだけです。その後、第 18 章で説明した`let`文のパターンを使って、これらの 2 つの値を`status_line`と`filename`に代入するために構文分解を使用します。

以前は重複していたコードは、今では`if`と`else`ブロックの外にあり、`status_line`と`filename`変数を使用しています。これにより、2 つのケースの違いを把握しやすくなり、ファイル読み取りと応答書き込みの仕組みを変更したい場合には、コードを更新する箇所が 1 か所になります。リスト 20-9 のコードの動作は、リスト 20-8 のものと同じです。

素晴らしい！これで、約 40 行の Rust コードでシンプルな Web サーバーができました。この Web サーバーは、1 つの要求に対してコンテンツのページを返し、その他のすべての要求に対して 404 応答を返します。

現在、私たちのサーバーは単一スレッドで実行されており、一度に 1 つの要求のみを処理できます。いくつかの低速な要求をシミュレートすることで、それがどのような問題になるかを調べましょう。その後、サーバーが一度に複数の要求を処理できるように修正します。
