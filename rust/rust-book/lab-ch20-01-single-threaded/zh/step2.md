# 监听 TCP 连接

我们的 Web 服务器需要监听 TCP 连接，所以这是我们要处理的第一部分。标准库提供了一个`std::net`模块，让我们能够做到这一点。让我们以通常的方式创建一个新项目：

```bash
$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
```

现在在`src/main.rs`中输入清单 20-1 中的代码来开始。这段代码将在本地地址`127.0.0.1:7878`监听传入的 TCP 流。当它接收到一个传入流时，会打印`Connection established!`。

文件名：`src/main.rs`

```rust
use std::net::TcpListener;

fn main() {
  1 let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

  2 for stream in listener.incoming() {
      3 let stream = stream.unwrap();

      4 println!("Connection established!");
    }
}
```

清单 20-1：监听传入流并在接收到流时打印消息

使用`TcpListener`，我们可以在地址`127.0.0.1:7878`监听 TCP 连接\[1\]。在这个地址中，冒号之前的部分是表示你的计算机的 IP 地址（在每台计算机上都是相同的，并不特指作者的计算机），而`7878`是端口号。我们选择这个端口号有两个原因：HTTP 通常不会在这个端口被接受，所以我们的服务器不太可能与你机器上可能运行的任何其他 Web 服务器冲突，并且 7878 在电话上拼出来是“rust”。

在这种情况下，`bind`函数的工作方式类似于`new`函数，它会返回一个新的`TcpListener`实例。这个函数被称为`bind`，是因为在网络中，连接到一个端口进行监听被称为“绑定到一个端口”。

`bind`函数返回一个`Result<T, E>`，这表明绑定有可能失败。例如，连接到端口 80 需要管理员权限（非管理员只能监听高于 1023 的端口），所以如果我们在不是管理员的情况下尝试连接到端口 80，绑定就不会成功。例如，如果我们运行程序的两个实例，因此有两个程序监听同一个端口，绑定也不会成功。因为我们只是为了学习目的编写一个基本的服务器，所以我们不会担心处理这类错误；相反，如果发生错误，我们使用`unwrap`来终止程序。

`TcpListener`上的`incoming`方法返回一个迭代器，它为我们提供一系列流\[2\]（更具体地说，是`TcpStream`类型的流）。单个**流**表示客户端和服务器之间的一个开放连接。**连接**是指客户端连接到服务器、服务器生成响应并关闭连接的整个请求和响应过程的名称。因此，我们将从`TcpStream`读取以查看客户端发送了什么，然后将我们的响应写入流以将数据发送回客户端。总体而言，这个`for`循环将依次处理每个连接，并为我们生成一系列流以供处理。

目前，我们对流的处理包括如果流有任何错误就调用`unwrap`来终止我们的程序\[3\]；如果没有错误，程序就打印一条消息\[4\]。在下一个清单中，我们将为成功的情况添加更多功能。当客户端连接到服务器时，我们可能从`incoming`方法收到错误的原因是，我们实际上不是在遍历连接。相反，我们是在遍历**连接尝试**。由于许多原因，连接可能不成功，其中许多原因与操作系统有关。例如，许多操作系统对它们可以支持的同时打开的连接数量有限制；超过该数量的新连接尝试将产生错误，直到一些打开的连接被关闭。

让我们尝试运行这段代码！在终端中调用`cargo run`，然后在 Web 浏览器中加载*127.0.0.1:7878*。浏览器应该会显示一个类似“Connection reset”的错误消息，因为服务器目前没有发送回任何数据。但是当你查看终端时，你应该会看到在浏览器连接到服务器时打印的几条消息！

         Running `target/debug/hello`
    Connection established!
    Connection established!
    Connection established!

有时，对于一个浏览器请求你会看到打印了多条消息；原因可能是浏览器在请求页面的同时还在请求其他资源，比如出现在浏览器标签中的*favicon.ico*图标。

也可能是因为服务器没有返回任何数据，浏览器正在多次尝试连接到服务器。当`stream`超出作用域并在循环结束时被丢弃时，连接作为`drop`实现的一部分被关闭。浏览器有时会通过重试来处理关闭的连接，因为问题可能是暂时的。重要的是，我们已经成功地获得了一个 TCP 连接的句柄！

当你完成运行特定版本的代码后，记得通过按 ctrl-C 来停止程序。然后在你进行每组代码更改后，通过调用`cargo run`命令重新启动程序，以确保你正在运行最新的代码。
