# Валидация запроса и выборочное ответы

В настоящее время наша веб-серверная программа возвращает HTML из файла независимо от того, что запросил клиент. Добавим функциональность для проверки того, запрашивает ли браузер _/_, прежде чем возвращать HTML-файл, и возвращаем ошибку, если браузер запрашивает что-то другое. Для этого нам нужно изменить `handle_connection`, как показано в Листинге 20-6. Этот новый код проверяет содержимое полученного запроса по сравнению с тем, как должен выглядеть запрос на _/_, и добавляет блоки `if` и `else`, чтобы обрабатывать запросы по-разному.

Имя файла: `src/main.rs`

```rust
--snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
  1 let request_line = buf_reader
      .lines()
      .next()
      .unwrap()
      .unwrap();

  2 if request_line == "GET / HTTP/1.1" {
        let status_line = "HTTP/1.1 200 OK";
        let contents = fs::read_to_string("hello.html").unwrap();
        let length = contents.len();

        let response = format!(
            "{status_line}\r\n\
             Content-Length: {length}\r\n\r\n\
             {contents}"
        );

        stream.write_all(response.as_bytes()).unwrap();
  3 } else {
        // some other request
    }
}
```

Листинг 20-6: Обработка запросов к _/_ по-разному от других запросов

Мы будем рассматривать только первую строку HTTP-запроса, поэтому вместо чтения всего запроса в вектор мы вызываем `next`, чтобы получить первый элемент из итератора \[1\]. Первый `unwrap` обрабатывает `Option` и останавливает программу, если у итератора нет элементов. Второй `unwrap` обрабатывает `Result` и имеет то же самое действие, что и `unwrap`, добавленный в `map` в Листинге 20-2.

Далее мы проверяем `request_line`, чтобы понять, равно ли оно строке запроса на GET-запрос к пути _/_ \[2\]. Если это так, блок `if` возвращает содержимое нашего HTML-файла.

Если `request_line` не равно GET-запросу к пути _/_, это означает, что мы получили какой-то другой запрос. Вскоре мы добавим код в блок `else` \[3\], чтобы ответить на все другие запросы.

Запустите этот код сейчас и запросите _127.0.0.1:7878_; вы должны получить HTML из _hello.html_. Если вы делаете любой другой запрос, например, _127.0.0.1:7878/something-else_, вы получите ошибку соединения, похожую на те, которые вы видели при запуске кода в Листинге 20-1 и Листинге 20-2.

Теперь добавим код из Листинга 20-7 в блок `else`, чтобы вернуть ответ с кодом статуса 404, который сигнализирует, что содержимое для запроса не найдено. Мы также вернем некоторый HTML для страницы, которая будет отображаться в браузере, чтобы показать ответ конечному пользователю.

Имя файла: `src/main.rs`

```rust
--snip--
} else {
  1 let status_line = "HTTP/1.1 404 NOT FOUND";
  2 let contents = fs::read_to_string("404.html").unwrap();
    let length = contents.len();

    let response = format!(
        "{status_line}\r\n\
         Content-Length: {length}\r\n\r\n
         {contents}"
    );

    stream.write_all(response.as_bytes()).unwrap();
}
```

Листинг 20-7: Ответ с кодом статуса 404 и страницей ошибки, если был запрошен что-то другое, кроме _/_

Здесь наш ответ имеет строку статуса с кодом статуса 404 и фразой-причиной `NOT FOUND` \[1\]. Тело ответа будет содержать HTML из файла _404.html_ \[1\]. Вам нужно создать файл _404.html_ рядом с _hello.html_ для страницы ошибки; снова вы можете использовать любой HTML, который хотите, или использовать пример HTML из Листинга 20-8.

Имя файла: `404.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Hello!</title>
  </head>
  <body>
    <h1>Oops!</h1>
    <p>Sorry, I don't know what you're asking for.</p>
  </body>
</html>
```

Листинг 20-8: Пример содержимого страницы, которая будет возвращена при любом ответе 404

После этих изменений запустите свой сервер снова. Запрос _127.0.0.1:7878_ должен вернуть содержимое _hello.html_, а любой другой запрос, например, _127.0.0.1:7878/foo_, должен вернуть ошибочный HTML из _404.html_.
