# Немного рефакторинга

В настоящее время блоки `if` и `else` имеют много повторяющегося кода: они оба читают файлы и записывают содержимое файлов в поток. Единственные различия - это строка статуса и имя файла. Давайте сделаем код более компактным, вынеся эти различия в отдельные строки `if` и `else`, которые будут присваивать значения строки статуса и имени файла переменным; затем мы можем использовать эти переменные безусловно в коде для чтения файла и записи ответа. Листинг 20-9 показывает получившийся код после замены больших блоков `if` и `else`.

Имя файла: `src/main.rs`

```rust
--snip--

fn handle_connection(mut stream: TcpStream) {
    --snip--

    let (status_line, filename) =
        if request_line == "GET / HTTP/1.1" {
            ("HTTP/1.1 200 OK", "hello.html")
        } else {
            ("HTTP/1.1 404 NOT FOUND", "404.html")
        };

    let contents = fs::read_to_string(filename).unwrap();
    let length = contents.len();

    let response = format!(
        "{status_line}\r\n\
         Content-Length: {length}\r\n\r\n\
         {contents}"
    );

    stream.write_all(response.as_bytes()).unwrap();
}
```

Листинг 20-9: Рефакторинг блоков `if` и `else`, чтобы они содержали только код, различающийся между двумя случаями

Теперь блоки `if` и `else` возвращают только соответствующие значения для строки статуса и имени файла в кортеже; затем мы используем деструктуризацию, чтобы присвоить эти два значения `status_line` и `filename` с использованием шаблона в инструкции `let`, как обсуждалось в главе 18.

Ранее дублированный код теперь находится вне блоков `if` и `else` и использует переменные `status_line` и `filename`. Это делает легче увидеть разницу между двумя случаями, и это означает, что у нас есть только одно место для обновления кода, если мы хотим изменить, как работает чтение файла и запись ответа. Поведение кода в Листинге 20-9 будет тем же, что и в Листинге 20-8.

Отлично! Теперь у нас есть простой веб-сервер на примерно 40 строках кода на Rust, который отвечает на один запрос страницей с содержимым и на все другие запросы ответом 404.

В настоящее время наш сервер работает в одном потоке, что означает, что он может обслуживать только один запрос за раз. Давайте рассмотрим, как это может стать проблемой, имитируя некоторые медленные запросы. Затем мы исправим это, чтобы наш сервер мог обрабатывать несколько запросов одновременно.
