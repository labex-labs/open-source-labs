# Чтение запроса

Реализуем функциональность для чтения запроса из браузера! Чтобы отделить заботы о получении соединения и последующем действии с соединением, мы создадим новую функцию для обработки соединений. В этой новой функции `handle_connection` мы будем читать данные из TCP-потока и выводить их, чтобы увидеть, какие данные отправляет браузер. Измените код, чтобы он выглядел как в Листинге 20-2.

Имя файла: `src/main.rs`

```rust
1 use std::{
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

      2 handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
  3 let buf_reader = BufReader::new(&mut stream);
  4 let http_request: Vec<_> = buf_reader
      5.lines()
      6.map(|result| result.unwrap())
      7.take_while(|line|!line.is_empty())
       .collect();

  8 println!("Request: {:#?}", http_request);
}
```

Листинг 20-2: Чтение из `TcpStream` и вывод данных

Мы подключаем `std::io::prelude` и `std::io::BufReader` для доступа к трейтам и типам, которые позволяют нам читать из и записывать в поток \[1\]. В цикле `for` в функции `main` вместо вывода сообщения о том, что мы установили соединение, мы теперь вызываем новую функцию `handle_connection` и передаем ей `stream` \[2\].

В функции `handle_connection` мы создаем новый экземпляр `BufReader`, который оборачивает изменяемую ссылку на `stream` \[3\]. `BufReader` добавляет буферизацию, управляя вызовами методов трейта `std::io::Read` для нас.

Мы создаем переменную с именем `http_request`, чтобы собрать строки запроса, который отправляет браузер на наш сервер. Мы указываем, что хотим собрать эти строки в вектор, добавив аннотацию типа `Vec<_>` \[4\].

`BufReader` реализует трейт `std::io::BufRead`, который предоставляет метод `lines` \[5\]. Метод `lines` возвращает итератор `Result<String, std::io::Error>` путем разделения потока данных при встрече байта новой строки. Чтобы получить каждую `String`, мы применяем `map` и `unwrap` к каждому `Result` \[6\]. `Result` может быть ошибкой, если данные не являются допустимой UTF-8 или если при чтении из потока возникла проблема. Опять же, в продакшн-программе эти ошибки должны быть обработаны более элегантно, но мы выбираем остановить программу в случае ошибки для простоты.

Браузер сигнализирует о конце HTTP-запроса, отправив два символа новой строки подряд, поэтому, чтобы получить один запрос из потока, мы берем строки, пока не получим строку, которая является пустой строкой \[7\]. Как только мы собрали строки в вектор, мы выводим их с помощью красивой отладочной форматирования \[8\], чтобы можно было посмотреть на инструкции, которые отправляет веб-браузер на наш сервер.

Попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы по-прежнему получим страницу ошибки в браузере, но вывод нашей программы в терминале теперь будет похож на этот:

```bash
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: [
    "GET / HTTP/1.1",
    "Host: 127.0.0.1:7878",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0)
Gecko/20100101 Firefox/99.0",
    "Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*
;q=0.8",
    "Accept-Language: en-US,en;q=0.5",
    "Accept-Encoding: gzip, deflate, br",
    "DNT: 1",
    "Connection: keep-alive",
    "Upgrade-Insecure-Requests: 1",
    "Sec-Fetch-Dest: document",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-User:?1",
    "Cache-Control: max-age=0",
]
```

В зависимости от вашего браузера вы можете получить немного другое значение. Теперь, когда мы выводим данные запроса, мы можем понять, почему из одного запроса браузера мы получаем несколько соединений, посмотрев на путь после `GET` в первой строке запроса. Если повторяющиеся соединения все запрашивают _/_, мы знаем, что браузер пытается повторно получить _/_, потому что не получает ответа от нашей программы.

Разберём данные этого запроса, чтобы понять, что браузер просит у нашей программы.
