# Слушаем TCP-соединение

Наше веб-серверу нужно слушать TCP-соединение, поэтому это будет первый этап нашей работы. Стандартная библиотека предоставляет модуль `std::net`, который позволяет нам это сделать. Создадим новый проект в обычном стиле:

```bash
$ cargo new hello
     Создан бинарный (приложение) проект `hello`
$ cd hello
```

Теперь вставьте код из Листинга 20-1 в `src/main.rs`, чтобы начать. Этот код будет слушать локальный адрес `127.0.0.1:7878` на входящие TCP-потоки. Когда он получает входящий поток, он выведет `Connection established!`.

Имя файла: `src/main.rs`

```rust
use std::net::TcpListener;

fn main() {
  1 let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

  2 for stream in listener.incoming() {
      3 let stream = stream.unwrap();

      4 println!("Connection established!");
    }
}
```

Листинг 20-1: Слушаем входящие потоки и выводим сообщение, когда получаем поток

С помощью `TcpListener` мы можем слушать TCP-соединения по адресу `127.0.0.1:7878` \[1\]. В этом адресе часть перед двоеточием - это IP-адрес, представляющий ваш компьютер (это одинаково на каждом компьютере и не относится конкретно к компьютеру авторов), а `7878` - это порт. Мы выбрали этот порт по двум причинам: HTTP обычно не принимается на этом порту, поэтому наш сервер不大 вероятен столкнуться с каким-либо другим веб-сервером, который может быть запущен на вашем компьютере, и 7878 - это _rust_, набранное на телефоне.

Функция `bind` в этом случае работает так же, как функция `new`, то есть она возвращает новый экземпляр `TcpListener`. Функция называется `bind`, потому что в сети подключение к порту для прослушивания называется "биндингом к порту".

Функция `bind` возвращает `Result<T, E>`, что означает, что возможно, что биндинг может неудачно завершиться. Например, подключение к порту 80 требует административных прав (нелокальные пользователи могут слушать только порты выше 1023), поэтому, если мы попытаемся подключиться к порту 80, не имея административных прав, биндинг не сработает. Кроме того, биндинг не сработает, если мы запустим два экземпляра нашей программы и будем пытаться слушать один и тот же порт. Поскольку мы пишем простой сервер только для учебных целей, мы не будем беспокоиться о обработке таких ошибок; вместо этого мы используем `unwrap`, чтобы остановить программу, если ошибки возникают.

Метод `incoming` на `TcpListener` возвращает итератор, который дает нам последовательность потоков \[2\] (более конкретно, потоки типа `TcpStream`). Один _поток_ представляет собой открытое соединение между клиентом и сервером. _Соединение_ - это название для всего процесса запросов и ответов, в котором клиент подключается к серверу, сервер генерирует ответ и сервер закрывает соединение. Таким образом, мы будем читать из `TcpStream`, чтобы увидеть, что клиент отправил, и затем записывать наш ответ в поток, чтобы отправить данные обратно клиенту. В целом, этот цикл `for` будет последовательно обрабатывать каждое соединение и создавать серию потоков для обработки.

На данный момент наша обработка потока заключается в вызове `unwrap`, чтобы завершить программу, если в потоке есть ошибки \[3\]; если ошибок нет, программа выводит сообщение \[4\]. В следующем листинге мы добавим больше функциональности для успешного случая. Причина, по которой мы можем получить ошибки от метода `incoming`, когда клиент подключается к серверу, заключается в том, что мы на самом деле не итерируемся по соединениям. Вместо этого мы итерируемся по _попыткам подключения_. Соединение может не быть успешным по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременно открытых соединений, которое они могут поддерживать; новые попытки подключения за пределами этого количества будут вызывать ошибку, пока не будут закрыты некоторые открытые соединения.

Попробуем запустить этот код! Вызовите `cargo run` в терминале, а затем загрузите _127.0.0.1:7878_ в веб-браузере. Браузер должен показать сообщение об ошибке, похожее на "Connection reset", потому что сервер в настоящее время не отправляет никаких данных обратно. Но когда вы смотрите в терминал, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключался к серверу!

         Запуск `target/debug/hello`
    Connection established!
    Connection established!
    Connection established!

Иногда вы можете увидеть несколько сообщений, напечатанных для одного запроса браузера; причина может быть в том, что браузер делает запрос на страницу, а также запрос на другие ресурсы, например, иконку _favicon.ico_, которая отображается в вкладке браузера.

Также может быть, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отвечает никакими данными. Когда `stream` выходит из области видимости и удаляется в конце цикла, соединение закрывается в рамках реализации `drop`. Браузеры иногда обрабатывают закрытые соединения путем повторной попытки, потому что проблема может быть временной. Главное, что мы успешно получили доступ к TCP-соединению!

Не забывайте останавливать программу, нажав ctrl-C, когда закончите запуск определенной версии кода. Затем перезапустите программу, вызвав команду `cargo run` после каждого набора изменений в коде, чтобы убедиться, что вы запускаете самую новую версию кода.
