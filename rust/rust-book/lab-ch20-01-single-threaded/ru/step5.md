# Отправка ответа

Мы собираемся реализовать отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:

    HTTP-версия Код-статуса Фраза-причины CRLF
    заголовки CRLF
    тело сообщения

Первая строка - это _строка статуса_, которая содержит версию HTTP, используемую в ответе, числовой код статуса, который суммаризирует результат запроса, и фразу-причину, которая дает текстовое описание кода статуса. После последовательности CRLF следуют любые заголовки, еще одна последовательность CRLF и тело ответа.

Вот пример ответа, который использует версию HTTP 1.1, имеет код статуса 200, фразу-причину OK, не имеет заголовков и не имеет тела:

```rust
HTTP/1.1 200 OK\r\n\r\n
```

Код статуса 200 - это стандартный успешный ответ. Текст - это минимальный успешный HTTP-ответ. Давайте запишем это в поток в качестве ответа на успешный запрос! В функции `handle_connection` удалите `println!`, который выводил данные запроса, и замените его кодом из Листинга 20-3.

Имя файла: `src/main.rs`

```rust
fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
     .lines()
     .map(|result| result.unwrap())
     .take_while(|line|!line.is_empty())
     .collect();

  1 let response = "HTTP/1.1 200 OK\r\n\r\n";

  2 stream.write_all(response.3 as_bytes()).unwrap();
}
```

Листинг 20-3: Отправка минимального успешного HTTP-ответа в поток

Первая новая строка определяет переменную `response`, которая хранит данные об успешном сообщении \[1\]. Затем мы вызываем `as_bytes` для нашей `response`, чтобы преобразовать строковые данные в байты \[3\]. Метод `write_all` на `stream` принимает `&[u8]` и отправляет эти байты непосредственно по соединению \[2\]. Поскольку операция `write_all` может завершиться неудачно, мы используем `unwrap` для любых ошибочных результатов, как и раньше. Опять же, в реальном приложении вы бы добавили обработку ошибок здесь.

После этих изменений запустим наш код и сделаем запрос. Теперь мы не выводим никаких данных в терминал, поэтому мы не увидим никакого вывода, кроме вывода от Cargo. Когда вы загрузите _127.0.0.1:7878_ в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали получение HTTP-запроса и отправку ответа!
