# Возвращение настоящего HTML

Реализуем функциональность для возврата более чем пустой страницы. Создайте новый файл _hello.html_ в корне каталога вашего проекта, а не в каталоге `src`. Вы можете ввести любой HTML, который хотите; Листинг 20-4 показывает один вариант.

Имя файла: `hello.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Hello!</title>
  </head>
  <body>
    <h1>Hello!</h1>
    <p>Hi from Rust</p>
  </body>
</html>
```

Листинг 20-4: Пример HTML-файла для возврата в ответе

Это минимальный HTML5-документ с заголовком и некоторым текстом. Чтобы вернуть его сервера при получении запроса, мы изменим `handle_connection`, как показано в Листинге 20-5, чтобы прочитать HTML-файл, добавить его в ответ в качестве тела и отправить.

Имя файла: `src/main.rs`

```rust
use std::{
  1 fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
};
--snip--

fn handle_connection(mut stream: TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
       .lines()
       .map(|result| result.unwrap())
       .take_while(|line|!line.is_empty())
       .collect();

    let status_line = "HTTP/1.1 200 OK";
    let contents = fs::read_to_string("hello.html").unwrap();
    let length = contents.len();

  2 let response = format!(
        "{status_line}\r\n\
         Content-Length: {length}\r\n\r\n\
         {contents}"
    );

    stream.write_all(response.as_bytes()).unwrap();
}
```

Листинг 20-5: Отправка содержимого _hello.html_ в качестве тела ответа

Мы добавили `fs` в инструкцию `use`, чтобы подключить модуль файловой системы стандартной библиотеки \[1\]. Код для чтения содержимого файла в строку должен выглядеть знакомым; мы использовали его, когда читали содержимое файла для нашего проекта по вводу-выводу в Листинге 12-4.

Далее мы используем `format!`, чтобы добавить содержимое файла в качестве тела успешного ответа \[2\]. Чтобы обеспечить валидный HTTP-ответ, мы добавляем заголовок `Content-Length`, который устанавливается равным размеру тела нашего ответа, в данном случае размеру `hello.html`.

Запустите этот код с помощью `cargo run` и загрузите _127.0.0.1:7878_ в вашем браузере; вы должны увидеть, как ваше HTML отображается!

В настоящее время мы игнорируем данные запроса в `http_request` и просто возвращаем содержимое HTML-файла无条件но. Это означает, что если вы попытаетесь запросить _127.0.0.1:7878/something-else_ в вашем браузере, вы по-прежнему получите этот же HTML-ответ. В настоящее время наш сервер очень ограничен и не делает то, что большинство веб-серверов делают. Мы хотим настроить наши ответы в зависимости от запроса и возвращать HTML-файл только для корректного запроса к _/_.
