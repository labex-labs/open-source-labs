# Тип среза

_Срезы_ позволяют ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию. Срез является типом ссылки, поэтому он не имеет владения.

Вот небольшая задача программирования: напишите функцию, которая принимает строку слов, разделенных пробелами, и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробела в строке, вся строка должна быть одним словом, поэтому вся строка должна быть возвращена.

Давайте разберем, как бы мы написали сигнатуру этой функции без использования срезов, чтобы понять проблему, которую срезы будут решать:

```rust
fn first_word(s: &String) ->?
```

Функция `first_word` имеет `&String` в качестве параметра. Мы не хотим владения, поэтому это нормально. Но что мы должны вернуть? Мы не имеем способа говорить о _части_ строки. Однако мы можем вернуть индекс конца слова, обозначенный пробелом. Давайте попробуем это, как показано в Листинге 4-7.

Имя файла: `src/main.rs`

```rust
fn first_word(s: &String) -> usize {
  1 let bytes = s.as_bytes();

    for (2 i, &item) in 3 bytes.iter().enumerate() {
      4 if item == b' ' {
            return i;
        }
    }

  5 s.len()
}
```

Листинг 4-7: Функция `first_word`, которая возвращает значение байтового индекса в параметре `String`

Поскольку нам нужно пройти по элементам `String` по одному и проверить, является ли значение пробелом, мы преобразуем нашу `String` в массив байтов с использованием метода `as_bytes` \[1\].

Далее мы создаем итератор по массиву байтов с использованием метода `iter` \[3\]. Мы поговорим о итераторах более подробно в главе 13. На данный момент просто запомните, что `iter` - это метод, который возвращает каждый элемент в коллекции, а `enumerate` оборачивает результат `iter` и возвращает каждый элемент в виде кортежа. Первый элемент кортежа, возвращаемый из `enumerate`, - это индекс, а второй элемент - это ссылка на элемент. Это немного удобнее, чем вычислять индекс самостоятельно.

Поскольку метод `enumerate` возвращает кортеж, мы можем использовать шаблоны для разбора этого кортежа. Мы поговорим о шаблонах более подробно в главе 6. В цикле `for` мы указываем шаблон, который имеет `i` для индекса в кортеже и `&item` для одного байта в кортеже \[2\]. Поскольку мы получаем ссылку на элемент из `.iter().enumerate()`, мы используем `&` в шаблоне.

Внутри цикла `for` мы ищем байт, представляющий пробел, с использованием синтаксиса литерала байта \[4\]. Если мы находим пробел, мы возвращаем позицию. В противном случае мы возвращаем длину строки с использованием `s.len()` \[5\].

Теперь у нас есть способ узнать индекс конца первого слова в строке, но есть проблема. Мы возвращаем `usize` самостоятельно, но это имеет смысл только в контексте `&String`. Другими словами, поскольку это отдельное значение от `String`, не гарантируется, что оно по-прежнему будет действительным в будущем. Рассмотрите программу в Листинге 4-8, которая использует функцию `first_word` из Листинга 4-7.

    // src/main.rs
    fn main() {
        let mut s = String::from("hello world");

        let word = first_word(&s); // word получит значение 5

        s.clear(); // это очищает String, делая его равным ""

        // word по-прежнему имеет значение 5 здесь, но больше нет строки,
        // с которой мы могли бы смыслfully использовать значение 5. word теперь совершенно недействителен!
    }

Листинг 4-8: Сохранение результата вызова функции `first_word` и затем изменение содержимого `String`

Эта программа компилируется без ошибок и также это сделает, если мы будем использовать `word` после вызова `s.clear()`. Поскольку `word` не связан с состоянием `s` вовсе, `word` по-прежнему содержит значение `5`. Мы могли бы использовать это значение `5` с переменной `s`, чтобы попробовать извлечь первое слово, но это будет ошибкой, потому что содержимое `s` изменилось с тех пор, как мы сохранили `5` в `word`.

Быть вынужденным беспокоиться о том, чтобы индекс в `word` не выйти из синхронизации с данными в `s`, - это утомительно и подвержено ошибкам! Управление этими индексами еще более хрупко, если мы напишем функцию `second_word`. Его сигнатура должна выглядеть так:

```rust
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем начальный _и_ конечный индексы, и у нас есть еще больше значений, которые были вычислены из данных в определенном состоянии, но не связаны с этим состоянием вовсе. У нас есть три не связанных переменные, которые нужно синхронизировать.

К счастью, у Rust есть решение этой проблемы: строковые срезы.
