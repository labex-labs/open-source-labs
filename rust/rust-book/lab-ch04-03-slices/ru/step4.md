# Строковые срезы в качестве параметров

Знание того, что можно брать срезы литералов и значений `String`, приводит нас к еще одному улучшению в `first_word`, а именно к его сигнатуре:

```rust
fn first_word(s: &String) -> &str {
```

Более опытный Rustacean вместо этого напишет сигнатуру, показанную в Листинге 4-9, потому что это позволяет использовать ту же функцию как для значений `&String`, так и для значений `&str`.

```rust
fn first_word(s: &str) -> &str {
```

Листинг 4-9: Улучшение функции `first_word` путем использования строкового среза для типа параметра `s`

Если у нас есть строковый срез, мы можем передать его напрямую. Если у нас есть `String`, мы можем передать срез `String` или ссылку на `String`. Эта гибкость использует _преобразования по неявному разыменованию_, функцию, которую мы рассмотрим в разделе "Неявные преобразования по разыменованию с функциями и методами".

Определение функции, которая принимает строковый срез вместо ссылки на `String`, делает наш API более общим и полезным, не теряя при этом никакой функциональности:

Имя файла: `src/main.rs`

```rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` работает с срезами `String`, как частичными,
    // так и целыми
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` также работает с ссылками на `String`, которые
    // эквивалентны целым срезам `String`
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` работает с срезами строковых литералов,
    // как частичными, так и целыми
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Поскольку строковые литералы *уже являются* строковыми срезами,
    // это также работает, без синтаксиса среза!
    let word = first_word(my_string_literal);
}
```
