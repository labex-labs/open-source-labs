# Строковые срезы

_Строковый срез_ - это ссылка на часть `String`, и он выглядит так:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Вместо ссылки на всю `String`, `hello` - это ссылка на часть `String`, указанную в дополнительном фрагменте `[0..5]`. Мы создаем срезы с использованием диапазона в квадратных скобках, указывая `[starting_index..ending_index]`, где `starting_index` - это первая позиция в срезе, а `ending_index` - на единицу больше последней позиции в срезе. Внутри структуры данных среза хранится начальная позиция и длина среза, которая соответствует `ending_index` минус `starting_index`. Таким образом, в случае `let world = &s[6..11];`, `world` будет срезом, содержащим указатель на байт с индексом 6 в `s` с значением длины `5`.

Рисунок 4-6 показывает это в виде схемы.

Рисунок 4-6: Строковый срез, ссылающийся на часть `String`

С использованием синтаксиса диапазона `..` в Rust, если вы хотите начать с индекса 0, вы можете опустить значение перед двумя точками. Другими словами, эти записи равны:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

По тем же причинам, если ваш срез включает последний байт `String`, вы можете опустить конечное число. Это означает, что эти записи равны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Вы также можете опустить оба значения, чтобы взять срез всей строки. Поэтому эти записи равны:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> Примечание: Индексы диапазона строкового среза должны находиться на допустимых границах UTF-8-символов. Если вы попытаетесь создать строковый срез в середине многобайтового символа, ваша программа будет завершаться с ошибкой. В целях введения строковых срезов в этом разделе мы предполагаем только ASCII; более подробное обсуждение обработки UTF-8 находится в разделе "Сохранение текста, закодированного в UTF-8, с использованием строк".

С учетом всей этой информации, давайте перепишем `first_word`, чтобы возвращать срез. Тип, означающий "строковый срез", записывается как `&str`:

Имя файла: `src/main.rs`

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Мы получаем индекс конца слова так же, как и в Листинге 4-7, ищем первое вхождение пробела. Когда мы находим пробел, мы возвращаем строковый срез, используя начало строки и индекс пробела в качестве начальных и конечных индексов.

Теперь, когда мы вызываем `first_word`, мы получаем обратно одно значение, которое связано с базовыми данными. Значение состоит из ссылки на начальную точку среза и количества элементов в срезе.

Возвращение среза также будет работать для функции `second_word`:

```rust
fn second_word(s: &String) -> &str {
```

Теперь у нас есть простой API, который гораздо сложнее испортить, потому что компилятор обеспечит, чтобы ссылки в `String` оставались валидными. Помните об ошибке в программе из Листинга 4-8, когда мы получили индекс до конца первого слова, а затем очистили строку, так что наш индекс стал недействительным? Код был логически неправильным, но не показывал никаких ошибок сразу. Проблемы могли бы появиться позже, если мы продолжали пытаться использовать индекс первого слова с пустой строкой. Срезы делают эту ошибку невозможной и позволяют нам узнать о проблеме в нашем коде гораздо раньше. Использование срезной версии `first_word` вызовет ошибку компиляции:

Имя файла: `src/main.rs`

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // ошибка!

    println!("the first word is: {word}");
}
```

Вот ошибка компилятора:

```bash
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                   ---- immutable borrow later used here
```

Помните из правил заимствования, что если у нас есть неизменяемая ссылка на что-то, мы не можем одновременно получить изменяемую ссылку. Поскольку `clear` должен обрезать `String`, ему нужно получить изменяемую ссылку. `println!` после вызова `clear` использует ссылку в `word`, поэтому неизменяемая ссылка должна по-прежнему быть активной в этот момент. Rust не позволяет существовать одновременно изменяемой ссылке в `clear` и неизменяемой ссылке в `word`, и компиляция завершается с ошибкой. Не только Rust упростил использование нашего API, но и избавился от целого класса ошибок на этапе компиляции!
