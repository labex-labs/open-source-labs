# スライス型

**スライス**を使うと、コレクション全体ではなく、コレクション内の連続した要素のシーケンスを参照できます。スライスは一種の参照なので、所有権を持っていません。

以下は、小さなプログラミング問題です。空白で区切られた単語の文字列を受け取り、その文字列で見つけた最初の単語を返す関数を書きましょう。関数が文字列内に空白を見つけない場合、文字列全体が 1 つの単語なので、文字列全体を返す必要があります。

スライスを使わずにこの関数のシグネチャを書く方法を考えてみましょう。これにより、スライスが解決する問題を理解できます。

```rust
fn first_word(s: &String) ->?
```

`first_word`関数は、パラメータとして`&String`を持っています。所有権を必要としないので、これは問題ありません。しかし、何を返すべきでしょうか？文字列の一部を表す方法がありません。ただし、空白で示される単語の末尾のインデックスを返すことができます。これを試してみましょう。リスト 4-7 を参照してください。

ファイル名：`src/main.rs`

```rust
fn first_word(s: &String) -> usize {
  1 let bytes = s.as_bytes();

    for (2 i, &item) in 3 bytes.iter().enumerate() {
      4 if item == b' ' {
            return i;
        }
    }

  5 s.len()
}
```

リスト 4-7: `String`パラメータに対してバイトインデックス値を返す`first_word`関数

`String`の要素を 1 つずつ調べ、値が空白かどうかを確認する必要があるため、`as_bytes`メソッドを使って`String`をバイト配列に変換します\[1\]。

次に、`iter`メソッドを使ってバイト配列のイテレータを作成します\[3\]。第 13 章でイテレータについて詳しく説明します。今のところ、`iter`はコレクション内の各要素を返すメソッドであり、`enumerate`は`iter`の結果をラップし、各要素をタプルの一部として返すことを知っておいてください。`enumerate`から返されるタプルの最初の要素はインデックスで、2 番目の要素は要素への参照です。これは、自分でインデックスを計算するよりも便利です。

`enumerate`メソッドはタプルを返すので、パターンを使ってそのタプルを分解できます。第 6 章でパターンについてもっと説明します。`for`ループでは、タプル内のインデックス用の`i`と、タプル内の 1 バイト用の`&item`を持つパターンを指定します\[2\]。`.iter().enumerate()`から要素への参照を取得するので、パターンで`&`を使います。

`for`ループの中では、バイトリテラル構文を使って空白を表すバイトを探します\[4\]。空白を見つけた場合は、その位置を返します。それ以外の場合は、`s.len()`を使って文字列の長さを返します\[5\]。

これで、文字列内の最初の単語の末尾のインデックスを取得する方法ができましたが、問題があります。`usize`を単独で返していますが、`&String`のコンテキストでのみ意味のある数値です。つまり、`String`とは別の値なので、将来も有効であることが保証されていません。リスト 4-7 の`first_word`関数を使ったリスト 4-8 のプログラムを見てみましょう。

    // src/main.rs
    fn main() {
        let mut s = String::from("hello world");

        let word = first_word(&s); // wordには5が代入されます

        s.clear(); // これでStringが空になり、""に等しくなります

        // ここでもwordにはまだ5が入っていますが、5を意味のある形で使える文字列はもうありません。wordはもはや完全に無効です！
    }

リスト 4-8: `first_word`関数を呼び出して結果を格納し、その後`String`の内容を変更する

このプログラムはエラーなくコンパイルされます。`s.clear()`を呼び出した後に`word`を使っても同じことが起こります。`word`は`s`の状態にまったく関連付けられていないので、`word`にはまだ`5`の値が入っています。`word`に保存された`5`を使って`変数s`から最初の単語を抽出しようとすると、バグになります。なぜなら、`word`に`5`を保存してから`s`の内容が変更されているからです。

`word`のインデックスが`s`のデータと同期しなくなることを心配するのは面倒くさく、エラーが発生しやすいです！`second_word`関数を書く場合、インデックスの管理はさらに脆弱になります。そのシグネチャはこのようになります。

```rust
fn second_word(s: &String) -> (usize, usize) {
```

これで、開始インデックスと終了インデックスの両方を追跡しています。そして、特定の状態のデータから計算された値がさらに増えましたが、その状態にまったく関連付けられていません。同期を保つ必要がある、無関係な 3 つの変数があります。

幸い、Rust にはこの問題の解決策があります。文字列スライスです。
