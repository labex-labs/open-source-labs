# 文字列スライス

**文字列スライス**は、`String`の一部への参照で、次のようになります。

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

`hello`は、`String`全体への参照ではなく、`String`の一部への参照で、追加の`[0..5]`部分で指定されます。スライスは、角括弧内の範囲を使って`[開始インデックス..終了インデックス]`を指定することで作成されます。ここで、`開始インデックス`はスライスの最初の位置で、`終了インデックス`はスライスの最後の位置より1つ多い位置です。内部的には、スライスデータ構造は開始位置とスライスの長さを保存します。これは、`終了インデックス`から`開始インデックス`を引いた値に相当します。したがって、`let world = &s[6..11];`の場合、`world`は、`s`のインデックス6のバイトへのポインタと長さ値5を持つスライスになります。

図4-6は、これを図示したものです。

図4-6: `String`の一部を参照する文字列スライス

Rustの`..`範囲構文を使うと、インデックス0から始める場合、2つのピリオドの前の値を省略できます。つまり、次の2つは等価です。

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

同様に、スライスが`String`の最後のバイトを含む場合、末尾の数字を省略できます。つまり、次の2つは等価です。

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

また、両方の値を省略して、文字列全体のスライスを取得することもできます。したがって、次の2つは等価です。

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

> 注: 文字列スライスの範囲インデックスは、有効なUTF-8文字境界で発生する必要があります。マルチバイト文字の途中で文字列スライスを作成しようとすると、プログラムはエラーで終了します。文字列スライスを紹介する目的で、このセクションではASCIIのみを想定しています。UTF-8の処理に関するより詳細な議論は、「文字列でUTF-8エンコードされた文字列を保存する」で行われます。

これらのことを心に留めて、`first_word`を書き直してスライスを返すようにしましょう。「文字列スライス」を表す型は`&str`と書かれます。

ファイル名: `src/main.rs`

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

最初の空白の最初の出現箇所を探すことで、リスト4-7と同じ方法で単語の末尾のインデックスを取得します。空白を見つけたときは、文字列の先頭と空白のインデックスを開始インデックスと終了インデックスとして使って文字列スライスを返します。

これで、`first_word`を呼び出すと、基礎データに関連付けられた単一の値が返されます。この値は、スライスの開始点への参照とスライス内の要素数で構成されています。

スライスを返すことは、`second_word`関数にも機能します。

```rust
fn second_word(s: &String) -> &str {
```

これで、コンパイラが`String`への参照が有効なままであることを保証するため、混乱しにくいシンプルなAPIができました。リスト4-8のプログラムのバグを思い出してください。最初の単語の末尾のインデックスを取得した後、文字列をクリアしてインデックスが無効になってしまったときです。そのコードは論理的に誤っていましたが、即座にエラーを表示しませんでした。空になった文字列を使って最初の単語のインデックスを使い続けると、後で問題が発生します。スライスを使うことで、このバグを防ぐことができ、コードに問題があることをはるかに早く知ることができます。`first_word`のスライスバージョンを使うと、コンパイル時エラーが発生します。

ファイル名: `src/main.rs`

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // エラー！

    println!("the first word is: {word}");
}
```

コンパイラエラーは次のとおりです。

```bash
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {word}");
   |                                   ---- immutable borrow later used here
```

借用規則を思い出してください。何かに対する不変参照を持っている場合、可変参照も取得できません。`clear`は`String`をトリムする必要があるため、可変参照を取得する必要があります。`clear`の呼び出しの後の`println!`は、`word`の参照を使っています。したがって、不変参照はその時点でまだ有効でなければなりません。Rustは、`clear`の可変参照と`word`の不変参照が同時に存在することを許可せず、コンパイルが失敗します。Rustは、APIを使いやすくするだけでなく、コンパイル時に完全なエラークラスを排除しました！
