# 切片类型

切片允许你引用集合中元素的连续序列，而不是整个集合。切片是一种引用，所以它不拥有所有权。

这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回在该字符串中找到的第一个单词。如果函数在字符串中没有找到空格，那么整个字符串必须是一个单词，所以应该返回整个字符串。

让我们逐步了解如何在不使用切片的情况下编写这个函数的签名，以便理解切片将解决的问题：

```rust
fn first_word(s: &String) ->?
```

`first_word` 函数有一个 `&String` 作为参数。我们不想要所有权，所以这样没问题。但是我们应该返回什么呢？我们实际上没有办法谈论字符串的一部分。然而，我们可以返回单词结束的索引，由空格表示。让我们试试，如清单4-7所示。

文件名：`src/main.rs`

```rust
fn first_word(s: &String) -> usize {
  1 let bytes = s.as_bytes();

    for (2 i, &item) in 3 bytes.iter().enumerate() {
      4 if item == b' ' {
            return i;
        }
    }

  5 s.len()
}
```

清单4-7：`first_word` 函数，它返回 `String` 参数中的字节索引值

因为我们需要逐个遍历 `String` 的元素并检查某个值是否是空格，所以我们将使用 `as_bytes` 方法将 `String` 转换为字节数组 \[1\]。

接下来，我们使用 `iter` 方法创建一个字节数组的迭代器 \[3\]。我们将在第13章更详细地讨论迭代器。目前，要知道 `iter` 是一个返回集合中每个元素的方法，而 `enumerate` 包装了 `iter` 的结果，并将每个元素作为元组的一部分返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是对该元素的引用。这比我们自己计算索引要方便一些。

因为 `enumerate` 方法返回一个元组，所以我们可以使用模式来解构该元组。我们将在第6章更详细地讨论模式。在 `for` 循环中，我们指定一个模式，元组中的索引用 `i` 表示，元组中的单个字节用 `&item` 表示 \[2\]。因为我们从 `.iter().enumerate()` 中得到了对元素的引用，所以我们在模式中使用 `&`。

在 `for` 循环内部，我们使用字节字面量语法搜索表示空格的字节 \[4\]。如果我们找到一个空格，就返回位置。否则，我们使用 `s.len()` 返回字符串的长度 \[5\]。

现在我们有了一种方法来找出字符串中第一个单词结束的索引，但有一个问题。我们单独返回一个 `usize`，但它只有在 `&String` 的上下文中才有意义。换句话说，因为它是与 `String` 分开的值，所以不能保证它在未来仍然有效。考虑清单4-8中的程序，它使用了清单4-7中的 `first_word` 函数。

    // src/main.rs
    fn main() {
        let mut s = String::from("hello world");

        let word = first_word(&s); // word 将得到值 5

        s.clear(); // 这会清空 String，使其等于 ""

        // 这里 word 仍然有值 5，但没有更多的字符串可以有意义地使用值 5 了。word 现在完全无效！
    }

清单4-8：调用 `first_word` 函数并存储结果，然后更改 `String` 的内容

这个程序编译时没有任何错误，如果我们在调用 `s.clear()` 后使用 `word`，它也会编译通过。因为 `word` 与 `s` 的状态完全没有关联，所以 `word` 仍然包含值 `5`。我们可以使用那个值 `5` 和变量 `s` 来尝试提取第一个单词，但这会是一个错误，因为自从我们在 `word` 中保存 `5` 以来，`s` 的内容已经改变了。

必须担心 `word` 中的索引与 `s` 中的数据不同步既繁琐又容易出错！如果我们编写一个 `second_word` 函数，管理这些索引会更脆弱。它的签名必须如下所示：

```rust
fn second_word(s: &String) -> (usize, usize) {
```

现在我们要跟踪一个起始索引和一个结束索引，并且有更多从特定状态的数据计算出来但与该状态完全没有关联的值。我们有三个不相关的变量在四处浮动，需要保持同步。

幸运的是，Rust 有解决这个问题的办法：字符串切片。
