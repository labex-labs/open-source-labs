# The Slice Type (슬라이스 타입)

*Slices*는 전체 컬렉션 대신 컬렉션 내의 연속된 요소 시퀀스를 참조할 수 있게 해줍니다. 슬라이스는 일종의 참조이므로 소유권을 갖지 않습니다.

다음은 작은 프로그래밍 문제입니다. 공백으로 구분된 단어 문자열을 입력받아 해당 문자열에서 처음 발견되는 단어를 반환하는 함수를 작성합니다. 함수가 문자열에서 공백을 찾지 못하면 전체 문자열이 하나의 단어여야 하므로 전체 문자열을 반환해야 합니다.

슬라이스를 사용하지 않고 이 함수의 시그니처를 작성하는 방법을 살펴보고, 슬라이스가 해결할 문제를 이해해 보겠습니다.

```rust
fn first_word(s: &String) -> ?
```

`first_word` 함수는 `&String`을 매개변수로 받습니다. 소유권을 원하지 않으므로 괜찮습니다. 하지만 무엇을 반환해야 할까요? 문자열의 *일부*에 대해 이야기할 방법이 실제로 없습니다. 하지만 공백으로 표시된 단어의 끝 인덱스를 반환할 수 있습니다. Listing 4-7 에 표시된 대로 시도해 보겠습니다.

파일 이름: `src/main.rs`

```rust
fn first_word(s: &String) -> usize {
  1 let bytes = s.as_bytes();

    for (2 i, &item) in 3 bytes.iter().enumerate() {
      4 if item == b' ' {
            return i;
        }
    }

  5 s.len()
}
```

Listing 4-7: `String` 매개변수에 대한 바이트 인덱스 값을 반환하는 `first_word` 함수

`String`을 요소별로 살펴보고 값이 공백인지 확인해야 하므로 `as_bytes` 메서드 \[1]를 사용하여 `String`을 바이트 배열로 변환합니다.

다음으로, `iter` 메서드 \[3]를 사용하여 바이트 배열에 대한 반복자를 생성합니다. 13 장에서 반복자에 대해 자세히 논의할 것입니다. 지금은 `iter`가 컬렉션의 각 요소를 반환하는 메서드이고, `enumerate`가 `iter`의 결과를 래핑하여 각 요소를 튜플의 일부로 반환한다는 것을 알아두세요. `enumerate`에서 반환된 튜플의 첫 번째 요소는 인덱스이고, 두 번째 요소는 요소에 대한 참조입니다. 이는 인덱스를 직접 계산하는 것보다 약간 더 편리합니다.

`enumerate` 메서드는 튜플을 반환하므로 패턴을 사용하여 해당 튜플을 분해할 수 있습니다. 6 장에서 패턴에 대해 더 자세히 논의할 것입니다. `for` 루프에서 튜플의 인덱스에 대해 `i`를, 튜플의 단일 바이트에 대해 `&item`을 갖는 패턴을 지정합니다 \[2]. `.iter().enumerate()`에서 요소에 대한 참조를 얻으므로 패턴에서 `&`를 사용합니다.

`for` 루프 내에서 바이트 리터럴 구문 \[4]을 사용하여 공백을 나타내는 바이트를 검색합니다. 공백을 찾으면 위치를 반환합니다. 그렇지 않으면 `s.len()` \[5]을 사용하여 문자열의 길이를 반환합니다.

이제 문자열에서 첫 번째 단어의 끝 인덱스를 찾는 방법이 있지만 문제가 있습니다. `usize`를 단독으로 반환하지만 `&String`의 컨텍스트에서만 의미 있는 숫자입니다. 즉, `String`과 별도의 값이므로 미래에도 유효하다는 보장이 없습니다. Listing 4-8 의 `first_word` 함수를 사용하는 프로그램을 생각해 보세요.

    // src/main.rs
    fn main() {
        let mut s = String::from("hello world");

        let word = first_word(&s); // word will get the value 5

        s.clear(); // this empties the String, making it equal to ""

        // word still has the value 5 here, but there's no more string that
        // we could meaningfully use the value 5 with. word is now totally invalid!
    }

Listing 4-8: `first_word` 함수를 호출한 결과 저장 후 `String` 내용 변경

이 프로그램은 오류 없이 컴파일되며, `s.clear()`를 호출한 후 `word`를 사용하더라도 마찬가지입니다. `word`는 `s`의 상태와 전혀 연결되지 않으므로 `word`는 여전히 값 `5`를 포함합니다. 변수 `s`와 함께 값 `5`를 사용하여 첫 번째 단어를 추출하려고 할 수 있지만, `word`에 `5`를 저장한 이후 `s`의 내용이 변경되었으므로 이는 버그가 됩니다.

`word`의 인덱스가 `s`의 데이터와 동기화되지 않는 것에 대해 걱정해야 하는 것은 지루하고 오류가 발생하기 쉽습니다! `second_word` 함수를 작성하면 이러한 인덱스를 관리하는 것이 훨씬 더 취약해집니다. 해당 시그니처는 다음과 같아야 합니다.

```rust
fn second_word(s: &String) -> (usize, usize) {
```

이제 시작 _및_ 종료 인덱스를 추적하고 특정 상태의 데이터에서 계산되었지만 해당 상태와 전혀 연결되지 않은 값이 더 많습니다. 동기화해야 하는 세 개의 관련 없는 변수가 있습니다.

다행히 Rust 에는 이 문제에 대한 해결책이 있습니다: 문자열 슬라이스입니다.
