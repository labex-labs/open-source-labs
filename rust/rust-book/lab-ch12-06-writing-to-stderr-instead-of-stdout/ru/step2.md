# Проверка, куда записываются ошибки

Сначала давайте посмотрим, как содержимое, выводимое `minigrep`, в настоящее время записывается в стандартный вывод, включая любые сообщения об ошибках, которые мы хотели бы записать в стандартный вывод ошибок вместо этого. Мы сделаем это, перенаправляя поток стандартного вывода в файл, в то время как намеренно вызываем ошибку. Мы не будем перенаправлять поток стандартного вывода ошибок, поэтому любое содержимое, отправляемое в стандартный вывод ошибок, будет продолжать отображаться на экране.

Ожидается, что командные строки программы будут отправлять сообщения об ошибках в поток стандартного вывода ошибок, чтобы мы могли по-прежнему видеть сообщения об ошибках на экране, даже если мы перенаправляем поток стандартного вывода в файл. Наша программа в настоящее время не работает правильно: мы вскоре увидим, что она сохраняет вывод сообщения об ошибке в файл вместо этого!

Для демонстрации этого поведения мы запустим программу с `>` и путём к файлу, _output.txt_, на который мы хотим перенаправить поток стандартного вывода. Мы не передадим никаких аргументов, что должно вызвать ошибку:

```bash
cargo run > output.txt
```

Синтаксис `>` сообщает оболочке записать содержимое стандартного вывода в _output.txt_ вместо экрана. Мы не увидели сообщение об ошибке, которое мы ожидали, напечатанное на экране, поэтому это означает, что оно, должно быть, окончалось в файле. Вот что содержит _output.txt_:

```rust
Problem parsing arguments: not enough arguments
```

Да, наше сообщение об ошибке выводится в стандартный вывод. гораздо более полезно, чтобы сообщения об ошибках такого рода выводились в стандартный вывод ошибок, так что только данные из успешного выполнения окончаются в файле. Мы исправим это.
