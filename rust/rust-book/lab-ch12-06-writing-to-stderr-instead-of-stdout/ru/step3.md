# Вывод ошибок в стандартный вывод ошибок

Мы будем использовать код из Листинга 12-24, чтобы изменить способ вывода сообщений об ошибках. В силу рефакторинга, который мы провели ранее в этом разделе, весь код, который выводит сообщения об ошибках, находится в одной функции `main`. Стандартная библиотека предоставляет макрос `eprintln!`, который выводит в поток стандартного вывода ошибок, поэтому давайте изменим два места, где мы вызывали `println!` для вывода ошибок, чтобы использовать `eprintln!` вместо этого.

Имя файла: `src/main.rs`

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

Листинг 12-24: Запись сообщений об ошибках в стандартный вывод ошибок вместо стандартного вывода с использованием `eprintln!`

Теперь давайте снова запустим программу так же, без каких-либо аргументов и перенаправляя стандартный вывод с помощью `>`:

```bash
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

Теперь мы видим ошибку на экране, а в _output.txt_ ничего не содержится, что является поведением, которое мы ожидаем от командных строк.

Давайте снова запустим программу с аргументами, которые не вызывают ошибку, но по-прежнему перенаправляют стандартный вывод в файл, вот так:

```bash
cargo run -- to poem.txt > output.txt
```

Мы не увидим никакого вывода в терминал, а в _output.txt_ будут содержаться наши результаты:

Имя файла: output.txt

```rust
Are you nobody, too?
How dreary to be somebody!
```

Это показывает, что мы теперь используем стандартный вывод для успешного вывода и стандартный вывод ошибок для вывода ошибок по-прежнему.
