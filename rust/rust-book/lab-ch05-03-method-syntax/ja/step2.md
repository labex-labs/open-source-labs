# メソッドの定義

`Rectangle`インスタンスをパラメータとして持つ`area`関数を変更し、代わりに`Rectangle`構造体に定義された`area`メソッドにしましょう。リスト 5-13 に示すようになります。

ファイル名：`src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

1 impl Rectangle {
  2 fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
      3 rect1.area()
    );
}
```

リスト 5-13: `Rectangle`構造体に`area`メソッドを定義する

`Rectangle`のコンテキスト内で関数を定義するには、`Rectangle`用の`impl`（実装）ブロックを開始します\[1\]。この`impl`ブロック内のすべてのものは`Rectangle`型に関連付けられます。次に、`area`関数を`impl`の波括弧内に移動し\[2\]、シグネチャと本体のどこでも最初の（この場合は唯一の）パラメータを`self`に変更します。`main`では、`area`関数を呼び出して`rect1`を引数として渡していましたが、代わりにメソッド構文を使用して`Rectangle`インスタンスの`area`メソッドを呼び出すことができます\[3\]。メソッド構文はインスタンスの後に続きます。ドットを追加し、その後にメソッド名、丸括弧、および任意の引数を追加します。

`area`のシグネチャでは、`&self`を使用して`rectangle: &Rectangle`の代わりにします。`&self`は実際には`self: &Self`の省略形です。`impl`ブロック内では、型`Self`は`impl`ブロックが対象とする型のエイリアスです。メソッドは最初のパラメータとして`Self`型の`self`という名前のパラメータを持たなければなりません。そのため、Rust は最初のパラメータの場所でこれを`self`という名前だけで省略することができます。ただし、`self`の省略形の前に`&`を使用する必要があります。これは、このメソッドが`Self`インスタンスを借用することを示すためで、`rectangle: &Rectangle`の場合と同じです。メソッドは`self`の所有権を取得することができ、ここで行ったように`self`を不変に借用することも、`self`を可変に借用することもできます。他のパラメータと同じようにです。

ここで`&self`を選んだ理由は、関数バージョンで`&Rectangle`を使用した理由と同じです。所有権を取得したくなく、構造体のデータを読み取るだけで書き込みたくないからです。メソッドの一部としてメソッドを呼び出したインスタンスを変更したい場合、最初のパラメータとして`&mut self`を使用します。最初のパラメータとして単に`self`を使用してインスタンスの所有権を取得するメソッドはまれです。この技術は、通常、メソッドが`self`を別のものに変換し、変換後に呼び出し元が元のインスタンスを使用できなくなるようにするために使用されます。

関数の代わりにメソッドを使用する主な理由は、メソッド構文を提供し、各メソッドのシグネチャで`self`の型を繰り返さなくて済むことに加えて、組織化のためです。型のインスタンスでできることすべてを 1 つの`impl`ブロックにまとめており、提供するライブラリのさまざまな場所で`Rectangle`の機能を探す必要がなくなります。

構造体のフィールドと同じ名前のメソッドを与えることができることに注意してください。たとえば、`Rectangle`にも`width`という名前のメソッドを定義できます。

ファイル名：`src/main.rs`

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(
            "The rectangle has a nonzero width; it is {}",
            rect1.width
        );
    }
}
```

ここでは、インスタンスの`width`フィールドの値が 0 より大きい場合、`width`メソッドが`true`を返し、値が 0 の場合に`false`を返すように選択しています。同じ名前のメソッド内のフィールドを任意の目的に使用できます。`main`では、`rect1.width`の後に丸括弧を付けると、Rust は`width`メソッドを意味することを知ります。丸括弧を使用しない場合、Rust は`width`フィールドを意味することを知ります。

多くの場合、フィールドと同じ名前のメソッドを与えるとき、それがフィールドの値だけを返して何もしないようにします。このようなメソッドは「ゲッター」と呼ばれ、Rust は他の言語のように構造体フィールドに対して自動的に実装しません。ゲッターは便利です。フィールドを非公開にすることができますが、メソッドを公開にすることができるため、型の公開 API の一部としてそのフィールドへの読み取り専用アクセスを可能にします。第 7 章では、公開と非公開とは何か、およびフィールドまたはメソッドを公開または非公開に指定する方法について説明します。

> **->演算子はどこにありますか？**
>
> C と C++ では、メソッドを呼び出すために 2 つの異なる演算子が使用されます。オブジェクト自体にメソッドを呼び出す場合は`.`を使用し、オブジェクトへのポインタにメソッドを呼び出して最初にポインタを解引用する必要がある場合は`->`を使用します。言い換えると、`object`がポインタの場合、`object->`something`()`は`(*object).`something`()`に似ています。
>
> Rust には`->`演算子に相当するものはありません。代わりに、Rust には「自動参照と解引用」と呼ばれる機能があります。メソッドを呼び出すことは、この動作を持つ Rust の少数の場所の 1 つです。
>
> 動作の仕方は次のとおりです。`object.`something`()`でメソッドを呼び出すと、Rust は自動的に`&`、`&mut`、または`*`を追加して、`object`がメソッドのシグネチャに一致するようにします。言い換えると、次の 2 つは同じです。
>
>     p1.distance(&p2);
>     (&p1).distance(&p2);
>
> 最初の方がはるかにクリーンに見えます。この自動参照動作が機能するのは、メソッドには明確なレシーバー（`self`の型）があるからです。メソッドのレシーバーと名前が与えられると、Rust はメソッドが読み取り（`&self`）、変更（`&mut self`）、または消費（`self`）しているかどうかを確定的に判断できます。Rust がメソッドレシーバーに対する借用を暗黙的に行うことは、所有権を実践的に使いやすくするための大きな要素の 1 つです。
