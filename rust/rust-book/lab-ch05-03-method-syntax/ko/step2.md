# 메서드 정의하기

Listing 5-13 에 나와 있는 것처럼, `Rectangle` 인스턴스를 매개변수로 받는 `area` 함수를 변경하여 `Rectangle` 구조체에 정의된 `area` 메서드를 만들어 보겠습니다.

파일 이름: `src/main.rs`

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

1 impl Rectangle {
  2 fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
      3 rect1.area()
    );
}
```

Listing 5-13: `Rectangle` 구조체에 `area` 메서드 정의하기

`Rectangle`의 컨텍스트 내에서 함수를 정의하려면, `Rectangle`에 대한 `impl` (구현) 블록을 시작합니다 \[1]. 이 `impl` 블록 내의 모든 것은 `Rectangle` 타입과 연관됩니다. 그런 다음 `area` 함수를 `impl` 중괄호 내로 옮기고 \[2], 첫 번째 (그리고 이 경우 유일한) 매개변수를 시그니처와 본문 내 모든 곳에서 `self`로 변경합니다. `main`에서 `area` 함수를 호출하고 `rect1`을 인수로 전달했던 곳에서, 대신 *메서드 구문*을 사용하여 `Rectangle` 인스턴스에 대한 `area` 메서드를 호출할 수 있습니다 \[3]. 메서드 구문은 인스턴스 뒤에 옵니다: 점 (.) 을 추가하고, 그 뒤에 메서드 이름, 괄호, 그리고 모든 인수를 추가합니다.

`area`의 시그니처에서 `rectangle: &Rectangle` 대신 `&self`를 사용합니다. `&self`는 실제로 `self: &Self`의 축약형입니다. `impl` 블록 내에서 `Self` 타입은 `impl` 블록이 속한 타입의 별칭입니다. 메서드는 첫 번째 매개변수로 `Self` 타입의 `self`라는 매개변수를 가져야 하므로, Rust 는 첫 번째 매개변수 위치에서 이름 `self`만 사용하여 이를 줄여 쓸 수 있도록 합니다. 여전히 `rectangle: &Rectangle`에서 했던 것처럼, 이 메서드가 `Self` 인스턴스를 빌린다는 것을 나타내기 위해 `self` 축약형 앞에 `&`를 사용해야 합니다. 메서드는 다른 매개변수와 마찬가지로 `self`의 소유권을 가져오거나, 불변으로 `self`를 빌리거나, 가변으로 `self`를 빌릴 수 있습니다.

함수 버전에서 `&Rectangle`을 사용했던 것과 같은 이유로 여기에서 `&self`를 선택했습니다: 소유권을 가져오고 싶지 않고, 구조체의 데이터를 읽기만 원하며, 쓰기는 원하지 않습니다. 메서드가 수행하는 작업의 일부로 메서드를 호출한 인스턴스를 변경하려면, 첫 번째 매개변수로 `&mut self`를 사용합니다. 첫 번째 매개변수로 `self`만 사용하여 인스턴스의 소유권을 가져가는 메서드는 드뭅니다; 이 기술은 일반적으로 메서드가 `self`를 다른 것으로 변환하고 변환 후 호출자가 원래 인스턴스를 사용하지 못하도록 하려는 경우에 사용됩니다.

메서드 구문을 제공하고 모든 메서드의 시그니처에서 `self`의 타입을 반복할 필요가 없다는 점 외에도, 메서드를 사용하는 주된 이유는 조직화입니다. 우리는 타입의 인스턴스로 할 수 있는 모든 것을 하나의 `impl` 블록에 넣었습니다. 이는 코드의 미래 사용자가 우리가 제공하는 라이브러리의 여러 곳에서 `Rectangle`의 기능을 검색하는 것을 방지합니다.

구조체의 필드와 동일한 이름을 가진 메서드를 지정할 수 있다는 점에 유의하십시오. 예를 들어, `width`라는 `Rectangle`에 대한 메서드를 정의할 수 있습니다.

파일 이름: `src/main.rs`

```rust
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!(
            "The rectangle has a nonzero width; it is {}",
            rect1.width
        );
    }
}
```

여기서, 인스턴스의 `width` 필드의 값이 `0`보다 크면 `true`를 반환하고, 값이 `0`이면 `false`를 반환하는 `width` 메서드를 만들기로 했습니다: 동일한 이름의 메서드 내에서 필드를 어떤 목적으로든 사용할 수 있습니다. `main`에서 `rect1.width` 뒤에 괄호를 붙이면, Rust 는 메서드 `width`를 의미한다는 것을 압니다. 괄호를 사용하지 않으면, Rust 는 필드 `width`를 의미한다는 것을 압니다.

종종, 항상 그런 것은 아니지만, 필드와 동일한 이름을 가진 메서드를 제공할 때, 필드의 값만 반환하고 다른 작업은 수행하지 않도록 합니다. 이러한 메서드를 *getter (게터)*라고 하며, Rust 는 다른 일부 언어처럼 구조체 필드에 대해 자동으로 구현하지 않습니다. 게터는 필드를 private (비공개) 로 만들고 메서드를 public (공개) 으로 만들 수 있으므로, 해당 필드에 대한 읽기 전용 액세스를 타입의 public API 의 일부로 활성화할 수 있기 때문에 유용합니다. 챕터 7 에서 public 과 private 이 무엇인지, 그리고 필드 또는 메서드를 public 또는 private 으로 지정하는 방법에 대해 논의할 것입니다.

> **-\> 연산자는 어디에 있습니까?**
>
> C 와 C++ 에서는 메서드를 호출하는 데 두 개의 다른 연산자가 사용됩니다: 객체에서 직접 메서드를 호출하는 경우 `.`을 사용하고, 객체에 대한 포인터에서 메서드를 호출하고 먼저 포인터를 역참조해야 하는 경우 `->`를 사용합니다. 즉, `object`가 포인터인 경우, `object->`something`()`은 `(*object).`something`()`과 유사합니다.
>
> Rust 에는 `->` 연산자에 해당하는 것이 없습니다; 대신, Rust 에는 *자동 참조 및 역참조*라는 기능이 있습니다. 메서드 호출은 Rust 에서 이 동작을 갖는 몇 안 되는 곳 중 하나입니다.
>
> 작동 방식은 다음과 같습니다: `object.`something`()`으로 메서드를 호출하면, Rust 는 자동으로 `&`, `&mut`, 또는 `*`를 추가하여 `object`가 메서드의 시그니처와 일치하도록 합니다. 즉, 다음은 동일합니다:
>
>     p1.distance(&p2);
>     (&p1).distance(&p2);
>
> 첫 번째는 훨씬 더 깔끔해 보입니다. 이 자동 참조 동작은 메서드가 명확한 수신자 (receiver)---`self`의 타입---를 갖기 때문에 작동합니다. 수신자와 메서드 이름이 주어지면, Rust 는 메서드가 읽기 (`&self`), 변경 (`&mut self`), 또는 소비 (`self`) 하는지 확실하게 파악할 수 있습니다. Rust 가 메서드 수신자에 대해 빌림을 암시적으로 만드는 사실은 실제로 소유권을 인체공학적으로 만드는 데 큰 부분을 차지합니다.
