# Методы с большим количеством параметров

Практикуем использование методов, реализуя второй метод для структуры `Rectangle`. На этот раз мы хотим, чтобы экземпляр `Rectangle` принимал другой экземпляр `Rectangle` и возвращал `true`, если второй `Rectangle` может полностью поместиться внутри `self` (первого `Rectangle`); в противном случае он должен вернуть `false`. То есть，一旦我们定义了`can_hold`方法，我们希望能够编写如清单 5-14 所示的程序。

Имя файла: `src/main.rs`

```rust
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

Листинг 5-14: Использование метода `can_hold`, который еще не написан

Ожидаемый вывод будет выглядеть примерно так, потому что обе размерности `rect2` меньше размерностей `rect1`, но `rect3` шире `rect1`:

```rust
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```

Мы знаем, что хотим определить метод, поэтому он будет внутри блока `impl Rectangle`. Имя метода будет `can_hold`, и он будет принимать неизменяемый долг другого `Rectangle` в качестве параметра. Мы можем определить тип параметра, посмотрев на код, который вызывает метод: `rect1.can_hold(&rect2)` передает `&rect2`, что является неизменяемым долгом к `rect2`, экземпляру `Rectangle`. Это имеет смысл, потому что нам нужно только прочитать `rect2` (а не записать, что бы означало, что нам нужен изменяемый долг), и мы хотим, чтобы `main` сохраняло владение над `rect2`, чтобы мы могли снова использовать его после вызова метода `can_hold`. Возвращаемое значение `can_hold` будет булевым, и реализация будет проверять, больше ли ширина и высота `self` по сравнению с шириной и высотой другого `Rectangle` соответственно. Добавим новый метод `can_hold` в блок `impl` из Листинга 5-13, как показано в Листинге 5-15.

Имя файла: `src/main.rs`

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

Листинг 5-15: Реализация метода `can_hold` для `Rectangle`, который принимает другой экземпляр `Rectangle` в качестве параметра

Когда мы запускаем этот код с функцией `main` из Листинга 5-14, мы получим ожидаемый вывод. Методы могут принимать несколько параметров, которые мы добавляем в сигнатуру после параметра `self`, и эти параметры работают точно так же, как параметры в функциях.
