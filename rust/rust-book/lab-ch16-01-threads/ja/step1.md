# スレッドを使ってコードを同時実行する

現在のほとんどのオペレーティングシステムでは、実行されるプログラムのコードは _プロセス_ 内で実行され、オペレーティングシステムは一度に複数のプロセスを管理します。プログラム内では、同時に実行される独立した部分も持つことができます。これらの独立した部分を実行する機能は _スレッド_ と呼ばれます。たとえば、Web サーバーは複数のスレッドを持つことができ、同時に 1 つ以上の要求に応答できるようになります。

プログラム内の計算を複数のスレッドに分割して、同時に複数のタスクを実行することでパフォーマンスを向上させることができますが、複雑さも増えます。スレッドは同時に実行できるため、異なるスレッド上のコードの各部分が実行される順序については、何らかの保証がありません。これにより、次のような問題が発生する可能性があります。

- 競合条件：スレッドがデータやリソースにアクセスする順序が整合していない場合
- 死鎖：2 つのスレッドが互いを待ち続け、両方のスレッドが進行できなくなる場合
- 特定の状況でのみ発生し、再現と信頼性の高い修正が困難なバグ

Rust は、スレッドを使用することのマイナス影響を軽減しようとしていますが、マルチスレッドコンテキストでのプログラミングには、依然として注意深い考えが必要であり、単一スレッドで実行されるプログラムとは異なるコード構造が必要です。

プログラミング言語は、いくつかの異なる方法でスレッドを実装しており、多くのオペレーティングシステムは、新しいスレッドを作成するために言語が呼び出せる API を提供しています。Rust 標準ライブラリは、スレッド実装の _1 対 1_ モデルを使用しており、プログラムは 1 つの言語スレッドに対して 1 つのオペレーティングシステムスレッドを使用します。1 対 1 モデルとは異なるトレードオフを行う他のスレッドモデルを実装するクレートもあります。
