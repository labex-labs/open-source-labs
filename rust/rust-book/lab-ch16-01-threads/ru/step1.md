# Использование потоков для параллельного выполнения кода

В большинстве современных операционных систем код выполняемой программы запускается в _процессе_, и операционная система может одновременно управлять несколькими процессами. В пределах программы вы также можете иметь независимые части, которые запускаются одновременно. Функции, которые запускают эти независимые части, называются _потоками_. Например, веб-сервер может иметь несколько потоков, чтобы он мог одновременно реагировать на несколько запросов.

Разделение вычислений в вашей программе на несколько потоков для параллельного выполнения нескольких задач может повысить производительность, но это также добавляет сложность. Поскольку потоки могут выполняться одновременно, не гарантируется никакой определенной последовательности выполнения частей вашего кода на разных потоках. Это может привести к таким проблемам, как:

- Гонки данных, когда потоки обращаются к данным или ресурсам в несовместимом порядке
- Взаимоблокировки, когда два потока ждут друг друга, не позволяя обоим потокам продолжить работу
- Ошибки, которые возникают только в определенных ситуациях и трудно воспроизводить и исправить надежно

Rust пытается минимизировать негативные последствия использования потоков, но программирование в многопоточном контексте по-прежнему требует тщательного мышления и требует структуры кода, которая отличается от программы, работающей в одном потоке.

Программирования языки реализуют потоки несколькими разными способами, и многие операционные системы предоставляют API, которое может вызываться языком для создания новых потоков. Стандартная библиотека Rust использует _1:1_ модель реализации потоков, при которой программа использует один операционной системный поток на каждый поток языка. Существуют пакеты, которые реализуют другие модели многопоточности, которые делают разные компромиссы по сравнению с моделью 1:1.
