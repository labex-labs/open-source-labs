# 코드를 동시에 실행하기 위한 스레드 사용

대부분의 현재 운영 체제에서 실행되는 프로그램의 코드는 _프로세스 (process)_ 내에서 실행되며, 운영 체제는 여러 프로세스를 동시에 관리합니다. 프로그램 내에서도 동시에 실행되는 독립적인 부분을 가질 수 있습니다. 이러한 독립적인 부분을 실행하는 기능을 *스레드 (thread)*라고 합니다. 예를 들어, 웹 서버는 여러 스레드를 가질 수 있어 동시에 여러 요청에 응답할 수 있습니다.

프로그램의 계산을 여러 스레드로 분할하여 여러 작업을 동시에 실행하면 성능을 향상시킬 수 있지만, 복잡성도 추가됩니다. 스레드는 동시에 실행될 수 있으므로, 서로 다른 스레드의 코드 부분이 실행되는 순서에 대한 본질적인 보장이 없습니다. 이는 다음과 같은 문제로 이어질 수 있습니다.

- 경쟁 조건 (race condition): 스레드가 일관성 없는 순서로 데이터 또는 리소스에 접근하는 경우
- 교착 상태 (deadlock): 두 스레드가 서로를 기다리면서 두 스레드 모두 계속 진행하지 못하는 경우
- 특정 상황에서만 발생하고 안정적으로 재현하고 수정하기 어려운 버그

Rust 는 스레드 사용의 부정적인 영향을 완화하려고 시도하지만, 멀티스레드 (multithreaded) 컨텍스트에서 프로그래밍하는 것은 여전히 신중한 사고를 필요로 하며, 단일 스레드에서 실행되는 프로그램과는 다른 코드 구조가 필요합니다.

프로그래밍 언어는 스레드를 몇 가지 다른 방식으로 구현하며, 많은 운영 체제는 언어가 새로운 스레드를 생성하기 위해 호출할 수 있는 API 를 제공합니다. Rust 표준 라이브러리는 _1:1_ 모델의 스레드 구현을 사용하며, 여기서 프로그램은 언어 스레드 하나당 하나의 운영 체제 스레드를 사용합니다. 1:1 모델과 다른 트레이드 오프를 만드는 다른 스레딩 모델을 구현하는 크레이트 (crate) 가 있습니다.
