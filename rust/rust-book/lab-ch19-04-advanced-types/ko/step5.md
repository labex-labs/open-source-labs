# 동적으로 크기가 정해지는 타입과 Sized 트레이트

Rust 는 특정 타입의 값에 대해 얼마나 많은 공간을 할당해야 하는지 등, 타입에 대한 특정 세부 정보를 알아야 합니다. 이것은 타입 시스템의 한 부분을 처음에는 약간 혼란스럽게 만듭니다. 바로 *동적으로 크기가 정해지는 타입 (dynamically sized types)*의 개념입니다. _DSTs_ 또는 *unsized types*라고도 불리는 이러한 타입은 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있게 해줍니다.

책 전체에서 사용해 온 `str`이라는 동적으로 크기가 정해지는 타입의 세부 사항을 살펴보겠습니다. 맞습니다. `&str`이 아니라, `str` 자체는 DST 입니다. 런타임까지 문자열이 얼마나 긴지 알 수 없으므로, `str` 타입의 변수를 생성할 수도 없고, `str` 타입의 인수를 사용할 수도 없습니다. 작동하지 않는 다음 코드를 고려하십시오.

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust 는 특정 타입의 모든 값에 대해 얼마나 많은 메모리를 할당해야 하는지 알아야 하며, 타입의 모든 값은 동일한 양의 메모리를 사용해야 합니다. Rust 가 이 코드를 작성하도록 허용했다면, 이 두 개의 `str` 값은 동일한 양의 공간을 차지해야 합니다. 하지만 길이가 다릅니다. `s1`은 12 바이트의 스토리지가 필요하고 `s2`는 15 바이트가 필요합니다. 이것이 동적으로 크기가 정해지는 타입을 담는 변수를 생성하는 것이 불가능한 이유입니다.

그렇다면 어떻게 해야 할까요? 이 경우, 이미 답을 알고 있습니다. `s1`과 `s2`의 타입을 `str`이 아닌 `&str`로 만듭니다. "String Slices"에서 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이를 저장한다는 것을 기억하십시오. 따라서 `&T`는 `T`가 위치한 메모리 주소를 저장하는 단일 값인 반면, `&str`은 _두_ 값입니다. 즉, `str`의 주소와 그 길이입니다. 따라서 컴파일 시간에 `&str` 값의 크기를 알 수 있습니다. 이는 `usize`의 두 배입니다. 즉, 참조하는 문자열이 얼마나 길든 상관없이 `&str`의 크기를 항상 알고 있습니다. 일반적으로, 이것이 Rust 에서 동적으로 크기가 정해지는 타입이 사용되는 방식입니다. 동적 정보의 크기를 저장하는 추가 메타데이터 비트가 있습니다. 동적으로 크기가 정해지는 타입의 황금률은 동적으로 크기가 정해지는 타입의 값을 항상 어떤 종류의 포인터 뒤에 두어야 한다는 것입니다.

`str`을 모든 종류의 포인터와 결합할 수 있습니다. 예를 들어, `Box<str>` 또는 `Rc<str>`입니다. 사실, 다른 동적으로 크기가 정해지는 타입인 트레이트를 사용하여 이전에 본 적이 있습니다. 모든 트레이트는 트레이트의 이름을 사용하여 참조할 수 있는 동적으로 크기가 정해지는 타입입니다. "Using Trait Objects That Allow for Values of Different Types"에서 트레이트를 트레이트 객체로 사용하려면 `&dyn Trait` 또는 `Box<dyn Trait>`와 같은 포인터 뒤에 두어야 한다고 언급했습니다 (`Rc<dyn Trait>`도 작동합니다).

DST 로 작업하기 위해 Rust 는 컴파일 시간에 타입의 크기를 알 수 있는지 여부를 결정하기 위해 `Sized` 트레이트를 제공합니다. 이 트레이트는 컴파일 시간에 크기를 알 수 있는 모든 것에 대해 자동으로 구현됩니다. 또한 Rust 는 모든 제네릭 함수에 `Sized`에 대한 바운드를 암시적으로 추가합니다. 즉, 다음과 같은 제네릭 함수 정의는

```rust
fn generic<T>(t: T) {
    --snip--
}
```

실제로 다음과 같이 작성한 것처럼 처리됩니다.

```rust
fn generic<T: Sized>(t: T) {
    --snip--
}
```

기본적으로 제네릭 함수는 컴파일 시간에 크기를 알 수 있는 타입에서만 작동합니다. 그러나 이 제한을 완화하기 위해 다음 특수 구문을 사용할 수 있습니다.

```rust
fn generic<T: ?Sized>(t: &T) {
    --snip--
}
```

`?Sized`에 대한 트레이트 바운드는 "`T`가 `Sized`일 수도 있고 아닐 수도 있다"는 의미이며, 이 표기법은 제네릭 타입이 컴파일 시간에 알려진 크기를 가져야 한다는 기본값을 재정의합니다. 이 의미를 가진 `?Trait` 구문은 `Sized`에 대해서만 사용할 수 있으며, 다른 트레이트에는 사용할 수 없습니다.

또한 `t` 매개변수의 타입을 `T`에서 `&T`로 변경했음을 유의하십시오. 타입이 `Sized`가 아닐 수 있으므로, 어떤 종류의 포인터 뒤에서 사용해야 합니다. 이 경우, 참조를 선택했습니다.

다음으로, 함수와 클로저에 대해 이야기하겠습니다!
