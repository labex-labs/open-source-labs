#Динамически размерные типы и трейт Sized

Rust должен знать определенные детали о своих типах, таких как сколько памяти выделить для значения определенного типа. Это делает один аспект его системы типов немного запутанным вначале: концепцию _динамически размерных типов_. Иногда называемых _DST_ или _неразмерными типами_, эти типы позволяют нам писать код, используя значения, размер которых мы можем знать только во время выполнения.

Давайте углубимся в детали динамически размерного типа, называемого `str`, который мы использовали на протяжении всей книги. Именно так, не `&str`, а `str` само по себе является DST. Мы не можем знать длину строки до времени выполнения, что означает, что мы не можем создать переменную типа `str`, ни брать аргумент типа `str`. Рассмотрите следующий код, который не работает:

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust должен знать, сколько памяти выделить для любого значения определенного типа, и все значения одного типа должны использовать одинаковое количество памяти. Если Rust позволил бы нам написать этот код, эти два значения `str` должны были бы занимать одинаковое количество места. Но они имеют разную длину: `s1` требует 12 байт памяти, а `s2` - 15. Именно поэтому невозможно создать переменную, хранящую динамически размерный тип.

Так что мы должны делать? В этом случае вы уже знаете ответ: мы делаем типы `s1` и `s2` `&str`, а не `str`. Напомним из раздела "Строковые срезы", что структура среза просто хранит начальную позицию и длину среза. Таким образом, хотя `&T` - это единичное значение, которое хранит адрес памяти, где находится `T`, `&str` - это _два_ значения: адрес `str` и его длина. Таким образом, мы можем знать размер значения `&str` на этапе компиляции: это в два раза больше длины `usize`. То есть, мы всегда знаем размер `&str`, независимо от длины строки, на которую он ссылается. В общем, именно таким образом используются динамически размерные типы в Rust: у них есть дополнительный бит метаданных, который хранит размер динамической информации. Золотое правило динамически размерных типов заключается в том, что мы должны всегда помещать значения динамически размерных типов за некоторым типом указателя.

Мы можем комбинировать `str` с разными типами указателей: например, `Box<str>` или `Rc<str>`. Фактически, вы уже видели это раньше, но с другим динамически размерным типом: трейтами. Каждый трейт - это динамически размерный тип, к которому мы можем ссылаться, используя имя трейта. В разделе "Использование объектов трейтов, которые допускают значения разных типов" мы упоминали, что, чтобы использовать трейты в качестве объектов трейтов, мы должны поместить их за указателем, например, `&dyn Trait` или `Box<dyn Trait>` (`Rc<dyn Trait>` также бы работал).

Для работы с DST Rust предоставляет трейт `Sized`, чтобы определить, известен ли размер типа на этапе компиляции или нет. Этот трейт автоматически реализуется для всех типов, размер которых известен на этапе компиляции. Кроме того, Rust неявно добавляет ограничение на `Sized` к каждой обобщенной функции. То есть, определение обобщенной функции такого вида:

```rust
fn generic<T>(t: T) {
    --snip--
}
```

на самом деле обрабатывается так, будто бы мы написали это:

```rust
fn generic<T: Sized>(t: T) {
    --snip--
}
```

По умолчанию обобщенные функции будут работать только с типами, размер которых известен на этапе компиляции. Однако, вы можете использовать следующий специальный синтаксис, чтобы снять это ограничение:

```rust
fn generic<T:?Sized>(t: &T) {
    --snip--
}
```

Ограничение трейта `?Sized` означает "`T` может быть или не быть `Sized`", и этот синтаксис переопределяет стандартное требование, что обобщенные типы должны иметь известный размер на этапе компиляции. Синтаксис `?Trait` с этим значением доступен только для `Sized`, а не для любых других трейтов.

Обратите внимание также, что мы изменили тип параметра `t` с `T` на `&T`. Поскольку тип может не быть `Sized`, мы должны использовать его за каким-то типом указателя. В этом случае мы выбрали ссылку.

Далее мы поговорим о функциях и замыканиях!
