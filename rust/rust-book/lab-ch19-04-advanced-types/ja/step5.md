# 動的にサイズ指定された型と Sized トレイト

Rust は、特定の型に関するいくつかの詳細を知る必要があります。たとえば、特定の型の値に割り当てるメモリ量を知る必要があります。このため、型システムの一部が最初は少し混乱します。それが _動的にサイズ指定された型_ の概念です。時には _DST_ または _サイズ指定されていない型_ と呼ばれます。これらの型を使うと、実行時にのみサイズを知ることができる値を使ってコードを書くことができます。

本書で頻繁に使ってきた `str` という動的にサイズ指定された型の詳細を掘り下げてみましょう。そうです、`&str` ではなく、それ自体の `str` が DST です。文字列の長さが実行時までわからないため、型 `str` の変数を作成することはできず、型 `str` の引数を取ることもできません。以下のコードを見てください。これは動作しません。

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust は、特定の型の任意の値に割り当てるメモリ量を知る必要があり、型のすべての値は同じ量のメモリを使用する必要があります。もし Rust がこのコードを許した場合、これらの 2 つの `str` 値は同じ量のスペースを占有する必要があります。しかし、それらの長さは異なります。`s1` には 12 バイトのストレージが必要で、`s2` には 15 バイトが必要です。これが、動的にサイズ指定された型を保持する変数を作成できない理由です。

では、どうすればよいでしょうか？この場合、既に答えを知っています。`s1` と `s2` の型を `&str` にして、`str` ではなくします。「文字列スライス」で思い出してください。スライスデータ構造は、スライスの開始位置と長さを保存します。したがって、`&T` は `T` が格納されているメモリアドレスを保存する単一の値ですが、`&str` は _2 つ_ の値です。`str` のアドレスとその長さです。したがって、コンパイル時に `&str` 値のサイズを知ることができます。それは `usize` の長さの 2 倍です。つまり、参照する文字列がどれだけ長くても、常に `&str` のサイズを知ることができます。一般的に、Rust で動的にサイズ指定された型を使う方法はこれです。動的にサイズ指定された型には、動的情報のサイズを保存する追加のメタデータがあります。動的にサイズ指定された型の黄金律は、動的にサイズ指定された型の値を必ず何らかのポインタの後ろに置かなければならないということです。

`str` をさまざまな種類のポインタと組み合わせることができます。たとえば、`Box<str>` や `Rc<str>` です。実際、これは以前見たことがありますが、異なる動的にサイズ指定された型です。トレイトです。すべてのトレイトは、トレイトの名前を使って参照できる動的にサイズ指定された型です。「異なる型の値を許すトレイトオブジェクトの使用」では、トレイトをトレイトオブジェクトとして使うには、`&dyn Trait` や `Box<dyn Trait>` (`Rc<dyn Trait>` も機能します) のようなポインタの後ろに置かなければならないことを述べました。

DST を使うには、Rust は `Sized` トレイトを提供して、型のサイズがコンパイル時にわかるかどうかを判断します。このトレイトは、コンパイル時にサイズがわかるすべてのものに自動的に実装されます。また、Rust は暗黙的にすべてのジェネリック関数に `Sized` の制約を追加します。つまり、このようなジェネリック関数の定義は、

```rust
fn generic<T>(t: T) {
    --snip--
}
```

実際はこのように書いたかのように扱われます。

```rust
fn generic<T: Sized>(t: T) {
    --snip--
}
```

デフォルトでは、ジェネリック関数はコンパイル時に既知のサイズの型のみで動作します。ただし、次の特殊な構文を使ってこの制約を緩和することができます。

```rust
fn generic<T:?Sized>(t: &T) {
    --snip--
}
```

`?Sized` のトレイト制約は、「`T` は `Sized` であるかもしれないし、そうでないかもしれない」という意味で、この表記はジェネリック型はコンパイル時に既知のサイズを持たなければならないというデフォルトを上書きします。この意味の `?Trait` 構文は、`Sized` にのみ利用可能で、他のトレイトにはありません。

また、`t` パラメータの型を `T` から `&T` に切り替えたことにも注意してください。型が `Sized` でない可能性があるため、何らかのポインタの後ろで使う必要があります。この場合、参照を選択しました。

次に、関数とクロージャについて話しましょう！
