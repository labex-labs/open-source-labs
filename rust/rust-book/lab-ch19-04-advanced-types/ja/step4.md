# 決して戻らないネバー型

Rustには、型理論の用語では _空の型_ と呼ばれる特別な型 `!` があります。これは値を持たないためです。私たちはこれを _ネバー型_ と呼ぶのが好ましいです。なぜなら、関数が決して戻らない場合、この型は戻り型の代わりに使われるからです。以下は例です。

```rust
fn bar() ->! {
    --snip--
}
```

このコードは「関数 `bar` は決して戻らない」と読みます。決して戻らない関数は _発散関数_ と呼ばれます。型 `!` の値を作成することはできないので、`bar` は決して戻ることはできません。

では、値を決して作成できない型が何の役に立つのでしょうか？2-5のリストのコードを思い出してください。これは数字当てゲームの一部です。19-26のリストに一部を再掲します。

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

リスト19-26: `continue` で終わるアームを持つ `match`

当時、このコードのいくつかの詳細を飛ばしました。「`match` 制御フロー構文」では、`match` のアームはすべて同じ型を返さなければならないことを説明しました。たとえば、次のコードは動作しません。

```rust
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
};
```

このコードでの `guess` の型は整数 _かつ_ 文字列になりますが、Rustでは `guess` は1つの型のみを持つ必要があります。では、`continue` は何を返しますか？19-26のリストで、1つのアームから `u32` を返し、もう1つのアームが `continue` で終わるように許されたのはなぜでしょうか？

おそらく想像通り、`continue` は `!` の値を持っています。つまり、Rustが `guess` の型を計算するとき、両方の `match` アームを見ます。前者は `u32` の値を持ち、後者は `!` の値を持ちます。`!` は決して値を持つことができないので、Rustは `guess` の型が `u32` であると判断します。

この動作を形式的に説明すると、型 `!` の式は他の任意の型に強制変換できるということです。この `match` のアームを `continue` で終えることができるのは、`continue` が値を返さないからです。代わりに、制御をループの先頭に戻します。したがって、`Err` の場合、`guess` に値を割り当てることはありません。

ネバー型は `panic!` マクロでも役立ちます。`Option<T>` の値に対して呼び出して値を生成するか、この定義でパニックする `unwrap` 関数を思い出してください。

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!(
                "called `Option::unwrap()` on a `None` value"
            ),
        }
    }
}
```

このコードでは、19-26のリストの `match` と同じことが起こります。Rustは、`val` が型 `T` で、`panic!` が型 `!` であることを見て、全体の `match` 式の結果が `T` であることを判断します。このコードが動作するのは、`panic!` が値を生成しないからです。つまり、プログラムを終了します。`None` の場合、`unwrap` から値を返さないので、このコードは有効です。

最後に、型 `!` を持つ式は `loop` です。

    print!("forever ");

    loop {
        print!("and ever ");
    }

ここでは、ループは決して終わりません。したがって、`!` が式の値になります。ただし、`break` を含めるとこれは当てはまりません。なぜなら、ループは `break` に到達すると終了するからです。
