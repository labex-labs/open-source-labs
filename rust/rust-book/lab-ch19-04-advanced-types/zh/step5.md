# 动态大小类型与 Sized 特性

Rust 需要了解其类型的某些细节，例如为特定类型的值分配多少空间。这使得其类型系统的一个角落一开始有点令人困惑：*动态大小类型*的概念。这些类型有时也被称为*DST* 或*未指定大小类型*，它们允许我们使用只有在运行时才能知道其大小的值来编写代码。

让我们深入探讨一种名为 `str` 的动态大小类型的细节，我们在整本书中都一直在使用它。没错，不是 `&str`，而是单独的 `str` 本身就是一个 DST。直到运行时我们才知道字符串有多长，这意味着我们不能创建 `str` 类型的变量，也不能接受 `str` 类型的参数。考虑以下无法正常工作的代码：

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust 需要知道为特定类型的任何值分配多少内存，并且一个类型的所有值必须使用相同数量的内存。如果 Rust 允许我们编写这段代码，这两个 `str` 值将需要占用相同的空间。但它们的长度不同：`s1` 需要 12 个字节的存储空间，而 `s2` 需要 15 个字节。这就是为什么不可能创建一个持有动态大小类型的变量。

那么我们该怎么办呢？在这种情况下，你已经知道答案了：我们将 `s1` 和 `s2` 的类型设为 `&str` 而不是 `str`。回忆一下“字符串切片”，切片数据结构只存储切片的起始位置和长度。所以，虽然 `&T` 是一个存储 `T` 所在内存地址的单个值，但 `&str` 是*两个*值：`str` 的地址及其长度。因此，我们可以在编译时知道 `&str` 值的大小：它是 `usize` 长度的两倍。也就是说，无论它所引用的字符串有多长，我们总是知道 `&str` 的大小。一般来说，这就是 Rust 中使用动态大小类型的方式：它们有额外的元数据来存储动态信息的大小。动态大小类型的黄金法则是，我们必须始终将动态大小类型的值放在某种指针后面。

我们可以将 `str` 与各种指针结合使用：例如，`Box<str>` 或 `Rc<str>`。实际上，你之前已经见过这种情况，但使用的是不同的动态大小类型：trait。每个 trait 都是一个动态大小类型，我们可以通过 trait 的名称来引用它。在“使用允许不同类型值的 trait 对象”中，我们提到要将 trait 用作 trait 对象，我们必须将它们放在指针后面，比如 `&dyn Trait` 或 `Box<dyn Trait>`（`Rc<dyn Trait>` 也可以）。

为了处理 DST，Rust 提供了 `Sized` 特性来确定一个类型的大小在编译时是否已知。这个特性会自动为所有在编译时大小已知的类型实现。此外，Rust 会隐式地为每个泛型函数添加一个 `Sized` 约束。也就是说，像这样的泛型函数定义：

```rust
fn generic<T>(t: T) {
    --snip--
}
```

实际上会被当作我们编写了这样的代码：

```rust
fn generic<T: Sized>(t: T) {
    --snip--
}
```

默认情况下，泛型函数只适用于在编译时大小已知的类型。然而，你可以使用以下特殊语法来放宽这个限制：

```rust
fn generic<T:?Sized>(t: &T) {
    --snip--
}
```

`?Sized` 上的 trait 约束意味着 “`T` 可能是也可能不是 `Sized`”，并且这种表示法会覆盖泛型类型在编译时必须有已知大小的默认规则。具有这种含义的 `?Trait` 语法仅适用于 `Sized`，不适用于任何其他 trait。

还要注意，我们将 `t` 参数的类型从 `T` 改为了 `&T`。因为类型可能不是 `Sized`，我们需要在某种指针后面使用它。在这种情况下，我们选择了引用。

接下来，我们将讨论函数和闭包！
