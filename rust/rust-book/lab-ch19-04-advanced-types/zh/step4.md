# 永远不会返回的空类型

Rust 有一个特殊的类型 `!`，在类型理论术语中被称为*空类型*，因为它没有值。我们更愿意称它为*永远类型*，因为当一个函数永远不会返回时，它会出现在返回类型的位置。这里有一个例子：

```rust
fn bar() ->! {
    --snip--
}
```

这段代码读作“函数 `bar` 返回永远类型”。返回永远类型的函数被称为*发散函数*。我们不能创建 `!` 类型的值，所以 `bar` 永远不可能返回。

但是一个你永远无法创建值的类型有什么用呢？回忆一下清单 2-5 中的代码，这是数字猜谜游戏的一部分；我们在清单 19-26 中重现了其中的一部分。

```rust
let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};
```

清单 19-26：一个以 `continue` 结尾的 `match` 分支

当时，我们跳过了这段代码中的一些细节。在“`match` 控制流结构”中，我们讨论过 `match` 分支必须都返回相同的类型。所以，例如，下面的代码不起作用：

```rust
let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
};
```

这段代码中 `guess` 的类型必须既是整数*又是*字符串，而 Rust 要求 `guess` 只能有一种类型。那么 `continue` 返回什么呢？在清单 19-26 中，我们怎么能从一个分支返回 `u32`，而另一个分支以 `continue` 结束呢？

你可能已经猜到了，`continue` 有一个 `!` 值。也就是说，当 Rust 计算 `guess` 的类型时，它会查看两个 `match` 分支，前一个分支的值是 `u32`，后一个分支的值是 `!`。因为 `!` 永远不可能有值，所以 Rust 决定 `guess` 的类型是 `u32`。

描述这种行为的正式方式是，类型为 `!` 的表达式可以被强制转换为任何其他类型。我们被允许在这个 `match` 分支以 `continue` 结束，是因为 `continue` 不返回值；相反，它将控制权移回到循环的顶部，所以在 `Err` 情况下，我们永远不会给 `guess` 赋值。

永远类型在 `panic!` 宏中也很有用。回忆一下我们在 `Option<T>` 值上调用的 `unwrap` 函数，它用于产生一个值或者根据这个定义引发恐慌：

```rust
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!(
                "called `Option::unwrap()` on a `None` value"
            ),
        }
    }
}
```

在这段代码中，与清单 19-26 中的 `match` 发生的情况相同：Rust 看到 `val` 的类型是 `T`，而 `panic!` 的类型是 `!`，所以整个 `match` 表达式的结果是 `T`。这段代码能正常工作是因为 `panic!` 不产生值；它会结束程序。在 `None` 情况下，我们不会从 `unwrap` 返回值，所以这段代码是有效的。

最后一个具有 `!` 类型的表达式是 `loop`：

    print!("forever ");

    loop {
        print!("and ever ");
    }

在这里，循环永远不会结束，所以 `!` 是表达式的值。然而，如果我们包含一个 `break`，情况就不是这样了，因为当循环执行到 `break` 时就会终止。
