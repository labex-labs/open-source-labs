# Раскрытие путей с использованием ключевого слова pub

Вернемся к ошибке в Listing 7-4, которая сообщила нам, что модуль `hosting` является приватным. Мы хотим, чтобы функция `eat_at_restaurant` в родительском модуле имела доступ к функции `add_to_waitlist` в дочернем модуле, поэтому мы помечаем модуль `hosting` ключевым словом `pub`, как показано в Listing 7-5.

Имя файла: `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

--snip--
```

Listing 7-5: Объявление модуля `hosting` как `pub`, чтобы использовать его из `eat_at_restaurant`

К сожалению, код в Listing 7-5 по-прежнему вызывает ошибки компиляции, как показано в Listing 7-6.

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: функция `add_to_waitlist` является приватной
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ приватная функция
  |
note: функция `add_to_waitlist` определена здесь
 --> src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: функция `add_to_waitlist` является приватной
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ приватная функция
   |
note: функция `add_to_waitlist` определена здесь
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^
```

Listing 7-6: Ошибки компиляции при сборке кода из Listing 7-5

Что произошло? Добавление ключевого слова `pub` перед `mod hosting` делает модуль публичным. С этой изменением, если мы можем получить доступ к `front_of_house`, мы можем получить доступ к `hosting`. Но _содержимое_ `hosting` по-прежнему приватно; сделать модуль публичным не делает его содержимое публичным. Ключевое слово `pub` на модуле позволяет только коду в его предках обращаться к нему, но не получать доступ к его внутреннему коду. Поскольку модули являются контейнерами, мы не можем сделать много, просто сделав модуль публичным; нам нужно пойти дальше и выбрать, чтобы один или несколько элементов внутри модуля были также публичными.

Ошибки в Listing 7-6 говорят, что функция `add_to_waitlist` является приватной. Правила приватности применяются к структурам, перечислениям, функциям и методам, а также модулям.

Давайте также сделаем функцию `add_to_waitlist` публичной, добавив ключевое слово `pub` перед ее определением, как в Listing 7-7.

Имя файла: `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

--snip--
```

Listing 7-7: Добавление ключевого слова `pub` к `mod hosting` и `fn add_to_waitlist` позволяет нам вызывать функцию из `eat_at_restaurant`.

Теперь код скомпилируется! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам использовать эти пути в `add_to_waitlist` в отношении правил приватности, рассмотрим абсолютный и относительные пути.

В абсолютном пути мы начинаем с `crate`, корня дерева модулей нашей коробки. Модуль `front_of_house` определен в корне коробки. Хотя `front_of_house` не является публичным, поскольку функция `eat_at_restaurant` определена в том же модуле, что и `front_of_house` (то есть `eat_at_restaurant` и `front_of_house` являются братьями), мы можем ссылаться на `front_of_house` из `eat_at_restaurant`. Далее идет модуль `hosting`, помеченный с `pub`. Мы можем получить доступ к родительскому модулю `hosting`, поэтому мы можем получить доступ к `hosting`. Наконец, функция `add_to_waitlist` помечена с `pub`, и мы можем получить доступ к ее родительскому модулю, поэтому вызов этой функции работает!

В относительном пути логика та же, что и в абсолютном пути, за исключением первого шага: вместо того, чтобы начинать с корня коробки, путь начинается с `front_of_house`. Модуль `front_of_house` определен в том же модуле, что и `eat_at_restaurant`, поэтому относительный путь, начинающийся с модуля, в котором определена `eat_at_restaurant`, работает. Затем, поскольку `hosting` и `add_to_waitlist` помечены с `pub`, остальная часть пути работает, и вызов этой функции действителен!

Если вы планируете распространять свою библиотечную коробку, чтобы другие проекты могли использовать ваш код, ваш публичный API является вашим контрактом с пользователями вашей коробки, который определяет, как они могут взаимодействовать с вашим кодом. При управлении изменениями в вашем публичном API есть много аспектов, которые нужно учитывать, чтобы сделать его легче для людей зависеть от вашей коробки. Эти аспекты выходят за рамки этой книги; если вы заинтересованы в этом вопросе, ознакомьтесь с Руководствами по API Rust по адресу *https://rust-lang.github.io/api-guidelines*.

> **Лучшие практики для пакетов с бинарником и библиотекой**
>
> Мы упоминали, что пакет может содержать как корень бинарной коробки `src/main.rs`, так и корень библиотечной коробки `src/lib.rs`, и обе коробки по умолчанию будут иметь имя пакета. Обычно пакеты с такой структурой, содержащие как библиотеку, так и бинарную коробку, будут иметь достаточно кода в бинарной коробке, чтобы запустить исполняемый файл, который вызывает код с использованием библиотечной коробки. Это позволяет другим проектам использовать наиболее полезные функции, которые предоставляет пакет, потому что код библиотечной коробки можно разделить.
>
> Дерево модулей должно быть определено в `src/lib.rs`. Затем любые публичные элементы могут быть использованы в бинарной коробке, начиная пути с имени пакета. Бинарная коробка становится пользователем библиотечной коробки так же, как и совершенно внешняя коробка использовала бы библиотечную коробку: она может использовать только публичный API. Это помогает вам спроектировать хороший API; не только вы являетесь автором, но и клиентом!
>
> В главе 12 мы продемонстрируем эту организационную практику с помощью командной строки программы, которая будет содержать как бинарную коробку, так и библиотечную коробку.
