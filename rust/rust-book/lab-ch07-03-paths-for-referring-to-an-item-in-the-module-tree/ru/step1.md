# Путь для обращения к элементу в дереве модулей

Чтобы показать Rust, где искать элемент в дереве модулей, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать ее путь.

Путь может быть в двух формах:

- _абсолютный путь_ — это полный путь, начинающийся с корня коробки; для кода из внешней коробки абсолютный путь начинается с имени коробки, а для кода из текущей коробки он начинается с литерала `crate`.
- _относительный путь_ начинается с текущего модуля и использует `self`, `super` или идентификатор в текущем модуле.

И абсолютный, и относительный пути заканчиваются одним или более идентификаторами, разделенными двойными двоеточиями (`::`).

Вернемся к Listing 7-1. Предположим, что мы хотим вызвать функцию `add_to_waitlist`. Это то же самое, что и вопрос: какой путь к функции `add_to_waitlist`? Listing 7-3 содержит Listing 7-1 с удаленными некоторыми модулями и функциями.

Мы покажем два способа вызвать функцию `add_to_waitlist` из новой функции `eat_at_restaurant`, определенной в корне коробки. Эти пути правильные, но остается еще одна проблема, которая препятствует компиляции этого примера в текущем виде. Мы объясним, почему это так чуть позже.

Функция `eat_at_restaurant` является частью публичного API нашей библиотеки-коробки, поэтому мы помечаем ее ключевым словом `pub`. В разделе "Раскрытие путей с использованием ключевого слова pub" мы рассмотрим `pub` более подробно.

Имя файла: `src/lib.rs`

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Абсолютный путь
    crate::front_of_house::hosting::add_to_waitlist();

    // Относительный путь
    front_of_house::hosting::add_to_waitlist();
}
```

Listing 7-3: Вызов функции `add_to_waitlist` с использованием абсолютного и относительного путей

В первый раз, когда мы вызываем функцию `add_to_waitlist` в `eat_at_restaurant`, мы используем абсолютный путь. Функция `add_to_waitlist` определена в той же коробке, что и `eat_at_restaurant`, что означает, что мы можем использовать ключевое слово `crate` для начала абсолютного пути. Затем мы включаем каждый следующий модуль, пока не дойдем до `add_to_waitlist`. Вы можете представить файловую систему с такой же структурой: мы бы указали путь `/front_of_house/hosting/add_to_waitlist`, чтобы запустить программу `add_to_waitlist`; использование имени коробки для начала пути от корня коробки аналогично использованию `/` для начала пути от корня файловой системы в вашей оболочке.

Во второй раз, когда мы вызываем `add_to_waitlist` в `eat_at_restaurant`, мы используем относительный путь. Путь начинается с `front_of_house`, имени модуля, определенного на том же уровне дерева модулей, что и `eat_at_restaurant`. Здесь эквивалент в файловой системе — использование пути `front_of_house/hosting/add_to_waitlist`. Начало с имени модуля означает, что путь относительный.

Выбор между относительным и абсолютным путем — это решение, которое вы принимаете в зависимости от вашего проекта, и оно зависит от того, насколько вероятно, что вы будете перемещать код определения элемента отдельно от или вместе с кодом, который использует этот элемент. Например, если мы переместить модуль `front_of_house` и функцию `eat_at_restaurant` в модуль с именем `customer_experience`, нам нужно обновить абсолютный путь к `add_to_waitlist`, но относительный путь по-прежнему будет действительным. Однако, если мы отдельно переместить функцию `eat_at_restaurant` в модуль с именем `dining`, абсолютный путь к вызову `add_to_waitlist` останется тем же, но относительный путь нужно будет обновить. В целом, наша предпочтительность — указывать абсолютные пути, потому что более вероятно, что мы захотим перемещать определения кода и вызовы элементов независимо друг от друга.

Попробуем скомпилировать Listing 7-3 и выясним, почему он еще не скомпилируется! Ошибки, которые мы получаем, показаны в Listing 7-4.

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: модуль `hosting` является приватным
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ приватный модуль
  |
note: модуль `hosting` определен здесь
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: модуль `hosting` является приватным
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ приватный модуль
   |
note: модуль `hosting` определен здесь
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^
```

Listing 7-4: Ошибки компилятора при сборке кода из Listing 7-3

Сообщения об ошибках говорят, что модуль `hosting` является приватным. Другими словами, у нас правильные пути к модулю `hosting` и функции `add_to_waitlist`, но Rust не позволяет нам их использовать, потому что у него нет доступа к приватным разделам. В Rust все элементы (функции, методы, структуры, перечисления, модули и константы) по умолчанию приватны для родительских модулей. Если вы хотите сделать элемент, такой как функция или структура, приватным, вы помещаете его в модуль.

Элементы в родительском модуле не могут использовать приватные элементы внутри дочерних модулей, но элементы в дочерних модулях могут использовать элементы в их предках. Это потому, что дочерние модули заключают и скрывают свои детали реализации, но дочерние модули могут видеть контекст, в котором они определены. Продолжая нашу метафору, представьте, что правила приватности похожи на внутреннюю часть ресторана: то, что там происходит, приватно для посетителей ресторана, но менеджеры офиса могут видеть и делать все в ресторане, который они управляют.

Rust выбрал, чтобы модульная система работала именно так, чтобы скрытие внутренних деталей реализации было по умолчанию. Таким образом, вы знаете, какие части внутреннего кода можно изменить, не нарушая внешнего кода. Однако Rust все-таки дает вам возможность раскрыть внутренние части кода дочерних модулей для внешних предков, используя ключевое слово `pub`, чтобы сделать элемент публичным.
