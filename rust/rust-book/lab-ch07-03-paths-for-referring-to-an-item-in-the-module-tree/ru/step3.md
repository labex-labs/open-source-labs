# Начало относительных путей с использованием super

Мы можем создавать относительные пути, которые начинаются в родительском модуле, а не в текущем модуле или корне коробки, используя `super` в начале пути. Это похоже на то, как начинается путь в файловой системе с синтаксиса `..`. Использование `super` позволяет нам ссылаться на элемент, который мы знаем, находится в родительском модуле, что может облегчить переупорядочивание дерева модулей, когда модуль тесно связан с родителем, но в будущем родитель может быть перемещен в другое место в дереве модулей.

Рассмотрим код в Listing 7-8, который моделирует ситуацию, когда повар исправляет неправильный заказ и лично доставляет его клиенту. Функция `fix_incorrect_order`, определенная в модуле `back_of_house`, вызывает функцию `deliver_order`, определенную в родительском модуле, указав путь к `deliver_order`, начиная с `super`.

Имя файла: `src/lib.rs`

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
```

Listing 7-8: Вызов функции с использованием относительного пути, начинающегося с `super`

Функция `fix_incorrect_order` находится в модуле `back_of_house`, поэтому мы можем использовать `super`, чтобы перейти к родительскому модулю `back_of_house`, который в этом случае — это `crate`, корень. Оттуда мы ищем `deliver_order` и находим его. Успех! Мы полагаем, что модуль `back_of_house` и функция `deliver_order` будут вероятно оставаться в той же взаимосвязи и перемещаться вместе, если мы решим переорганизовать дерево модулей коробки. Поэтому мы использовали `super`, чтобы в будущем иметь меньше мест, где нужно обновлять код, если этот код будет перемещен в другой модуль.
