# モジュールツリー内のアイテムを参照するためのパス

Rust にモジュールツリー内のアイテムがどこにあるかを示すには、ファイルシステムをナビゲートする際にパスを使用するのと同じ方法でパスを使用します。関数を呼び出すには、そのパスを知る必要があります。

パスは 2 つの形式をとることができます。

- **絶対パス**は、クレートのルートから始まる完全なパスです。外部クレートのコードの場合、絶対パスはクレート名から始まり、現在のクレートのコードの場合、リテラル `crate` から始まります。
- **相対パス**は、現在のモジュールから始まり、`self`、`super`、または現在のモジュール内の識別子を使用します。

絶対パスと相対パスの両方の後には、2 つのコロン (`::`) で区切られた 1 つ以上の識別子が続きます。

リスト 7-1 に戻りますが、`add_to_waitlist` 関数を呼び出したいとしましょう。これは、「`add_to_waitlist` 関数のパスは何か？」と尋ねるのと同じことです。リスト 7-3 には、いくつかのモジュールと関数が削除されたリスト 7-1 が含まれています。

クレートのルートで定義された新しい関数 `eat_at_restaurant` から `add_to_waitlist` 関数を呼び出す 2 つの方法を示します。これらのパスは正しいですが、この例をそのままコンパイルできない別の問題が残っています。少し後でその理由を説明します。

`eat_at_restaurant` 関数は、私たちのライブラリクレートのパブリック API の一部であるため、`pub` キーワードでマークされています。「`pub` キーワードを使用したパスの公開」では、`pub` に関する詳細を説明します。

ファイル名：`src/lib.rs`

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // 絶対パス
    crate::front_of_house::hosting::add_to_waitlist();

    // 相対パス
    front_of_house::hosting::add_to_waitlist();
}
```

リスト 7-3: 絶対パスと相対パスを使用した `add_to_waitlist` 関数の呼び出し

`eat_at_restaurant` で `add_to_waitlist` 関数を最初に呼び出すとき、絶対パスを使用します。`add_to_waitlist` 関数は、`eat_at_restaurant` と同じクレートに定義されているため、絶対パスを始めるために `crate` キーワードを使用できます。その後、次々と続くモジュールを含め、`add_to_waitlist` に到達するまで進みます。同じ構造のファイルシステムを想像してみてください。`add_to_waitlist` プログラムを実行するには、パス `/front_of_house/hosting/add_to_waitlist` を指定します。クレートのルートから始めるためにクレート名を使用するのは、シェルでファイルシステムのルートから始めるために `/` を使用するのと同じです。

2 回目に `eat_at_restaurant` で `add_to_waitlist` を呼び出すとき、相対パスを使用します。このパスは、`eat_at_restaurant` と同じモジュールツリーのレベルで定義されたモジュールの名前である `front_of_house` から始まります。ここでのファイルシステムと同等のものは、パス `front_of_house/hosting/add_to_waitlist` を使用することになります。モジュール名から始まることは、パスが相対的であることを意味します。

相対パスと絶対パスをどちらを使用するかを選ぶかは、プロジェクトに応じて決定します。これは、アイテム定義コードを使用するコードとは別に、または一緒に移動する可能性が高いかどうかに依存します。たとえば、`front_of_house` モジュールと `eat_at_restaurant` 関数を `customer_experience` という名前のモジュールに移動した場合、`add_to_waitlist` への絶対パスを更新する必要がありますが、相対パスは依然として有効です。ただし、`eat_at_restaurant` 関数を `dining` という名前の別のモジュールに個別に移動した場合、`add_to_waitlist` 呼び出しの絶対パスは同じままですが、相対パスを更新する必要があります。一般的に私たちの好みは、コード定義とアイテム呼び出しを互いに独立して移動したい可能性が高いため、絶対パスを指定することです。

リスト 7-3 をコンパイルして、まだコンパイルできない理由を調べてみましょう！得られたエラーはリスト 7-4 に示されています。

```bash
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^
```

リスト 7-4: リスト 7-3 のコードをビルドしたときのコンパイラエラー

エラーメッセージは、モジュール `hosting` が非公開であることを示しています。言い換えると、`hosting` モジュールと `add_to_waitlist` 関数のパスは正しいですが、Rust は非公開セクションにアクセスできないため、それらを使用できません。Rust では、既定ですべてのアイテム（関数、メソッド、構造体、列挙体、モジュール、定数）は親モジュールに対して非公開です。関数や構造体などのアイテムを非公開にする場合は、モジュールに入れます。

親モジュール内のアイテムは、子モジュール内の非公開アイテムを使用できませんが、子モジュール内のアイテムは、その祖先モジュール内のアイテムを使用できます。これは、子モジュールがその実装詳細をラップして隠すためですが、子モジュールはそれが定義されているコンテキストを見ることができます。この比喩を続けると、プライバシールールはレストランのオフィスのようなものであると考えてください。そこで行われることは、レストランのお客にとって非公開ですが、オフィスマネージャーは、彼らが運営するレストランのすべてを見て、何でもできます。

Rust は、内部の実装詳細を隠すことが既定になるようにモジュールシステムを機能させるように選びました。このようにすることで、内部コードのどの部分を変更しても外部コードを破壊しないことがわかります。ただし、Rust は、`pub` キーワードを使用してアイテムを公開することで、子モジュールのコードの内部部分を外部の祖先モジュールに公開するオプションも提供しています。
