# 상태 패턴의 장단점

Rust 가 게시물이 각 상태에서 가져야 하는 다양한 종류의 동작을 캡슐화하기 위해 객체 지향 상태 패턴을 구현할 수 있음을 보여주었습니다. `Post`의 메서드는 다양한 동작에 대해 아무것도 모릅니다. 코드를 구성한 방식에 따라 게시된 게시물이 동작할 수 있는 다양한 방식을 알기 위해 한 곳만 살펴보면 됩니다. 즉, `Published` 구조체에서 `State` 트레이트를 구현하는 것입니다.

상태 패턴을 사용하지 않는 대체 구현을 생성하는 경우, 대신 `Post`의 메서드 또는 게시물의 상태를 확인하고 해당 위치에서 동작을 변경하는 `main` 코드에서 `match` 표현식을 사용할 수 있습니다. 즉, 게시물이 게시된 상태에 있는 모든 의미를 이해하기 위해 여러 곳을 살펴봐야 합니다! 이것은 더 많은 상태를 추가할수록 증가할 것입니다. 각 `match` 표현식에는 다른 arm 이 필요합니다.

상태 패턴을 사용하면 `Post` 메서드와 `Post`를 사용하는 위치에 `match` 표현식이 필요하지 않으며, 새 상태를 추가하려면 새 구조체를 추가하고 해당 구조체에서 트레이트 메서드를 구현하기만 하면 됩니다.

상태 패턴을 사용하는 구현은 더 많은 기능을 추가하기 위해 쉽게 확장할 수 있습니다. 상태 패턴을 사용하는 코드를 유지 관리하는 단순성을 확인하려면 다음 제안 사항을 시도해 보십시오.

- 게시물의 상태를 `PendingReview`에서 `Draft`로 변경하는 `reject` 메서드를 추가합니다.
- 상태를 `Published`로 변경하기 전에 `approve`를 두 번 호출해야 합니다.
- 게시물이 `Draft` 상태일 때만 사용자가 텍스트 콘텐츠를 추가할 수 있도록 허용합니다. 힌트: 콘텐츠에 대해 변경될 수 있는 사항을 담당하지만 `Post`를 수정하는 것은 담당하지 않는 상태 객체를 사용합니다.

상태 패턴의 한 가지 단점은 상태가 상태 간의 전환을 구현하기 때문에 일부 상태가 서로 결합된다는 것입니다. `PendingReview`와 `Published` 사이에 `Scheduled`와 같은 다른 상태를 추가하면 `PendingReview`의 코드를 변경하여 대신 `Scheduled`로 전환해야 합니다. `PendingReview`가 새 상태를 추가할 때 변경할 필요가 없다면 작업량이 줄어들겠지만, 이는 다른 디자인 패턴으로 전환해야 함을 의미합니다.

또 다른 단점은 일부 로직을 중복했다는 것입니다. 중복을 제거하기 위해 `self`를 반환하는 `State` 트레이트에서 `request_review` 및 `approve` 메서드에 대한 기본 구현을 시도할 수 있습니다. 그러나 이것은 작동하지 않습니다. `State`를 트레이트 객체로 사용하는 경우 트레이트는 구체적인 `self`가 정확히 무엇인지 알 수 없으므로 반환 타입은 컴파일 시간에 알 수 없습니다.

다른 중복에는 `Post`에서 `request_review` 및 `approve` 메서드의 유사한 구현이 포함됩니다. 두 메서드 모두 `Option`의 `state` 필드에 있는 값에서 동일한 메서드의 구현으로 위임하고 `state` 필드의 새 값을 결과로 설정합니다. 이 패턴을 따르는 `Post`에 많은 메서드가 있는 경우 반복을 제거하기 위해 매크로를 정의하는 것을 고려할 수 있습니다 ("매크로" 참조).

객체 지향 언어에 대해 정의된 대로 상태 패턴을 정확하게 구현함으로써 Rust 의 강점을 최대한 활용하지 못하고 있습니다. `blog` 크레이트에 대한 몇 가지 변경 사항을 살펴보고 잘못된 상태와 전환을 컴파일 시간 오류로 만들 수 있습니다.
