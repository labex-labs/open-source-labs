# Сравнительные преимущества и недостатки паттерна состояния

Мы показали, что Rust способен реализовать объектно-ориентированный паттерн состояния для инкапсуляции различных видов поведения, которое должна иметь запись в каждом состоянии. Методы на `Post` ничего не знают о различных видах поведения. В том виде, в котором мы организовали код, нам нужно смотреть только в одном месте, чтобы знать разные способы поведения опубликованной записи: реализация трейта `State` на структуре `Published`.

Если бы мы создали альтернативную реализацию, которая не использовала паттерн состояния, мы, возможно, бы использовали `match`-выражения в методах на `Post` или даже в коде `main`, который проверяет состояние записи и изменяет поведение в этих местах. Это означало бы, что нам нужно было бы смотреть в нескольких местах, чтобы понять все последствия того, что запись находится в опубликованном состоянии! Это只会增加我们添加的状态数量：每个`match`表达式都需要另一个分支。

С паттерном состояния методы `Post` и места, где мы используем `Post`, не нуждаются в `match`-выражениях, и чтобы добавить новое состояние, нам нужно только добавить новую структуру и реализовать методы трейта на этой одной структуре.

Реализация с использованием паттерна состояния легко расширяется для добавления дополнительной функциональности. Чтобы увидеть простоту поддержки кода, использующего паттерн состояния, попробуйте следующие предложения:

- Добавьте метод `reject`, который изменяет состояние записи из `PendingReview` обратно в `Draft`.
- Требуйте двух вызовов `approve`, прежде чем состояние можно будет изменить на `Published`.
- Разрешайте пользователям добавлять текстовое содержание только когда запись находится в состоянии `Draft`. Совет: пусть объект состояния отвечает за то, что может измениться в контенте, но не отвечает за изменение `Post`.

Одним из недостатков паттерна состояния является то, что, поскольку состояния реализуют переходы между состояниями, некоторые из состояний связаны друг с другом. Если мы добавим еще одно состояние между `PendingReview` и `Published`, например, `Scheduled`, мы должны будем изменить код в `PendingReview`, чтобы переключаться на `Scheduled` вместо этого. Было бы меньше работы, если `PendingReview` не нужно было изменяться при добавлении нового состояния, но это означало бы переход на другой паттерн проектирования.

Еще одним недостатком является то, что мы дублировали некоторую логику. Чтобы устранить часть дублирования, мы можем попробовать сделать реализации по умолчанию для методов `request_review` и `approve` на трейте `State`, которые возвращают `self`. Однако это не сработает: когда используем `State` в качестве объекта трейта, трейт не знает, какой будет конкретный `self` точно, поэтому тип возврата неизвестен на этапе компиляции.

Другая дублировка включает в себя похожие реализации методов `request_review` и `approve` на `Post`. Оба метода делегируют реализации того же метода на значении в поле `state` структуры `Option` и устанавливают новое значение поля `state` равным результату. Если бы у нас было много методов на `Post`, которые следовали этой схеме, мы могли бы рассмотреть определение макроса для устранения повторений (см. "Макросы").

Реализуя паттерн состояния так, как он определен для объектно-ориентированных языков, мы не充分利用 Rust 的优势。让我们看看我们可以对`blog` crate 进行哪些更改，以使无效状态和转换成为编译时错误。
