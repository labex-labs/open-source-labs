# Запрос на обзор изменяет состояние записи

Далее, нам нужно добавить функциональность для запроса обзора записи, которая должна изменить ее состояние с `Draft` на `PendingReview`. Листинг 17-15 показывает этот код.

Имя файла: `src/lib.rs`

```rust
impl Post {
    --snip--
  1 pub fn request_review(&mut self) {
      2 if let Some(s) = self.state.take() {
          3 self.state = Some(s.request_review())
        }
    }
}

trait State {
  4 fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
      5 Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
      6 self
    }
}
```

Листинг 17-15: Реализация методов `request_review` на `Post` и трейте `State`

Мы даем `Post` публичный метод с именем `request_review`, который будет принимать изменяемую ссылку на `self` \[1\]. Затем мы вызываем внутренний метод `request_review` для текущего состояния `Post` \[3\], и этот второй метод `request_review` потребляет текущее состояние и возвращает новое состояние.

Мы добавляем метод `request_review` в трейт `State` \[4\]; все типы, которые реализуют этот трейт, теперь должны реализовать метод `request_review`. Обратите внимание, что вместо `self`, `&self` или `&mut self` в качестве первого параметра метода у нас `self: Box<Self>`. Эта синтаксис означает, что метод действителен только при вызове на `Box`, хранящем этот тип. Эта синтаксис забирает владение `Box<Self>`, делая старое состояние недействительным, чтобы значение состояния `Post` могло преобразоваться в новое состояние.

Чтобы потребить старое состояние, метод `request_review` должен забрать владение значением состояния. Именно здесь приходит `Option` в поле `state` структуры `Post`: мы вызываем метод `take`, чтобы вытащить значение `Some` из поля `state` и оставить `None` на его месте, потому что Rust не позволяет иметь незаполненные поля в структурах \[2\]. Это позволяет нам переместить значение `state` из `Post` вместо того, чтобы брать его в долг. Затем мы установим значение `state` записи равным результату этой операции.

Мы должны временно установить `state` в `None`, а не напрямую с помощью кода, такого как `self.state = self.state.request_review();`, чтобы получить владение значением `state`. Это гарантирует, что `Post` не сможет использовать старое значение `state` после того, как мы преобразовали его в новое состояние.

Метод `request_review` на `Draft` возвращает новый, заboxed экземпляр новой структуры `PendingReview`, которая представляет состояние, когда запись ожидает обзора \[5\]. Структура `PendingReview` также реализует метод `request_review`, но не делает никаких преобразований. Вместо этого она возвращает себя \[6\], потому что когда мы запрашиваем обзор записи, которая уже находится в состоянии `PendingReview`, она должна оставаться в этом состоянии.

Теперь мы можем увидеть преимущества паттерна состояния: метод `request_review` на `Post` одинаковый независимо от значения его `state`. Каждое состояние отвечает за свои собственные правила.

Мы оставим метод `content` на `Post` без изменений, возвращающий пустой срез строки. Теперь мы можем иметь `Post` в состоянии `PendingReview` так же, как и в состоянии `Draft`, но мы хотим иметь одинаковое поведение в состоянии `PendingReview`. Листинг 17-11 теперь работает до строки \[5\]!
