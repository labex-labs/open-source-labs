# Реализация объектно-ориентированного паттерна проектирования

_Паттерн состояния_ - это объектно-ориентированный паттерн проектирования. Суть паттерна заключается в том, что мы определяем набор состояний, которые может иметь значение внутри. Состояния представляются набором _объектов состояния_, и поведение значения меняется в зависимости от его состояния. Мы рассмотрим пример структуры записи блога, которая имеет поле для хранения своего состояния, которое будет объектом состояния из набора "черновик", "на рассмотрении" или "опубликована".

Объекты состояния имеют общие функции: в Rust, конечно, мы используем структуры и трейты вместо объектов и наследования. Каждый объект состояния отвечает за свое собственное поведение и за то, когда оно должно измениться на другое состояние. Значение, которое хранит объект состояния, ничего не знает о разном поведении состояний или о том, когда переключаться между состояниями.

Преимуществом использования паттерна состояния является то, что при изменении бизнес-требований программы мы не будем изменять код значения, хранящего состояние, или код, который использует это значение. Мы будем только обновлять код внутри одного из объектов состояния, чтобы изменить его правила или, возможно, добавить больше объектов состояния.

Сначала мы реализуем паттерн состояния более традиционным объектно-ориентированным способом, а затем мы будем использовать подход, который более естественен в Rust. Давайте углубимся и постепенно реализуем рабочий процесс записи блога с использованием паттерна состояния.

Конечная функциональность будет выглядеть так:

1.  Запись блога начинается как пустой черновик.
2.  Когда черновик готов, запрашивается обзор записи.
3.  Когда запись одобряется, она публикуется.
4.  Только опубликованные записи блога возвращают содержание для печати, поэтому неподтвержденные записи не могут случайно быть опубликованы.

Любые другие попытки изменения записи должны быть без эффекта. Например, если мы попытаемся одобрить черновик записи блога до того, как мы запросили обзор, запись должна остаться непубликуемым черновиком.

Листинг 17-11 показывает этот рабочий процесс в кодовом виде: это пример использования API, которое мы реализуем в библиотечном пакете под названием `blog`. Это еще не скомпилируется, потому что мы не реализовали пакет `blog`.

Имя файла: `src/main.rs`

```rust
use blog::Post;

fn main() {
  1 let mut post = Post::new();

  2 post.add_text("I ate a salad for lunch today");
  3 assert_eq!("", post.content());

  4 post.request_review();
  5 assert_eq!("", post.content());

  6 post.approve();
  7 assert_eq!("I ate a salad for lunch today", post.content());
}
```

Листинг 17-11: Код, демонстрирующий ожидаемое поведение, которое мы хотим, чтобы имел пакет `blog`

Мы хотим, чтобы пользователь мог создавать новый черновик записи блога с помощью `Post::new` \[1\]. Мы хотим, чтобы можно было добавлять текст в запись блога \[2\]. Если мы попытаемся сразу получить содержание записи до одобрения, мы не должны получить никакого текста, потому что запись еще является черновиком. Мы добавили `assert_eq!` в код для демонстрационных целей \[3\]. Отличным юнит-тестом для этого было бы утверждение, что черновик записи блога возвращает пустую строку из метода `content`, но мы не собираемся писать тесты для этого примера.

Далее, мы хотим возможность запросить обзор записи \[4\], и мы хотим, чтобы `content` возвращал пустую строку в течение ожидания обзора \[5\]. Когда запись получает одобрение \[6\], она должна быть опубликована, что означает, что текст записи будет возвращен, когда вызывается `content` \[7\].

Заметим, что единственный тип, с которым мы взаимодействуем из пакета, это тип `Post`. Этот тип будет использовать паттерн состояния и будет хранить значение, которое будет одним из трех объектов состояния, представляющих различные состояния, в которых может быть запись - черновик, на рассмотрении или опубликована. Переключение между состояниями будет управляться внутри типа `Post`. Состояния меняются в ответ на методы, вызываемые пользователями нашей библиотеки на экземпляре `Post`, но они не должны напрямую управлять изменением состояния. Кроме того, пользователи не могут ошибиться с состояниями, например, опубликовать запись до ее обзора.
