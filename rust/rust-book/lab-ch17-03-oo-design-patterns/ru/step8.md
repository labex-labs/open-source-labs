# Кодирование состояний и поведения в виде типов

Мы покажем, как пересмотреть паттерн состояния, чтобы получить другой набор сравнительных преимуществ и недостатков. Вместо полной инкапсуляции состояний и переходов, чтобы внешний код не имел о них никакой информации, мы будем кодировать состояния в разные типы. В результате система типизации Rust будет предотвращать попытки использовать черновики записей там, где разрешены только опубликованные записи, выдавая ошибку компиляции.

Рассмотрим первую часть `main` в Листинге 17-11:

Имя файла: `src/main.rs`

```rust
fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
}
```

Мы по-прежнему можем создавать новые записи в состоянии черновика с использованием `Post::new` и добавлять текст в содержание записи. Но вместо того, чтобы у черновика записи был метод `content`, который возвращает пустую строку, мы сделаем так, чтобы черновики записей вообще не имели метода `content`. Таким образом, если мы попытаемся получить содержание черновика записи, мы получим ошибку компиляции, которая сообщит нам, что метод не существует. В результате мы не сможем случайно показать содержание черновика записи в production, потому что этот код даже не скомпилируется. Листинг 17-19 показывает определение структуры `Post` и структуры `DraftPost`, а также методы для каждой из них.

Имя файла: `src/lib.rs`

```rust
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
  1 pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

  2 pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
  3 pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
```

Листинг 17-19: `Post` с методом `content` и `DraftPost` без метода `content`

И структура `Post`, и структура `DraftPost` имеют приватное поле `content`, которое хранит текст записи блога. Структуры больше не имеют поля `state`, потому что мы переносим кодирование состояния в типы структур. Структура `Post` будет представлять опубликованную запись, и у нее есть метод `content`, который возвращает `content` \[2\].

У нас по-прежнему есть функция `Post::new`, но вместо возврата экземпляра `Post` она возвращает экземпляр `DraftPost` \[1\]. Поскольку `content` приватно и нет функций, которые возвращают `Post`, невозможно создать экземпляр `Post` в настоящее время.

Структура `DraftPost` имеет метод `add_text`, поэтому мы можем добавлять текст в `content` как и раньше \[3\], но обратите внимание, что для `DraftPost` не определен метод `content`! Теперь программа гарантирует, что все записи начинаются как черновики, и содержание черновиков недоступно для отображения. Любая попытка обойти эти ограничения приведет к ошибке компиляции.
