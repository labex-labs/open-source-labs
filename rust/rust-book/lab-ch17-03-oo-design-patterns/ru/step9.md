# Реализация переходов в виде преобразований в разные типы

Итак, как мы получаем опубликованную запись? Мы хотим закрепить правило, согласно которому черновик записи должен быть обзарен и одобрен, прежде чем можно опубликовать его. Запись в состоянии ожидания обзора по-прежнему не должна отображать никакого содержания. Реализуем эти ограничения, добавив еще одну структуру, `PendingReviewPost`, определив метод `request_review` на `DraftPost`, чтобы он возвращал `PendingReviewPost`, и определив метод `approve` на `PendingReviewPost`, чтобы он возвращал `Post`, как показано в Листинге 17-20.

Имя файла: `src/lib.rs`

```rust
impl DraftPost {
    --snip--
    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```

Листинг 17-20: `PendingReviewPost`, который создается при вызове `request_review` на `DraftPost`, и метод `approve`, который превращает `PendingReviewPost` в опубликованную `Post`

Методы `request_review` и `approve` берут владение `self`, тем самым потребляя экземпляры `DraftPost` и `PendingReviewPost` и преобразуя их соответственно в `PendingReviewPost` и опубликованную `Post`. Таким образом, после вызова `request_review` на них у нас не останется никаких экземпляров `DraftPost` и т.д. Структуре `PendingReviewPost` не определен метод `content`, поэтому попытка прочитать ее содержание приводит к ошибке компиляции, как и в случае с `DraftPost`. Поскольку единственный способ получить экземпляр опубликованной `Post` с определенным методом `content` - это вызвать метод `approve` на `PendingReviewPost`, а единственный способ получить `PendingReviewPost` - это вызвать метод `request_review` на `DraftPost`, мы теперь закодировали рабочий процесс записи блога в систему типов.

Но мы также должны внести некоторые небольшие изменения в `main`. Методы `request_review` и `approve` возвращают новые экземпляры, а не модифицируют структуру, на которой они вызываются, поэтому нам нужно добавить больше инструкций `let post =` для создания новых переменных, чтобы сохранить возвращаемые экземпляры. Также мы не можем утверждать, что содержание черновика и записи в состоянии ожидания обзора - это пустые строки, и мы не нуждаемся в этом: мы не можем скомпилировать код, который пытается использовать содержание записей в этих состояниях. Обновленный код в `main` показан в Листинге 17-21.

Имя файла: `src/main.rs`

```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}
```

Листинг 17-21: Изменения в `main` для использования нового реализации рабочего процесса записи блога

Изменения, которые мы внесли в `main`, чтобы переопределить `post`, означают, что эта реализация уже не совсем соответствует объекно-ориентированному паттерну состояния: преобразования между состояниями больше не полностью инкапсулированы внутри реализации `Post`. Однако наша выгода заключается в том, что теперь невозможны недействительные состояния из-за системы типов и проверки типов, которая происходит на этапе компиляции! Это гарантирует, что некоторые ошибки, такие как отображение содержания неопубликованной записи, будут обнаружены до того, как код перейдет в production.

Попробуйте выполнить задачи, предложенные в начале этого раздела, для `blog` crate в том виде, в котором он представлен после Листинга 17-21, чтобы понять, как вы относитесь к дизайну этой версии кода. Обратите внимание, что некоторые из задач могут быть уже выполнены в этом дизайне.

Мы убедились, что хотя Rust способен реализовать объектно-ориентированные паттерны проектирования, в Rust также доступны и другие паттерны, такие как кодирование состояния в систему типов. Эти паттерны имеют разные сравнительные преимущества и недостатки. Хотя вы, возможно, знакомы с объектно-ориентированными паттернами, пересмотр проблемы с использованием особенностей Rust может принести выгоду, например, предотвращение некоторых ошибок на этапе компиляции. Объектно-ориентированные паттерны не всегда будут наилучшим решением в Rust из-за некоторых особенностей, таких как владение ресурсами, которых не имеют объектно-ориентированные языки.
