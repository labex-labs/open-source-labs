# 状態パターンのトレードオフ

Rust は、投稿が各状態で持つべきさまざまな種類の動作をカプセル化するために、オブジェクト指向の状態パターンを実装できることを示しました。`Post`のメソッドは、さまざまな動作について何も知りません。コードの組織化の仕方により、公開済みの投稿がどのように振る舞うかを知るには、たった 1 か所を見ればよいことになります。つまり、`Published`構造体における`State`トレイトの実装です。

状態パターンを使用しない代替実装を作成する場合、代わりに`Post`のメソッドや、投稿の状態をチェックしてそこで動作を変更する`main`コードの中で`match`式を使用するかもしれません。これは、投稿が公開状態にある場合のすべての影響を理解するために、いくつかの場所を見なければならないことを意味します！追加する状態が増えるほど、この問題はさらに深刻になります。それぞれの`match`式には別のアームが必要になるからです。

状態パターンを使用すると、`Post`のメソッドや`Post`を使用する場所では`match`式が必要なくなります。新しい状態を追加する場合、新しい構造体を追加して、その 1 つの構造体にトレイトメソッドを実装するだけです。

状態パターンを使用した実装は、機能を追加するために拡張しやすいです。状態パターンを使用するコードの保守の簡単さを見るには、次のいくつかの提案を試してみてください。

- `reject`メソッドを追加して、投稿の状態を`PendingReview`から`Draft`に戻します。
- 状態を`Published`に変更する前に、`approve`を 2 回呼び出す必要があります。
- 投稿が`Draft`状態の場合にのみ、ユーザーがテキストコンテントを追加できるようにします。ヒント：状態オブジェクトにコンテントに関する変更を担わせるが、`Post`を変更する責任は負わせないでください。

状態パターンの欠点の 1 つは、状態が状態間の遷移を実装しているため、一部の状態が互いに結合していることです。`PendingReview`と`Published`の間に`Scheduled`などの別の状態を追加する場合、`PendingReview`のコードを変更して、代わりに`Scheduled`に遷移する必要があります。新しい状態の追加に伴って`PendingReview`が変更されなければ、作業量は少なくなりますが、それは別のデザインパターンに切り替えることを意味します。

もう 1 つの欠点は、一部のロジックを重複させていることです。重複を排除するために、`State`トレイトの`request_review`と`approve`メソッドに対して、`self`を返すデフォルト実装を試してみるかもしれません。しかし、これは機能しません。`State`をトレイトオブジェクトとして使用する場合、トレイトは具体的な`self`がどのようなものかを正確に知らないため、返却型はコンパイル時にわかりません。

他の重複には、`Post`の`request_review`と`approve`メソッドの似たような実装が含まれます。両方のメソッドは、`Option`の`state`フィールドの値に対する同じメソッドの実装に委譲し、`state`フィールドの新しい値を結果に設定します。`Post`にこのパターンに従う多くのメソッドがある場合、繰り返しを排除するためにマクロを定義することを検討するかもしれません（「マクロ」を参照）。

オブジェクト指向言語で定義されている通りに状態パターンを実装することで、Rust の強みを最大限に活用していません。`blog`クレートに対して行うことができるいくつかの変更を見てみましょう。それにより、無効な状態と遷移をコンパイル時エラーにすることができます。
