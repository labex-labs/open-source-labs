# オブジェクト指向のデザインパターンの実装

「状態パターン」はオブジェクト指向のデザインパターンです。このパターンの要点は、値が内部的に持つことができる一連の状態を定義することです。状態は一連の「状態オブジェクト」で表され、値の動作はその状態に基づいて変化します。ここでは、ブログ投稿の構造体の例を通じて作業します。この構造体には、状態を保持するフィールドがあり、これは「下書き」、「レビュー」、または「公開」のセットからの状態オブジェクトになります。

状態オブジェクトは機能を共有します。もちろん Rust では、オブジェクトや継承ではなく構造体とトレイトを使用します。各状態オブジェクトは独自の動作と、他の状態に変化するタイミングを管理する責任があります。状態オブジェクトを保持する値は、状態の異なる動作や状態間の遷移タイミングについて何も知りません。

状態パターンを使用する利点は、プログラムのビジネス要件が変更された場合、状態を保持する値のコードや値を使用するコードを変更する必要がないことです。状態オブジェクトの 1 つの内部コードを更新してルールを変更するか、もしくは状態オブジェクトを追加するだけです。

まず、より伝統的なオブジェクト指向の方法で状態パターンを実装します。その後、Rust でより自然なアプローチを使用します。状態パターンを使ってブログ投稿のワークフローを段階的に実装していきましょう。

最終的な機能は以下のようになります。

1. ブログ投稿は空の下書きから始まります。
2. 下書きが完了すると、投稿のレビューが依頼されます。
3. 投稿が承認されると、公開されます。
4. 公開されたブログ投稿のみがコンテンツを返して印刷できるようになり、承認されていない投稿は誤って公開されることがなくなります。

投稿に対して試みられる他の変更は、何の影響も与えません。たとえば、レビューを依頼する前に下書きのブログ投稿を承認しようとした場合、投稿は未公開の下書きのままでなければなりません。

リスト 17-11 は、このワークフローをコード形式で示しています。これは、`blog`という名前のライブラリクレートで実装する API の使用例です。まだコンパイルされません。なぜなら、`blog`クレートを実装していないからです。

ファイル名：`src/main.rs`

```rust
use blog::Post;

fn main() {
  1 let mut post = Post::new();

  2 post.add_text("I ate a salad for lunch today");
  3 assert_eq!("", post.content());

  4 post.request_review();
  5 assert_eq!("", post.content());

  6 post.approve();
  7 assert_eq!("I ate a salad for lunch today", post.content());
}
```

リスト 17-11: 私たちが望む`blog`クレートの動作を示すコード

`Post::new`を使って新しい下書きのブログ投稿を作成できるようにしたいと思います\[1\]。ブログ投稿にテキストを追加できるようにしたいと思います\[2\]。承認前に投稿のコンテンツをすぐに取得しようとした場合、投稿がまだ下書きなので何のテキストも取得できないはずです。このコードには、示す目的で`assert_eq!`を追加しています\[3\]。これに対する優れた単体テストは、下書きのブログ投稿が`content`メソッドから空の文字列を返すことをアサートすることですが、この例ではテストを書きません。

次に、投稿のレビュー依頼を可能にしたいと思います\[4\]。レビュー待ちの間、`content`が空の文字列を返すようにしたいと思います\[5\]。投稿が承認されると\[6\]、公開されるはずで、`content`を呼び出したときに投稿のテキストが返されるはずです\[7\]。

このクレートとやり取りしている唯一の型は`Post`型であることに注意してください。この型は状態パターンを使用し、投稿がとりうるさまざまな状態（下書き、レビュー、または公開）を表す 3 つの状態オブジェクトの 1 つである値を保持します。状態の変更は`Post`型の内部で管理されます。状態の変更は、ライブラリのユーザーが`Post`インスタンスに対して呼び出すメソッドに応答して起こりますが、ユーザーは直接状態の変更を管理する必要はありません。また、ユーザーは状態に関して間違いを犯すこともありません。たとえば、レビューする前に投稿を公開するなどです。
