# Создание нового потока для каждого запроса

Сначала рассмотрим, как может выглядеть наш код, если он создаст новый поток для каждого соединения. Как уже говорилось ранее, это не наш окончательный план из-за проблем, связанных с потенциальным созданием неограниченного количества потоков, но это хороший стартовый вариант для создания работающего многопоточного сервера. Затем мы добавим пул потоков для улучшения, и сравнение двух решений будет проще.

Listing 20-11 показывает изменения в `main`, которые позволяют создать новый поток для обработки каждого потока в цикле `for`.

Filename: `src/main.rs`

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

Listing 20-11: Создание нового потока для каждого потока

Как вы узнали в главе 16, `thread::spawn` создаст новый поток и запустит код в замыкании в новом потоке. Если вы запустите этот код и загрузите _/sleep_ в браузере, а затем _/_ в двух других вкладках браузера, вы увидите, что запросы к _/_ не должны ждать завершения _/sleep_. Однако, как мы уже говорили, это в конечном итоге может перегрузить систему, потому что вы будете создавать новые потоки без ограничений.
