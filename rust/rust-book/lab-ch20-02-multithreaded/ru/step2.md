# Симуляция медленного запроса

Мы рассмотрим, как медленный запрос может повлиять на другие запросы к нашей текущей реализации сервера. Listing 20-10 реализует обработку запроса к _/sleep_ с имитированным медленным ответом, который заставит сервер спать в течение пяти секунд перед отправкой ответа.

Filename: `src/main.rs`

```rust
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
--snip--

fn handle_connection(mut stream: TcpStream) {
    --snip--

    let (status_line, filename) = 1 match &request_line[..] {
      2 "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
      3 "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
      4 _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    --snip--
}
```

Listing 20-10: Симуляция медленного запроса с помощью сна в течение пяти секунд

Мы переключились от `if` к `match`, так как теперь у нас три случая \[1\]. Мы должны явно сопоставить срез `request_line`, чтобы сопоставить с литеральными значениями строки; `match` не делает автоматическое ссылкирование и разыменование, как это делает метод равенства.

Первый случай \[2\] такой же, как и блок `if` из Listing 20-9. Второй случай \[3\] сопоставляет запрос к _/sleep_. Когда этот запрос получен, сервер будет спать в течение пяти секунд, прежде чем отобразить успешную HTML-страницу. Третий случай \[4\] такой же, как и блок `else` из Listing 20-9.

Вы можете увидеть, насколько примитивен наш сервер: настоящие библиотеки обрабатывали бы распознавание нескольких запросов гораздо менее избыточно!

Запустите сервер с помощью `cargo run`. Затем откройте два окна браузера: одно для *http://127.0.0.1:7878*, а другое для *http://127.0.0.1:7878/sleep*. Если вы несколько раз введете URI _/_, как и раньше, вы увидите, что он быстро отвечает. Но если вы введете _/sleep_, а затем загрузите _/_, вы увидите, что _/_ ждет, пока `sleep` не проспит полные пять секунд, прежде чем загрузиться.

Существует несколько методов, которые мы могли бы использовать, чтобы избежать накопления запросов за медленным запросом; тем, который мы реализуем, является пул потоков.
