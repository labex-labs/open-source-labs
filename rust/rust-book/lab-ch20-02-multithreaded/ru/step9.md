# Передача кода из ThreadPool в поток

В Listing 20-14 мы оставили комментарий в цикле `for` по поводу создания потоков. Здесь мы рассмотрим, как мы на самом деле создаем потоки. Стандартная библиотека предоставляет `thread::spawn` в качестве способа создания потоков, и `thread::spawn` ожидает получить некоторый код, который поток должен запустить сразу после создания. Однако в нашем случае мы хотим создать потоки и заставить их _ждать_ кода, который мы отправим позже. Реализация потоков в стандартной библиотеке не включает никакого способа сделать это; мы должны реализовать это вручную.

Мы реализуем это поведение, введя новую структуру данных между `ThreadPool` и потоками, которая будет управлять этим новым поведением. Мы назовем эту структуру данных _Worker_, что является распространенным термином в реализациях пулов. `Worker` получает код, который нужно выполнить, и запускает этот код в своем потоке.

Представьте, что люди работают в кухне ресторана: работники ждут, пока придут заказы от клиентов, а затем они отвечают за получение и выполнение этих заказов.

Вместо хранения вектора экземпляров `JoinHandle<()>` в пуле потоков мы будем хранить экземпляры структуры `Worker`. Каждый `Worker` будет хранить один экземпляр `JoinHandle<()`. Затем мы реализуем метод на `Worker`, который будет принимать замыкание кода для выполнения и отправлять его уже запущенному потоку для выполнения. Мы также дадим каждому `Worker` `id`, чтобы мы могли различать между различными экземплярами `Worker` в пуле при логировании или отладке.

Вот новый процесс, который будет происходить, когда мы создаем `ThreadPool`. Мы реализуем код, который отправляет замыкание в поток после того, как `Worker` будет настроен следующим образом:

1. Определить структуру `Worker`, которая содержит `id` и `JoinHandle<()`.
2. Изменить `ThreadPool`, чтобы хранить вектор экземпляров `Worker`.
3. Определить функцию `Worker::new`, которая принимает номер `id` и возвращает экземпляр `Worker`, который содержит `id` и поток, созданный с пустым замыканием.
4. В `ThreadPool::new` использовать счетчик цикла `for` для генерации `id`, создать новый `Worker` с этим `id` и сохранить `Worker` в векторе.

Если вы готовы к вызову, попробуйте самостоятельно реализовать эти изменения, прежде чем смотреть на код в Listing 20-15.

Готовы? Вот Listing 20-15 с одним способом вносить вышеперечисленные изменения.

Filename: `src/lib.rs`

```rust
use std::thread;

pub struct ThreadPool {
  1 workers: Vec<Worker>,
}

impl ThreadPool {
    --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

      2 for id in 0..size {
          3 workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    --snip--
}

4 struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
  5 fn new(id: usize) -> Worker {
      6 let thread = thread::spawn(|| {});

        Worker { 7 id, 8 thread }
    }
}
```

Listing 20-15: Изменение `ThreadPool` для хранения экземпляров `Worker` вместо прямого хранения потоков

Мы изменили имя поля в `ThreadPool` с `threads` на `workers`, потому что теперь оно хранит экземпляры `Worker` вместо экземпляров `JoinHandle<()>` \[1\]. Мы используем счетчик в цикле `for` \[2\] в качестве аргумента для `Worker::new`, и мы сохраняем каждый новый `Worker` в векторе под названием `workers` \[3\].

Внешний код (например, наша серверная программа в `src/main.rs`) не должен знать о реализации деталей использования структуры `Worker` внутри `ThreadPool`, поэтому мы делаем структуру `Worker` \[4\] и ее функцию `new` \[5\] приватными. Функция `Worker::new` использует `id`, которое мы ей передаем \[7\], и сохраняет экземпляр `JoinHandle<()>` \[8\], который создается путем запуска нового потока с пустым замыканием \[6\].

> Примечание: Если операционная система не может создать поток, потому что не хватает системных ресурсов, `thread::spawn` завершится с ошибкой. Это вызовет аварийное завершение нашей всей программы, даже если создание некоторых потоков может быть успешным. Для простоты этого поведение приемлемо, но в реализации пула потоков для производства вы, вероятно, захотите использовать `std::thread::Builder` и ее метод `spawn`, который возвращает `Result` вместо этого.

Этот код скомпилируется и будет хранить количество экземпляров `Worker`, которое мы указали в качестве аргумента для `ThreadPool::new`. Но мы _по-прежнему_ не обрабатываем замыкание, которое мы получаем в `execute`. Посмотрим, как это сделать дальше.
