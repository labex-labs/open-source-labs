# Создание места для хранения потоков

Теперь, когда у нас есть способ узнать, что у нас есть допустимое количество потоков для хранения в пуле, мы можем создать эти потоки и сохранить их в структуре `ThreadPool` перед возвратом структуры. Но как мы "сохраняем" поток? Давайте еще раз посмотрим на сигнатуру `thread::spawn`:

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,
```

Функция `spawn` возвращает `JoinHandle<T>`, где `T` - это тип, который возвращает замыкание. Попробуем также использовать `JoinHandle` и посмотрим, что произойдет. В нашем случае замыкания, которые мы передаем в пул потоков, будут обрабатывать соединение и ничего не возвращать, поэтому `T` будет единичным типом `()`.

Код в Listing 20-14 скомпилируется, но еще не создает никаких потоков. Мы изменили определение `ThreadPool`, чтобы хранить вектор экземпляров `thread::JoinHandle<()`, инициализировали вектор с вместимостью `size`, настроили цикл `for`, который будет выполнять некоторый код для создания потоков, и вернули экземпляр `ThreadPool`, содержащий их.

Filename: `src/lib.rs`

```rust
1 use std::thread;

pub struct ThreadPool {
  2 threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

      3 let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }
    --snip--
}
```

Listing 20-14: Создание вектора для `ThreadPool` для хранения потоков

Мы импортировали `std::thread` в библиотечный крейт \[1\], потому что мы используем `thread::JoinHandle` в качестве типа элементов в векторе в `ThreadPool` \[2\].

После получения допустимого размера наш `ThreadPool` создает новый вектор, который может хранить `size` элементов \[3\]. Функция `with_capacity` выполняет ту же задачу, что и `Vec::new`, но с важной разницей: она предварительно выделяет память в векторе. Поскольку мы знаем, что нужно сохранить `size` элементов в векторе, выполнение этой аллокации заранее немного более эффективно, чем использование `Vec::new`, которое изменяет свою размерность при вставке элементов.

Когда вы снова запустите `cargo check`, он должен выполниться успешно.
