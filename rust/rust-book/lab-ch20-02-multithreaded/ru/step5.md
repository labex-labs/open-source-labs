# Создание конечного количества потоков

Мы хотим, чтобы наш пул потоков работал похожим, знакомым способом, так чтобы переход от отдельных потоков к пулу потоков не требовал больших изменений в коде, использующем наш API. Listing 20-12 показывает гипотетический интерфейс для структуры `ThreadPool`, которую мы хотим использовать вместо `thread::spawn`.

Filename: `src/main.rs`

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
  1 let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

      2 pool.execute(|| {
            handle_connection(stream);
        });
    }
}
```

Listing 20-12: Наш идеальный интерфейс `ThreadPool`

Мы используем `ThreadPool::new` для создания нового пула потоков с конфигурируемым количеством потоков, в данном случае четыре \[1\]. Затем, в цикле `for`, `pool.execute` имеет похожий интерфейс, как и `thread::spawn`, в том смысле, что он принимает замыкание, которое пул должен выполнять для каждого потока \[2\]. Мы должны реализовать `pool.execute`, чтобы он принимал замыкание и передавало его потоку в пуле для выполнения. Этот код еще не скомпилируется, но мы попробуем, чтобы компилятор помог нам понять, как его исправить.
