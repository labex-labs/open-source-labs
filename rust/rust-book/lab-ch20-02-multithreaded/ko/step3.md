# 스레드 풀로 처리량 개선하기

*스레드 풀 (thread pool)*은 작업을 처리하기 위해 대기하고 준비된 스레드 그룹입니다. 프로그램이 새로운 작업을 받으면 풀의 스레드 중 하나를 해당 작업에 할당하고 해당 스레드가 작업을 처리합니다. 첫 번째 스레드가 처리하는 동안 풀의 나머지 스레드는 들어오는 다른 모든 작업을 처리할 수 있습니다. 첫 번째 스레드가 작업을 처리하는 것을 마치면 유휴 스레드 풀로 반환되어 새로운 작업을 처리할 준비가 됩니다. 스레드 풀을 사용하면 연결을 동시에 처리하여 서버의 처리량을 늘릴 수 있습니다.

DoS 공격으로부터 보호하기 위해 풀의 스레드 수를 소수로 제한합니다. 프로그램이 들어오는 각 요청에 대해 새로운 스레드를 생성하면, 누군가 서버에 1,000 만 개의 요청을 보내 서버의 모든 리소스를 소모하고 요청 처리를 중단시켜 혼란을 야기할 수 있습니다.

따라서 무제한 스레드를 생성하는 대신 풀에서 대기하는 고정된 수의 스레드를 갖게 됩니다. 들어오는 요청은 처리를 위해 풀로 전송됩니다. 풀은 들어오는 요청의 큐를 유지합니다. 풀의 각 스레드는 이 큐에서 요청을 꺼내 처리한 다음 큐에 다른 요청을 요청합니다. 이 설계를 사용하면 N 개의 요청을 동시에 처리할 수 있으며, 여기서 N 은 스레드 수입니다. 각 스레드가 장기 실행 요청에 응답하는 경우 후속 요청은 여전히 큐에 백업될 수 있지만, 해당 지점에 도달하기 전에 처리할 수 있는 장기 실행 요청의 수를 늘렸습니다.

이 기술은 웹 서버의 처리량을 개선하는 여러 가지 방법 중 하나일 뿐입니다. 탐색할 수 있는 다른 옵션으로는 fork/join 모델, 단일 스레드 비동기 I/O 모델 및 멀티스레드 비동기 I/O 모델이 있습니다. 이 주제에 관심이 있다면 다른 솔루션에 대해 자세히 알아보고 구현해 볼 수 있습니다. Rust 와 같은 저수준 언어를 사용하면 이러한 모든 옵션이 가능합니다.

스레드 풀을 구현하기 전에 풀을 사용하는 모습이 어떠해야 하는지 이야기해 보겠습니다. 코드를 설계하려는 경우, 먼저 클라이언트 인터페이스를 작성하면 설계를 안내하는 데 도움이 될 수 있습니다. 코드를 호출하려는 방식으로 구조화되도록 API 를 작성합니다. 그런 다음 공용 API 를 설계하는 대신 해당 구조 내에서 기능을 구현합니다.

12 장에서 프로젝트에서 테스트 주도 개발을 사용했던 방식과 유사하게, 여기서는 컴파일러 주도 개발을 사용합니다. 원하는 함수를 호출하는 코드를 작성한 다음 컴파일러의 오류를 살펴보고 코드가 작동하도록 하기 위해 다음에 무엇을 변경해야 하는지 결정합니다. 그러나 그 전에 시작점으로 사용할 수 없는 기술을 살펴보겠습니다.
