# 각 요청에 대해 스레드 생성하기

먼저, 각 연결에 대해 새로운 스레드를 생성하는 경우 코드가 어떻게 보일 수 있는지 살펴보겠습니다. 앞서 언급했듯이, 잠재적으로 무제한 수의 스레드를 생성하는 문제로 인해 이것은 최종 계획이 아니지만, 먼저 작동하는 멀티스레드 서버를 얻기 위한 시작점입니다. 그런 다음 스레드 풀을 개선 사항으로 추가하고 두 솔루션을 비교하는 것이 더 쉬워질 것입니다.

Listing 20-11 은 `for` 루프 내에서 각 스트림을 처리하기 위해 새로운 스레드를 생성하도록 `main`에 적용할 변경 사항을 보여줍니다.

파일 이름: `src/main.rs`

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

Listing 20-11: 각 스트림에 대해 새로운 스레드 생성

16 장에서 배운 것처럼, `thread::spawn`은 새로운 스레드를 생성한 다음 새로운 스레드에서 클로저의 코드를 실행합니다. 이 코드를 실행하고 브라우저에서 */sleep*을 로드한 다음 다른 두 개의 브라우저 탭에서 */*를 로드하면, */*에 대한 요청이 */sleep*이 완료될 때까지 기다릴 필요가 없다는 것을 실제로 확인할 수 있습니다. 그러나 언급했듯이, 이는 결국 시스템을 압도할 것입니다. 왜냐하면 제한 없이 새로운 스레드를 생성하게 될 것이기 때문입니다.
