# ThreadPool からスレッドにコードを送信する

リスト 20-14 の `for` ループに、スレッドの作成に関するコメントを残しました。ここでは、実際にスレッドを作成する方法を見ていきます。標準ライブラリは、スレッドを作成する方法として `thread::spawn` を提供しており、`thread::spawn` は、スレッドが作成されるとすぐに実行するコードを取得することを期待しています。しかし、私たちの場合、スレッドを作成して、後で送信するコードを待たせたいと考えています。標準ライブラリのスレッドの実装には、そのような方法は含まれていません。手動で実装する必要があります。

この動作を実装するには、`ThreadPool` とスレッドの間に新しいデータ構造を導入して、この新しい動作を管理します。このデータ構造を _Worker_ と呼びます。これは、プーリングの実装で一般的な用語です。`Worker` は、実行する必要のあるコードを拾い上げて、そのコードを自分のスレッドで実行します。

レストランのキッチンで働く人を想像してみてください。従業員は、客からの注文が届くまで待ち、その注文を受け取って処理する責任があります。

スレッドプールに `JoinHandle<()>` インスタンスのベクトルを格納する代わりに、`Worker` 構造体のインスタンスを格納します。各 `Worker` は、1 つの `JoinHandle<()>` インスタンスを格納します。そして、`Worker` のメソッドを実装して、実行するコードのクロージャを受け取り、それを既に実行中のスレッドに送信して実行させます。また、各 `Worker` に `id` を与えて、ログ記録やデバッグ時にプール内の異なる `Worker` インスタンスを区別できるようにします。

これが、`ThreadPool` を作成する際に起こる新しいプロセスです。このように `Worker` をセットアップした後、クロージャをスレッドに送信するコードを実装します。

1. `id` と `JoinHandle<()>` を保持する `Worker` 構造体を定義する。
2. `ThreadPool` を変更して、`Worker` インスタンスのベクトルを保持する。
3. `id` 番号を受け取り、`id` と空のクロージャで生成されたスレッドを保持する `Worker` インスタンスを返す `Worker::new` 関数を定義する。
4. `ThreadPool::new` では、`for` ループのカウンタを使って `id` を生成し、その `id` で新しい `Worker` を作成し、`Worker` をベクトルに格納する。

もしチャレンジが好きなら、リスト 20-15 のコードを見る前に、自分でこれらの変更を実装してみてください。

準備はできましたか？以下に、前述の変更を行う 1 つの方法を示すリスト 20-15 を掲載します。

ファイル名：`src/lib.rs`

```rust
use std::thread;

pub struct ThreadPool {
  1 workers: Vec<Worker>,
}

impl ThreadPool {
    --snip--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut workers = Vec::with_capacity(size);

      2 for id in 0..size {
          3 workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    --snip--
}

4 struct Worker {
    id: usize,
    thread: thread::JoinHandle<()>,
}

impl Worker {
  5 fn new(id: usize) -> Worker {
      6 let thread = thread::spawn(|| {});

        Worker { 7 id, 8 thread }
    }
}
```

リスト 20-15: `ThreadPool` を変更して、直接スレッドを保持する代わりに `Worker` インスタンスを保持する

`ThreadPool` のフィールド名を `threads` から `workers` に変更しました。なぜなら、今では `JoinHandle<()>` インスタンスではなく `Worker` インスタンスを保持しているからです \[1\]。`for` ループのカウンタを \[2\]、`Worker::new` の引数として使い、各新しい `Worker` を `workers` という名前のベクトルに格納します \[3\]。

外部コード（`src/main.rs` のサーバのようなもの）は、`ThreadPool` 内で `Worker` 構造体を使用する実装の詳細を知る必要はありません。ですから、`Worker` 構造体 \[4\] とその `new` 関数 \[5\] を非公開にします。`Worker::new` 関数は、与えられた `id` を使って \[7\]、空のクロージャを使って新しいスレッドを生成することで作成された `JoinHandle<()>` インスタンスを格納します \[8\] \[6\]。

> 注：システムリソースが足りないためにオペレーティングシステムがスレッドを作成できない場合、`thread::spawn` はパニックになります。これにより、一部のスレッドの作成が成功したとしても、私たちのサーバ全体がパニックになります。単純化のため、この動作は問題ありませんが、本番環境のスレッドプールの実装では、おそらく `std::thread::Builder` とその `spawn` メソッドを使って、代わりに `Result` を返す方が良いでしょう。

このコードはコンパイルされ、`ThreadPool::new` に引数として指定した `Worker` インスタンスの数を格納します。しかし、まだ `execute` で受け取ったクロージャを処理していません。次に、それを行う方法を見ていきましょう。
