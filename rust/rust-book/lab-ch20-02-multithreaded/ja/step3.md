# スレッドプールを使ったスループットの向上

「スレッドプール」とは、生成されたスレッドのグループであり、タスクを処理するために待機していて準備ができています。プログラムが新しいタスクを受け取ると、プール内のスレッドの1つをそのタスクに割り当て、そのスレッドがタスクを処理します。プール内の残りのスレッドは、最初のスレッドが処理している間に入ってくる他のタスクを処理するために利用可能です。最初のスレッドがタスクの処理を終えると、それは待機中のスレッドのプールに戻され、新しいタスクを処理する準備ができます。スレッドプールを使うことで、接続を同時に処理して、サーバのスループットを向上させることができます。

DoS攻撃から守るために、プール内のスレッド数を少ない数に制限します。もし、プログラムが各要求が入ってきたときに新しいスレッドを作成するようにしていた場合、誰かがサーバに1000万回の要求を行うことで、すべてのサーバのリソースを使い果たして要求の処理を停止させて大混乱を引き起こす可能性があります。

そのため、無制限のスレッドを生成するのではなく、プール内に固定数のスレッドを待機させます。入ってきた要求は、処理のためにプールに送られます。プールは、入ってきた要求のキューを維持します。プール内の各スレッドは、このキューから要求を取り出し、要求を処理し、その後、キューに別の要求を求めます。この設計では、N個の要求を同時に処理することができます。ここでNはスレッドの数です。各スレッドが長時間実行される要求に応答している場合、その後の要求は依然としてキューにバックアップする可能性がありますが、その時点に達する前に処理できる長時間実行される要求の数を増やしました。

この技術は、Webサーバのスループットを向上させるための多くの方法の1つにすぎません。他に探検できるオプションとしては、フォーク/ジョインモデル、単一スレッドの非同期I/Oモデル、およびマルチスレッドの非同期I/Oモデルがあります。このトピックに興味がある場合は、他のソリューションについてもっと読んで実装してみることができます。Rustのような低レベル言語では、これらのオプションすべてが可能です。

スレッドプールを実装する前に、プールを使った場合がどのようになるかについて話し合いましょう。コードを設計しようとするとき、最初にクライアントインターフェイスを書くことで、設計を導くことができます。コードのAPIをその呼び出し方を望むように構造化するように書きます。そして、その構造内で機能を実装します。機能を実装してから公開APIを設計するのではなくです。

第12章のプロジェクトでテスト駆動開発を使った方法と同様に、ここではコンパイラ駆動開発を使います。私たちが呼び出したい関数を呼び出すコードを書き、その後、コードが動作するように次に何を変更すべきかを決定するために、コンパイラからのエラーを見ます。しかし、それを行う前に、最初として使わない技術を探ります。
