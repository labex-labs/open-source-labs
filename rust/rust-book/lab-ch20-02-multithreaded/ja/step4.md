# 各要求に対してスレッドを生成する

まず、コードが各接続に対して新しいスレッドを生成する場合のコードの見た目を見てみましょう。前述の通り、潜在的に無制限の数のスレッドを生成する問題のため、これは私たちの最終的な計画ではありませんが、まず動作するマルチスレッドサーバを作るための出発点としては役立ちます。その後、スレッドプールを改善策として追加し、2つのソリューションを比較することがより容易になります。

リスト20-11は、`for` ループ内の各ストリームを処理するために新しいスレッドを生成するために `main` に加える変更を示しています。

ファイル名: `src/main.rs`

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

リスト20-11: 各ストリームに対して新しいスレッドを生成する

第16章で学んだように、`thread::spawn` は新しいスレッドを作成し、その後、クロージャ内のコードを新しいスレッドで実行します。このコードを実行して、ブラウザで _/sleep_ を読み込み、その後、さらに2つのブラウザタブで _/_ を読み込むと、_/_ への要求が _/sleep_ が終了するのを待たなくて済むことが確認できます。しかし、前述の通り、これは最終的にはシステムを圧倒してしまうでしょう。なぜなら、制限なく新しいスレッドを作成してしまうからです。
