# 低速な要求のシミュレーション

低速な処理を行う要求が、現在のサーバ実装に対して行われる他の要求にどのような影響を与えるか見てみましょう。リスト 20-10 では、5 秒間スリープしてから応答する疑似的な低速な応答で、_/sleep_ への要求の処理を実装しています。

ファイル名：`src/main.rs`

```rust
use std::{
    fs,
    io::{prelude::*, BufReader},
    net::{TcpListener, TcpStream},
    thread,
    time::Duration,
};
--snip--

fn handle_connection(mut stream: TcpStream) {
    --snip--

    let (status_line, filename) = 1 match &request_line[..] {
      2 "GET / HTTP/1.1" => ("HTTP/1.1 200 OK", "hello.html"),
      3 "GET /sleep HTTP/1.1" => {
            thread::sleep(Duration::from_secs(5));
            ("HTTP/1.1 200 OK", "hello.html")
        }
      4 _ => ("HTTP/1.1 404 NOT FOUND", "404.html"),
    };

    --snip--
}
```

リスト 20-10: 5 秒間スリープすることで低速な要求をシミュレートする

3 つのケースがあるので、今では `if` から `match` に切り替えました \[1\]。文字列リテラル値とのパターンマッチングのために、`request_line` のスライスを明示的にマッチさせる必要があります。`match` は、等値メソッドのように自動的な参照と参照解除を行いません。

最初のアーム \[2\] は、リスト 20-9 の `if` ブロックと同じです。2 番目のアーム \[3\] は、_/sleep_ への要求をマッチさせます。その要求が受け取られると、サーバは成功した HTML ページをレンダリングする前に 5 秒間スリープします。3 番目のアーム \[4\] は、リスト 20-9 の `else` ブロックと同じです。

サーバがどれほど単純であるかがわかります。実際のライブラリは、もっと簡潔な方法で複数の要求の認識を処理します！

`cargo run` を使ってサーバを起動します。そして、2 つのブラウザウィンドウを開きます。1 つは *http://127.0.0.1:7878* 用で、もう 1 つは *http://127.0.0.1:7878/sleep* 用です。以前と同じように、_/_ URI を何度か入力すると、すばやく応答することがわかります。しかし、_/sleep_ を入力してから _/_ を読み込むと、_/_ は `sleep` が 5 秒間完全にスリープするのを待ってから読み込まれることがわかります。

低速な要求の後に要求がバックアップするのを回避するために、いくつかの手法があります。ここで実装するのは、スレッドプールです。
