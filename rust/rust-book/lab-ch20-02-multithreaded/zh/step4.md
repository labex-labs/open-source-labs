# 为每个请求生成一个线程

首先，让我们探讨一下如果代码真的为每个连接都创建一个新线程，代码会是什么样子。如前所述，由于可能会生成无限制数量的线程存在问题，这不是我们的最终方案，但这是首先获得一个可运行的多线程服务器的起点。然后我们将添加线程池作为改进，对比这两种解决方案会更容易。

清单 20-11 展示了对`main`函数所做的更改，以便在`for`循环中为每个流生成一个新线程来处理。

文件名：`src/main.rs`

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

清单 20-11：为每个流生成一个新线程

正如你在第 16 章中学到的，`thread::spawn`会创建一个新线程，然后在新线程中运行闭包中的代码。如果你运行这段代码，并在浏览器中加载`/sleep`，然后再在另外两个浏览器标签中加载`/_`，你确实会看到对`/_`的请求不必等待`/sleep`完成。然而，正如我们所提到的，这最终会使系统不堪重负，因为你会无限制地创建新线程。
