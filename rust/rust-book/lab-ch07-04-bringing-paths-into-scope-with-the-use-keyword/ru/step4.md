# Re-exporting Names with pub use

Когда мы подключаем имя в скоуп с помощью ключевого слова `use`, имя, доступное в новом скоупе, является приватным. Чтобы позволить коду, вызывающему наш код, ссылаться на это имя так, будто бы оно было определено в скоупе этого кода, мы можем комбинировать `pub` и `use`. Эта техника называется _re-exporting_ (переэкспортированием), потому что мы подключаем элемент в скоуп, но также делаем этот элемент доступным для других, чтобы они могли подключить его в свой скоуп.

Listing 7-17 показывает код из Listing 7-11 с `use` в корневом модуле, изменённым на `pub use`.

Filename: `src/lib.rs`

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

Listing 7-17: Making a name available for any code to use from a new scope with `pub use`

До этого изменения внешний код должен был вызывать функцию `add_to_waitlist` с использованием пути `restaurant::front_of_house::hosting::add_to_waitlist()`. Теперь, когда `pub use` переэкспортировал модуль `hosting` из корневого модуля, внешний код может использовать путь `restaurant::hosting::add_to_waitlist()` вместо этого.

Переэкспортирование полезно, когда внутренняя структура вашего кода отличается от того, как программисты, вызывающие ваш код, представляют собой домен. Например, в этой метафоре ресторана люди, управляющие рестораном, думают о "фронте дома" и "заднем доме". Но посетители ресторана, вероятно, не будут думать о частях ресторана в этих терминах. С помощью `pub use` мы можем писать свой код с одной структурой, но предоставлять другую структуру. Это делает нашу библиотеку хорошо организованной как для программистов, работающих над библиотекой, так и для программистов, вызывающих библиотеку. Мы рассмотрим еще один пример `pub use` и то, как он влияет на документацию вашего пакета в разделе "Exporting a Convenient Public API with pub use".
