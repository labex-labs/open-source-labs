# Using Nested Paths to Clean Up Large use Lists

Если мы используем несколько элементов, определенных в одном и том же пакете или модуле, перечисление каждого элемента на отдельной строке может занимать много вертикального пространства в наших файлах. Например, эти два `use`-статмента, которые мы имели в игре в угадайку в Listing 2-4, подключают элементы из `std` в скоуп:

Filename: `src/main.rs`

```rust
--snip--
use std::cmp::Ordering;
use std::io;
--snip--
```

Вместо этого мы можем использовать вложенные пути, чтобы подключить те же элементы в скоуп в одну строку. Мы делаем это, указав общий участок пути, за которым следуют два двоеточия, а затем фигурные скобки вокруг списка частей путей, которые отличаются, как показано в Listing 7-18.

Filename: `src/main.rs`

```rust
--snip--
use std::{cmp::Ordering, io};
--snip--
```

Listing 7-18: Specifying a nested path to bring multiple items with the same prefix into scope

В больших программах подключение многих элементов в скоуп из одного и того же пакета или модуля с использованием вложенных путей может значительно сократить количество отдельных `use`-статментов!

Мы можем использовать вложенный путь на любом уровне в пути, что полезно при комбинировании двух `use`-статментов, которые имеют общий подпуть. Например, Listing 7-19 показывает два `use`-статмента: один, который подключает `std::io` в скоуп, и другой, который подключает `std::io::Write` в скоуп.

Filename: `src/lib.rs`

```rust
use std::io;
use std::io::Write;
```

Listing 7-19: Two `use` statements where one is a subpath of the other

Общий участок этих двух путей - это `std::io`, и это полный первый путь. Чтобы объединить эти два пути в один `use`-статмент, мы можем использовать `self` в вложенном пути, как показано в Listing 7-20.

Filename: `src/lib.rs`

```rust
use std::io::{self, Write};
```

Listing 7-20: Combining the paths in Listing 7-19 into one `use` statement

Эта строка подключает `std::io` и `std::io::Write` в скоуп.
