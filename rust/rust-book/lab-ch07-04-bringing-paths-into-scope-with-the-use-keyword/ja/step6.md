# ネストされたパスを使って大きな use リストを整理する

同じクレートまたは同じモジュールに定義された複数の項目を使用する場合、それぞれの項目を個別の行に列挙すると、ファイル内で多くの垂直スペースを占めることになります。たとえば、リスト 2-4 の予想ゲームで使用したこれら 2 つの `use` 文は、`std` からの項目をスコープに持ち込みます。

ファイル名: `src/main.rs`

```rust
--snip--
use std::cmp::Ordering;
use std::io;
--snip--
```

代わりに、ネストされたパスを使って、同じ項目を 1 行でスコープに持ち込むことができます。これは、パスの共通部分を指定し、その後に 2 つのコロンを続け、その後に異なるパスの部分のリストを囲む波括弧を使うことで行います。これはリスト 7-18 に示されています。

ファイル名: `src/main.rs`

```rust
--snip--
use std::{cmp::Ordering, io};
--snip--
```

リスト 7-18: 同じ接頭辞を持つ複数の項目をスコープに持ち込むためのネストされたパスを指定する

より大きなプログラムでは、同じクレートまたはモジュールから多数の項目をネストされたパスを使ってスコープに持ち込むことで、必要な個別の `use` 文の数を大幅に減らすことができます！

パスのどのレベルでもネストされたパスを使用できます。これは、サブパスを共有する 2 つの `use` 文を結合する際に便利です。たとえば、リスト 7-19 は 2 つの `use` 文を示しています。1 つは `std::io` をスコープに持ち込み、もう 1 つは `std::io::Write` をスコープに持ち込みます。

ファイル名: `src/lib.rs`

```rust
use std::io;
use std::io::Write;
```

リスト 7-19: 1 つがもう 1 つのサブパスである 2 つの `use` 文

これら 2 つのパスの共通部分は `std::io` であり、これが最初の完全なパスです。これら 2 つのパスを 1 つの `use` 文にマージするには、ネストされたパスで `self` を使用することができます。これはリスト 7-20 に示されています。

ファイル名: `src/lib.rs`

```rust
use std::io::{self, Write};
```

リスト 7-20: リスト 7-19 のパスを 1 つの `use` 文に結合する

この行は、`std::io` と `std::io::Write` をスコープに持ち込みます。
