# Скрытие (Shadowing)

Как вы видели в уроке по игре в угадывание в главе 2, вы можете объявить новую переменную с тем же именем, что и предыдущая переменная. Rustaceans говорят, что первая переменная **скрывается** (shadowed) второй, что означает, что вторая переменная - это то, что увидит компилятор, когда вы используете имя переменной. По сути, вторая переменная скрывает первую, захватывая любые использования имени переменной для себя, пока она сама не будет скрыта или не закончится область видимости. Мы можем скрыть переменную, используя то же имя переменной и повторяя использование ключевого слова `let` следующим образом:

Имя файла: `src/main.rs`

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

Эта программа сначала связывает `x` с значением `5`. Затем она создает новую переменную `x`, повторяя `let x =`, беря исходное значение и добавляя `1`, так что значение `x` становится `6`. Затем, внутри области видимости, созданной с помощью фигурных скобок, третье объявление `let` также скрывает `x` и создает новую переменную, умножая предыдущее значение на `2`, чтобы `x` получил значение `12`. Когда эта область видимости заканчивается, внутреннее скрытие заканчивается и `x` возвращается к значению `6`. Когда мы запускаем эту программу, она выведет следующее:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
```

Скрытие отличается от пометки переменной как `mut`, потому что мы получим ошибку компиляции, если случайно попытаемся переприсвоить значение этой переменной без использования ключевого слова `let`. Используя `let`, мы можем выполнить несколько преобразований над значением, но переменная останется неизменяемой после завершения этих преобразований.

Другой разница между `mut` и скрытием заключается в том, что, так как мы фактически создаем новую переменную, когда снова используем ключевое слово `let`, мы можем изменить тип значения, но повторно использовать то же имя. Например, допустим, наша программа запрашивает у пользователя, сколько пробелов он хочет вставить между некоторым текстом, вводя пробельные символы, а затем мы хотим сохранить этот ввод в виде числа:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

Первая переменная `spaces` имеет тип строки, а вторая переменная `spaces` имеет тип числа. Таким образом, скрытие позволяет избежать необходимости придумывать разные имена, такие как `spaces_str` и `spaces_num`; вместо этого мы можем повторно использовать более простое имя `spaces`. Однако, если мы попытаемся использовать `mut` для этого, как показано ниже, мы получим ошибку компиляции:

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

Ошибка говорит, что мы не можем изменять тип переменной:

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
2 |     let mut spaces = "   ";
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&str`, found `usize`
```

Теперь, когда мы изучили, как работают переменные, давайте посмотрим на более типы данных, которые они могут иметь.
