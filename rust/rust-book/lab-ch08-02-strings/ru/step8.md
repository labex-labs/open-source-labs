# Внутреннее представление

`String` - это обертка над `Vec<u8>`. Посмотрим на некоторые из наших правильно закодированных примеров строк в UTF-8 из Listing 8-14. Во - первых, этот:

```rust
let hello = String::from("Hola");
```

В этом случае `len` будет равным `4`, что означает, что вектор, хранящий строку `"Hola"`, имеет длину 4 байта. Каждая из этих букв занимает один байт при кодировании в UTF-8. Однако, следующая строка может удиви вас (заметьте, что эта строка начинается с заглавной кириллической буквы _Ze_, а не арабской цифры 3):

```rust
let hello = String::from("Здравствуйте");
```

Если бы вас попросили сказать, какова длина строки, вы, возможно, бы ответили 12. Фактически Rust ответит 24: это количество байт, которое требуется для кодирования "Здравствуйте" в UTF-8, потому что каждый кодовая точка Юникода в этой строке занимает 2 байта памяти. Поэтому индекс в байты строки не всегда будет соответствовать валидной кодовой точке Юникода. Чтобы продемонстрировать это, рассмотрим этот недействительный код на Rust:

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

Вы уже знаете, что `answer` не будет равно `З`, первой букве. При кодировании в UTF-8 первый байт `З` равен `208`, а второй - `151`, так что может показаться, что `answer` на самом деле должен быть `208`, но `208` по себе не является валидным символом. Возвращение `208`, вероятно, не то, что пользователь ожидает, если он попросил первую букву этой строки; однако, это единственная информация, которую Rust имеет по байтовому индексу 0. Пользователи обычно не хотят получать байтовое значение, даже если строка содержит только латинские буквы: если `&"hello"[0]` было бы допустимым кодом, который возвращает байтовое значение, то он вернул бы `104`, а не `h`.

Поэтому ответ заключается в том, чтобы избежать возврата неожиданного значения и возникновения ошибок, которые могут не быть обнаружены сразу, Rust не компилирует этот код вовсе и предотвращает недоразумения в ранней стадии разработки.
