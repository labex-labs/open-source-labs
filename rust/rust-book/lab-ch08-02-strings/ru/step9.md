# Байты, кодовые точки и кластеры графем! Ого!

Еще один аспект UTF-8 заключается в том, что на самом деле есть три взаимосвязанных способа рассматривать строки с точки зрения Rust: как байты, кодовые точки и кластеры графем (ближайшее к тому, что мы называем _буквами_).

Если мы посмотрим на индийское слово "नमस्ते", написанное в देवанागари, оно хранится в виде вектора значений `u8`, который выглядит так:

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224,
164, 164, 224, 165, 135]
```

Это 18 байт, и именно так компьютеры в конечном итоге хранят эти данные. Если мы рассматриваем их как кодовые точки Юникода, которые соответствуют типу `char` в Rust, эти байты выглядят так:

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

Здесь шесть значений `char`, но четвертое и шестое не являются буквами: это диакритические знаки, которые не имеют смысла по отдельности. Наконец, если мы рассматриваем их как кластеры графем, мы получим то, что человек назовет четыре буквы, составляющие индийское слово:

```rust
["न", "म", "स्", "ते"]
```

Rust предоставляет разные способы интерпретации исходных данных строк, которые хранят компьютеры, чтобы каждый программа могла выбрать ту интерпретацию, которая ей нужна, независимо от того, на каком человеческом языке данные представлены.

Последняя причина, по которой Rust не позволяет нам обращаться к `String` по индексу, чтобы получить символ, заключается в том, что операции индексирования должны всегда выполняться за постоянное время (O(1)). Но невозможно гарантировать такую производительность для `String`, потому что Rust должен был бы просмотреть содержимое от начала до индекса, чтобы определить, сколько валидных символов есть.
