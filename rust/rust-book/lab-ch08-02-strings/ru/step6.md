# Конкатенация с помощью оператора + или макроса format!

Часто вы захотите объединить две существующие строки. Одним из способов сделать это является использование оператора `+`, как показано в Listing 8-18.

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // обратите внимание, что s1 была перемещена сюда и больше не может быть использована
```

Listing 8-18: Использование оператора `+` для объединения двух значений `String` в новое значение `String`

Строка `s3` будет содержать `Hello, world!`. Причина, по которой `s1` больше недействительна после сложения, и причина, по которой мы использовали ссылку на `s2`, связана с сигнатурой метода, который вызывается, когда мы используем оператор `+`. Оператор `+` использует метод `add`, сигнатура которого выглядит примерно так:

```rust
fn add(self, s: &str) -> String {
```

В стандартной библиотеке вы увидите, что `add` определяется с использованием обобщений и связанных типов. Здесь мы подставили конкретные типы, что происходит, когда мы вызываем этот метод с значениями `String`. Мы обсудим обобщения в главе 10. Эта сигнатура дает нам подсказки, которые нам нужны, чтобы понять сложные аспекты оператора `+`.

Во - первых, `s2` имеет `&`, что означает, что мы добавляем _ссылку_ на вторую строку к первой строке. Это связано с параметром `s` в функции `add`: мы можем добавить только `&str` к `String`; мы не можем сложить два значения `String` вместе. Но подождите - тип `&s2` - это `&String`, а не `&str`, как указано во втором параметре для `add`. Тогда почему Listing 8-18 компилируется?

Причина, по которой мы можем использовать `&s2` в вызове `add`, заключается в том, что компилятор может _принудительно преобразовать_ аргумент `&String` в `&str`. Когда мы вызываем метод `add`, Rust использует _принудительное приведение по делименованию_ (deref coercion), которое здесь преобразует `&s2` в `&s2[..]`. Мы обсудим принудительное приведение по делименованию более подробно в главе 15. Поскольку `add` не берет владение параметром `s`, `s2` по-прежнему будет действительным `String` после этой операции.

Во - вторых, мы можем видеть в сигнатуре, что `add` берет владение `self`, потому что `self` не имеет `&`. Это означает, что `s1` в Listing 8-18 будет перемещен в вызов `add` и больше не будет действительным после этого. Таким образом, хотя `let s3 = s1 + &s2;` выглядит так, будто он скопирует обе строки и создаст новую, на самом деле этот оператор берет владение `s1`, добавляет копию содержимого `s2` и затем возвращает владение результатом. Другими словами, кажется, что он делает много копий, но на самом деле не делает; реализация более эффективна, чем копирование.

Если нам нужно конкатенировать несколько строк, поведение оператора `+` становится неудобным:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

В этом случае `s` будет равна `tic-tac-toe`. Со всеми символами `+` и `"` трудно понять, что происходит. Для более сложного объединения строк мы вместо этого можем использовать макрос `format!`:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

Этот код также устанавливает `s` равным `tic-tac-toe`. Макрос `format!` работает так же, как `println!`, но вместо вывода вывода на экран он возвращает `String` с содержимым. Версия кода, использующая `format!`, гораздо легче читать, и код, сгенерированный макросом `format!`, использует ссылки, чтобы этот вызов не занимал владение ни одним из своих параметров.
