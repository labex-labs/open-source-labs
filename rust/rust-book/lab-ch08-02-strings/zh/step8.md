# 内部表示

`String` 是 `Vec<u8>` 的一个包装器。让我们来看一下清单 8-14 中一些正确编码的 UTF-8 示例字符串。首先，这个：

```rust
let hello = String::from("Hola");
```

在这种情况下，`len` 将是 `4`，这意味着存储字符串“Hola”的向量长度为 4 个字节。在 UTF-8 编码中，这些字母每个都占用一个字节。然而，下一行可能会让你感到惊讶（请注意，这个字符串以大写西里尔字母“Зе”开头，而不是阿拉伯数字 3）：

```rust
let hello = String::from("Здравствуйте");
```

如果你被问到这个字符串有多长，你可能会说 12。实际上，Rust 的答案是 24：这是将“Здравствуйте”编码为 UTF-8 所需的字节数，因为该字符串中的每个 Unicode 标量值都占用 2 个字节的存储空间。因此，对字符串字节的索引并不总是与有效的 Unicode 标量值相关联。为了说明这一点，考虑这段无效的 Rust 代码：

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

你已经知道 `answer` 不会是第一个字母“З”。在 UTF-8 编码中，“З”的第一个字节是 `208`，第二个字节是 `151`，所以看起来 `answer` 实际上应该是 `208`，但 `208` 本身并不是一个有效的字符。如果用户询问这个字符串的第一个字母，返回 `208` 可能不是他们想要的；然而，这是 Rust 在字节索引 0 处唯一拥有的数据。即使字符串只包含拉丁字母，用户通常也不希望返回字节值：如果 `&"hello"[0]` 是返回字节值的有效代码，它将返回 `104`，而不是 `h`。

那么答案是，为了避免返回意外的值并导致可能不会立即被发现的错误，Rust 根本不会编译这段代码，并在开发过程的早期防止误解。
