# 使用 + 运算符或 format! 宏进行拼接

通常，你会想要将两个现有的字符串组合起来。一种方法是使用 `+` 运算符，如清单 8-18 所示。

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意，s1 在这里已经被移动，不能再使用
```

清单 8-18：使用 `+` 运算符将两个 `String` 值组合成一个新的 `String` 值

字符串 `s3` 将包含“Hello, world!”。加法运算后 `s1` 不再有效，以及我们使用 `s2` 的引用的原因，与我们使用 `+` 运算符时调用的方法签名有关。`+` 运算符使用 `add` 方法，其签名大致如下：

```rust
fn add(self, s: &str) -> String {
```

在标准库中，你会看到 `add` 是使用泛型和关联类型定义的。这里，我们代入了具体类型，这就是我们用 `String` 值调用这个方法时发生的情况。我们将在第 10 章讨论泛型。这个签名为我们提供了理解 `+` 运算符棘手部分所需的线索。

首先，`s2` 有一个 `&`，这意味着我们将第二个字符串的一个 _引用_ 添加到第一个字符串中。这是因为 `add` 函数中的 `s` 参数：我们只能将一个 `&str` 添加到一个 `String`；我们不能将两个 `String` 值相加。但是等等——`&s2` 的类型是 `&String`，而不是 `add` 的第二个参数中指定的 `&str`。那么为什么清单 8-18 能编译呢？

我们能够在调用 `add` 时使用 `&s2` 的原因是编译器可以将 `&String` 参数 _强制转换_ 为 `&str`。当我们调用 `add` 方法时，Rust 使用了一种 _解引用强制转换_，在这里它将 `&s2` 转换为 `&s2[..]`。我们将在第 15 章更深入地讨论解引用强制转换。因为 `add` 不获取 `s` 参数的所有权，所以在这个操作之后 `s2` 仍然是一个有效的 `String`。

其次，我们可以在签名中看到 `add` 获取了 `self` 的所有权，因为 `self` 没有 `&`。这意味着清单 8-18 中的 `s1` 将被移动到 `add` 调用中，并且在那之后将不再有效。所以，尽管 `let s3 = s1 + &s2;` 看起来像是会复制两个字符串并创建一个新的，但实际上这条语句获取了 `s1` 的所有权，追加了 `s2` 内容的一个副本，然后返回结果的所有权。换句话说，它看起来像是在进行大量复制，但实际上不是；其实现比复制更高效。

如果我们需要拼接多个字符串，`+` 运算符的行为会变得很麻烦：

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

此时，`s` 将是“tic-tac-toe”。有了所有的 `+` 和 `"` 字符，很难看出发生了什么。为了以更复杂的方式组合字符串，我们可以使用 `format!` 宏：

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

这段代码也将 `s` 设置为“tic-tac-toe”。`format!` 宏的工作方式类似于 `println!`，但它不是将输出打印到屏幕上，而是返回一个包含内容的 `String`。使用 `format!` 的代码版本更易于阅读，并且 `format!` 宏生成的代码使用引用，这样这个调用不会获取其任何参数的所有权。
