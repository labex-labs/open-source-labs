# 내부 표현 (Internal Representation)

`String`은 `Vec<u8>`을 감싸는 래퍼 (wrapper) 입니다. Listing 8-14 에서 올바르게 인코딩된 UTF-8 예제 문자열을 살펴보겠습니다. 먼저, 다음 문자열입니다.

```rust
let hello = String::from("Hola");
```

이 경우 `len`은 `4`가 되며, 이는 문자열 `"Hola"`를 저장하는 벡터가 4 바이트 길이임을 의미합니다. UTF-8 로 인코딩될 때 각 문자는 1 바이트를 차지합니다. 그러나 다음 줄은 예상 밖일 수 있습니다 (이 문자열은 아라비아 숫자 3 이 아닌 키릴 문자 대문자 *Ze*로 시작합니다).

```rust
let hello = String::from("Здравствуйте");
```

문자열의 길이가 얼마인지 묻는다면 12 라고 대답할 수 있습니다. 사실, Rust 의 대답은 24 입니다. 이는 "Здравствуйте"를 UTF-8 로 인코딩하는 데 필요한 바이트 수입니다. 이 문자열의 각 유니코드 스칼라 값은 2 바이트의 저장 공간을 차지하기 때문입니다. 따라서 문자열의 바이트에 대한 인덱스는 항상 유효한 유니코드 스칼라 값과 일치하지 않습니다. 이를 설명하기 위해 다음 잘못된 Rust 코드를 고려해 보겠습니다.

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

이미 `answer`가 첫 번째 글자인 `З`가 아니라는 것을 알고 있습니다. UTF-8 로 인코딩될 때 `З`의 첫 번째 바이트는 `208`이고 두 번째 바이트는 `151`이므로, `answer`는 실제로 `208`이어야 하지만, `208`은 그 자체로 유효한 문자가 아닙니다. 이 문자열의 첫 번째 글자를 요청한 경우 `208`을 반환하는 것은 사용자가 원하는 것이 아닐 것입니다. 그러나 이것이 Rust 가 바이트 인덱스 0 에서 가지고 있는 유일한 데이터입니다. 사용자는 문자열에 라틴 문자가 포함된 경우에도 바이트 값을 반환하는 것을 일반적으로 원하지 않습니다. 만약 `&"hello"[0]`이 바이트 값을 반환하는 유효한 코드였다면, `h`가 아닌 `104`를 반환했을 것입니다.

따라서 답은 예기치 않은 값을 반환하고 즉시 발견되지 않을 수 있는 버그를 방지하기 위해 Rust 는 이 코드를 전혀 컴파일하지 않고 개발 프로세스 초기에 오해를 방지한다는 것입니다.
