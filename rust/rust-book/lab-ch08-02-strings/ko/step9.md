# 바이트, 스칼라 값, 그리고 그래피미 클러스터 (Grapheme Clusters)! 세상에!

UTF-8 에 대한 또 다른 점은 Rust 의 관점에서 문자열을 볼 수 있는 세 가지 관련 방식이 있다는 것입니다: 바이트, 스칼라 값, 그리고 그래피미 클러스터 (우리가 *글자*라고 부르는 것에 가장 가까운 것).

Devanagari 스크립트로 작성된 힌디어 단어 "नमस्ते"를 살펴보면, 다음과 같은 `u8` 값의 벡터로 저장됩니다.

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224,
164, 164, 224, 165, 135]
```

이는 18 바이트이며, 컴퓨터가 궁극적으로 이 데이터를 저장하는 방식입니다. Rust 의 `char` 타입인 유니코드 스칼라 값으로 보면, 해당 바이트는 다음과 같습니다.

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

여기에는 6 개의 `char` 값이 있지만, 네 번째와 여섯 번째는 글자가 아닙니다. 그 자체로는 의미가 없는 발음 구별 기호입니다. 마지막으로, 그래피미 클러스터로 보면, 사람이 힌디어 단어를 구성하는 4 개의 글자라고 부르는 것을 얻게 됩니다.

```rust
["न", "म", "स्", "ते"]
```

Rust 는 컴퓨터가 저장하는 원시 문자열 데이터를 해석하는 다양한 방법을 제공하여, 각 프로그램이 데이터가 어떤 언어로 되어 있든 필요한 해석을 선택할 수 있도록 합니다.

Rust 가 `String`을 인덱싱하여 문자를 가져오는 것을 허용하지 않는 마지막 이유는 인덱싱 연산이 항상 상수 시간 (O(1)) 을 갖도록 예상되기 때문입니다. 그러나 Rust 가 유효한 문자가 몇 개인지 결정하기 위해 처음부터 인덱스까지 내용을 살펴봐야 하므로, `String`으로 해당 성능을 보장하는 것은 불가능합니다.
