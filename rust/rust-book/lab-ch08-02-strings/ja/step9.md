# バイトとスカラー値、そして文字素クラスタ！おやまあ！

UTF-8 に関するもう 1 つのポイントは、Rust の視点から見ると、文字列は実際には 3 つの関連する方法で見ることができるということです。バイトとして、スカラー値として、そして文字素クラスタ（私たちが「文字」と呼ぶものに最も近いもの）としてです。

デヴァナガリ文字で書かれたヒンディー語の言葉 "नमस्ते" を見てみると、それは次のような `u8` 値のベクトルとして格納されています。

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224,
164, 164, 224, 165, 135]
```

これは 18 バイトで、コンピュータが最終的にこのデータを格納する方法です。これらを Rust の `char` 型である Unicode スカラー値として見ると、これらのバイトは次のようになります。

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

ここには 6 つの `char` 値がありますが、4 番目と 6 番目は文字ではありません。それらは単独では意味を持たないダイアクリティックです。最後に、これらを文字素クラスタとして見ると、ヒンディー語の言葉を構成する 4 つの文字が得られます。

```rust
["न", "म", "स्", "ते"]
```

Rust は、コンピュータが格納する生の文字列データを解釈するさまざまな方法を提供しています。これにより、各プログラムは、データがどの人間の言語であっても、必要な解釈を選択できるようになります。

Rust が `String` に対して文字を取得するためのインデックス付けを許さない最終的な理由は、インデックス操作は常に一定時間（O(1)）で行われることが期待されるからです。しかし、`String` でそのパフォーマンスを保証することは不可能です。なぜなら、Rust は有効な文字がいくつあるかを判断するために、インデックスまでの内容を最初から辿らなければならないからです。
