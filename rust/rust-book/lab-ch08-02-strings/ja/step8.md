# 内部表現

`String` は `Vec<u8>` のラッパーです。リスト8-14の適切にエンコードされたUTF-8の例の文字列を見てみましょう。まず、この文字列です。

```rust
let hello = String::from("Hola");
```

この場合、`len` は `4` になります。これは、文字列 `"Hola"` を格納するベクトルが4バイト長であることを意味します。これらの文字のそれぞれはUTF-8でエンコードされるときに1バイトを占めます。しかし、次の行はあなたを驚かせるかもしれません（この文字列は大文字のキリル文字 _Ze_ で始まり、アラビア数字の3ではありません）。

```rust
let hello = String::from("Здравствуйте");
```

文字列の長さがどれくらいか尋ねられた場合、あなたは12だと答えるかもしれません。実際、Rustの答えは24です。これは、文字列 "Здравствуйте" をUTF-8でエンコードするのに必要なバイト数です。なぜなら、その文字列の各Unicodeスカラー値は2バイトのストレージを必要とするからです。したがって、文字列のバイトに対するインデックスは常に有効なUnicodeスカラー値と一致しないことがあります。これを示すために、この無効なRustコードを見てみましょう。

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

あなたは既に `answer` が最初の文字 `З` ではないことを知っています。UTF-8でエンコードされたとき、`З` の最初のバイトは `208`、2番目のバイトは `151` です。したがって、`answer` は実際には `208` でなければならないように思えます。しかし、`208` 自体は有効な文字ではありません。この文字列の最初の文字を求められた場合、ユーザーが望むものはおそらく `208` ではないでしょう。ただし、それはRustがバイトインデックス0に持っている唯一のデータです。文字列がラテン文字のみで構成されていても、ユーザーは一般的にバイト値を返されたくありません。もし `&"hello"[0]` がバイト値を返す有効なコードだった場合、それは `104` を返し、`h` ではないでしょう。

したがって、予期しない値を返して、すぐには発見されない可能性のあるバグを引き起こすことを避けるために、Rustはこのコードをまったくコンパイルせず、開発プロセスの初期段階で誤解を防ぎます。
