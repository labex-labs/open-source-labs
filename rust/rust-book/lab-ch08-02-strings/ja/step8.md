# 内部表現

`String` は `Vec<u8>` のラッパーです。リスト 8-14 の適切にエンコードされた UTF-8 の例の文字列を見てみましょう。まず、この文字列です。

```rust
let hello = String::from("Hola");
```

この場合、`len` は `4` になります。これは、文字列 `"Hola"` を格納するベクトルが 4 バイト長であることを意味します。これらの文字のそれぞれは UTF-8 でエンコードされるときに 1 バイトを占めます。しかし、次の行はあなたを驚かせるかもしれません（この文字列は大文字のキリル文字 _Ze_ で始まり、アラビア数字の 3 ではありません）。

```rust
let hello = String::from("Здравствуйте");
```

文字列の長さがどれくらいか尋ねられた場合、あなたは 12 だと答えるかもしれません。実際、Rust の答えは 24 です。これは、文字列 "Здравствуйте" を UTF-8 でエンコードするのに必要なバイト数です。なぜなら、その文字列の各 Unicode スカラー値は 2 バイトのストレージを必要とするからです。したがって、文字列のバイトに対するインデックスは常に有効な Unicode スカラー値と一致しないことがあります。これを示すために、この無効な Rust コードを見てみましょう。

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

あなたは既に `answer` が最初の文字 `З` ではないことを知っています。UTF-8 でエンコードされたとき、`З` の最初のバイトは `208`、2 番目のバイトは `151` です。したがって、`answer` は実際には `208` でなければならないように思えます。しかし、`208` 自体は有効な文字ではありません。この文字列の最初の文字を求められた場合、ユーザーが望むものはおそらく `208` ではないでしょう。ただし、それは Rust がバイトインデックス 0 に持っている唯一のデータです。文字列がラテン文字のみで構成されていても、ユーザーは一般的にバイト値を返されたくありません。もし `&"hello"[0]` がバイト値を返す有効なコードだった場合、それは `104` を返し、`h` ではないでしょう。

したがって、予期しない値を返して、すぐには発見されない可能性のあるバグを引き起こすことを避けるために、Rust はこのコードをまったくコンパイルせず、開発プロセスの初期段階で誤解を防ぎます。
