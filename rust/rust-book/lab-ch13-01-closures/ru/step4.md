# Захват ссылок или передача владения

Замыкания могут захватывать значения из своей окружающей среды тремя способами, которые напрямую соответствуют трем видам параметров, которые может принимать функция: неизменяемая ссылка, изменяемая ссылка и передача владения. Замыкание решит, какой из них использовать, исходя из того, что делает тело функции с захваченными значениями.

В Листинге 13-4 мы определяем замыкание, которое захватывает неизменяемую ссылку на вектор с именем `list`, потому что для вывода значения ему нужна только неизменяемая ссылка.

Filename: `src/main.rs`

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

  1 let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
  2 only_borrows();
    println!("After calling closure: {:?}", list);
}
```

Листинг 13-4: Определение и вызов замыкания, которое захватывает неизменяемую ссылку

Этот пример также показывает, что переменная может связываться с определением замыкания \[1\], и мы позже можем вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции \[2\].

Поскольку мы можем иметь несколько неизменяемых ссылок на `list` одновременно, `list` по-прежнему доступен из кода до определения замыкания, после определения замыкания, но до вызова замыкания и после вызова замыкания. Этот код компилируется, запускается и выводит:

    Before defining closure: [1, 2, 3]
    Before calling closure: [1, 2, 3]
    From closure: [1, 2, 3]
    After calling closure: [1, 2, 3]

Далее, в Листинге 13-5, мы меняем тело замыкания так, чтобы оно добавляло элемент в вектор `list`. Теперь замыкание захватывает изменяемую ссылку.

Filename: `src/main.rs`

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list);
}
```

Листинг 13-5: Определение и вызов замыкания, которое захватывает изменяемую ссылку

Этот код компилируется, запускается и выводит:

```rust
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
```

Обратите внимание, что между определением и вызовом замыкания `borrows_mutably` больше нет `println!`: когда определяется `borrows_mutably`, оно захватывает изменяемую ссылку на `list`. Мы не используем замыкание снова после его вызова, поэтому изменяемая ссылка заканчивается. Между определением замыкания и вызовом замыкания не допускается неизменяемая ссылка для вывода, потому что когда есть изменяемая ссылка, не допускаются другие ссылки. Попробуйте добавить `println!` там, чтобы увидеть, какую ошибку вы получите!

Если вы хотите заставить замыкание принимать владение значениями, которые оно использует в окружающей среде, даже если тело замыкания не строго требует владения, вы можете использовать ключевое слово `move` перед списком параметров.

Этот метод в основном полезен при передаче замыкания в новый поток, чтобы передать данные, чтобы они были в собственности нового потока. Мы подробно обсудим потоки и почему вы захотите их использовать в главе 16, когда будем говорить о конкурентности, но пока давайте кратко рассмотрим создание нового потока с использованием замыкания, которое требует ключевого слова `move`. Листинг 13-6 показывает, как Листинг 13-4 изменен для вывода вектора в новом потоке, а не в главном потоке.

Filename: `src/main.rs`

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

  1 thread::spawn(move || {
      2 println!("From thread: {:?}", list)
    }).join().unwrap();
}
```

Листинг 13-6: Использование `move` для заставления замыкания для потока принять владение `list`

Мы создаем новый поток, передавая потоку замыкание для выполнения в качестве аргумента. Тело замыкания выводит список. В Листинге 13-4 замыкание только захватывало `list` с использованием неизменяемой ссылки, потому что для вывода этого требуется наименьший доступ к `list`. В этом примере, хотя тело замыкания по-прежнему требует только неизменяемой ссылки \[2\], мы должны указать, что `list` должно быть передано в замыкание, поместив ключевое слово `move` \[1\] в начале определения замыкания. Новый поток может завершиться раньше, чем остальная часть главного потока, или главной поток может завершиться раньше. Если главный поток сохраняет владение `list`, но завершается раньше, чем новый поток, и уничтожает `list`, неизменяемая ссылка в потоке станет недействительной. Поэтому компилятор требует, чтобы `list` было передано в замыкание, переданное новому потоку, чтобы ссылка была действительной. Попробуйте удалить ключевое слово `move` или использовать `list` в главном потоке после определения замыкания, чтобы увидеть, какие ошибки компиляции вы получите!
