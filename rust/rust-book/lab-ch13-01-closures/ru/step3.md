# Инференс типа и аннотация для замыканий

Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют аннотирования типов параметров или возвращаемого значения, как это делают функции `fn`. Аннотации типов обязательны для функций, потому что типы являются частью явного интерфейса, доступного для ваших пользователей. Тщательное определение этого интерфейса важно для того, чтобы все были согласны по тем типам значений, которые использует и возвращает функция. Замыкания же не используются в таких открытых интерфейсах: они хранятся в переменных и используются без именования и предоставления их пользователям библиотеки.

Замыкания обычно короткие и имеют смысл только в узком контексте, а не в произвольной ситуации. В рамках этих ограниченных контекстов компилятор может вывести типы параметров и тип возвращаемого значения, аналогично тому, как он может вывести типы большинства переменных (есть редкие случаи, когда компилятор также нуждается в аннотациях типов для замыканий).

Как и с переменными, мы можем добавить аннотации типов, если хотим повысить ясность и четкость, жертвуя тем более избыточностью. Аннотация типов для замыкания будет выглядеть как в определении, показанном в Листинге 13-2. В этом примере мы определяем замыкание и сохраняем его в переменной, а не определяем замыкание непосредственно в месте, где передаем его в качестве аргумента, как мы делали в Листинге 13-1.

Filename: `src/main.rs`

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

Листинг 13-2: Добавление необязательных аннотаций типов параметра и возвращаемого значения в замыкании

После добавления аннотаций типов синтаксис замыканий становится более похож на синтаксис функций. Здесь мы определяем функцию, которая добавляет 1 к своему параметру, и замыкание с тем же поведением для сравнения. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, как синтаксис замыканий похож на синтаксис функций, за исключением использования вертикальных полос и количества необязательного синтаксиса:

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

Первая строка показывает определение функции, а вторая - полностью аннотированное определение замыкания. В третьей строке мы удаляем аннотации типов из определения замыкания. В четвертой строке мы удаляем фигурные скобки, которые являются необязательными, потому что тело замыкания состоит только из одного выражения. Все эти определения валидны и будут иметь одинаковое поведение при вызове. Строки `add_one_v3` и `add_one_v4` требуют вычисления замыканий для компиляции, потому что типы будут выведены из их использования. Это похоже на то, что `let v = Vec::new();` требует либо аннотаций типов, либо значений какого-то типа для вставки в `Vec`, чтобы Rust мог вывести тип.

Для определений замыканий компилятор будет выводить один конкретный тип для каждого их параметра и для возвращаемого значения. Например, Листинг 13-3 показывает определение короткого замыкания, которое просто возвращает значение, которое получает в качестве параметра. Это замыкание не очень полезно, кроме целей данного примера. Обратите внимание, что мы не добавили никаких аннотаций типов в определение. Поскольку нет аннотаций типов, мы можем вызывать замыкание с любым типом, что мы сделали здесь с `String` в первый раз. Если мы затем попытаемся вызвать `example_closure` с целым числом, мы получим ошибку.

Filename: `src/main.rs`

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

Листинг 13-3: Попытка вызвать замыкание, типы которого выведены, с двумя разными типами

Компилятор выдаёт нам такую ошибку:

```bash
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method:
`.to_string()`
  |                             |
  |                             expected struct `String`, found integer
```

В первый раз, когда мы вызываем `example_closure` с значением `String`, компилятор выводит тип `x` и тип возвращаемого значения замыкания как `String`. Эти типы затем фиксируются в замыкании `example_closure`, и мы получаем ошибку типа, когда затем пытаемся использовать другой тип с тем же замыканием.
