# Захват окружающей среды с помощью замыканий

Сначала мы рассмотрим, как можно использовать замыкания для захвата значений из окружающей среды, в которой они определены, для последующего использования. Вот сценарий: периодически наша компания по производству футболок раздает эксклюзивную ограниченную серию футболок кому-то из нашей рассылки в качестве продвижения. Люди из рассылки могут по своему усмотрению добавить свой любимый цвет в свой профиль. Если выбранный для бесплатной футболки человек имеет установлен свой любимый цвет, он получает футболку в этом цвете. Если человек не указал любимый цвет, он получает тот цвет, который у компании в данный момент в большем количестве.

Существует множество способов реализовать это. Для примера мы будем использовать перечисление `ShirtColor`, которое имеет варианты `Red` и `Blue` (ограничим количество доступных цветов для простоты). Мы представляем инвентарь компании с помощью структуры `Inventory`, которая имеет поле `shirts`, содержащее `Vec<ShirtColor>`, представляющее цвета футболок, которые в наличии в данный момент. Метод `giveaway`, определенный для `Inventory`, получает необязательное предпочтение цвета футболки победителя в розыгрыше и возвращает цвет футболки, который получит человек. Эта схема показана в Листинге 13-1.

Filename: `src/main.rs`

```rust
#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec<ShirtColor>,
}

impl Inventory {
    fn giveaway(
        &self,
        user_preference: Option<ShirtColor>,
    ) -> ShirtColor {
      1 user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&self) -> ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &self.shirts {
            match color {
                ShirtColor::Red => num_red += 1,
                ShirtColor::Blue => num_blue += 1,
            }
        }
        if num_red > num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
      2 shirts: vec![
            ShirtColor::Blue,
            ShirtColor::Red,
            ShirtColor::Blue,
        ],
    };

    let user_pref1 = Some(ShirtColor::Red);
  3 let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
  4 let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
```

Листинг 13-1: Ситуация с розыгрышем футболок компанией

`store`, определенный в `main`, имеет по-прежнему два футболки голубого цвета и одну красного цвета для розыгрыша этой ограниченной серии \[2\]. Мы вызываем метод `giveaway` для пользователя, который предпочитает красный цвет футболки \[3\] и для пользователя, у которого нет никаких предпочтений \[4\].

Здесь снова этот код можно было реализовать многими способами, и здесь, чтобы сосредоточиться на замыканиях, мы придерживались концепций, которые вы уже изучали, за исключением тела метода `giveaway`, которое использует замыкание. В методе `giveaway` мы получаем предпочтение пользователя в виде параметра типа `Option<ShirtColor>` и вызываем метод `unwrap_or_else` для `user_preference` \[1\]. Метод `unwrap_or_else` для `Option<T>` определен стандартной библиотекой. Он принимает один аргумент: замыкание без аргументов, которое возвращает значение `T` (тот же тип, который хранится в варианте `Some` перечисления `Option<T>`, в данном случае `ShirtColor`). Если `Option<T>` представляет собой вариант `Some`, метод `unwrap_or_else` возвращает значение из `Some`. Если `Option<T>` представляет собой вариант `None`, метод `unwrap_or_else` вызывает замыкание и возвращает значение, возвращаемое замыканием.

Мы указываем выражение замыкания `|| self.most_stocked()` в качестве аргумента для `unwrap_or_else`. Это замыкание, которое не имеет собственных параметров (если бы у замыкания были параметры, они бы появились между двумя вертикальными трубами). Тело замыкания вызывает `self.most_stocked()`. Мы определяем здесь замыкание, а реализация `unwrap_or_else` будет оценивать замыкание позже, если это необходимо.

Запуск этого кода выводит следующее:

```rust
The user with preference Some(Red) gets Red
The user with preference None gets Blue
```

Одним интересным аспектом здесь является то, что мы передали замыкание, которое вызывает `self.most_stocked()` для текущего экземпляра `Inventory`. Стандартная библиотека не должна была знать ничего о типах `Inventory` или `ShirtColor`, которые мы определили, или о логике, которую мы хотим использовать в этом сценарии. Замыкание захватывает неизменяемую ссылку на текущий экземпляр `Inventory` и передает ее вместе с кодом, который мы указываем, методу `unwrap_or_else`. Функции, с другой стороны, не могут захватывать свою окружающую среду таким образом.
