# 参照のキャプチャまたは所有権の移動

クロージャは、環境から値をキャプチャする方法が3つあり、これは関数がパラメータを受け取る3つの方法に直接対応しています。不変参照を借りる、可変参照を借りる、所有権を取得するです。クロージャは、関数の本体がキャプチャされた値をどのように使用するかに基づいて、これらのどれを使用するかを決定します。

リスト13-4では、`list`というベクトルへの不変参照をキャプチャするクロージャを定義しています。なぜなら、値を表示するだけなので、不変参照が必要だからです。

ファイル名: `src/main.rs`

```rust
fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

  1 let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
  2 only_borrows();
    println!("After calling closure: {:?}", list);
}
```

リスト13-4: 不変参照をキャプチャするクロージャの定義と呼び出し

この例はまた、変数がクロージャの定義にバインドできること\[1\]、および後で変数名を関数名のように変数名と丸括弧を使ってクロージャを呼び出せること\[2\]を示しています。

`list`に同時に複数の不変参照を持てるため、クロージャ定義の前のコード、クロージャ定義の後でクロージャ呼び出しの前、およびクロージャ呼び出しの後でも、`list`にアクセスできます。このコードはコンパイルされ、実行され、以下のように表示されます。

    Before defining closure: [1, 2, 3]
    Before calling closure: [1, 2, 3]
    From closure: [1, 2, 3]
    After calling closure: [1, 2, 3]

次に、リスト13-5では、クロージャの本体を変更して、`list`ベクトルに要素を追加するようにします。クロージャは現在、可変参照をキャプチャします。

ファイル名: `src/main.rs`

```rust
fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!("After calling closure: {:?}", list);
}
```

リスト13-5: 可変参照をキャプチャするクロージャの定義と呼び出し

このコードはコンパイルされ、実行され、以下のように表示されます。

```rust
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
```

`borrows_mutably`クロージャの定義と呼び出しの間に`println!`がないことに注意してください。`borrows_mutably`が定義されると、`list`への可変参照をキャプチャします。クロージャを呼び出した後はもう使わないので、可変借用は終了します。クロージャ定義とクロージャ呼び出しの間では、可変借用があるときには他の借用は許されないため、表示用の不変借用は許されません。そこに`println!`を追加して、どのようなエラーメッセージが表示されるか見てみてください！

クロージャの本体が厳密に所有権を必要としなくても、環境で使用する値の所有権をクロージャに強制的に譲渡したい場合は、パラメータリストの前に`move`キーワードを使用できます。

この技術は主に、新しいスレッドにクロージャを渡してデータを移動させて、新しいスレッドが所有するようにするときに役立ちます。第16章で並列処理について話すときに、スレッドとそれを使う理由について詳細に説明しますが、今のところ、`move`キーワードが必要なクロージャを使って新しいスレッドを生成することを簡単に調べてみましょう。リスト13-6は、リスト13-4を変更して、メインスレッドではなく新しいスレッドでベクトルを表示するようにしたものです。

ファイル名: `src/main.rs`

```rust
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

  1 thread::spawn(move || {
      2 println!("From thread: {:?}", list)
    }).join().unwrap();
}
```

リスト13-6: `move`を使ってスレッド用のクロージャに`list`の所有権を強制的に譲渡する

新しいスレッドを生成し、スレッドに実行するクロージャを引数として渡します。クロージャの本体はリストを表示します。リスト13-4では、クロージャは表示に必要な`list`へのアクセスが最も少ないため、不変参照を使って`list`をキャプチャしていました。この例では、クロージャの本体がまだ不変参照のみを必要としているにもかかわらず\[2\]、クロージャ定義の先頭に`move`キーワードを入れることで\[1\]、`list`をクロージャに移動させるように指定する必要があります。新しいスレッドはメインスレッドの残りの部分が終了する前に終了する場合もあれば、メインスレッドが先に終了する場合もあります。メインスレッドが`list`の所有権を維持したまま、新しいスレッドよりも先に終了して`list`を破棄すると、スレッド内の不変参照は無効になります。したがって、コンパイラは、参照が有効になるように、`list`を新しいスレッドに渡されるクロージャに移動させることを要求します。`move`キーワードを削除したり、クロージャを定義した後にメインスレッドで`list`を使用したりして、どのようなコンパイラエラーが表示されるか見てみてください！
