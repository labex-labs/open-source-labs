# クロージャの型推論とアノテーション

関数とクロージャにはさらに違いがあります。クロージャは通常、`fn`関数のように、パラメータや戻り値の型を明示的に指定する必要はありません。関数では型アノテーションが必要ですが、それは型がユーザーに公開される明示的なインターフェイスの一部だからです。このインターフェイスを厳密に定義することは、関数が使用する値の型と返す値の型について誰もが合意することを確保するために重要です。一方、クロージャはこのような公開されたインターフェイスでは使用されません。クロージャは変数に保存され、名前を付けずに使用され、ライブラリのユーザーに公開されません。

クロージャは通常短く、狭いコンテキスト内でのみ関連性があり、任意のシナリオではなく、特定のコンテキスト内でのみ使用されます。これらの制限されたコンテキスト内では、コンパイラはパラメータの型と戻り値の型を推論することができます。これは、ほとんどの変数の型を推論することができるのと同じようになっています（コンパイラにクロージャの型アノテーションが必要な場合もまれにあります）。

変数と同様に、もっと冗長になる代わりに明示性と明確さを高めたい場合は、型アノテーションを追加することができます。クロージャの型をアノテーションするには、リスト 13-2 に示す定義のようになります。この例では、クロージャを定義して変数に保存していますが、リスト 13-1 のように、引数として渡す場所でクロージャを定義するのではなく、変数に保存しています。

ファイル名：`src/main.rs`

```rust
let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
```

リスト 13-2: クロージャのパラメータと戻り値の型のオプショナルな型アノテーションの追加

型アノテーションを追加すると、クロージャの構文は関数の構文に似てきます。ここでは、比較のために、引数に 1 を加える関数と同じ動作をするクロージャを定義しています。関連する部分を整えるためにいくつかの空白を追加しています。これは、パイプの使用と省略可能な構文の量を除いて、クロージャの構文が関数の構文にどのように似ているかを示しています。

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

1 行目は関数の定義を示し、2 行目は完全にアノテーションされたクロージャの定義を示しています。3 行目では、クロージャの定義から型アノテーションを削除しています。4 行目では、クロージャの本体が 1 つの式のみであるため省略可能なカッコを削除しています。これらはすべて有効な定義であり、呼び出されたときに同じ動作を行います。`add_one_v3`と`add_one_v4`の行では、型が使用法から推論されるため、クロージャを評価してコンパイルする必要があります。これは、`let v = Vec::new();`が型アノテーションまたは`Vec`に挿入するいくつかの型の値のいずれかを必要として、Rust が型を推論できるようにするのと同じです。

クロージャの定義では、コンパイラはそれぞれのパラメータと戻り値について 1 つの具体的な型を推論します。たとえば、リスト 13-3 は、引数として受け取った値をそのまま返す短いクロージャの定義を示しています。このクロージャは、この例の目的以外ではあまり役に立ちません。定義に型アノテーションを追加していないことに注意してください。型アノテーションがないため、最初は`String`でクロージャを呼び出すことができます。その後、整数で`example_closure`を呼び出そうとすると、エラーが発生します。

ファイル名：`src/main.rs`

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

リスト 13-3: 2 つの異なる型で型が推論されたクロージャを呼び出そうとする

コンパイラはこのエラーを表示します。

```bash
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method:
`.to_string()`
  |                             |
  |                             expected struct `String`, found integer
```

最初に`String`値で`example_closure`を呼び出すとき、コンパイラは`x`の型とクロージャの戻り値の型を`String`と推論します。その型は次に`example_closure`のクロージャに固定され、同じクロージャで異なる型を使用しようとするときに型エラーが発生します。
