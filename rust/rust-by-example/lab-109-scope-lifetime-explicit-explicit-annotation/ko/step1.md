# 명시적 어노테이션 (Explicit annotation)

차용 검사기 (borrow checker) 는 참조 (reference) 가 얼마나 오랫동안 유효해야 하는지 결정하기 위해 명시적 생명주기 어노테이션을 사용합니다. 생명주기가 생략되지 않는 경우, Rust 는 참조의 생명주기가 무엇이어야 하는지 결정하기 위해 명시적 어노테이션을 필요로 합니다. 명시적으로 생명주기를 어노테이션하는 구문은 다음과 같이 작은 따옴표 문자를 사용합니다.

```rust
foo<'a>
// `foo` 는 생명주기 매개변수 `'a` 를 가집니다.
```

클로저 (closure) 와 유사하게, 생명주기를 사용하려면 제네릭 (generics) 이 필요합니다. 또한, 이 생명주기 구문은 `foo`의 생명주기가 `'a`의 생명주기를 초과할 수 없음을 나타냅니다. 타입의 명시적 어노테이션은 `&'a T` 형식을 가지며, 여기서 `'a`는 이미 도입되었습니다.

여러 생명주기가 있는 경우, 구문은 유사합니다.

```rust
foo<'a, 'b>
// `foo` 는 생명주기 매개변수 `'a` 와 `'b` 를 가집니다.
```

이 경우, `foo`의 생명주기는 `'a` _또는_ `'b`의 생명주기를 초과할 수 없습니다.

명시적 생명주기 어노테이션의 사용 예는 다음을 참조하십시오.

```rust
// `print_refs` 는 서로 다른 생명주기 `'a` 와 `'b` 를 가진 `i32` 에 대한 두 개의 참조를 받습니다.
// 이 두 생명주기는 모두 함수 `print_refs` 만큼 길어야 합니다.
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 인수를 받지 않지만 생명주기 매개변수 `'a` 를 갖는 함수입니다.
fn failed_borrow<'a>() {
    let _x = 12;

    // ERROR: `_x` 의 생명주기가 충분히 길지 않습니다.
    let y: &'a i32 = &_x;
    // 함수 내부에서 명시적 타입 어노테이션으로 생명주기 `'a` 를 사용하려고 하면 실패합니다.
    // `&_x` 의 생명주기가 `y` 의 생명주기보다 짧기 때문입니다. 짧은 생명주기는 더 긴 생명주기로 강제 변환될 수 없습니다.
}

fn main() {
    // 아래에서 차용될 변수를 생성합니다.
    let (four, nine) = (4, 9);

    // 두 변수의 차용 (`&`) 이 함수로 전달됩니다.
    print_refs(&four, &nine);
    // 차용된 모든 입력은 차용자보다 오래 지속되어야 합니다.
    // 즉, `four` 와 `nine` 의 생명주기는 `print_refs` 의 생명주기보다 길어야 합니다.

    failed_borrow();
    // `failed_borrow` 는 `'a` 가 함수의 생명주기보다 길도록 강제하는 참조를 포함하지 않지만, `'a` 는 더 깁니다.
    // 생명주기가 제한되지 않으므로 기본값은 `'static` 입니다.
}
```
