# Тестовый случай: List

Реализация `fmt::Display` для структуры, где каждый элемент должен быть обработан последовательно, является сложной задачей. Проблема заключается в том, что каждый вызов `write!` генерирует `fmt::Result`. Правильная обработка этого требует обращения с _всеми_ результатами. Для этого в Rust предусмотрен оператор `?`.

Использование `?` с `write!` выглядит так:

```rust
// Попытайтесь выполнить `write!` и проверить, не возникло ли ошибки.
// Если ошибка возникла, верните ее. В противном случае продолжайте.
write!(f, "{}", value)?;
```

С использованием `?` реализация `fmt::Display` для `Vec` становится простой:

```rust
use std::fmt; // Импортируем модуль `fmt`.

// Определяем структуру `List`, содержащую `Vec`.
struct List(Vec<i32>);

impl fmt::Display for List {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Извлекаем значение с использованием индексирования кортежа
        // и создаем ссылку на `vec`.
        let vec = &self.0;

        write!(f, "[")?;

        // Перебираем элементы `v` в `vec`, при этом нумеруя
        // итерацию в `count`.
        for (count, v) in vec.iter().enumerate() {
            // Для каждого элемента, кроме первого, добавляем запятую.
            // Используем оператор `?` для возврата при ошибках.
            if count!= 0 { write!(f, ", ")?; }
            write!(f, "{}", v)?;
        }

        // Закрываем открытую скобку и возвращаем значение `fmt::Result`.
        write!(f, "]")
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!("{}", v);
}
```

## Активность

Попробуйте изменить программу так, чтобы выводился также индекс каждого элемента в векторе. Новый вывод должен выглядеть так:

```rust
[0: 1, 1: 2, 2: 3]
```
