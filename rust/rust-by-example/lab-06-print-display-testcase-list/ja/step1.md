# テストケース: List

要素を順次処理する必要がある構造体に対して `fmt::Display` を実装することは難しいです。問題は、各 `write!` が `fmt::Result` を生成することです。これを適切に処理するには、_すべての_ 結果を処理する必要があります。Rust はまさにこの目的のために `?` 演算子を提供しています。

`write!` に `?` を使用すると、次のようになります。

```rust
// `write!` を試してエラーが発生するかどうかを確認します。エラーが発生した場合は、
// エラーを返します。そうでなければ処理を続行します。
write!(f, "{}", value)?;
```

`?` が利用できるので、`Vec` に対して `fmt::Display` を実装するのは簡単です。

```rust
use std::fmt; // `fmt` モジュールをインポートします。

// `Vec` を含む `List` という名前の構造体を定義します。
struct List(Vec<i32>);

impl fmt::Display for List {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // タプルインデックスを使用して値を抽出し、
        // `vec` への参照を作成します。
        let vec = &self.0;

        write!(f, "[")?;

        // `vec` 内の `v` を反復処理しながら、反復処理の
        // カウントを `count` に列挙します。
        for (count, v) in vec.iter().enumerate() {
            // 最初の要素以外のすべての要素には、コンマを追加します。
            // エラーが発生した場合は `?` 演算子を使用して返します。
            if count!= 0 { write!(f, ", ")?; }
            write!(f, "{}", v)?;
        }

        // 開いた角括弧を閉じて、`fmt::Result` 値を返します。
        write!(f, "]")
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!("{}", v);
}
```

## アクティビティ

ベクトル内の各要素のインデックスも表示するようにプログラムを変更してみてください。新しい出力は次のようになるはずです。

```rust
[0: 1, 1: 2, 2: 3]
```
