# Примитивы

Rust предоставляет доступ к широкому спектру `примитивов`. Пример включает в себя:

## Скалярные типы

- Знаковые целые числа: `i8`, `i16`, `i32`, `i64`, `i128` и `isize` (размер указателя)
- Беззнаковые целые числа: `u8`, `u16`, `u32`, `u64`, `u128` и `usize` (размер указателя)
- Числа с плавающей точкой: `f32`, `f64`
- `char` Юникодовые скалярные значения, такие как `'a'`, `'α'` и `'∞'` (по 4 байта каждый)
- `bool`, принимающий значения `true` или `false`
- Единичный тип `()`, единственное возможное значение которого представляет собой пустой кортеж: `()`

Несмотря на то, что значение единичного типа представляет собой кортеж, он не считается составным типом, так как не содержит нескольких значений.

## Составные типы

- Массивы, такие как `[1, 2, 3]`
- Кортежи, такие как `(1, true)`

Переменные всегда могут быть _аннотированы типом_. Числа могут быть дополнительно аннотированы с использованием _суффикса_ или _по умолчанию_. Целые числа по умолчанию имеют тип `i32`, а числа с плавающей точкой - `f64`. Обратите внимание, что Rust также может определить типы из контекста.

```rust
fn main() {
    // Переменные могут быть аннотированы типом.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Стандартная аннотация
    let an_integer   = 5i32; // Аннотация с использованием суффикса

    // Или будет использовано значение по умолчанию.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // Тип также может быть определен из контекста.
    let mut inferred_type = 12; // Тип i64 определяется из другой строки.
    inferred_type = 4294967296i64;

    // Значение изменяемой переменной может быть изменено.
    let mut mutable = 12; // Изменяемая переменная с типом `i32`
    mutable = 21;

    // Ошибка! Тип переменной не может быть изменен.
    mutable = true;

    // Переменные могут быть перезаписаны с использованием скрытия.
    let mutable = true;
}
```
