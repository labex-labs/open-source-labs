# プリミティブ型

Rustは、幅広い「プリミティブ型」にアクセスできます。サンプルには以下が含まれます。

## スカラー型

- 符号付き整数: `i8`, `i16`, `i32`, `i64`, `i128` および `isize` (ポインタサイズ)
- 符号なし整数: `u8`, `u16`, `u32`, `u64`, `u128` および `usize` (ポインタサイズ)
- 浮動小数点数: `f32`, `f64`
- `char` Unicodeスカラー値、たとえば `'a'`, `'α'` および `'∞'` (それぞれ4バイト)
- `bool` は `true` または `false`
- ユニット型 `()`、その唯一の可能な値は空のタプル: `()`

ユニット型の値はタプルですが、複数の値を含まないため、複合型とは見なされません。

## 複合型

- 配列、たとえば `[1, 2, 3]`
- タプル、たとえば `(1, true)`

変数には常に型注釈を行うことができます。数値には、サフィックスまたはデフォルト値を使って追加的に注釈を行うことができます。整数はデフォルトで `i32`、浮動小数点数は `f64` です。Rustはコンテキストから型を推論することもできます。

```rust
fn main() {
    // 変数には型注釈を行うことができます。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 通常の注釈
    let an_integer   = 5i32; // サフィックス注釈

    // またはデフォルト値が使われます。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // 型はコンテキストからも推論できます。
    let mut inferred_type = 12; // 型i64は別の行から推論されます。
    inferred_type = 4294967296i64;

    // 可変変数の値は変更できます。
    let mut mutable = 12; // 可変 `i32`
    mutable = 21;

    // エラー! 変数の型は変更できません。
    mutable = true;

    // 変数はシャドーイングで上書きできます。
    let mutable = true;
}
```
