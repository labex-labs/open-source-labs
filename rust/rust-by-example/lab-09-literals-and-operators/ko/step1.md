# 리터럴과 연산자

정수 `1`, 부동 소수점 숫자 `1.2`, 문자 `'a'`, 문자열 `"abc"`, 부울 값 `true` 및 유닛 타입 `()`은 리터럴을 사용하여 표현할 수 있습니다.

정수는 또한, 각각 `0x`, `0o` 또는 `0b` 접두사를 사용하여 16 진수, 8 진수 또는 2 진수 표기법으로 표현할 수 있습니다.

숫자 리터럴의 가독성을 높이기 위해 밑줄을 삽입할 수 있습니다. 예를 들어, `1_000`은 `1000`과 같고, `0.000_001`은 `0.000001`과 같습니다.

Rust 는 또한 과학적 E-표기법을 지원합니다. 예를 들어, `1e6`, `7.6e-4`가 있습니다. 관련 타입은 `f64`입니다.

사용하는 리터럴의 타입을 컴파일러에게 알려줘야 합니다. 현재로서는, 리터럴이 부호 없는 32 비트 정수임을 나타내기 위해 `u32` 접미사를 사용하고, 부호 있는 32 비트 정수임을 나타내기 위해 `i32` 접미사를 사용합니다.

Rust 에서 사용 가능한 연산자와 그 우선 순위는 다른 C-like 언어와 유사합니다.

```rust
fn main() {
    // 정수 덧셈
    println!("1 + 2 = {}", 1u32 + 2);

    // 정수 뺄셈
    println!("1 - 2 = {}", 1i32 - 2);
    // TODO ^ `1i32` 를 `1u32` 로 변경하여 타입이 왜 중요한지 확인해 보세요.

    // 과학적 표기법
    println!("1e4 is {}, -2.5e-3 is {}", 1e4, -2.5e-3);

    // 단락 평가 (short-circuiting) 부울 논리
    println!("true AND false is {}", true && false);
    println!("true OR false is {}", true || false);
    println!("NOT true is {}", !true);

    // 비트 연산
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);

    // 가독성을 높이기 위해 밑줄을 사용하세요!
    println!("백만은 다음과 같이 작성됩니다 {}", 1_000_000u32);
}
```
