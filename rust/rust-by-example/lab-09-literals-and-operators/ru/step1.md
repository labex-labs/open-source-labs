# Литералы и операторы

Целые числа `1`, числа с плавающей точкой `1.2`, символы `'a'`, строки `"abc"`, логические значения `true` и единичный тип `()` могут быть выражены с использованием литералов.

Вместо этого целые числа могут быть выражены с использованием шестнадцатеричной, восьмеричной или двоичной записи с использованием соответствующих префиксов: `0x`, `0o` или `0b` соответственно.

Нижние подчеркивания можно вставлять в числовые литералы для улучшения читаемости, например, `1_000` эквивалентно `1000`, а `0.000_001` эквивалентно `0.000001`.

Rust также поддерживает научную запись E, например, `1e6`, `7.6e-4`. Тип, связанный с ними, — `f64`.

Нам нужно указать компилятору тип литералов, которые мы используем. В настоящее время мы будем использовать суффикс `u32`, чтобы указать, что литерал — это незнаковое целое число 32-разрядное, и суффикс `i32`, чтобы указать, что это знаковое целое число 32-разрядное.

Доступные операторы и их приоритет в Rust аналогичны другим языкам, похожим на C.

```rust
fn main() {
    // Сложение целых чисел
    println!("1 + 2 = {}", 1u32 + 2);

    // Вычитание целых чисел
    println!("1 - 2 = {}", 1i32 - 2);
    // TODO ^ Попробуйте изменить `1i32` на `1u32`, чтобы понять, почему тип важен

    // Научная запись
    println!("1e4 равно {}, -2.5e-3 равно {}", 1e4, -2.5e-3);

    // Логика булевых значений с коротким замыканием
    println!("true И false равно {}", true && false);
    println!("true ИЛИ false равно {}", true || false);
    println!("НЕ true равно {}",!true);

    // Побитовые операции
    println!("0011 И 0101 равно {:04b}", 0b0011u32 & 0b0101);
    println!("0011 ИЛИ 0101 равно {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 равно {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 равно {}", 1u32 << 5);
    println!("0x80 >> 2 равно 0x{:x}", 0x80u32 >> 2);

    // Используйте нижние подчеркивания для улучшения читаемости!
    println!("Одна миллион пишется как {}", 1_000_000u32);
}
```
