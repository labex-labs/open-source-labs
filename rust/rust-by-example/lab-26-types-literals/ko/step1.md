# 리터럴

숫자 리터럴은 접미사로 타입을 추가하여 타입을 지정할 수 있습니다. 예를 들어, 리터럴 `42`가 `i32` 타입이어야 한다고 지정하려면 `42i32`를 작성합니다.

접미사가 없는 숫자 리터럴의 타입은 사용 방법에 따라 달라집니다. 제약이 없다면 컴파일러는 정수에 `i32`를, 부동소수점 수에 `f64`를 사용합니다.

```rust
fn main() {
    // 접미사가 있는 리터럴, 초기화 시 타입이 결정됨
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // 접미사가 없는 리터럴, 타입은 사용 방법에 따라 결정됨
    let i = 1;
    let f = 1.0;

    // `size_of_val` 은 변수의 크기를 바이트 단위로 반환합니다.
    println!("`x` 의 바이트 크기: {}", std::mem::size_of_val(&x));
    println!("`y` 의 바이트 크기: {}", std::mem::size_of_val(&y));
    println!("`z` 의 바이트 크기: {}", std::mem::size_of_val(&z));
    println!("`i` 의 바이트 크기: {}", std::mem::size_of_val(&i));
    println!("`f` 의 바이트 크기: {}", std::mem::size_of_val(&f));
}
```

이전 코드에서 사용된 몇 가지 개념은 아직 설명되지 않았습니다. 참고를 위해 간략히 설명합니다.

- `std::mem::size_of_val`은 함수이지만, 전체 경로로 호출됩니다. 코드는 논리적인 단위인 모듈로 분할될 수 있습니다. 이 경우 `size_of_val` 함수는 `mem` 모듈에 정의되어 있고, `mem` 모듈은 `std` 크레이트에 정의되어 있습니다. 자세한 내용은 모듈과 크레이트를 참조하십시오.
