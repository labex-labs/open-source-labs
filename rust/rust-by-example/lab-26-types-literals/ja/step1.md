# リテラル

数値リテラルには、型をサフィックスとして追加することで型付けを行うことができます。例として、リテラル `42` が `i32` 型であることを指定するには、`42i32` と書きます。

サフィックスなしの数値リテラルの型は、その使用方法に依存します。制約がない場合、コンパイラは整数に対して `i32` を、浮動小数点数に対して `f64` を使用します。

```rust
fn main() {
    // サフィックス付きのリテラルは、初期化時に型が既知です
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // サフィックスなしのリテラルは、その使用方法に依存します
    let i = 1;
    let f = 1.0;

    // `size_of_val` は、バイト数で変数のサイズを返します
    println!("`x` のバイト数: {}", std::mem::size_of_val(&x));
    println!("`y` のバイト数: {}", std::mem::size_of_val(&y));
    println!("`z` のバイト数: {}", std::mem::size_of_val(&z));
    println!("`i` のバイト数: {}", std::mem::size_of_val(&i));
    println!("`f` のバイト数: {}", std::mem::size_of_val(&f));
}
```

前のコードで使用されているいくつかの概念にはまだ説明がありません。ここでは、焦った読者のための簡単な説明をします：

- `std::mem::size_of_val` は関数ですが、その _完全修飾名_ で呼び出されます。コードは _モジュール_ と呼ばれる論理単位に分割することができます。この場合、`size_of_val` 関数は `mem` モジュールに定義されており、`mem` モジュールは `std` _クレート_ に定義されています。詳細については、モジュールとクレートを参照してください。
