# Литералы

Числовые литералы могут быть аннотированы типом, добавляя тип в качестве суффикса. Например, чтобы указать, что литерал `42` должен иметь тип `i32`, напишите `42i32`.

Тип несуффиксных числовых литералов зависит от того, как они используются. Если нет никаких ограничений, компилятор будет использовать `i32` для целых чисел и `f64` для чисел с плавающей точкой.

```rust
fn main() {
    // Литералы с суффиксами, их типы известны при инициализации
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Несуффиксные литералы, их типы зависят от того, как они используются
    let i = 1;
    let f = 1.0;

    // `size_of_val` возвращает размер переменной в байтах
    println!("размер `x` в байтах: {}", std::mem::size_of_val(&x));
    println!("размер `y` в байтах: {}", std::mem::size_of_val(&y));
    println!("размер `z` в байтах: {}", std::mem::size_of_val(&z));
    println!("размер `i` в байтах: {}", std::mem::size_of_val(&i));
    println!("размер `f` в байтах: {}", std::mem::size_of_val(&f));
}
```

В предыдущем коде используются некоторые концепции, которые ещё не были объяснены. Вот краткое объяснение для нетерпеливых читателей:

- `std::mem::size_of_val` - это функция, но она вызывается с её _полным путём_. Код может быть разделён на логические единицы, называемые _модулями_. В этом случае функция `size_of_val` определена в модуле `mem`, а модуль `mem` определён в _коробке_ `std`. Подробнее см. в разделе о модулях и коробках.
