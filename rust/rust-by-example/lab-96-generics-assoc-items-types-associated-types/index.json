{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Exploring Rust's Associated Types",
  "description": "In this lab, we explore the concept of associated types in Rust, which allows for improved readability of code by defining inner types locally within a trait as output types. This is achieved by using the type keyword within the trait definition. with associated types, functions that use the trait no longer need to explicitly express the types A and B, making the code more concise and flexible. We rewrite an example from a previous section using associated types to illustrate their usage in practice.",
  "meta": {
    "title": "Rust Programming | Associated Types | Improved Readability",
    "description": "Explore the concept of associated types in Rust, which enhances code readability by defining inner types within a trait as output types.",
    "keywords": "Rust, Programming, Associated Types, Trait, Readability"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Associated types",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": [
          "rust/expressions_statements",
          "rust/function_syntax",
          "rust/integer_types",
          "rust/method_syntax",
          "rust/operator_overloading",
          "rust/traits",
          "rust/type_casting",
          "rust/variable_declarations"
        ]
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "探索 Rust 的关联类型",
      "description": "在本实验中，我们探索 Rust 中关联类型的概念，它通过在 trait 中局部定义内部类型作为输出类型，提高了代码的可读性。这是通过在 trait 定义中使用 type 关键字来实现的。有了关联类型，使用该 trait 的函数不再需要显式地表达类型 A 和 B，从而使代码更加简洁和灵活。我们使用关联类型重写了上一节中的一个示例，以说明它们在实际中的用法。",
      "meta": {
        "title": "Rust 编程 | 关联类型 | 提高可读性",
        "description": "探索 Rust 中关联类型的概念，它通过将 trait 中的内部类型定义为输出类型来提高代码可读性。",
        "keywords": "Rust, 编程，关联类型，trait, 可读性"
      },
      "details": {
        "steps": [
          {
            "title": "关联类型",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Explorando los Tipos Asociados de Rust",
      "description": "En este laboratorio, exploramos el concepto de tipos asociados en Rust, que permite mejorar la legibilidad del código al definir tipos internos localmente dentro de un trato como tipos de salida. Esto se logra mediante el uso de la palabra clave type dentro de la definición del trato. Con tipos asociados, las funciones que usan el trato ya no necesitan expresar explícitamente los tipos A y B, lo que hace que el código sea más conciso y flexible. Reescribimos un ejemplo de la sección anterior usando tipos asociados para ilustrar su uso en la práctica.",
      "meta": {
        "title": "Programación en Rust | Tipos Asociados | Mejora de la Legibilidad",
        "description": "Explore el concepto de tipos asociados en Rust, que mejora la legibilidad del código al definir tipos internos dentro de un trato como tipos de salida.",
        "keywords": "Rust, Programación, Tipos Asociados, Trato, Legibilidad"
      },
      "details": {
        "steps": [
          {
            "title": "Tipos asociados",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "Este paso no tiene verificación en este momento",
                "file": "verify1-1.sh",
                "hint": "Este paso no tiene verificación en este momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Explorer les types associés de Rust",
      "description": "Dans ce laboratoire, nous explorons le concept de types associés en Rust, qui permet d'améliorer la lisibilité du code en définissant des types internes localement dans un trait en tant que types de sortie. Cela est réalisé en utilisant le mot clé type à l'intérieur de la définition du trait. Avec des types associés, les fonctions qui utilisent le trait n'ont plus besoin d'exprimer explicitement les types A et B, rendant le code plus concis et flexible. Nous réécrivons un exemple d'une section précédente en utilisant des types associés pour illustrer leur utilisation en pratique.",
      "meta": {
        "title": "Programmation Rust | Types associés | Meilleure lisibilité",
        "description": "Explorez le concept de types associés en Rust, qui améliore la lisibilité du code en définissant des types internes dans un trait en tant que types de sortie.",
        "keywords": "Rust, Programmation, Types associés, Trait, Lisibilité"
      },
      "details": {
        "steps": [
          {
            "title": "Types associés",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Das Entdecken von assoziierten Typen in Rust",
      "description": "In diesem Lab untersuchen wir das Konzept assoziierten Typen in Rust, das es ermöglicht, die Lesbarkeit des Codes zu verbessern, indem innere Typen lokal innerhalb eines Traits als Ausgabetypen definiert werden. Dies wird durch Verwendung des type-Schlüsselworts innerhalb der Traitdefinition erreicht. Mit assoziierten Typen müssen Funktionen, die das Trait verwenden, die Typen A und B nicht mehr explizit ausdrücken, was den Code kompakter und flexibler macht. Wir schreiben ein Beispiel aus einem vorherigen Abschnitt um, um die Verwendung von assoziierten Typen in der Praxis zu veranschaulichen.",
      "meta": {
        "title": "Rust-Programmierung | Assoziierte Typen | Verbesserte Lesbarkeit",
        "description": "Entdecken Sie das Konzept assoziierten Typen in Rust, das die Code-Lesbarkeit verbessert, indem innere Typen innerhalb eines Traits als Ausgabetypen definiert werden.",
        "keywords": "Rust, Programmierung, Assoziierte Typen, Trait, Lesbarkeit"
      },
      "details": {
        "steps": [
          {
            "title": "Assoziierte Typen",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "Rust の関連型を探る",
      "description": "この実験では、Rust における関連型の概念を調べます。これにより、トレイト内でローカルに内部型を出力型として定義することで、コードの読みやすさが向上します。これは、トレイト定義内で type キーワードを使用することで達成されます。関連型を使用することで、トレイトを使用する関数はもはや型 A と B を明示的に表現する必要がなくなり、コードがより簡潔で柔軟になります。前のセクションの例を関連型を使用して書き直して、実際の使用方法を示します。",
      "meta": {
        "title": "Rust プログラミング | 関連型 | 読みやすさの向上",
        "description": "Rust における関連型の概念を探り、トレイト内の内部型を出力型として定義することでコードの読みやすさを向上させます。",
        "keywords": "Rust, プログラミング，関連型，トレイト，読みやすさ"
      },
      "details": {
        "steps": [
          {
            "title": "関連型",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップは現在検証がありません",
                "file": "verify1-1.sh",
                "hint": "このステップは現在検証がありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Изучение ассоциированных типов в Rust",
      "description": "В этой лабораторной работе мы исследуем концепцию ассоциированных типов в Rust, которая позволяет повысить читаемость кода путем определения внутренних типов локально внутри трейта в качестве типов вывода. Это достигается с использованием ключевого слова type внутри определения трейта. С ассоциированными типами функции, использующие трейт, больше не нужно явно указывать типы A и B, что делает код более компактным и гибким. Мы переписываем пример из предыдущего раздела с использованием ассоциированных типов, чтобы показать их практическое применение.",
      "meta": {
        "title": "Программирование на Rust | Ассоциированные типы | Повышенная читаемость",
        "description": "Исследуйте концепцию ассоциированных типов в Rust, которая повышает читаемость кода, определяя внутренние типы внутри трейта в качестве типов вывода.",
        "keywords": "Rust, Программирование, Ассоциированные типы, Трейт, Читаемость"
      },
      "details": {
        "steps": [
          {
            "title": "Ассоциированные типы",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    }
  ]
}
