# Возвращение трейтов с использованием `dyn`

Компилятор Rust должен знать, сколько места требует возвращаемый тип каждой функции. Это означает, что все ваши функции должны возвращать конкретный тип. В отличие от других языков, если у вас есть трейт, такой как `Animal`, вы не можете написать функцию, которая возвращает `Animal`, потому что его различные реализации будут требовать разного количества памяти.

Однако есть простой способ обойти это ограничение. Вместо прямого возврата объекта трейта наши функции возвращают `Box`, который _содержит_ некоторого `Animal`. `Box` - это просто ссылка на некоторую память в куче. Поскольку размер ссылки известен на этапе компиляции, и компилятор может гарантировать, что она указывает на `Animal`, выделенный в куче, мы можем вернуть трейт из нашей функции!

Rust старается быть как можно более явным, когда выделяет память в куче. Поэтому, если ваша функция возвращает указатель на трейт в куче таким образом, вам нужно указать возвращаемый тип с использованием ключевого слова `dyn`, например, `Box<dyn Animal>`.

```rust
struct Sheep {}
struct Cow {}

trait Animal {
    // Сигнатура метода экземпляра
    fn noise(&self) -> &'static str;
}

// Реализуйте трейт `Animal` для `Sheep`.
impl Animal for Sheep {
    fn noise(&self) -> &'static str {
        "baaaaah!"
    }
}

// Реализуйте трейт `Animal` для `Cow`.
impl Animal for Cow {
    fn noise(&self) -> &'static str {
        "moooooo!"
    }
}

// Возвращает некоторую структуру, которая реализует `Animal`, но мы не знаем, какая именно, на этапе компиляции.
fn random_animal(random_number: f64) -> Box<dyn Animal> {
    if random_number < 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!("You've randomly chosen an animal, and it says {}", animal.noise());
}
```
