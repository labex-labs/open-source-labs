# Границы

Популярно, что обобщенные типы могут быть ограничены, так же ограничиваются и жизненные периоды (сами по себе обобщенные). Символ `:` имеет немного другое значение здесь, но `+` остается тем же. Обратите внимание, как читаются следующие выражения:

1.  `T: 'a`: _Все_ ссылки в `T` должны иметь более длительный срок жизни, чем `'a`.
2.  `T: Trait + 'a`: Тип `T` должен реализовать трейт `Trait` и _все_ ссылки в `T` должны иметь более длительный срок жизни, чем `'a`.

Пример ниже демонстрирует использование вышеуказанного синтаксиса после ключевого слова `where`:

```rust
use std::fmt::Debug; // Трейт для ограничения.

#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);
// `Ref` содержит ссылку на обобщенный тип `T`, который имеет
// неизвестный жизненный период `'a`. `T` ограничивается таким образом,
// что любые *ссылки* в `T` должны иметь более длительный срок жизни, чем `'a`.
// Кроме того, жизненный период `Ref` не может превышать `'a`.

// Обобщенная функция, которая выводит с использованием трейта `Debug`.
fn print<T>(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// Здесь берется ссылка на `T`, где `T` реализует
// `Debug` и все *ссылки* в `T` имеют более длительный срок жизни, чем `'a`.
// Кроме того, `'a` должен иметь более длительный срок жизни, чем функция.
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
```
