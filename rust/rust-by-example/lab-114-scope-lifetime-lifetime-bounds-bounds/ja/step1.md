# 境界

ジェネリック型が境界付けられるのと同じように、寿命（それ自体がジェネリック）も境界を使います。ここでは `:` 文字の意味が少し異なりますが、`+` は同じです。次の文の読み方に注目してください。

1.  `T: 'a`: `T` 内の _すべての_ 参照は寿命 `'a` よりも長くなければなりません。
2.  `T: Trait + 'a`: 型 `T` はトレイト `Trait` を実装しなければならず、`T` 内の _すべての_ 参照は `'a` よりも長くなければなりません。

次の例は、キーワード `where` の後に使われる上記の構文を示しています。

```rust
use std::fmt::Debug; // 境界付けるトレイト。

#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);
// `Ref` は未知の寿命 `'a` を持つジェネリック型 `T` への参照を含んでいます。`T` は境界付けられており、`T` 内の任意の *参照* は `'a` よりも長くなければなりません。また、`Ref` の寿命は `'a` を超えてはなりません。

// `Debug` トレイトを使って出力するジェネリック関数。
fn print<T>(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// ここでは、`T` が `Debug` を実装し、`T` 内のすべての *参照* が `'a` よりも長くなる場合に `T` への参照を取得します。また、`'a` は関数よりも長くなければなりません。
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
```
