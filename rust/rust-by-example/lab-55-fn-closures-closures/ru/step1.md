# Замыкания

Замыкания - это функции, которые могут захватывать окружающую среду. Например, замыкание, которое захватывает переменную `x`:

```rust
|val| val + x
```

Синтаксис и возможности замыканий делают их очень удобными для即兴ового использования. Вызов замыкания происходит точно так же, как вызов функции. Однако как тип ввода, так и тип возврата _могут_ быть проинференцированы, а имена переменных ввода _должны_ быть указаны.

Другие характеристики замыканий включают в себя:

- использование `||` вместо `()` вокруг переменных ввода.
- необязательное обрамление тела (`{}`) для одного выражения (обязательно в противном случае).
- возможность захвата внешних переменных окружения.

```rust
fn main() {
    let outer_var = 42;

    // Обычная функция не может ссылаться на переменные в окружающей среде
    //fn function(i: i32) -> i32 { i + outer_var }
    // TODO: раскомментируйте строку выше и посмотрите на ошибку компилятора. Компилятор
    // предлагает определить замыкание вместо этого.

    // Замыкания анонимны, здесь мы связываем их с ссылками
    // Аннотация идентична аннотации функции, но является необязательной
    // так же, как и `{}` вокруг тела. Эти именованные функции
    // назначаются переменным с соответствующими именами.
    let closure_annotated = |i: i32| -> i32 { i + outer_var };
    let closure_inferred  = |i     |          i + outer_var  ;

    // Вызов замыканий.
    println!("closure_annotated: {}", closure_annotated(1));
    println!("closure_inferred: {}", closure_inferred(1));
    // Как только тип замыкания был проинференцирован, он не может быть проинференцирован снова с другим типом.
    //println!("cannot reuse closure_inferred with another type: {}", closure_inferred(42i64));
    // TODO: раскомментируйте строку выше и посмотрите на ошибку компилятора.

    // Замыкание, не принимающее аргументов, которое возвращает `i32`.
    // Тип возврата проинференцирован.
    let one = || 1;
    println!("closure returning one: {}", one());

}
```
