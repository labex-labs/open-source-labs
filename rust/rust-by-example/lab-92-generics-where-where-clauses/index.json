{
  "type": "lab",
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "en",
      "title": "Expressive Rust Generics with Where Clause",
      "description": "In this lab, we learn that a where clause in Rust can be used to express bounds for generic types separately from their declaration, allowing for clearer syntax, and can also apply bounds to arbitrary types rather than just type parameters. The where clause is especially useful when the bounds are more expressive than the normal syntax, as shown in the example involving the PrintInOption trait.",
      "meta": {
        "title": "Rust Programming | Where Clauses | Expressive Bounds",
        "description": "Learn how to use Rust's where clauses to express bounds for generic types separately, enabling clearer syntax and applying bounds to arbitrary types.",
        "keywords": "Rust, Programming, Where Clauses, Generic Types, Bounds, Expressive Syntax"
      },
      "details": {
        "steps": [
          {
            "title": "Where clauses",
            "text": "en/step1.md",
            "verify": [
              {
                "name": "This step has no verification at the moment",
                "file": "verify1.sh",
                "hint": "This step has no verification at the moment",
                "timeout": 0,
                "showstderr": true
              }
            ],
            "skills": [
              "rust/expressions_statements",
              "rust/function_syntax",
              "rust/lifetime_specifiers",
              "rust/method_syntax",
              "rust/operator_overloading",
              "rust/traits",
              "rust/type_casting",
              "rust/variable_declarations"
            ]
          }
        ],
        "intro": {
          "text": "en/intro.md",
          "background": "setup.sh",
          "title": "Introduction"
        },
        "finish": {
          "text": "en/finish.md",
          "title": "Summary"
        }
      }
    },
    {
      "lang": "zh",
      "title": "使用 `where` 子句实现富有表现力的 Rust 泛型",
      "description": "在本实验中，我们了解到 Rust 中的 `where` 子句可用于在声明泛型类型时单独表达其边界，从而使语法更清晰，并且还可以将边界应用于任意类型，而不仅仅是类型参数。当边界比普通语法更具表现力时，`where` 子句特别有用，如涉及 `PrintInOption` 特征的示例所示。",
      "meta": {
        "title": "Rust 编程 | `where` 子句 | 富有表现力的边界",
        "description": "学习如何使用 Rust 的 `where` 子句来单独表达泛型类型的边界，从而实现更清晰的语法，并将边界应用于任意类型。",
        "keywords": "Rust, 编程, `where` 子句, 泛型类型, 边界, 富有表现力的语法"
      },
      "details": {
        "steps": [
          {
            "title": "`where` 子句",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1.sh",
                "hint": "此步骤目前没有验证",
                "timeout": 0,
                "showstderr": true
              }
            ],
            "skills": [
              "rust/expressions_statements",
              "rust/function_syntax",
              "rust/lifetime_specifiers",
              "rust/method_syntax",
              "rust/operator_overloading",
              "rust/traits",
              "rust/type_casting",
              "rust/variable_declarations"
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "background": "setup.sh",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    }
  ]
}
