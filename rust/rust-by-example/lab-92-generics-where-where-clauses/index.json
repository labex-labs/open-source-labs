{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Expressive Rust Generics with Where Clause",
  "description": "In this lab, we learn that a where clause in Rust can be used to express bounds for generic types separately from their declaration, allowing for clearer syntax, and can also apply bounds to arbitrary types rather than just type parameters. The where clause is especially useful when the bounds are more expressive than the normal syntax, as shown in the example involving the PrintInOption trait.",
  "meta": {
    "title": "Rust Programming | Where Clauses | Expressive Bounds",
    "description": "Learn how to use Rust's where clauses to express bounds for generic types separately, enabling clearer syntax and applying bounds to arbitrary types.",
    "keywords": "Rust, Programming, Where Clauses, Generic Types, Bounds, Expressive Syntax"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Where clauses",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": []
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "使用 where 子句实现富有表现力的 Rust 泛型",
      "description": "在本实验中，我们了解到 Rust 中的 `where` 子句可用于在声明泛型类型时单独表达其边界，从而使语法更清晰，并且还可以将边界应用于任意类型，而不仅仅是类型参数。当边界比普通语法更具表现力时，`where` 子句特别有用，如涉及 `PrintInOption` 特征的示例所示。",
      "meta": {
        "title": "Rust 编程 | where 子句 | 富有表现力的边界",
        "description": "学习如何使用 Rust 的 `where` 子句来单独表达泛型类型的边界，从而实现更清晰的语法，并将边界应用于任意类型。",
        "keywords": "Rust, 编程，`where` 子句，泛型类型，边界，富有表现力的语法"
      },
      "details": {
        "steps": [
          {
            "title": "where 子句",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Genéricos expresivos de Rust con cláusula where",
      "description": "En este laboratorio, aprendemos que una cláusula where en Rust se puede utilizar para expresar límites para tipos genéricos por separado de su declaración, lo que permite una sintaxis más clara, y también se puede aplicar a tipos arbitrarios en lugar de solo a parámetros de tipo. La cláusula where es especialmente útil cuando los límites son más expresivos que la sintaxis normal, como se muestra en el ejemplo que involucra el trato PrintInOption.",
      "meta": {
        "title": "Programación Rust | Cláusulas where | Límites expresivos",
        "description": "Aprende cómo utilizar las cláusulas where de Rust para expresar límites para tipos genéricos por separado, lo que permite una sintaxis más clara y aplicar límites a tipos arbitrarios.",
        "keywords": "Rust, Programación, Cláusulas where, Tipos genéricos, Límites, Sintaxis expresiva"
      },
      "details": {
        "steps": [
          {
            "title": "Cláusulas where",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "Este paso no tiene verificación en este momento",
                "file": "verify1-1.sh",
                "hint": "Este paso no tiene verificación en este momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Génériques Rust expressifs avec la clause where",
      "description": "Dans ce laboratoire, nous apprenons qu'une clause where en Rust peut être utilisée pour exprimer des contraintes pour les types génériques séparément de leur déclaration, permettant une syntaxe plus claire, et peut également appliquer des contraintes à des types arbitraires plutôt que seulement aux paramètres de type. La clause where est particulièrement utile lorsque les contraintes sont plus expressives que la syntaxe normale, comme dans l'exemple impliquant le trait PrintInOption.",
      "meta": {
        "title": "Programmation Rust | Clauses where | Contraintes expressives",
        "description": "Découvrez comment utiliser les clauses where de Rust pour exprimer des contraintes pour les types génériques séparément, permettant une syntaxe plus claire et l'application de contraintes à des types arbitraires.",
        "keywords": "Rust, Programmation, Clauses where, Types génériques, Contraintes, Syntax expressives"
      },
      "details": {
        "steps": [
          {
            "title": "Clauses where",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Ausdrucksstarke Rust-Generika mit der where-Klausel",
      "description": "In diesem Lab lernen wir, dass eine where-Klausel in Rust verwendet werden kann, um die Grenzen für generische Typen getrennt von ihrer Deklaration auszudrücken, was zu einer klareren Syntax führt, und dass es auch möglich ist, Grenzen auf beliebige Typen anzuwenden, nicht nur auf Typparameter. Die where-Klausel ist besonders nützlich, wenn die Grenzen ausdrucksstärker sind als die normale Syntax, wie im Beispiel mit dem PrintInOption-Trait gezeigt.",
      "meta": {
        "title": "Rust-Programmierung | where-Klauseln | Ausdrucksstarke Grenzen",
        "description": "Lernen Sie, wie Sie Rusts where-Klauseln verwenden, um die Grenzen für generische Typen separat auszudrücken, was eine klarere Syntax ermöglicht und Grenzen auf beliebige Typen anwendet.",
        "keywords": "Rust, Programmierung, where-Klauseln, generische Typen, Grenzen, ausdrucksstarke Syntax"
      },
      "details": {
        "steps": [
          {
            "title": "where-Klauseln",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "Where 句を使った表現力豊かな Rust のジェネリクス",
      "description": "この実験では、Rust の where 句を使って、ジェネリック型の境界を宣言とは別に表現できることを学びます。これにより、構文が明確になり、型パラメータに限らず、任意の型に境界を適用することもできます。`PrintInOption` トレイトを含む例に示すように、境界が通常の構文よりも表現力がある場合、where 句は特に役に立ちます。",
      "meta": {
        "title": "Rust プログラミング | Where 句 | 表現力豊かな境界",
        "description": "Rust の where 句を使って、ジェネリック型の境界を別々に表現する方法を学び、明確な構文を可能にし、任意の型に境界を適用します。",
        "keywords": "Rust, プログラミング，Where 句，ジェネリック型，境界，表現力豊かな構文"
      },
      "details": {
        "steps": [
          {
            "title": "Where 句",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップは現在検証がありません",
                "file": "verify1-1.sh",
                "hint": "このステップは現在検証がありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Экспрессивные обобщения Rust с предложением where",
      "description": "В этом лабораторном задании мы узнаем, что в Rust можно использовать предложение where для выражения ограничений для обобщенных типов отдельно от их объявления, что позволяет получить более ясный синтаксис, и можно также применять ограничения к произвольным типам, а не только к параметрам типа. Предложение where особенно полезно, когда ограничения более выразительны, чем обычный синтаксис, как показано в примере, связанном с треитом PrintInOption.",
      "meta": {
        "title": "Программирование на Rust | Предложения where | Экспрессивные ограничения",
        "description": "Изучите, как использовать предложения where в Rust для отдельного выражения ограничений для обобщенных типов, обеспечивая более ясный синтаксис и применение ограничений к произвольным типам.",
        "keywords": "Rust, Программирование, Предложения where, Обобщенные типы, Ограничения, Экспрессивный синтаксис"
      },
      "details": {
        "steps": [
          {
            "title": "Предложения where",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    },
    {
      "lang": "ko",
      "title": "Where 절을 활용한 표현력 있는 Rust 제네릭",
      "description": "이 실습에서는 Rust 의 where 절이 제네릭 타입의 제약 조건을 선언과 분리하여 표현할 수 있음을 배우고, 이를 통해 더 명확한 구문을 제공하고, 타입 매개변수뿐만 아니라 임의의 타입에 제약 조건을 적용할 수 있음을 알아봅니다. where 절은 PrintInOption 트레이트를 포함한 예제에서 보여주듯, 일반적인 구문보다 더 표현력이 풍부한 경우 특히 유용합니다.",
      "meta": {
        "title": "Rust 프로그래밍 | Where 절 | 표현력 있는 제약 조건",
        "description": "Rust 의 where 절을 사용하여 제네릭 타입의 제약 조건을 분리하여 표현하고, 더 명확한 구문을 제공하고 임의의 타입에 제약 조건을 적용하는 방법을 배우세요.",
        "keywords": "Rust, 프로그래밍, Where 절, 제네릭 타입, 제약 조건, 표현력, 구문, 제네릭, Rust 제네릭, Rust 코딩, Rust 개발"
      },
      "details": {
        "steps": [
          {
            "title": "Where 절",
            "text": "ko/step1.md",
            "verify": [
              {
                "name": "현재 이 단계에는 검증이 없습니다.",
                "file": "verify1-1.sh",
                "hint": "현재 이 단계에는 검증이 없습니다."
              }
            ]
          }
        ],
        "intro": {
          "text": "ko/intro.md",
          "title": "소개"
        },
        "finish": {
          "text": "ko/finish.md",
          "title": "요약"
        }
      }
    },
    {
      "lang": "pt",
      "title": "Gerenciando Tipos Genéricos em Rust com Cláusulas Where",
      "description": "Neste laboratório, aprendemos que uma cláusula where em Rust pode ser usada para expressar limites para tipos genéricos separadamente de sua declaração, permitindo uma sintaxe mais clara, e também pode aplicar limites a tipos arbitrários, e não apenas a parâmetros de tipo. A cláusula where é especialmente útil quando os limites são mais expressivos do que a sintaxe normal, como demonstrado no exemplo envolvendo a trait PrintInOption.",
      "meta": {
        "title": "Programação em Rust | Cláusulas Where | Limites Expressivos",
        "description": "Aprenda como usar as cláusulas where do Rust para expressar limites para tipos genéricos separadamente, permitindo uma sintaxe mais clara e aplicando limites a tipos arbitrários.",
        "keywords": "Rust, Programação, Cláusulas Where, Tipos Genéricos, Limites, Sintaxe Expressiva, Tipos Genéricos Rust, Limites em Rust, Cláusulas Where Rust"
      },
      "details": {
        "steps": [
          {
            "title": "Cláusulas Where",
            "text": "pt/step1.md",
            "verify": [
              {
                "name": "Este passo não possui verificação no momento",
                "file": "verify1-1.sh",
                "hint": "Este passo não possui verificação no momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "pt/intro.md",
          "title": "Introdução"
        },
        "finish": {
          "text": "pt/finish.md",
          "title": "Resumo"
        }
      }
    }
  ]
}
