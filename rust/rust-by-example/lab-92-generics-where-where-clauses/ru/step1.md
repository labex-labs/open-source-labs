# Предложения where

Ограничение также можно выразить с помощью предложения `where` сразу перед открывающейся фигурной скобкой `{`, а не при первом упоминании типа. Кроме того, предложения `where` могут применять ограничения к произвольным типам, а не только к параметрам типа.

Некоторые случаи, когда предложение `where` полезно:

- Когда указание обобщенных типов и ограничений отдельно является более понятным:

```rust
impl <A: TraitB + TraitC, D: TraitE + TraitF> MyTrait<A, D> for YourType {}

// Выражение ограничений с помощью предложения `where`
impl <A, D> MyTrait<A, D> for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
```

- Когда использование предложения `where` более выразительно, чем использование обычного синтаксиса. `impl` в этом примере не может быть напрямую выражено без предложения `where`:

```rust
use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Поскольку в противном случае нам пришлось бы выразить это как `T: Debug` или
// использовать другой метод косвенного подхода, для этого требуется предложение `where`:
impl<T> PrintInOption for T where
    Option<T>: Debug {
    // Мы хотим, чтобы `Option<T>: Debug` было нашим ограничением, потому что именно это
    // выводится. В противном случае мы будем использовать неправильное ограничение.
    fn print_in_option(self) {
        println!("{:?}", Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
```
