# Функции ввода

Поскольку замыкания могут использоваться в качестве аргументов, вы, возможно, задаетесь вопросом, можно ли сказать то же самое о функциях. И, действительно, можно! Если вы объявите функцию, которая принимает замыкание в качестве параметра, то любая функция, которая удовлетворяет ограничению типа этого замыкания, может быть передана в качестве параметра.

```rust
// Определите функцию, которая принимает обобщенный аргумент `F`
// ограниченный `Fn`, и вызовите ее
fn call_me<F: Fn()>(f: F) {
    f();
}

// Определите обертку-функцию, которая удовлетворяет ограничению `Fn`
fn function() {
    println!("I'm a function!");
}

fn main() {
    // Определите замыкание, удовлетворяющее ограничению `Fn`
    let closure = || println!("I'm a closure!");

    call_me(closure);
    call_me(function);
}
```

В качестве дополнительной примечательности отметим, что трейты `Fn`, `FnMut` и `FnOnce` определяют, как замыкание захватывает переменные из окружающей области видимости.
