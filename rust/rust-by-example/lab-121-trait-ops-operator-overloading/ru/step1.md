# Перегрузка операторов

В Rust многие операторы можно перегрузить с помощью трейтов. То есть некоторые операторы могут использоваться для выполнения различных задач в зависимости от своих входных аргументов. Это возможно, потому что операторы являются синтаксическим сахаром для вызовов методов. Например, оператор `+` в `a + b` вызывает метод `add` (как в `a.add(b)`). Этот метод `add` является частью трейта `Add`. Следовательно, оператор `+` может использоваться любым реализатором трейта `Add`.

Список трейтов, таких как `Add`, которые перегружают операторы, можно найти в `core::ops`.

```rust
use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// Трейт `std::ops::Add` используется для определения функциональности `+`.
// Здесь мы определяем `Add<Bar>` - трейт для сложения с правым операндом типа `Bar`.
// Следующий блок реализует операцию: Foo + Bar = FooBar
impl ops::Add<Bar> for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -> FooBar {
        println!("> Foo.add(Bar) was called");

        FooBar
    }
}

// Меняя местами типы, мы получаем некоммутативное сложение.
// Здесь мы определяем `Add<Foo>` - трейт для сложения с правым операндом типа `Foo`.
// Этот блок реализует операцию: Bar + Foo = BarFoo
impl ops::Add<Foo> for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -> BarFoo {
        println!("> Bar.add(Foo) was called");

        BarFoo
    }
}

fn main() {
    println!("Foo + Bar = {:?}", Foo + Bar);
    println!("Bar + Foo = {:?}", Bar + Foo);
}
```
