# 所有権とムーブ

変数が自分自身のリソースの解放を担当しているため、**リソースは所有者を1人だけにすることができます**。これにより、リソースが2回以上解放されることも防止されます。ただし、すべての変数がリソースを所有しているわけではありません（たとえば、\[参照\]）。

代入 (`let x = y`) や関数の引数を値渡し (`foo(x)`) を行う場合、リソースの _所有権_ が移されます。Rustの用語では、これを _ムーブ_ と呼びます。

リソースを移動させた後、以前の所有者はもはや使用できなくなります。これにより、ダングリングポインターが作成されるのが回避されます。

```rust
// この関数は、ヒープ上に割り当てられたメモリの所有権を取得します
fn destroy_box(c: Box<i32>) {
    println!("Destroying a box that contains {}", c);

    // `c` が破棄され、メモリが解放されます
}

fn main() {
    // _スタック_ 上に割り当てられた整数
    let x = 5u32;

    // `x` を *コピー* して `y` に代入 - リソースは移動しません
    let y = x;

    // 両方の値を独立して使用できます
    println!("x is {}, and y is {}", x, y);

    // `a` は、ヒープ上に割り当てられた整数へのポインターです
    let a = Box::new(5i32);

    println!("a contains: {}", a);

    // `a` を *ムーブ* して `b` に代入
    let b = a;
    // `a` のポインターアドレスがコピーされ（データではなく）、`b` に代入されます。
    // 両方は現在、同じヒープ上に割り当てられたデータへのポインターですが、
    // 現在は `b` がそれを所有しています。

    // エラー！ `a` はもはやデータにアクセスできなくなりました。なぜなら、
    // ヒープメモリを所有していなくなったからです
    //println!("a contains: {}", a);
    // TODO ^ この行のコメントを外してみてください

    // この関数は、`b` からヒープ上に割り当てられたメモリの所有権を取得します
    destroy_box(b);

    // この時点でヒープメモリが解放されているため、この操作は
    // 解放されたメモリを参照することになりますが、コンパイラによって禁止されています
    // エラー！ 前のエラーと同じ理由です
    //println!("b contains: {}", b);
    // TODO ^ この行のコメントを外してみてください
}
```
