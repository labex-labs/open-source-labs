{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Ownership and Moves",
  "description": "In this lab, it is explained that in Rust, variables have ownership of resources and can only have one owner, which prevents resources from being freed multiple times. When variables are assigned or function arguments are passed by value, the ownership of resources is transferred, known as a move. After the move, the previous owner can no longer be used to avoid creating dangling pointers. The code example demonstrates these concepts by showing how the ownership of stack-allocated and heap-allocated variables is transferred and how accessing a variable after its ownership has been moved leads to errors.",
  "meta": {
    "title": "Mastering Rust's Ownership and Moves",
    "description": "Explore the fundamental concepts of ownership and moves in Rust, a crucial aspect of the language's memory management system.",
    "keywords": "rust playground, rust tutor, memory management, moves, rust online compiler, ownership, rust commands, rust practice, rust online playground, rust online"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Ownership and moves",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": [
          "rust/expressions_statements",
          "rust/function_syntax",
          "rust/integer_types",
          "rust/lifetime_specifiers",
          "rust/method_syntax",
          "rust/operator_overloading",
          "rust/type_casting",
          "rust/variable_declarations"
        ]
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "所有权与移动",
      "description": "在本实验中，将解释在 Rust 中，变量拥有资源的所有权，并且只能有一个所有者，这可防止资源被多次释放。当通过值来赋值变量或传递函数参数时，资源的所有权会被转移，这称为移动。移动之后，先前的所有者不能再使用，以避免创建悬空指针。代码示例通过展示栈分配和堆分配变量的所有权如何转移，以及在变量所有权被移动后访问该变量如何导致错误，来演示这些概念。",
      "meta": {
        "title": "掌握 Rust 的所有权与移动",
        "description": "探索 Rust 中所有权和移动的基本概念，这是该语言内存管理系统的一个关键方面。",
        "keywords": "Rust 游乐场，Rust 教程，内存管理，移动，Rust 在线编译器，所有权，Rust 命令，Rust 练习，Rust 在线游乐场，Rust 在线"
      },
      "details": {
        "steps": [
          {
            "title": "所有权与移动",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Propiedad y Moves",
      "description": "En este laboratorio, se explica que en Rust, las variables tienen la propiedad de los recursos y solo pueden tener un propietario, lo que evita que los recursos se liberen múltiples veces. Cuando se asignan variables o se pasan argumentos de función por valor, se transfiere la propiedad de los recursos, lo que se conoce como un move. Después del move, el propietario anterior ya no se puede utilizar para evitar la creación de punteros colgantes. El ejemplo de código demuestra estos conceptos mostrando cómo se transfiere la propiedad de variables asignadas en la pila y en el montón y cómo acceder a una variable después de que se haya transferido su propiedad conduce a errores.",
      "meta": {
        "title": "Dominando la Propiedad y los Moves en Rust",
        "description": "Explora los conceptos fundamentales de propiedad y moves en Rust, un aspecto crucial del sistema de gestión de memoria del lenguaje.",
        "keywords": "rust playground, rust tutor, gestión de memoria, moves, compilador en línea de rust, propiedad, comandos de rust, práctica de rust, playground en línea de rust, rust en línea"
      },
      "details": {
        "steps": [
          {
            "title": "Propiedad y moves",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "Este paso no tiene verificación en este momento",
                "file": "verify1-1.sh",
                "hint": "Este paso no tiene verificación en este momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Propriété et Mouvements",
      "description": "Dans ce laboratoire, il est expliqué que dans Rust, les variables ont la propriété des ressources et ne peuvent avoir qu'un seul propriétaire, ce qui empêche les ressources d'être libérées plusieurs fois. Lorsque des variables sont assignées ou que des arguments de fonction sont passés par valeur, la propriété des ressources est transférée, ce qui est appelé un *move*. Après le *move*, l'ancien propriétaire ne peut plus être utilisé pour éviter de créer des pointeurs faussaires. L'exemple de code illustre ces concepts en montrant comment la propriété des variables allouées sur la pile et sur le tas est transférée et comment accéder à une variable après que sa propriété a été transférée entraîne des erreurs.",
      "meta": {
        "title": "Maîtriser la Propriété et les Mouvements en Rust",
        "description": "Explorez les concepts fondamentaux de propriété et de mouvements en Rust, un aspect crucial du système de gestion de mémoire du langage.",
        "keywords": "plateforme de pratique Rust, tutoriel Rust, gestion de mémoire, mouvements, compilateur en ligne Rust, propriété, commandes Rust, pratique Rust, plateforme de pratique en ligne Rust, Rust en ligne"
      },
      "details": {
        "steps": [
          {
            "title": "Propriété et mouvements",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Eigentum und Moves",
      "description": "In diesem Lab wird erklärt, dass in Rust Variablen die Eigentumsgewalt an Ressourcen haben und nur einen Besitzer haben können, was verhindert, dass Ressourcen mehrfach freigegeben werden. Wenn Variablen zugewiesen werden oder Funktionsargumente per Wert übergeben werden, wird die Eigentumsgewalt an die Ressourcen übertragen, was als Move bezeichnet wird. Nach dem Move kann der vorherige Besitzer nicht mehr verwendet werden, um das Erstellen von fehlerhaften Zeigern zu vermeiden. Das Codebeispiel demonstriert diese Konzepte, indem gezeigt wird, wie die Eigentumsgewalt von auf dem Stack und auf dem Heap zugewiesenen Variablen übertragen wird und wie das Zugreifen auf eine Variable nach Übertragung ihrer Eigentumsgewalt zu Fehlern führt.",
      "meta": {
        "title": "Meisterung von Rusts Eigentum und Moves",
        "description": "Erkunden Sie die grundlegenden Konzepte von Eigentum und Moves in Rust, einem entscheidenden Aspekt des Sprachsystems zur Arbeitsspeicherverwaltung.",
        "keywords": "rust playground, rust tutor, Arbeitsspeicherverwaltung, moves, rust online compiler, Eigentum, rust Befehle, rust Übung, rust online playground, rust online"
      },
      "details": {
        "steps": [
          {
            "title": "Eigentum und Moves",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "所有権とムーブ",
      "description": "この実験では、Rust において変数がリソースの所有権を持ち、所有者は 1 人だけであることが説明されます。これにより、リソースが複数回解放されることが防止されます。変数が代入される場合や関数の引数が値渡しで渡される場合、リソースの所有権が移されます。これをムーブと呼びます。ムーブの後、以前の所有者はもはや使用できなくなり、ダングリングポインターが作成されるのを避けるためです。コード例は、スタック上に割り当てられた変数とヒープ上に割り当てられた変数の所有権がどのように移されるか、および所有権が移された後に変数にアクセスするとどのようにエラーが発生するかを示しています。",
      "meta": {
        "title": "Rust の所有権とムーブをマスターする",
        "description": "Rust の言語のメモリ管理システムの重要な側面である、所有権とムーブの基本概念を探ります。",
        "keywords": "rust playground, rust tutor, メモリ管理，ムーブ，rust オンラインコンパイラ，所有権，rust コマンド，rust 練習，rust オンライン playground, rust オンライン"
      },
      "details": {
        "steps": [
          {
            "title": "所有権とムーブ",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップには現在、検証はありません",
                "file": "verify1-1.sh",
                "hint": "このステップには現在、検証はありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Владение и Перемещения",
      "description": "В этой лабе объясняется, что в Rust переменные обладают ресурсами и могут иметь только одного владельца, что предотвращает освобождение ресурсов несколько раз. Когда переменным присваивается значение или аргументы функции передаются по значению, владение ресурсами передается, что называется перемещением (move). После перемещения предыдущий владелец больше не может использоваться, чтобы избежать создания \"проматывающихся\" указателей. Пример кода демонстрирует эти концепции, показывая, как передается владение переменным, размещенным на стеке и куче, и как обращение к переменной после перемещения ее владения приводит к ошибкам.",
      "meta": {
        "title": "Освоение Владения и Перемещений в Rust",
        "description": "Изучите фундаментальные концепции владения и перемещений в Rust, важный аспект системы управления памятью языка.",
        "keywords": "rust playground, rust tutor, управление памятью, перемещения, онлайн-компилятор rust, владение, rust команды, практика rust, онлайн-площадка rust, rust онлайн"
      },
      "details": {
        "steps": [
          {
            "title": "Владение и перемещения",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    },
    {
      "lang": "ko",
      "title": "소유권과 이동",
      "description": "이 랩에서는 Rust 에서 변수가 리소스의 소유권을 가지며 하나의 소유자만 가질 수 있다는 점을 설명합니다. 이는 리소스가 여러 번 해제되는 것을 방지합니다. 변수가 할당되거나 함수 인수가 값으로 전달될 때 리소스의 소유권이 이전되며, 이를 이동 (move) 이라고 합니다. 이동 후에는 이전 소유자를 더 이상 사용할 수 없어 댕글링 포인터 (dangling pointer) 생성을 방지합니다. 코드 예제는 스택 할당 및 힙 할당 변수의 소유권이 어떻게 이전되는지, 그리고 소유권이 이동된 후 변수에 접근하면 어떤 오류가 발생하는지를 보여주면서 이러한 개념을 시연합니다.",
      "meta": {
        "title": "Rust 의 소유권과 이동 마스터하기 - Rust 학습 가이드",
        "description": "Rust 의 메모리 관리 시스템의 핵심인 소유권과 이동의 기본 개념을 탐구하세요. Rust 초보자를 위한 완벽 가이드.",
        "keywords": "러스트 플레이그라운드, 러스트 튜터, 메모리 관리, 이동, 러스트 온라인 컴파일러, 소유권, 러스트 명령어, 러스트 연습, 러스트 온라인 플레이그라운드, 러스트 온라인, 러스트 강좌, Rust 기초"
      },
      "details": {
        "steps": [
          {
            "title": "소유권과 이동",
            "text": "ko/step1.md",
            "verify": [
              {
                "name": "현재 이 단계에는 검증이 없습니다.",
                "file": "verify1-1.sh",
                "hint": "현재 이 단계에는 검증이 없습니다."
              }
            ]
          }
        ],
        "intro": {
          "text": "ko/intro.md",
          "title": "소개"
        },
        "finish": {
          "text": "ko/finish.md",
          "title": "요약"
        }
      }
    },
    {
      "lang": "pt",
      "title": "Propriedade (Ownership) e Movimentações (Moves)",
      "description": "Neste laboratório, explica-se que, em Rust, as variáveis têm propriedade (ownership) sobre os recursos e só podem ter um proprietário, o que impede que os recursos sejam liberados várias vezes. Quando as variáveis são atribuídas ou os argumentos de função são passados por valor, a propriedade dos recursos é transferida, conhecida como uma movimentação (move). Após a movimentação, o proprietário anterior não pode mais ser usado para evitar a criação de ponteiros pendentes (dangling pointers). O exemplo de código demonstra esses conceitos, mostrando como a propriedade de variáveis alocadas na pilha (stack) e no heap é transferida e como o acesso a uma variável após sua propriedade ter sido movida leva a erros.",
      "meta": {
        "title": "Dominando a Propriedade (Ownership) e Movimentações (Moves) em Rust",
        "description": "Explore os conceitos fundamentais de propriedade (ownership) e movimentações (moves) em Rust, um aspecto crucial do sistema de gerenciamento de memória da linguagem.",
        "keywords": "rust playground, tutorial rust, gerenciamento de memória, moves, compilador rust online, ownership, comandos rust, prática rust, playground rust online, rust online"
      },
      "details": {
        "steps": [
          {
            "title": "Propriedade (Ownership) e Movimentações (Moves)",
            "text": "pt/step1.md",
            "verify": [
              {
                "name": "Esta etapa não possui verificação no momento",
                "file": "verify1-1.sh",
                "hint": "Esta etapa não possui verificação no momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "pt/intro.md",
          "title": "Introdução"
        },
        "finish": {
          "text": "pt/finish.md",
          "title": "Resumo"
        }
      }
    }
  ]
}
