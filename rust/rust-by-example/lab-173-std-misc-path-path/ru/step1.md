# Path

Структура `Path` представляет пути к файлам в underlying файловой системе. `Path` имеет два вида: `posix::Path` для UNIX-подобных систем и `windows::Path` для Windows. Предварительный заголовок экспортирует соответствующую платформо-зависимую вариацию `Path`.

`Path` можно создать из `OsStr`, и предоставляет несколько методов для получения информации из файла/директории, на которую указывает путь.

`Path` является неизменяемым. Владелец `Path` - это `PathBuf`. Отношение между `Path` и `PathBuf` аналогично отношению между `str` и `String`: `PathBuf` можно изменить "на месте", и можно снять ссылочную зависимость, превращая его в `Path`.

Обратите внимание, что `Path` не представляется внутри как UTF-8 строка, а хранится как `OsString`. Поэтому преобразование `Path` в `&str` не происходит бесплатно и может завершиться ошибкой (возвращается `Option`). Однако `Path` можно свободно преобразовать в `OsString` или `&OsStr` с использованием `into_os_string` и `as_os_str` соответственно.

```rust
use std::path::Path;

fn main() {
    // Создаем `Path` из `&'static str`
    let path = Path::new(".");

    // Метод `display` возвращает структуру, реализующую `Display`
    let _display = path.display();

    // `join` объединяет путь с байтовым контейнером с использованием
    // разделителя, специфичного для операционной системы, и возвращает `PathBuf`
    let mut new_path = path.join("a").join("b");

    // `push` расширяет `PathBuf` с использованием `&Path`
    new_path.push("c");
    new_path.push("myfile.tar.gz");

    // `set_file_name` обновляет имя файла `PathBuf`
    new_path.set_file_name("package.tgz");

    // Преобразуем `PathBuf` в срез строки
    match new_path.to_str() {
        None => panic!("новый путь не является допустимой UTF-8 последовательностью"),
        Some(s) => println!("новый путь - {}", s),
    }
}
```

Обязательно ознакомьтесь с другими методами `Path` (`posix::Path` или `windows::Path`) и структурой `Metadata`.
