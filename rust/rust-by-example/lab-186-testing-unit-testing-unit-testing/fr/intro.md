# Introduction

Dans ce laboratoire, nous apprenons les tests unitaires en Rust. Les tests unitaires sont des fonctions Rust qui vérifient le code non de test en effectuant le paramétrage, en exécutant le code et en affirmant les résultats. Ces tests sont écrits dans un module `tests` avec l'attribut `#[cfg(test)]` et sont marqués avec l'attribut `#[test]`. Les tests peuvent échouer si quelque chose dans la fonction de test provoque une panique, et des macros d'assistance telles que `assert!`, `assert_eq!` et `assert_ne!` sont utilisées pour les affirmations. Rust 2018 permet aux tests unitaires de renvoyer `Result<()>` pour utiliser l'opérateur `?` pour un test concis. Il existe également une prise en charge pour tester les panics en utilisant l'attribut `#[should_panic]`. Des tests spécifiques peuvent être exécutés en utilisant le nom du test avec la commande `cargo test`, et les tests peuvent être ignorés en utilisant l'attribut `#[ignore]` ou en exécutant `cargo test -- --ignored`.

> **Note:** Si le laboratoire ne spécifie pas un nom de fichier, vous pouvez utiliser n'importe quel nom de fichier que vous voulez. Par exemple, vous pouvez utiliser `main.rs`, le compiler et l'exécuter avec `rustc main.rs &&./main`.
