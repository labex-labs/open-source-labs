{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Rust Unit Testing Fundamentals",
  "description": "In this lab, we learn about unit testing in Rust. Unit tests are Rust functions that verify the non-test code by performing setup, running the code, and asserting the results. These tests are written in a tests mod with the #[cfg(test)] attribute and marked with the #[test] attribute. Tests can fail if something in the test function panics, and helper macros like assert!, assert_eq!, and assert_ne! are used for assertions. Rust 2018 allows unit tests to return Result<()> to use the ? operator for concise testing. There is also support for testing panics using the #[should_panic] attribute. Specific tests can be run using the test name with the cargo test command, and tests can be ignored using the #[ignore] attribute or by running cargo test -- --ignored.",
  "meta": {
    "title": "Rust Unit Testing | Programming Tutorials",
    "description": "Learn about unit testing in Rust, including writing tests, using assertions, testing panics, and running specific tests. Improve your Rust programming skills with these comprehensive tutorials.",
    "keywords": "Rust, Unit Testing, Programming Tutorials, Assertions, Panics, Test Running"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Unit testing",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": [
          "rust/expressions_statements",
          "rust/floating_types",
          "rust/function_syntax",
          "rust/integer_types",
          "rust/lifetime_specifiers",
          "rust/method_syntax",
          "rust/operator_overloading",
          "rust/panic_usage",
          "rust/string_type",
          "rust/variable_declarations"
        ]
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "Rust 单元测试基础",
      "description": "在本实验中，我们学习 Rust 中的单元测试。单元测试是 Rust 函数，通过执行设置、运行代码并断言结果来验证非测试代码。这些测试是在带有#[cfg(test)] 属性的 tests 模块中编写的，并使用#[test] 属性进行标记。如果测试函数中的某些内容导致恐慌，测试可能会失败，并且像 assert!、assert_eq! 和 assert_ne! 这样的辅助宏用于断言。Rust 2018 允许单元测试返回 Result<()>以使用？运算符进行简洁的测试。此外，还支持使用#[should_panic] 属性来测试恐慌情况。可以使用 cargo test 命令并加上测试名称来运行特定的测试，也可以使用#[ignore] 属性或通过运行 cargo test -- --ignored 来忽略测试。",
      "meta": {
        "title": "Rust 单元测试 | 编程教程",
        "description": "了解 Rust 中的单元测试，包括编写测试、使用断言、测试恐慌情况以及运行特定测试。通过这些全面的教程提升你的 Rust 编程技能。",
        "keywords": "Rust, 单元测试，编程教程，断言，恐慌，测试运行"
      },
      "details": {
        "steps": [
          {
            "title": "单元测试",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Fundamentos de Pruebas Unitarias en Rust",
      "description": "En este laboratorio, aprendemos sobre las pruebas unitarias en Rust. Las pruebas unitarias son funciones de Rust que verifican el código no de prueba mediante la realización de configuraciones, la ejecución del código y la afirmación de los resultados. Estas pruebas se escriben en un módulo tests con el atributo #[cfg(test)] y se marcan con el atributo #[test]. Las pruebas pueden fallar si algo en la función de prueba produce un panic, y se utilizan macros auxiliares como assert!, assert_eq! y assert_ne! para las afirmaciones. Rust 2018 permite que las pruebas unitarias devuelvan Result<()> para utilizar el operador? para una prueba concisa. También hay soporte para probar panics utilizando el atributo #[should_panic]. Se pueden ejecutar pruebas específicas utilizando el nombre de la prueba con el comando cargo test, y se pueden ignorar las pruebas utilizando el atributo #[ignore] o ejecutando cargo test -- --ignored.",
      "meta": {
        "title": "Pruebas Unitarias en Rust | Tutoriales de Programación",
        "description": "Aprende sobre las pruebas unitarias en Rust, incluyendo la escritura de pruebas, el uso de afirmaciones, la prueba de panics y la ejecución de pruebas específicas. Mejora tus habilidades de programación en Rust con estos tutoriales completos.",
        "keywords": "Rust, Pruebas Unitarias, Tutoriales de Programación, Afirmaciones, Panics, Ejecución de Pruebas"
      },
      "details": {
        "steps": [
          {
            "title": "Pruebas unitarias",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "Este paso no tiene verificaciones en este momento",
                "file": "verify1-1.sh",
                "hint": "Este paso no tiene verificaciones en este momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Fondamentaux des tests unitaires en Rust",
      "description": "Dans ce laboratoire, nous apprenons les tests unitaires en Rust. Les tests unitaires sont des fonctions Rust qui vérifient le code non de test en effectuant le paramétrage, en exécutant le code et en affirmant les résultats. Ces tests sont écrits dans un module tests avec l'attribut #[cfg(test)] et sont marqués avec l'attribut #[test]. Les tests peuvent échouer si quelque chose dans la fonction de test provoque une panique, et des macros d'assistance telles que assert!, assert_eq! et assert_ne! sont utilisées pour les affirmations. Rust 2018 permet aux tests unitaires de renvoyer Result<()> pour utiliser l'opérateur? pour un test concis. Il existe également une prise en charge pour tester les panics en utilisant l'attribut #[should_panic]. Des tests spécifiques peuvent être exécutés en utilisant le nom du test avec la commande cargo test, et les tests peuvent être ignorés en utilisant l'attribut #[ignore] ou en exécutant cargo test -- --ignored.",
      "meta": {
        "title": "Tests unitaires en Rust | Tutoriels de programmation",
        "description": "Découvrez les tests unitaires en Rust, y compris l'écriture de tests, l'utilisation d'affirmations, le test des panics et l'exécution de tests spécifiques. Améliorez vos compétences en programmation Rust avec ces tutoriels complets.",
        "keywords": "Rust, Tests unitaires, Tutoriels de programmation, Affirmations, Panics, Exécution de tests"
      },
      "details": {
        "steps": [
          {
            "title": "Tests unitaires",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Grundlagen der Rust Unit-Tests",
      "description": "In diesem Lab lernen wir über die Unit-Tests in Rust. Unit-Tests sind Rust-Funktionen, die den nicht-testenden Code über das Durchführen von Einstellungen, Ausführen des Codes und Behaupten der Ergebnisse überprüfen. Diese Tests werden in einem tests-Modul mit dem #[cfg(test)]-Attribut geschrieben und mit dem #[test]-Attribut markiert. Tests können fehlschlagen, wenn etwas im Testfunktion-Panik auslöst, und Hilfsmakros wie assert!, assert_eq! und assert_ne! werden für die Behauptungen verwendet. Rust 2018 erlaubt es Unit-Tests, Result<()> zurückzugeben, um den?-Operator für das präzise Testen zu verwenden. Es gibt auch Unterstützung für das Testen von Paniken mit dem #[should_panic]-Attribut. Spezifische Tests können mit dem Testnamen mit dem cargo test-Befehl ausgeführt werden, und Tests können mit dem #[ignore]-Attribut oder durch Ausführen von cargo test -- --ignored ignoriert werden.",
      "meta": {
        "title": "Rust Unit-Tests | Programmier-Tutorials",
        "description": "Lernen Sie über die Unit-Tests in Rust, einschließlich des Schreibens von Tests, des Verwenden von Behauptungen, des Testens von Paniken und des Ausführens von spezifischen Tests. Verbessern Sie Ihre Rust-Programmierfähigkeiten mit diesen umfassenden Tutorials.",
        "keywords": "Rust, Unit-Tests, Programmier-Tutorials, Behauptungen, Paniken, Testausführung"
      },
      "details": {
        "steps": [
          {
            "title": "Unit-Tests",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "Rust の単体テストの基本",
      "description": "この実験では、Rust の単体テストについて学びます。単体テストは、セットアップを行い、コードを実行し、結果をアサートすることで非テストコードを検証する Rust 関数です。これらのテストは、#[cfg(test)] 属性付きの tests モジュール内に記述され、#[test] 属性でマークされます。テスト関数内の何かがパニックする場合、テストは失敗することができ、アサーションには assert!、assert_eq!、assert_ne! などのヘルパーマクロが使用されます。Rust 2018 では、単体テストが Result<()>を返すことができ、簡潔なテストに？演算子を使用することができます。また、#[should_panic] 属性を使用したパニックのテストにも対応しています。特定のテストを実行するには、cargo test コマンドにテスト名を付けて実行し、#[ignore] 属性を使用するか、cargo test -- --ignored を実行することでテストを無視することができます。",
      "meta": {
        "title": "Rust の単体テスト | プログラミングチュートリアル",
        "description": "Rust の単体テストについて学びましょう。テストの作成、アサーションの使用、パニックのテスト、特定のテストの実行などが含まれます。これらの包括的なチュートリアルで Rust のプログラミング技術を向上させましょう。",
        "keywords": "Rust, 単体テスト，プログラミングチュートリアル，アサーション，パニック，テスト実行"
      },
      "details": {
        "steps": [
          {
            "title": "単体テスト",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップは現在検証がありません",
                "file": "verify1-1.sh",
                "hint": "このステップは現在検証がありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Основы модульного тестирования в Rust",
      "description": "В этой лабораторной работе мы изучаем модульное тестирование в Rust. Модульные тесты — это функции Rust, которые проверяют код, не являющийся тестом, путём выполнения подготовительных действий, запуска кода и утверждения результатов. Эти тесты пишутся в модуле tests с атрибутом #[cfg(test)] и помечаются атрибутом #[test]. Тесты могут завершиться с ошибкой, если в тестовой функции произойдёт паника, и для утверждений используются вспомогательные макросы, такие как assert!, assert_eq! и assert_ne!. Rust 2018 позволяет модульным тестам возвращать Result<()>, чтобы использовать оператор?, что делает тестирование более компактным. Также есть поддержка для тестирования паник с использованием атрибута #[should_panic]. Специфические тесты можно запустить, используя имя теста с командой cargo test, а тесты можно игнорировать с использованием атрибута #[ignore] или запустив cargo test -- --ignored.",
      "meta": {
        "title": "Модульное тестирование в Rust | Руководства по программированию",
        "description": "Изучите модульное тестирование в Rust, включая написание тестов, использование утверждений, тестирование паник и запуск конкретных тестов. Повысьте свои навыки в программировании на Rust с помощью этих полноценных руководств.",
        "keywords": "Rust, Модульное тестирование, Руководства по программированию, Утверждения, Паники, Запуск тестов"
      },
      "details": {
        "steps": [
          {
            "title": "Модульное тестирование",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверок",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверок"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    }
  ]
}
