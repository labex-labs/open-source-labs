# Частичные перемещения

При деструктуризации одной переменной можно одновременно использовать как `by-move`, так и `by-reference` паттерны связывания. Это приведет к частичному перемещению переменной, что означает, что некоторые части переменной будут перемещены, а другие останутся. В таком случае родительская переменная нельзя использовать в целом после этого, однако части, которые только используются для обращения (и не перемещаются), по-прежнему могут быть использованы.

```rust
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box<u8>,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // `name` перемещается из `person`, но `age` используется для обращения
    let Person { name, ref age } = person;

    println!("Возраст человека равен {}", age);

    println!("Имя человека - {}", name);

    // Ошибка! Попытка использовать частично перемещенное значение: происходит частичное перемещение `person`
    //println!("Структура `person` выглядит так: {:?}", person);

    // `person` нельзя использовать, но `person.age` можно использовать, так как оно не перемещено
    println!("Возраст человека из структуры `person` равен {}", person.age);
}
```

(В этом примере мы храним переменную `age` на куче, чтобы показать частичное перемещение: удаление `ref` в коде выше вызовет ошибку, так как владение `person.age` будет передано переменной `age`. Если `Person.age` хранилось на стеке, `ref` не понадобился бы, так как определение `age` скопирует данные из `person.age` без перемещения их.)
