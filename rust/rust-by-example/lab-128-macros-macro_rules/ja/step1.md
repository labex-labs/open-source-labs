# macro_rules!

Rust は、メタプログラミングを可能にする強力なマクロシステムを提供しています。前の章で見たように、マクロは関数のように見えますが、その名前の末尾にバング `!` が付きます。ただし、関数呼び出しを生成する代わりに、マクロはプログラムの残りの部分と一緒にコンパイルされるソースコードに展開されます。ただし、C や他の言語のマクロとは異なり、Rust のマクロは文字列の事前処理ではなく抽象構文木に展開されるため、予期しない優先順位のバグが発生しません。

マクロは `macro_rules!` マクロを使用して作成されます。

```rust
// これは `say_hello` という名前の簡単なマクロです。
macro_rules! say_hello {
    // `()` は、マクロが引数を取らないことを示しています。
    () => {
        // マクロはこのブロックの内容に展開されます。
        println!("Hello!")
    };
}

fn main() {
    // この呼び出しは `println!("Hello")` に展開されます
    say_hello!()
}
```

では、なぜマクロが便利なのでしょうか？

1.  繰り返しを避ける。複数の場所で同じような機能が必要になる場合がありますが、型が異なる場合も多いです。多くの場合、マクロを書くことはコードの繰り返しを避けるための便利な方法です。(後ほど詳しく説明します)

2.  ドメイン固有の言語。マクロを使うと、特定の目的のための特殊な構文を定義できます。(後ほど詳しく説明します)

3.  可変長インターフェイス。時には、可変数の引数を取るインターフェイスを定義したい場合があります。例として `println!` があり、フォーマット文字列に応じて任意の数の引数を取ることができます。(後ほど詳しく説明します)
