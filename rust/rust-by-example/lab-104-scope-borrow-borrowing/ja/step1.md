# バローイング

ほとんどの場合、データの所有権を取得することなくアクセスしたいと思います。これを達成するために、Rust は _バローイング_ メカニズムを使用します。値渡し（`T`）ではなく、参照（`&T`）を使ってオブジェクトを渡すことができます。

コンパイラは静的に（バローチェッカーを通じて）参照が _常に_ 有効なオブジェクトを指すことを保証します。つまり、オブジェクトへの参照が存在する間、そのオブジェクトを破棄することはできません。

```rust
// この関数はボックスの所有権を取得して破棄します
fn eat_box_i32(boxed_i32: Box<i32>) {
    println!("Destroying box that contains {}", boxed_i32);
}

// この関数は i32 を借用します
fn borrow_i32(borrowed_i32: &i32) {
    println!("This int is: {}", borrowed_i32);
}

fn main() {
    // ボックス化された i32 とスタック上の i32 を作成します
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // ボックスの内容を借用します。所有権は取得されず、
    // したがって内容を再度借用できます。
    borrow_i32(&boxed_i32);
    borrow_i32(&stacked_i32);

    {
        // ボックス内に含まれるデータへの参照を取得します
        let _ref_to_i32: &i32 = &boxed_i32;

        // エラー！
        // スコープ内で内部値が借用されている間、`boxed_i32` を破棄することはできません。
        eat_box_i32(boxed_i32);
        // FIXME ^ この行をコメントアウトしてください

        // 内部値が破棄された後に `_ref_to_i32` を借用しようとする
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` はスコープ外になり、もはや借用されていません。
    }

    // `boxed_i32` は現在、`eat_box` に所有権を譲ることができ、破棄されます
    eat_box_i32(boxed_i32);
}
```
