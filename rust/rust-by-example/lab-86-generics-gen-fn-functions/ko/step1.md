# 함수

함수에도 동일한 규칙이 적용됩니다. 타입 `T`가 `<T>`로 앞에 오면 제네릭 타입이 됩니다.

제네릭 함수를 사용할 때는 때때로 타입 매개변수를 명시적으로 지정해야 할 수 있습니다. 이는 함수의 반환 타입이 제네릭이거나 컴파일러가 필요한 타입 매개변수를 추론할 정보가 충분하지 않은 경우일 수 있습니다.

명시적으로 타입 매개변수를 지정한 함수 호출은 `fun::<A, B, ...>()`와 같습니다.

```rust
struct A;          // 구체적인 타입 `A`.
struct S(A);       // 구체적인 타입 `S`.
struct SGen<T>(T); // 제네릭 타입 `SGen`.

// 다음 함수들은 모두 전달받은 변수의 소유권을 가져서 즉시 범위를 벗어나 변수를 해제합니다.

// `S` 타입의 인수 `_s` 를 받는 함수 `reg_fn` 을 정의합니다.
// `<T>` 가 없으므로 이 함수는 제네릭 함수가 아닙니다.
fn reg_fn(_s: S) {}

// `SGen<T>` 타입의 인수 `_s` 를 받는 함수 `gen_spec_t` 를 정의합니다.
// 타입 매개변수 `A` 를 명시적으로 지정했지만, `gen_spec_t` 에 `A` 가 제네릭 타입 매개변수로 지정되지 않았으므로 제네릭 함수가 아닙니다.
fn gen_spec_t(_s: SGen<A>) {}

// `SGen<i32>` 타입의 인수 `_s` 를 받는 함수 `gen_spec_i32` 를 정의합니다.
// 명시적으로 `i32` 라는 특정 타입을 지정했습니다.
// `i32` 가 제네릭 타입이 아니므로 이 함수도 제네릭 함수가 아닙니다.
fn gen_spec_i32(_s: SGen<i32>) {}

// `SGen<T>` 타입의 인수 `_s` 를 받는 함수 `generic` 을 정의합니다.
// `SGen<T>` 가 `<T>` 로 앞에 오므로 `T` 에 대해 제네릭 함수입니다.
fn generic<T>(_s: SGen<T>) {}

fn main() {
    // 일반 함수 사용
    reg_fn(S(A));          // 구체적인 타입.
    gen_spec_t(SGen(A));   // 암시적으로 타입 매개변수 `A` 지정.
    gen_spec_i32(SGen(6)); // 암시적으로 타입 매개변수 `i32` 지정.

    // `generic()` 에 명시적으로 타입 매개변수 `char` 지정.
    generic::<char>(SGen('a'));

    // 암시적으로 타입 매개변수 `char` 지정하여 `generic()` 호출.
    generic(SGen('c'));
}
```
