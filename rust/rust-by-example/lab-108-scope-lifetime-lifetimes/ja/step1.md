# 寿命

「寿命」は、コンパイラ（より具体的には、その「借用チェッカー」）が使用する構成要素であり、すべての借用が妥当であることを保証するために使用されます。具体的には、変数の寿命は作成時に始まり、破棄時に終了します。寿命とスコープはしばしば一緒に言及されますが、同じではありません。

たとえば、`&`を介して変数を借用する場合を考えてみましょう。借用には宣言された場所によって決まる寿命があります。その結果、借用は貸し手が破棄される前に終了する限り有効です。ただし、借用のスコープは参照が使用される場所によって決まります。

次の例とこのセクションの残りの部分では、寿命がスコープとどのように関係しているか、また両者がどのように異なるかを見ていきます。

```rust
// 寿命は、各変数の作成と破棄を表す線で下に注釈付けされています。
// `i` は最長の寿命を持ちます。なぜなら、そのスコープは
// `borrow1` と `borrow2` の両方を完全に囲んでいるからです。
// `borrow1` と `borrow2` の期間を比較することは無関係です。
// なぜなら、それらは互いに分離しているからです。
fn main() {
    let i = 3; // `i` の寿命が始まります。 ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &i; // `borrow1` の寿命が始まります。 ──┐│
        //                                                ││
        println!("borrow1: {}", borrow1); //              ││
    } // `borrow1` が終了します。 ─────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &i; // `borrow2` の寿命が始まります。 ──┐│
        //                                                ││
        println!("borrow2: {}", borrow2); //              ││
    } // `borrow2` が終了します。 ─────────────────────────────────┘│
    //                                                     │
}   // 寿命が終了します。 ─────────────────────────────────────┘
```

寿命に名前や型を割り当てていないことに注意してください。これは、後で見るように、寿命をどのように使用できるかを制限します。
