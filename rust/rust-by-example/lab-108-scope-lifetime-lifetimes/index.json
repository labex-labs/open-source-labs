{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Lifetime Concepts in Rust Programming",
  "description": "In this lab, we will explore the concept of lifetimes in Rust and how they are used by the compiler to ensure the validity of borrows in the code. Lifetimes are a construct of the compiler that determine the duration of a variable, from its creation to its destruction. While lifetimes and scopes are related, they are not the same. When borrowing a variable using the & operator, the borrow has a lifetime that is determined by its declaration, and it is valid as long as it ends before the lender is destroyed. However, the scope of the borrow is determined by where the reference is used. The provided example code demonstrates how lifetimes and scopes are used in practice, with each variable having its own lifetime and scope.",
  "meta": {
    "title": "Mastering Rust Lifetimes",
    "description": "Explore the essential concept of lifetimes in Rust programming and learn how to ensure the validity of borrows in your code.",
    "keywords": "rust playground, borrows, lifetimes, rust tutor, rust online compiler, rust commands, scopes, rust practice, rust online playground, rust online"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Lifetimes",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": [
          "rust/expressions_statements",
          "rust/function_syntax",
          "rust/variable_declarations"
        ]
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "Rust编程中的生命周期概念",
      "description": "在本实验中，我们将探讨Rust中的生命周期概念，以及编译器如何使用它们来确保代码中借用的有效性。生命周期是编译器的一种结构，它决定了变量从创建到销毁的持续时间。虽然生命周期和作用域相关，但它们并不相同。当使用`&`运算符借用一个变量时，借用具有一个由其声明决定的生命周期，并且只要它在出借者被销毁之前结束，它就是有效的。然而，借用的作用域是由引用的使用位置决定的。提供的示例代码演示了生命周期和作用域在实际中的使用方式，每个变量都有自己的生命周期和作用域。",
      "meta": {
        "title": "掌握Rust生命周期",
        "description": "探索Rust编程中生命周期的基本概念，并学习如何确保代码中借用的有效性。",
        "keywords": "Rust游乐场, 借用, 生命周期, Rust教程, Rust在线编译器, Rust命令, 作用域, Rust练习, Rust在线游乐场, Rust在线"
      },
      "details": {
        "steps": [
          {
            "title": "生命周期",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Conceptos de Lifetime en el Programa de Rust",
      "description": "En este laboratorio, exploraremos el concepto de lifetimes en Rust y cómo el compilador los utiliza para garantizar la validez de los préstamos en el código. Los lifetimes son una construcción del compilador que determinan la duración de una variable, desde su creación hasta su destrucción. Si bien los lifetimes y los ámbitos están relacionados, no son lo mismo. Cuando se presta una variable utilizando el operador &, el préstamo tiene un lifetime que se determina por su declaración, y es válido siempre y cuando termine antes de que el prestamista sea destruido. Sin embargo, el ámbito del préstamo se determina por donde se utiliza la referencia. El código de ejemplo proporcionado demuestra cómo se utilizan los lifetimes y los ámbitos en la práctica, con cada variable teniendo su propio lifetime y ámbito.",
      "meta": {
        "title": "Dominando los Lifetimes de Rust",
        "description": "Explore el concepto esencial de lifetimes en el programa de Rust y aprenda cómo garantizar la validez de los préstamos en su código.",
        "keywords": "playground de rust, préstamos, lifetimes, tutor de rust, compilador en línea de rust, comandos de rust, ámbitos, práctica de rust, playground en línea de rust, rust en línea"
      },
      "details": {
        "steps": [
          {
            "title": "Lifetimes",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "Este paso no tiene verificación en este momento",
                "file": "verify1-1.sh",
                "hint": "Este paso no tiene verificación en este momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Concepts de durée de vie en programmation Rust",
      "description": "Dans ce laboratoire, nous allons explorer le concept de durées de vie en Rust et la manière dont le compilateur les utilise pour garantir la validité des emprunts dans le code. Les durées de vie sont une construction du compilateur qui déterminent la durée d'une variable, depuis sa création jusqu'à sa destruction. Bien que les durées de vie et les portées soient liées, elles ne sont pas les mêmes. Lorsque l'on emprunte une variable en utilisant l'opérateur &, l'emprunt a une durée de vie qui est déterminée par sa déclaration, et il est valide tant qu'il se termine avant que le prêteur ne soit détruit. Cependant, la portée de l'emprunt est déterminée par l'endroit où la référence est utilisée. Le code d'exemple fourni montre comment les durées de vie et les portées sont utilisées en pratique, chaque variable ayant sa propre durée de vie et sa propre portée.",
      "meta": {
        "title": "Maîtriser les durées de vie en Rust",
        "description": "Explorez le concept essentiel de durées de vie en programmation Rust et apprenez à garantir la validité des emprunts dans votre code.",
        "keywords": "plateforme de pratique Rust, emprunts, durées de vie, tutoriel Rust, compilateur en ligne Rust, commandes Rust, portées, pratique Rust, plateforme de pratique en ligne Rust, Rust en ligne"
      },
      "details": {
        "steps": [
          {
            "title": "Durées de vie",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Lebenszeitkonzepte in der Rust-Programmierung",
      "description": "In diesem Lab werden wir das Konzept der Lebenszeiten in Rust untersuchen und wie der Compiler diese verwendet, um die Gültigkeit von Entleihen im Code sicherzustellen. Lebenszeiten sind ein Konstrukt des Compilers, das die Lebensdauer einer Variable von ihrer Erstellung bis zu ihrer Zerstörung bestimmt. Während Lebenszeiten und Gültigkeitsbereiche verwandt sind, sind sie nicht identisch. Wenn eine Variable mit dem &-Operator entliehen wird, hat das Entlehen eine Lebenszeit, die durch seine Deklaration bestimmt wird, und es ist gültig, solange es vor dem Zerstören des Verleiher endet. Der Gültigkeitsbereich des Entlehens wird jedoch durch den Ort bestimmt, an dem die Referenz verwendet wird. Der bereitgestellte Beispielcode zeigt, wie Lebenszeiten und Gültigkeitsbereiche in der Praxis verwendet werden, wobei jede Variable ihre eigene Lebenszeit und ihren eigenen Gültigkeitsbereich hat.",
      "meta": {
        "title": "Meisterung von Rust-Lebenszeiten",
        "description": "Erkunden Sie das essentielle Konzept der Lebenszeiten in der Rust-Programmierung und lernen Sie, wie Sie die Gültigkeit von Entleihen in Ihrem Code gewährleisten.",
        "keywords": "Rust-Spielfeld, Entleihen, Lebenszeiten, Rust-Lehrer, Rust-Online-Compiler, Rust-Befehle, Gültigkeitsbereiche, Rust-Praxis, Rust-Online-Spielfeld, Rust-Online"
      },
      "details": {
        "steps": [
          {
            "title": "Lebenszeiten",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "Rust プログラミングにおける寿命の概念",
      "description": "この実験では、Rustにおける寿命の概念と、コンパイラがコード内の借用の妥当性を保証するためにどのように使用するかを探ります。寿命は、変数の作成から破棄までの期間を決定するコンパイラの構成要素です。寿命とスコープは関連していますが、同じではありません。`&`演算子を使用して変数を借用する場合、借用には宣言によって決定される寿命があり、貸し手が破棄される前に終了する限り有効です。ただし、借用のスコープは参照が使用される場所によって決定されます。提供されたサンプルコードは、各変数が独自の寿命とスコープを持つ実際の使用例を示しています。",
      "meta": {
        "title": "Rustの寿命をマスターする",
        "description": "Rustプログラミングにおける寿命の重要な概念を探り、コード内の借用の妥当性を確保する方法を学びましょう。",
        "keywords": "rust playground, 借用, 寿命, rust tutor, rustオンラインコンパイラ, rustコマンド, スコープ, rust練習, rustオンラインplayground, rustオンライン"
      },
      "details": {
        "steps": [
          {
            "title": "寿命",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップには現在、検証はありません",
                "file": "verify1-1.sh",
                "hint": "このステップには現在、検証はありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Концепции времени жизни в программировании на Rust",
      "description": "В этой лабораторной работе мы исследуем концепцию времени жизни в Rust и то, как компилятор использует их для обеспечения валидности ссылок в коде. Время жизни - это конструкция компилятора, которая определяет длительность переменной, от ее создания до уничтожения. Хотя время жизни и области видимости связаны, они не идентичны. Когда берется ссылка на переменную с помощью оператора &, ссылка имеет время жизни, которое определяется ее объявлением, и она остается валидной, пока не закончится перед уничтожением переменной, от которой была взята ссылка. Однако область видимости ссылки определяется местом ее использования. Приведенный пример кода демонстрирует, как используются время жизни и области видимости на практике, при этом каждая переменная имеет свое собственное время жизни и область видимости.",
      "meta": {
        "title": "Мастерство в времени жизни Rust",
        "description": "Исследуйте важную концепцию времени жизни в программировании на Rust и узнайте, как обеспечить валидность ссылок в своем коде.",
        "keywords": "rust playground, ссылочные типы, время жизни, наставник по Rust, онлайн-компилятор Rust, команды Rust, области видимости, практика Rust, онлайн-плейгрунд Rust, Rust онлайн"
      },
      "details": {
        "steps": [
          {
            "title": "Время жизни",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    }
  ]
}
