# 绑定

间接访问变量会导致在不重新绑定的情况下无法对该变量进行分支和使用。`match` 提供了 `@` 符号用于将值绑定到名称：

```rust
// 一个返回 `u32` 类型的函数 `age`。
fn age() -> u32 {
    15
}

fn main() {
    println!("告诉我你是什么类型的人");

    match age() {
        0             => println!("我还没有庆祝过我的第一个生日"),
        // 可以直接匹配 1..=12，但这样孩子的年龄该怎么表示呢？
        // 相反，将 1..=12 的序列绑定到 `n`。现在就可以报告年龄了。
        n @ 1 ..= 12 => println!("我是一个 {} 岁的孩子", n),
        n @ 13..= 19 => println!("我是一个 {} 岁的青少年", n),
        // 没有绑定任何值。返回结果。
        n             => println!("我是一个 {} 岁的老人", n),
    }
}
```

你还可以使用绑定来“解构” `enum` 变体，比如 `Option`：

```rust
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // 得到了 `Some` 变体，如果其值（绑定到 `n`）等于 42，则进行匹配。
        Some(n @ 42) => println!("答案是：{}！", n),
        // 匹配任何其他数字。
        Some(n)      => println!("没什么意思... {}", n),
        // 匹配任何其他情况（`None` 变体）。
        _            => (),
    }
}
```
