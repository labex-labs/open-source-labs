# 바인딩

변수에 간접적으로 접근하면 재바인딩 없이 변수를 분기하고 사용하는 것이 불가능합니다. `match`는 값을 이름에 바인딩하기 위해 `@` 기호를 제공합니다.

```rust
// `u32` 를 반환하는 함수 `age`.
fn age() -> u32 {
    15
}

fn main() {
    println!("Tell me what type of person you are");

    match age() {
        0             => println!("제 생일을 아직 맞이하지 못했습니다"),
        // 1 ~ 12 를 직접 `match` 할 수 있지만, 그렇다면 아이의 나이는 얼마입니까?
        // 대신 1 ~ 12 의 시퀀스에 대해 `n` 에 바인딩합니다. 이제 나이를 보고할 수 있습니다.
        n @ 1  ..= 12 => println!("저는 {:?}살의 어린이입니다", n),
        n @ 13 ..= 19 => println!("저는 {:?}살의 청소년입니다", n),
        // 아무것도 바인딩되지 않음. 결과를 반환합니다.
        n             => println!("저는 {:?}살의 어른입니다", n),
    }
}
```

바인딩을 사용하여 `Option`과 같은 `enum` 변형을 "구조 분해"할 수도 있습니다.

```rust
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // `Some` 변형을 받았습니다. 값이 42 와 같은지 확인합니다. 값은 `n` 에 바인딩됩니다.
        Some(n @ 42) => println!("답: {}!", n),
        // 다른 숫자를 일치시킵니다.
        Some(n)      => println!("흥미롭지 않습니다... {}", n),
        // 다른 모든 것 (`None` 변형) 을 일치시킵니다.
        _            => (),
    }
}
```
