# Связывание

Косвенный доступ к переменной делает невозможным ветвление и использование этой переменной без повторного связывания. `match` предоставляет сигил `@` для связывания значений с именами:

```rust
// Функция `age`, которая возвращает `u32`.
fn age() -> u32 {
    15
}

fn main() {
    println!("Расскажи, какой ты тип человека");

    match age() {
        0             => println!("Я еще не отмечал свой первый день рождения"),
        // Можно напрямую `match` 1..= 12, но тогда какой возраст
        // будет у ребенка? Вместо этого, привяжите к `n` для
        // последовательности 1..= 12. Теперь возраст можно сообщить.
        n @ 1 ..= 12 => println!("Я ребенок в возрасте {:?}", n),
        n @ 13..= 19 => println!("Я подросток в возрасте {:?}", n),
        // Ничего не привязано. Возвращаем результат.
        n             => println!("Я старый человек в возрасте {:?}", n),
    }
}
```

Вы также можете использовать связывание для «разбора» вариантов `enum`, таких как `Option`:

```rust
fn some_number() -> Option<u32> {
    Some(42)
}

fn main() {
    match some_number() {
        // Получен вариант `Some`, проверяем, равно ли его значение,
        // привязанное к `n`, 42.
        Some(n @ 42) => println!("Ответ: {}!", n),
        // Проверяем любое другое число.
        Some(n)      => println!("Неинтересно... {}", n),
        // Проверяем все остальное (`None` вариант).
        _            => (),
    }
}
```
