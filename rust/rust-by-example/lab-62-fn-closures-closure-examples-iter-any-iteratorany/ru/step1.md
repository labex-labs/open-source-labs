# Iterator::any

`Iterator::any` - это функция, которая, когда ей передается итератор, возвращает `true`, если любой элемент удовлетворяет предикату. В противном случае возвращает `false`. Его сигнатура:

```rust
pub trait Iterator {
    // Тип, по которому осуществляется итерация.
    type Item;

    // `any` принимает `&mut self`, что означает, что вызывающий код может быть заимствован
    // и модифицирован, но не потреблен.
    fn any<F>(&mut self, f: F) -> bool where
        // `FnMut` означает, что любая захваченная переменная может быть по крайней мере
        // модифицирована, но не потреблена. `Self::Item` указывает, что аргументы
        // для замыкания передаются по значению.
        F: FnMut(Self::Item) -> bool;
}
```

```rust
fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` для векторов возвращает `&i32`. Деструктурируем в `i32`.
    println!("2 в vec1: {}", vec1.iter()    .any(|&x| x == 2));
    // `into_iter()` для векторов возвращает `i32`. Деструктурирование не требуется.
    println!("2 в vec2: {}", vec2.into_iter().any(|x| x == 2));

    // `iter()` только заимствует `vec1` и его элементы, поэтому они могут быть использованы снова
    println!("Длина vec1: {}", vec1.len());
    println!("Первый элемент vec1: {}", vec1[0]);
    // `into_iter()` перемещает `vec2` и его элементы, поэтому они не могут быть использованы снова
    // println!("Первый элемент vec2: {}", vec2[0]);
    // println!("Длина vec2: {}", vec2.len());
    // TODO: раскомментируйте две строки выше и посмотрите на ошибки компиляции.

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` для массивов возвращает `&i32`.
    println!("2 в array1: {}", array1.iter()    .any(|&x| x == 2));
    // `into_iter()` для массивов возвращает `i32`.
    println!("2 в array2: {}", array2.into_iter().any(|x| x == 2));
}
```
