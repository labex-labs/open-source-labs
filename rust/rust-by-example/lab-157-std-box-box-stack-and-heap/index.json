{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Box, Stack and Heap",
  "description": "In this lab, the concept of boxing, stack allocation, and heap allocation in Rust is explored. All values in Rust are stack allocated by default, but they can be boxed (allocated on the heap) using the Box<T> type. A box is a smart pointer to a heap-allocated value, and when it goes out of scope, its destructor is called and the memory on the heap is freed. Boxing allows for the creation of double indirection and can be dereferenced using the * operator. The lab provides code examples and explanations of how boxing works and how it affects memory allocation on the stack.",
  "meta": {
    "title": "Exploring Rust's Memory Allocation Concepts",
    "description": "Dive into the fundamentals of boxing, stack allocation, and heap allocation in Rust programming language.",
    "keywords": "rust playground, stack, boxing, rust tutor, rust online compiler, heap, rust commands, memory allocation, rust practice, rust online"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Box, stack and heap",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": []
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "装箱、栈和堆",
      "description": "在本实验中，我们将探索 Rust 中的装箱、栈分配和堆分配概念。在 Rust 中，所有值默认都是在栈上分配的，但可以使用 Box<T>类型将它们装箱（在堆上分配）。一个装箱是指向堆分配值的智能指针，当它超出作用域时，其析构函数会被调用，堆上的内存会被释放。装箱允许创建双重间接引用，并且可以使用*运算符进行解引用。本实验提供了代码示例，并解释了装箱的工作原理以及它如何影响栈上的内存分配。",
      "meta": {
        "title": "探索 Rust 的内存分配概念",
        "description": "深入了解 Rust 编程语言中装箱、栈分配和堆分配的基础知识。",
        "keywords": "Rust 游乐场，栈，装箱，Rust 教程，Rust 在线编译器，堆，Rust 命令，内存分配，Rust 练习，Rust 在线"
      },
      "details": {
        "steps": [
          {
            "title": "装箱、栈和堆",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Box, Pila y Montón",
      "description": "En este laboratorio, se explora el concepto de boxing, asignación en pila y asignación en el montón en Rust. Todos los valores en Rust se asignan en pila por defecto, pero se pueden empaquetar (asignar en el montón) utilizando el tipo Box<T>. Una caja es un puntero inteligente a un valor asignado en el montón, y cuando sale del ámbito, se llama a su destructor y se libera la memoria en el montón. El boxing permite la creación de doble indirección y se puede desreferenciar utilizando el operador *. El laboratorio proporciona ejemplos de código y explicaciones de cómo funciona el boxing y cómo afecta a la asignación de memoria en la pila.",
      "meta": {
        "title": "Explorando los Conceptos de Asignación de Memoria en Rust",
        "description": "Sumérgete en los fundamentos del boxing, la asignación en pila y la asignación en el montón en el lenguaje de programación Rust.",
        "keywords": "rust playground, pila, boxing, rust tutor, compilador en línea de rust, montón, comandos de rust, asignación de memoria, práctica de rust, rust en línea"
      },
      "details": {
        "steps": [
          {
            "title": "Box, pila y montón",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "En este momento, este paso no tiene verificaciones",
                "file": "verify1-1.sh",
                "hint": "En este momento, este paso no tiene verificaciones"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Box, Pile et Tas",
      "description": "Dans ce laboratoire, on explore le concept de boxing, d'allocation sur la pile et d'allocation sur le tas en Rust. Toutes les valeurs en Rust sont par défaut allouées sur la pile, mais elles peuvent être emballées (allouées sur le tas) à l'aide du type Box<T>. Un emballage est un pointeur intelligent vers une valeur allouée sur le tas, et lorsqu'il sort de portée, son destructeur est appelé et la mémoire sur le tas est libérée. Le boxing permet de créer une double indirection et peut être déréférencé à l'aide de l'opérateur *. Le laboratoire fournit des exemples de code et des explications sur la manière dont le boxing fonctionne et sur la façon dont il affecte l'allocation de mémoire sur la pile.",
      "meta": {
        "title": "Explorer les Concepts d'Allocation de Mémoire en Rust",
        "description": "Plongez dans les bases du boxing, de l'allocation sur la pile et de l'allocation sur le tas dans le langage de programmation Rust.",
        "keywords": "plateforme de pratique Rust, pile, boxing, tuteur Rust, compilateur en ligne Rust, tas, commandes Rust, allocation de mémoire, pratique Rust, en ligne Rust"
      },
      "details": {
        "steps": [
          {
            "title": "Box, pile et tas",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Box, Stack und Heap",
      "description": "In diesem Lab wird das Konzept des Boxings, der Stack- und Heap-Allokation in Rust untersucht. Alle Werte in Rust werden standardmäßig auf dem Stack zugewiesen, können jedoch mit dem Typ Box<T> geboxed (auf dem Heap zugewiesen) werden. Ein Box ist ein Smart-Pointer auf einen auf dem Heap zugewiesenen Wert, und wenn er außer Reichweite gelangt, wird dessen Destruktor aufgerufen und der Speicher auf dem Heap freigegeben. Boxing ermöglicht die Erstellung von Doppelindirektion und kann mit dem *-Operator dereferenziert werden. Das Lab bietet Codebeispiele und Erklärungen dazu, wie Boxing funktioniert und wie es die Speicherzuweisung auf dem Stack beeinflusst.",
      "meta": {
        "title": "Das Erkunden von Rusts Arbeitsspeicherzuweisungskonzepten",
        "description": "Taucht in die Grundlagen des Boxings, der Stack- und Heap-Allokation in der Rust-Programmiersprache ein.",
        "keywords": "Rust-Spielplatz, Stack, Boxing, Rust-Tutor, Rust-Online-Compiler, Heap, Rust-Befehle, Arbeitsspeicherzuweisung, Rust-Praxis, Rust-Online"
      },
      "details": {
        "steps": [
          {
            "title": "Box, Stack und Heap",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "ボックス、スタックとヒープ",
      "description": "この実験では、Rust におけるボクシング、スタック割り当て、およびヒープ割り当ての概念を調べます。Rust のすべての値はデフォルトでスタック割り当てされますが、Box<T> 型を使用してボクシング（ヒープ上に割り当てる）することができます。ボックスは、ヒープ上に割り当てられた値へのスマートポインタであり、スコープ外になると、そのデストラクタが呼び出され、ヒープ上のメモリが解放されます。ボクシングにより、二重の間接参照の作成が可能になり、* 演算子を使用して参照解除することができます。この実験では、ボクシングがどのように機能するか、およびスタック上のメモリ割り当てにどのように影響するかについて、コード例と説明を提供しています。",
      "meta": {
        "title": "Rust のメモリ割り当て概念を探る",
        "description": "Rust プログラミング言語におけるボクシング、スタック割り当て、およびヒープ割り当ての基本を学びましょう。",
        "keywords": "rust playground, スタック，ボクシング，rust tutor, rust オンラインコンパイラ，ヒープ，rust コマンド，メモリ割り当て，rust 練習，rust オンライン"
      },
      "details": {
        "steps": [
          {
            "title": "ボックス、スタックとヒープ",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップは現在検証がありません",
                "file": "verify1-1.sh",
                "hint": "このステップは現在検証がありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Box, Stack and Heap",
      "description": "В этом лабе исследуется концепция boxing, стека и кучи в Rust. Все значения в Rust по умолчанию выделяются на стеке, но их можно \"упаковать\" (выделить в куче), используя тип Box<T>. Box - это умный указатель на значение, выделенное в куче, и когда он выходит из области видимости, вызывается его деструктор и память в куче освобождается. Boxing позволяет создавать двойную косвенность и можно разыменовывать с помощью оператора *. В лабе приводятся примеры кода и объяснения того, как работает boxing и как это влияет на выделение памяти на стеке.",
      "meta": {
        "title": "Исследование концепций распределения памяти в Rust",
        "description": "Освойте основы boxing, стека и кучи в языке программирования Rust.",
        "keywords": "rust playground, stack, boxing, rust tutor, rust online compiler, heap, rust commands, memory allocation, rust practice, rust online"
      },
      "details": {
        "steps": [
          {
            "title": "Box, stack and heap",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    },
    {
      "lang": "ko",
      "title": "Box, 스택 및 힙",
      "description": "이 랩에서는 Rust 에서 boxing, 스택 할당 및 힙 할당의 개념을 탐구합니다. Rust 의 모든 값은 기본적으로 스택에 할당되지만, `Box<T>` 타입을 사용하여 boxing(힙에 할당) 할 수 있습니다. Box 는 힙에 할당된 값을 가리키는 스마트 포인터이며, scope 밖으로 벗어날 때 소멸자가 호출되어 힙의 메모리가 해제됩니다. Boxing 을 통해 이중 간접 참조를 생성할 수 있으며, `*` 연산자를 사용하여 역참조할 수 있습니다. 이 랩은 boxing 이 어떻게 작동하고 스택의 메모리 할당에 어떤 영향을 미치는지에 대한 코드 예제와 설명을 제공합니다.",
      "meta": {
        "title": "Rust 의 메모리 할당 개념 탐구",
        "description": "Rust 프로그래밍 언어에서 boxing, 스택 할당 및 힙 할당의 기본 사항을 자세히 알아보세요.",
        "keywords": "러스트 플레이그라운드, 스택, boxing, 러스트 튜터, 러스트 온라인 컴파일러, 힙, 러스트 명령어, 메모리 할당, 러스트 연습, 러스트 온라인"
      },
      "details": {
        "steps": [
          {
            "title": "Box, 스택 및 힙",
            "text": "ko/step1.md",
            "verify": [
              {
                "name": "현재 이 단계에는 검증이 없습니다.",
                "file": "verify1-1.sh",
                "hint": "현재 이 단계에는 검증이 없습니다."
              }
            ]
          }
        ],
        "intro": {
          "text": "ko/intro.md",
          "title": "소개"
        },
        "finish": {
          "text": "ko/finish.md",
          "title": "요약"
        }
      }
    },
    {
      "lang": "pt",
      "title": "Box, Stack e Heap",
      "description": "Neste laboratório, o conceito de *boxing*, alocação na *stack* e alocação na *heap* em Rust é explorado. Todos os valores em Rust são alocados na *stack* por padrão, mas podem ser *boxed* (alocados na *heap*) usando o tipo `Box<T>`. Um *box* é um *smart pointer* para um valor alocado na *heap*, e quando ele sai do escopo, seu destrutor é chamado e a memória na *heap* é liberada. O *boxing* permite a criação de dupla indireção e pode ser desreferenciado usando o operador *. O laboratório fornece exemplos de código e explicações de como o *boxing* funciona e como ele afeta a alocação de memória na *stack*.",
      "meta": {
        "title": "Explorando os Conceitos de Alocação de Memória em Rust",
        "description": "Mergulhe nos fundamentos de *boxing*, alocação na *stack* e alocação na *heap* na linguagem de programação Rust.",
        "keywords": "rust playground, stack, boxing, tutorial rust, compilador rust online, heap, comandos rust, alocação de memória, prática rust, rust online"
      },
      "details": {
        "steps": [
          {
            "title": "Box, stack e heap",
            "text": "pt/step1.md",
            "verify": [
              {
                "name": "Este passo não possui verificação no momento",
                "file": "verify1-1.sh",
                "hint": "Este passo não possui verificação no momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "pt/intro.md",
          "title": "Introdução"
        },
        "finish": {
          "text": "pt/finish.md",
          "title": "Resumo"
        }
      }
    }
  ]
}
