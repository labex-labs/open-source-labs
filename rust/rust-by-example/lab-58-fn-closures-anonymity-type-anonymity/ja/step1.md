# 型の匿名性

クロージャは、囲むスコープから変数を簡潔にキャプチャします。これには何か結果がありますか？確かにあります。クロージャを関数パラメータとして使用するときに\[ジェネリクス\]が必要になることを見てみましょう。これは、それらが定義されている方法のために必要です。

```rust
// `F` はジェネリックでなければなりません。
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

クロージャが定義されると、コンパイラは暗黙的に新しい匿名構造を作成して、キャプチャされた変数を内部に格納します。同時に、この未知の型に対して `traits` の1つである `Fn`、`FnMut`、または `FnOnce` を介して機能を実装します。この型は、呼び出しまで格納される変数に割り当てられます。

この新しい型は未知の型であるため、関数内での使用にはジェネリクスが必要になります。ただし、無制限の型パラメータ `<T>` は依然として曖昧で、許可されません。したがって、`traits` の1つである `Fn`、`FnMut`、または `FnOnce`（それが実装しているもの）による制限は、その型を指定するのに十分です。

```rust
// `F` は、入力を取らずに何も返さないクロージャに対して `Fn` を実装する必要があります。
// これは `print` に必要なものとまったく同じです。
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // `x` を匿名型にキャプチャして、それに対して `Fn` を実装します。
    // それを `print` に格納します。
    let print = || println!("{}", x);

    apply(print);
}
```
