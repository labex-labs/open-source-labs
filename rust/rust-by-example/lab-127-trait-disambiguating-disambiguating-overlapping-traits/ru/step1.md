# Устранение неоднозначности перекрывающихся характеристик

Тип может реализовывать множество различных характеристик. Что делать, если две характеристики требуют одного и того же имени? Например, у многих характеристик может быть метод с именем `get()`. Возможно, они даже имеют разные типы возвращаемых значений!

Хорошие новости: поскольку каждое реализация характеристики имеет свою собственную `impl`-блок, понятно, какой метод `get` из какой характеристики вы реализуете.

Что делать, когда приходит время _вызывать_ эти методы? Чтобы избежать неоднозначности между ними, мы должны использовать полный синтаксис.

```rust
trait UsernameWidget {
    // Получить выбранное имя пользователя из этого виджета
    fn get(&self) -> String;
}

trait AgeWidget {
    // Получить выбранный возраст из этого виджета
    fn get(&self) -> u8;
}

// Форма, которая содержит и UsernameWidget, и AgeWidget
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&self) -> String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&self) -> u8 {
        self.age
    }
}

fn main() {
    let form = Form {
        username: "rustacean".to_owned(),
        age: 28,
    };

    // Если вы раскомментируете эту строку, вы получите ошибку, которая говорит,
    // что "найдено несколько `get`". Потому что, в конце концов, есть несколько методов
    // с именем `get`.
    // println!("{}", form.get());

    let username = <Form as UsernameWidget>::get(&form);
    assert_eq!("rustacean".to_owned(), username);
    let age = <Form as AgeWidget>::get(&form);
    assert_eq!(28, age);
}
```
