# Функции

Игнорируя \[элиминацию\], сигнатуры функций с временем жизни имеют несколько ограничений:

- любая ссылка _должна_ иметь аннотированное время жизни.
- любая возвращаемая ссылка _должна_ иметь то же время жизни, что и входной параметр или быть `static`.

此外,请注意,如果返回没有输入的引用会导致返回对无效数据的引用,则禁止这样做。以下示例展示了一些具有生命周期的函数的有效形式:

```rust
// Один входной параметр с временем жизни `'a`, которое должно существовать
// по крайней мере столько же времени, сколько и функция.
fn print_one<'a>(x: &'a i32) {
    println!("`print_one`: x is {}", x);
}

// Возможны и изменяемые ссылки с временем жизни.
fn add_one<'a>(x: &'a mut i32) {
    *x += 1;
}

// Несколько элементов с разными временем жизни. В этом случае
// оба могут иметь одинаковое время жизни `'a`, но
// в более сложных случаях могут потребоваться разные времена жизни.
fn print_multi<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("`print_multi`: x is {}, y is {}", x, y);
}

// Возвращение ссылок, которые были переданы в функцию, допустимо.
// Однако, необходимо вернуть правильное время жизни.
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { x }

//fn invalid_output<'a>() -> &'a String { &String::from("foo") }
// Вышеприведенный код неверен: `'a` должно существовать дольше функции.
// Здесь `&String::from("foo")` создаст `String`, а затем ссылку.
// Затем данные будут уничтожены при выходе из области видимости,
// оставляя ссылку на недействительные данные для возврата.

fn main() {
    let x = 7;
    let y = 9;

    print_one(&x);
    print_multi(&x, &y);

    let z = pass_x(&x, &y);
    print_one(z);

    let mut t = 3;
    add_one(&mut t);
    print_one(&t);
}
```
