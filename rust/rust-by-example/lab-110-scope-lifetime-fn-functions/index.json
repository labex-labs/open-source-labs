{
  "$schema": "https://cdn.jsdelivr.net/gh/labex-labs/schema/index.json",
  "type": "lab",
  "title": "Rust Function Signatures with Lifetimes",
  "description": "In this lab, we are introduced to function signatures with lifetimes in Rust, where any reference must have an annotated lifetime and any reference being returned must have the same lifetime as an input or be static. It is important to note that returning references without input is prohibited if it would result in returning references to invalid data. The examples provided demonstrate valid forms of functions with lifetimes, including functions with one input reference, functions with mutable references, functions with multiple elements and different lifetimes, and functions that return references that have been passed in as parameters.",
  "meta": {
    "title": "Rust Programming | Function Signatures with Lifetimes",
    "description": "Learn about function signatures with lifetimes in Rust, where references must have annotated lifetimes and returned references must match input lifetimes or be static.",
    "keywords": "Rust, Programming, Function Signatures, Lifetimes, References"
  },
  "difficulty": "Beginner",
  "time": 5,
  "hidden": false,
  "fee_type": "free",
  "show_in_tutorial": true,
  "details": {
    "steps": [
      {
        "title": "Functions",
        "text": "en/step1.md",
        "verify": [
          {
            "name": "This step has no verification at the moment",
            "file": "verify1-1.sh",
            "hint": "This step has no verification at the moment",
            "timeout": 0,
            "showstderr": true
          }
        ],
        "skills": [
          "rust/expressions_statements",
          "rust/function_syntax",
          "rust/integer_types",
          "rust/method_syntax",
          "rust/mutable_variables",
          "rust/string_type",
          "rust/type_casting",
          "rust/variable_declarations"
        ]
      }
    ],
    "intro": {
      "text": "en/intro.md",
      "title": "Introduction",
      "background": "setup.sh"
    },
    "finish": {
      "text": "en/finish.md",
      "title": "Summary"
    }
  },
  "backend": {
    "imageid": "webide-ubuntu:2204"
  },
  "contributors": [],
  "license": {
    "name": "MIT",
    "url": "https://github.com/rust-lang/rust-by-example/blob/master/LICENSE-MIT",
    "repo": "https://github.com/rust-lang/rust-by-example"
  },
  "i18n": [
    {
      "lang": "zh",
      "title": "带有生命周期的 Rust 函数签名",
      "description": "在本实验中，我们学习 Rust 中带有生命周期的函数签名，其中任何引用都必须带有注释生命周期，并且返回的任何引用都必须与输入具有相同的生命周期，或者是静态的。需要注意的是，如果返回没有输入的引用会导致返回对无效数据的引用，则是被禁止的。提供的示例展示了带有生命周期的函数的有效形式，包括带有一个输入引用的函数、带有可变引用的函数、带有多个具有不同生命周期的元素的函数，以及返回作为参数传入的引用的函数。",
      "meta": {
        "title": "Rust 编程 | 带有生命周期的函数签名",
        "description": "了解 Rust 中带有生命周期的函数签名，其中引用必须带有注释生命周期，并且返回的引用必须与输入生命周期匹配或为静态。",
        "keywords": "Rust, 编程，函数签名，生命周期，引用"
      },
      "details": {
        "steps": [
          {
            "title": "函数",
            "text": "zh/step1.md",
            "verify": [
              {
                "name": "此步骤目前没有验证",
                "file": "verify1-1.sh",
                "hint": "此步骤目前没有验证"
              }
            ]
          }
        ],
        "intro": {
          "text": "zh/intro.md",
          "title": "介绍"
        },
        "finish": {
          "text": "zh/finish.md",
          "title": "总结"
        }
      }
    },
    {
      "lang": "es",
      "title": "Firmas de funciones en Rust con tiempos de vida",
      "description": "En este laboratorio, se nos presenta la firma de funciones con tiempos de vida en Rust, donde cualquier referencia debe tener un tiempo de vida anotado y cualquier referencia devuelta debe tener el mismo tiempo de vida que una entrada o ser estática. Es importante destacar que no está permitido devolver referencias sin entrada si eso implicaría devolver referencias a datos no válidos. Los ejemplos proporcionados demuestran formas válidas de funciones con tiempos de vida, incluyendo funciones con una referencia de entrada, funciones con referencias mutables, funciones con múltiples elementos y diferentes tiempos de vida, y funciones que devuelven referencias que se han pasado como parámetros.",
      "meta": {
        "title": "Programación en Rust | Firmas de funciones con tiempos de vida",
        "description": "Aprende sobre las firmas de funciones con tiempos de vida en Rust, donde las referencias deben tener tiempos de vida anotados y las referencias devueltas deben coincidir con los tiempos de vida de la entrada o ser estáticas.",
        "keywords": "Rust, Programación, Firmas de funciones, Tiempos de vida, Referencias"
      },
      "details": {
        "steps": [
          {
            "title": "Funciones",
            "text": "es/step1.md",
            "verify": [
              {
                "name": "En este momento, este paso no tiene verificación",
                "file": "verify1-1.sh",
                "hint": "En este momento, este paso no tiene verificación"
              }
            ]
          }
        ],
        "intro": {
          "text": "es/intro.md",
          "title": "Introducción"
        },
        "finish": {
          "text": "es/finish.md",
          "title": "Resumen"
        }
      }
    },
    {
      "lang": "fr",
      "title": "Signatures de fonctions Rust avec des durées de vie",
      "description": "Dans ce laboratoire, nous sommes introduits aux signatures de fonctions avec des durées de vie en Rust, où toute référence doit avoir une durée de vie annotée et toute référence retournée doit avoir la même durée de vie qu'une entrée ou être statique. Il est important de noter que la restitution de références sans entrée est interdite si elle entraînerait la restitution de références à des données invalides. Les exemples fournis démontrent les formes valides de fonctions avec des durées de vie, y compris des fonctions avec une référence d'entrée, des fonctions avec des références mutables, des fonctions avec plusieurs éléments et différentes durées de vie, et des fonctions qui retournent des références qui ont été passées en tant que paramètres.",
      "meta": {
        "title": "Programmation Rust | Signatures de fonctions avec des durées de vie",
        "description": "Découvrez les signatures de fonctions avec des durées de vie en Rust, où les références doivent avoir des durées de vie annotées et les références retournées doivent correspondre aux durées de vie d'entrée ou être statiques.",
        "keywords": "Rust, Programmation, Signatures de fonctions, Durées de vie, Références"
      },
      "details": {
        "steps": [
          {
            "title": "Fonctions",
            "text": "fr/step1.md",
            "verify": [
              {
                "name": "Cette étape n'a pas de vérification pour le moment",
                "file": "verify1-1.sh",
                "hint": "Cette étape n'a pas de vérification pour le moment"
              }
            ]
          }
        ],
        "intro": {
          "text": "fr/intro.md",
          "title": "Introduction"
        },
        "finish": {
          "text": "fr/finish.md",
          "title": "Résumé"
        }
      }
    },
    {
      "lang": "de",
      "title": "Rust-Funktionssignaturen mit Lebensdauern",
      "description": "In diesem Lab werden wir auf Funktionssignaturen mit Lebensdauern in Rust eingestuft, wobei jede Referenz eine annotierte Lebensdauer haben muss und jede zurückgegebene Referenz die gleiche Lebensdauer wie eine Eingabe haben muss oder `static` sein muss. Es ist wichtig zu beachten, dass das Zurückgeben von Referenzen ohne Eingabe verboten ist, wenn dies zu einem Zurückgeben von Referenzen auf ungültige Daten führen würde. Die bereitgestellten Beispiele veranschaulichen gültige Formen von Funktionen mit Lebensdauern, einschließlich Funktionen mit einer Eingabereferenz, Funktionen mit mutablen Referenzen, Funktionen mit mehreren Elementen und unterschiedlicher Lebensdauer sowie Funktionen, die Referenzen zurückgeben, die als Parameter übergeben wurden.",
      "meta": {
        "title": "Rust-Programmierung | Funktionssignaturen mit Lebensdauern",
        "description": "Lernen Sie über Funktionssignaturen mit Lebensdauern in Rust, wobei Referenzen annotierte Lebensdauern haben müssen und zurückgegebene Referenzen der Eingabelebensdauer entsprechen müssen oder `static` sein müssen.",
        "keywords": "Rust, Programmierung, Funktionssignaturen, Lebensdauern, Referenzen"
      },
      "details": {
        "steps": [
          {
            "title": "Funktionen",
            "text": "de/step1.md",
            "verify": [
              {
                "name": "Dieser Schritt hat momentan keine Verifizierung",
                "file": "verify1-1.sh",
                "hint": "Dieser Schritt hat momentan keine Verifizierung"
              }
            ]
          }
        ],
        "intro": {
          "text": "de/intro.md",
          "title": "Einführung"
        },
        "finish": {
          "text": "de/finish.md",
          "title": "Zusammenfassung"
        }
      }
    },
    {
      "lang": "ja",
      "title": "寿命付きの Rust 関数シグネチャ",
      "description": "この実験では、Rust における寿命付きの関数シグネチャについて学びます。ここでは、任意の参照には寿命が付与されており、返される任意の参照は入力と同じ寿命を持たなければならず、または static でなければなりません。返される参照が無効なデータを参照することになる場合、入力なしで参照を返すことは禁止されていることに注意する必要があります。提供された例では、寿命付きの関数の有効な形式が示されており、1 つの入力参照を持つ関数、可変参照を持つ関数、複数の要素と異なる寿命を持つ関数、およびパラメータとして渡された参照を返す関数が含まれます。",
      "meta": {
        "title": "Rust プログラミング | 寿命付きの関数シグネチャ",
        "description": "Rust における寿命付きの関数シグネチャについて学びましょう。ここでは、参照には寿命が付与されており、返される参照は入力の寿命と一致するか、または static でなければなりません。",
        "keywords": "Rust, プログラミング，関数シグネチャ，寿命，参照"
      },
      "details": {
        "steps": [
          {
            "title": "関数",
            "text": "ja/step1.md",
            "verify": [
              {
                "name": "このステップには現在、検証はありません",
                "file": "verify1-1.sh",
                "hint": "このステップには現在、検証はありません"
              }
            ]
          }
        ],
        "intro": {
          "text": "ja/intro.md",
          "title": "はじめに"
        },
        "finish": {
          "text": "ja/finish.md",
          "title": "まとめ"
        }
      }
    },
    {
      "lang": "ru",
      "title": "Rust: сигнатуры функций с временем жизни",
      "description": "В этом лабораторном задании мы познакомимся с сигнатурами функций с временем жизни в Rust, где любая ссылка должна иметь аннотированное время жизни, а любая возвращаемая ссылка должна иметь то же время жизни, что и входной параметр или быть static. Следует обратить внимание, что возвращение ссылок без входных параметров запрещено, если это приведет к возврату ссылок на недействительные данные. Приведенные примеры демонстрируют допустимые формы функций с временем жизни, включая функции с одной входной ссылкой, функции с изменяемыми ссылками, функции с несколькими элементами и разными временем жизни, а также функции, которые возвращают ссылки, переданные в качестве параметров.",
      "meta": {
        "title": "Программирование на Rust | Сигнатуры функций с временем жизни",
        "description": "Изучите сигнатуры функций с временем жизни в Rust, где ссылки должны иметь аннотированные времена жизни, а возвращаемые ссылки должны соответствовать временам жизни входных параметров или быть static.",
        "keywords": "Rust, Программирование, Сигнатуры функций, Время жизни, Ссылки"
      },
      "details": {
        "steps": [
          {
            "title": "Функции",
            "text": "ru/step1.md",
            "verify": [
              {
                "name": "На данный момент эта стадия не имеет проверки",
                "file": "verify1-1.sh",
                "hint": "На данный момент эта стадия не имеет проверки"
              }
            ]
          }
        ],
        "intro": {
          "text": "ru/intro.md",
          "title": "Введение"
        },
        "finish": {
          "text": "ru/finish.md",
          "title": "Резюме"
        }
      }
    },
    {
      "lang": "ko",
      "title": "Rust 생명주기를 사용한 함수 시그니처",
      "description": "이 랩에서는 Rust 에서 생명주기를 가진 함수 시그니처를 소개합니다. 여기서 모든 참조는 주석 처리된 생명주기를 가져야 하며, 반환되는 모든 참조는 입력과 동일한 생명주기를 가지거나 static 이어야 합니다. 입력 없이 참조를 반환하는 것은 유효하지 않은 데이터에 대한 참조를 반환하는 결과를 초래할 경우 금지된다는 점에 유의해야 합니다. 제공된 예제는 하나의 입력 참조를 가진 함수, 가변 참조를 가진 함수, 여러 요소와 서로 다른 생명주기를 가진 함수, 그리고 매개변수로 전달된 참조를 반환하는 함수를 포함하여 생명주기를 가진 함수의 유효한 형태를 보여줍니다.",
      "meta": {
        "title": "Rust 프로그래밍 | 생명주기를 사용한 함수 시그니처 - Rust 학습",
        "description": "Rust 에서 참조가 주석 처리된 생명주기를 가져야 하고 반환된 참조가 입력 생명주기와 일치하거나 static 이어야 하는 생명주기를 사용한 함수 시그니처에 대해 알아보세요. Rust 프로그래밍 기초 학습.",
        "keywords": "Rust, 프로그래밍, 함수 시그니처, 생명주기, 참조, Rust 튜토리얼, Rust 강좌"
      },
      "details": {
        "steps": [
          {
            "title": "함수",
            "text": "ko/step1.md",
            "verify": [
              {
                "name": "현재 이 단계에는 검증이 없습니다.",
                "file": "verify1-1.sh",
                "hint": "현재 이 단계에는 검증이 없습니다."
              }
            ]
          }
        ],
        "intro": {
          "text": "ko/intro.md",
          "title": "소개"
        },
        "finish": {
          "text": "ko/finish.md",
          "title": "요약"
        }
      }
    },
    {
      "lang": "pt",
      "title": "Assinaturas de Funções Rust com Lifetimes",
      "description": "Neste laboratório, somos introduzidos às assinaturas de funções com *lifetimes* em Rust, onde qualquer referência deve ter um *lifetime* anotado e qualquer referência que está sendo retornada deve ter o mesmo *lifetime* de uma entrada ou ser *static*. É importante notar que retornar referências sem entrada é proibido se isso resultar em retornar referências a dados inválidos. Os exemplos fornecidos demonstram formas válidas de funções com *lifetimes*, incluindo funções com uma referência de entrada, funções com referências mutáveis, funções com múltiplos elementos e diferentes *lifetimes*, e funções que retornam referências que foram passadas como parâmetros.",
      "meta": {
        "title": "Programação Rust | Assinaturas de Funções com Lifetimes - Aprenda Agora!",
        "description": "Aprenda sobre assinaturas de funções com *lifetimes* em Rust. Descubra como as referências devem ter *lifetimes* anotados e como as referências retornadas devem corresponder aos *lifetimes* de entrada ou ser *static*. Domine os conceitos essenciais da programação Rust!",
        "keywords": "Rust, Programação, Assinaturas de Funções, Lifetimes, Referências, Tutorial Rust, Aprender Rust"
      },
      "details": {
        "steps": [
          {
            "title": "Funções",
            "text": "pt/step1.md",
            "verify": [
              {
                "name": "Este passo não possui verificação no momento",
                "file": "verify1-1.sh",
                "hint": "Este passo não possui verificação no momento"
              }
            ]
          }
        ],
        "intro": {
          "text": "pt/intro.md",
          "title": "Introdução"
        },
        "finish": {
          "text": "pt/finish.md",
          "title": "Resumo"
        }
      }
    }
  ]
}
