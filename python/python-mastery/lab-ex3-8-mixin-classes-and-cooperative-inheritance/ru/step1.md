# Понимание проблемы с форматированием столбцов

На этом этапе мы рассмотрим ограничение в текущей реализации форматирования таблиц. Также мы изучим возможные решения этой проблемы.

Сначала разберемся, что предстоит сделать. Откроем редактор VSCode и посмотрим на файл `tableformat.py` в директории проекта. Этот файл важен, так как он содержит код, позволяющий форматировать табличные данные различными способами, например, в текстовом, CSV или HTML форматах.

Для открытия файла используем следующие команды в терминале. Команда `cd` изменяет текущую директорию на директорию проекта, а команда `code` открывает файл `tableformat.py` в VSCode.

```bash
cd ~/project
code tableformat.py
```

При открытии файла вы заметите, что определено несколько классов. Эти классы выполняют различные роли в форматировании табличных данных.

- `TableFormatter`: Это абстрактный базовый класс. Он содержит методы, используемые для форматирования заголовков и строк таблицы. Представьте его как чертеж для других классов-форматеров.
- `TextTableFormatter`: Этот класс используется для вывода таблицы в простом текстовом формате.
- `CSVTableFormatter`: Он отвечает за форматирование табличных данных в формате CSV (Comma-Separated Values, разделенные запятыми значения).
- `HTMLTableFormatter`: Этот класс форматирует табличные данные в HTML формате.

В файле также есть функция `print_table()`. Эта функция использует только что упомянутые классы-форматеры для отображения табличных данных.

Теперь посмотрим, как эти классы работают, запустив некоторый Python-код. Откройте терминал и начните сессию Python. Следующий код импортирует необходимые функции и классы из файла `tableformat.py`, создает объект `TextTableFormatter`, а затем использует функцию `print_table()` для отображения данных о портфеле.

```python
python3 -c "
from tableformat import print_table, TextTableFormatter, portfolio
formatter = TextTableFormatter()
print_table(portfolio, ['name', 'shares', 'price'], formatter)
"
```

После запуска кода вы должны увидеть вывод, похожий на следующий:

```
      name     shares      price
---------- ---------- ----------
        AA        100       32.2
       IBM         50       91.1
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50       65.1
       IBM        100      70.44
```

Теперь найдем проблему. Обратите внимание, что значения в столбце `price` не имеют единообразного формата. Некоторые значения имеют одну десятичную цифру, например 32.2, а другие - две десятичные цифры, например 51.23. В финансовых данных обычно требуется единообразное форматирование.

Вот как должен выглядеть вывод:

```
      name     shares      price
---------- ---------- ----------
        AA        100      32.20
       IBM         50      91.10
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50      65.10
       IBM        100      70.44
```

Один из способов исправить это - модифицировать функцию `print_table()` так, чтобы она принимала спецификации формата. Следующий код показывает, как это можно сделать. Мы определяем новую функцию `print_table()`, которая принимает дополнительный параметр `formats`. Внутри функции мы используем эти спецификации формата для форматирования каждого значения в строке.

```python
python3 -c "
from tableformat import TextTableFormatter, portfolio

def print_table(records, fields, formats, formatter):
    formatter.headings(fields)
    for r in records:
        rowdata = [(fmt % getattr(r, fieldname))
             for fieldname, fmt in zip(fields, formats)]
        formatter.row(rowdata)

formatter = TextTableFormatter()
print_table(portfolio,
            ['name','shares','price'],
            ['%s','%d','%0.2f'],
            formatter)
"
```

Это решение работает, но имеет недостаток. Изменение интерфейса функции может нарушить работу существующего кода, который использует старую версию функции `print_table()`.

Другой подход - создать настраиваемый форматер путем наследования. Мы можем создать новый класс, который наследуется от `TextTableFormatter` и переопределить метод `row()` для применения нужного форматирования.

```python
python3 -c "
from tableformat import TextTableFormatter, print_table, portfolio

class PortfolioFormatter(TextTableFormatter):
    def row(self, rowdata):
        formats = ['%s','%d','%0.2f']
        rowdata = [(fmt % d) for fmt, d in zip(formats, rowdata)]
        super().row(rowdata)

formatter = PortfolioFormatter()
print_table(portfolio, ['name','shares','price'], formatter)
"
```

Это решение также работает, но не очень удобно. Каждый раз, когда мы хотим использовать другое форматирование, нам приходится создавать новый класс. Кроме того, мы ограничены конкретным типом форматера, от которого наследуемся, в данном случае `TextTableFormatter`.

На следующем этапе мы рассмотрим более элегантное решение с использованием миксин-классов (mixin classes).
