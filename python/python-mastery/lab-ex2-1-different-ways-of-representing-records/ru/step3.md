# Работа со структурированными данными с использованием кортежей

До сих пор мы занимались хранением необработанных текстовых данных. Но когда дело доходит до анализа данных, обычно нужно преобразовать данные в более организованные и структурированные форматы. Это упрощает выполнение различных операций и получение полезной информации из данных. На этом этапе мы научимся считывать данные в виде списка кортежей с использованием модуля `csv`. Кортежи - это простая и полезная структура данных в Python, которая может хранить несколько значений.

## Создание функции-читателя с использованием кортежей

Создадим новый файл с именем `readrides.py` в каталоге `/home/labex/project`. Этот файл будет содержать код для чтения данных из CSV-файла и их хранения в виде списка кортежей.

```python
# readrides.py
import csv
import tracemalloc

def read_rides_as_tuples(filename):
    '''
    Read the bus ride data as a list of tuples
    '''
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headings = next(rows)     # Skip headers
        for row in rows:
            route = row[0]
            date = row[1]
            daytype = row[2]
            rides = int(row[3])
            record = (route, date, daytype, rides)
            records.append(record)
    return records

if __name__ == '__main__':
    tracemalloc.start()

    rows = read_rides_as_tuples('/home/labex/project/ctabus.csv')

    current, peak = tracemalloc.get_traced_memory()
    print(f'Number of records: {len(rows)}')
    print(f'First record: {rows[0]}')
    print(f'Second record: {rows[1]}')
    print(f'Memory Use: Current {current/1024/1024:.2f} MB, Peak {peak/1024/1024:.2f} MB')
```

Этот скрипт определяет функцию `read_rides_as_tuples`. Вот что она делает пошагово:

1. Она открывает CSV-файл, указанный параметром `filename`. Это позволяет нам получить доступ к данным в файле.
2. Она использует модуль `csv` для разбора каждой строки файла. Функция `csv.reader` помогает нам разделить строки на отдельные значения.
3. Она извлекает четыре поля (маршрут, дата, тип дня и количество поездок) из каждой строки. Эти поля важны для нашего анализа данных.
4. Она преобразует поле 'rides' в целое число. Это необходимо, так как данные в CSV-файле изначально имеют строковый формат, а для вычислений нужен числовой тип.
5. Она создает кортеж с этими четырьмя значениями. Кортежи неизменяемы, то есть их значения нельзя изменить после создания.
6. Она добавляет кортеж в список с именем `records`. Этот список будет содержать все записи из CSV-файла.

Теперь запустим скрипт. Откройте терминал и введите следующую команду:

```bash
python3 /home/labex/project/readrides.py
```

Вы должны увидеть вывод, похожий на следующий:

```
Number of records: 577563
First record: ('3', '01/01/2001', 'U', 7354)
Second record: ('4', '01/01/2001', 'U', 9288)
Memory Use: Current 89.12 MB, Peak 89.15 MB
```

Обратите внимание, что использование памяти увеличилось по сравнению с предыдущими примерами. Это связано с несколькими причинами:

1. Теперь мы храним данные в структурированном формате (кортежи). Структурированные данные обычно требуют больше памяти, так как имеют определенную организацию.
2. Каждое значение в кортеже является отдельным объектом Python. Объекты Python имеют определенную накладную нагрузку, которая способствует увеличению использования памяти.
3. У нас есть дополнительная структура списка, которая хранит все эти кортежи. Списки также занимают память для хранения своих элементов.

Преимущество использования этого подхода заключается в том, что наши данные теперь правильно структурированы и готовы к анализу. Мы можем легко получить доступ к определенным полям каждой записи по индексу. Например:

```python
# Example of accessing tuple elements (add this to readrides.py file to try it)
first_record = rows[0]
route = first_record[0]
date = first_record[1]
daytype = first_record[2]
rides = first_record[3]
print(f"Route: {route}, Date: {date}, Day type: {daytype}, Rides: {rides}")
```

Однако получение доступа к данным по числовому индексу не всегда интуитивно понятно. Можно легко забыть, какой индекс соответствует какому полю, особенно при работе с большим количеством полей. На следующем этапе мы рассмотрим другие структуры данных, которые могут сделать наш код более читаемым и поддерживаемым.
