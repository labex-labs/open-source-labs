# Применение инспекции функций в классах

Теперь мы применим то, что узнали о инспекции функций, чтобы улучшить реализацию класса. Инспекция функций позволяет нам заглянуть внутрь функций и понять их структуру, например, параметры, которые они принимают. В данном случае мы используем это, чтобы сделать наш код класса более эффективным и менее подверженным ошибкам. Мы модифицируем класс `Structure` так, чтобы он мог автоматически определять имена полей из сигнатуры метода `__init__`.

## Понимание класса `Structure`

В файле `structure.py` содержится класс `Structure`. Этот класс является базовым классом, то есть другие классы могут наследовать от него, чтобы создавать структурированные объекты данных. В настоящее время, чтобы определить атрибуты объектов, созданных из классов, наследующих от `Structure`, нам нужно установить переменную класса `_fields`.

Откроем файл в редакторе. Используем следующую команду, чтобы перейти в директорию проекта:

```bash
cd ~/project
```

После выполнения этой команды вы можете найти и просмотреть существующий класс `Structure` в файле `structure.py` в WebIDE.

## Создание класса `Stock`

Создадим класс `Stock`, который наследует от класса `Structure`. Наследование означает, что класс `Stock` получит все функции класса `Structure` и также может добавить свои собственные. Добавим следующий код в конец файла `structure.py`:

```python
class Stock(Structure):
    _fields = ('name', 'shares', 'price')

    def __init__(self, name, shares, price):
        self._init()
```

Однако у этого подхода есть проблема. Мы должны определить как кортеж `_fields`, так и метод `__init__` с теми же именами параметров. Это избыточно, так как по сути мы записываем ту же информацию дважды. Если мы забудем обновить одно, когда меняем другое, это может привести к ошибкам.

## Добавление методу класса `set_fields`

Чтобы исправить эту проблему, мы добавим метод класса `set_fields` в класс `Structure`. Этот метод автоматически определит имена полей из сигнатуры метода `__init__`. Вот код, который нужно добавить в класс `Structure`:

```python
@classmethod
def set_fields(cls):
    # Get the signature of the __init__ method
    import inspect
    sig = inspect.signature(cls.__init__)

    # Get parameter names, skipping 'self'
    params = list(sig.parameters.keys())[1:]

    # Set _fields attribute on the class
    cls._fields = tuple(params)
```

Этот метод использует модуль `inspect`, который является мощным инструментом в Python для получения информации о таких объектах, как функции и классы. Сначала он получает сигнатуру метода `__init__`. Затем он извлекает имена параметров, но пропускает параметр `self`, так как `self` является специальным параметром в классах Python, который ссылается на сам экземпляр. Наконец, он устанавливает переменную класса `_fields` с этими именами параметров.

## Модификация класса `Stock`

Теперь, когда у нас есть метод `set_fields`, мы можем упростить наш класс `Stock`. Замените предыдущий код класса `Stock` следующим:

```python
class Stock(Structure):
    def __init__(self, name, shares, price):
        self._init()

# Call set_fields to automatically set _fields from __init__
Stock.set_fields()
```

Таким образом, нам не нужно вручную определять кортеж `_fields`. Метод `set_fields` сделает это за нас.

## Тестирование модифицированного класса

Чтобы убедиться, что наш модифицированный класс работает правильно, создадим простой тестовый скрипт. Создайте новый файл с именем `test_structure.py` и добавьте следующий код:

```python
from structure import Stock

def test_stock():
    # Create a Stock object
    s = Stock(name='GOOG', shares=100, price=490.1)

    # Test string representation
    print(f"Stock representation: {s}")

    # Test attribute access
    print(f"Name: {s.name}")
    print(f"Shares: {s.shares}")
    print(f"Price: {s.price}")

    # Test attribute modification
    s.shares = 50
    print(f"Updated shares: {s.shares}")

    # Test attribute error
    try:
        s.share = 50  # Misspelled attribute
        print("Error: Did not raise AttributeError")
    except AttributeError as e:
        print(f"Correctly raised: {e}")

if __name__ == "__main__":
    test_stock()
```

Этот тестовый скрипт создает объект `Stock`, тестирует его строковое представление, обращается к его атрибутам, изменяет атрибут и пытается обратиться к атрибуту с опечаткой, чтобы проверить, вызывает ли он правильную ошибку.

Чтобы запустить тестовый скрипт, используйте следующую команду:

```bash
python3 test_structure.py
```

Вы должны увидеть вывод, похожий на следующий:

```
Stock representation: Stock('GOOG',100,490.1)
Name: GOOG
Shares: 100
Price: 490.1
Updated shares: 50
Correctly raised: No attribute share
```

## Как это работает

1. Метод `set_fields` использует `inspect.signature()`, чтобы получить имена параметров из метода `__init__`. Эта функция дает нам подробную информацию о параметрах метода `__init__`.
2. Затем он автоматически устанавливает переменную класса `_fields` на основе этих имен параметров. Таким образом, нам не нужно записывать одни и те же имена параметров в двух разных местах.
3. Это устраняет необходимость вручную определять как `_fields`, так и `__init__` с совпадающими именами параметров. Это делает наш код более поддерживаемым, так как если мы изменим параметры в методе `__init__`, `_fields` будут автоматически обновлены.

Этот подход использует инспекцию функций, чтобы сделать наш код более поддерживаемым и менее подверженным ошибкам. Это практическое применение возможностей интроспекции Python, которые позволяют нам исследовать и модифицировать объекты во время выполнения.
