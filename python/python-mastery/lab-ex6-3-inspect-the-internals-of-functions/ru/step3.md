# Собираем все вместе

В упражнении 6.1 вы создали класс `Structure`, в котором были определены обобщенные методы `__init__()`, `__setattr__()` и `__repr__()`. Этот класс требовал от пользователя определить переменную класса `_fields` следующим образом:

```python
class Stock(Structure):
    _fields = ('name','shares','price')
```

Проблема с этим классом заключается в том, что функция `__init__()` не имела полезной сигнатуры аргументов для целей помощи и передачи аргументов по ключу. В упражнении 6.2 вы применили хитрый трюк, который включал специальную функцию `self._init()`. Например:

```python
class Stock(Structure):
    _fields = ('name','shares', 'price')
    def __init__(self, name, shares, price):
        self._init()
  ...
```

Это дало полезную сигнатуру, но теперь класс выглядит странно, потому что пользователю приходится задавать как переменную `_fields`, так и метод `__init__()`.

Ваша задача - убрать переменную `_fields` с использованием некоторых методов инспекции функций. Во - первых, обратите внимание, что вы можете получить сигнатуру аргументов из `Stock` следующим образом:

```python
>>> import inspect
>>> sig = inspect.signature(Stock)
>>> tuple(sig.parameters)
('name','shares', 'price')
>>>
```

Возможно, вы можете установить переменную `_fields` из сигнатуры аргументов `__init__()`. Добавьте метод класса `set_fields(cls)` в `Structure`, который будет инспектировать функцию `__init__()` и устанавливать переменную `_fields` соответствующим образом. Вы должны использовать свою новую функцию следующим образом:

```python
class Stock(Structure):
    def __init__(self, name, shares, price):
        self._init()

  ...

Stock.set_fields()
```

Результирующий класс должен работать так же, как и раньше:

```python
>>> s = Stock(name='GOOG', shares=100, price=490.1)
>>> s
Stock('GOOG',100,490.1)
>>> s.shares = 50
>>> s.share = 50
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "structure.py", line 12, in __setattr__
    raise AttributeError('No attribute %s' % name)
AttributeError: No attribute share
>>>
```

Проверьте снова немного измененный класс `Stock` с помощью своих юнит-тестов. Возможно, все еще будут ошибки, но ничего не должно измениться по сравнению с предыдущим упражнением.

На этом этапе все еще выглядит несколько "хакерским", но вы делаете прогресс. У вас есть класс структуры `Stock` с полезной функцией `__init__()`, есть полезная строка представления, и метод `__setattr__()` ограничивает набор имен атрибутов. Дополнительный шаг, заключающийся в вызове `set_fields()`, выглядит несколько странно, но мы вернемся к этому вопросу.
