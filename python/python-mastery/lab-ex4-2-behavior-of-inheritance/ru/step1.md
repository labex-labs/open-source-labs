# Понимание одиночного и множественного наследования

В этом шаге мы узнаем о двух основных типах наследования в Python: одиночном наследовании и множественном наследовании. Наследование является фундаментальным концептом в объектно - ориентированном программировании, который позволяет классу наследовать атрибуты и методы от других классов. Мы также рассмотрим, как Python определяет, какой метод вызывать, когда есть несколько кандидатов, процесс, известный как разрешение методов (method resolution).

## Одиночное наследование

Одиночное наследование возникает, когда классы образуют единую линию предков. Представьте себе это как генеалогическое дерево, где каждый класс имеет только одного непосредственного родителя. Создадим пример, чтобы понять, как это работает.

Сначала откройте новый терминал в WebIDE. После открытия терминала запустите интерпретатор Python, введя следующую команду и нажав Enter:

```bash
python3
```

Теперь, когда вы находитесь в интерпретаторе Python, мы создадим три класса, которые образуют цепочку одиночного наследования. Введите следующий код:

```python
class A:
    def spam(self):
        print('A.spam')

class B(A):
    def spam(self):
        print('B.spam')
        super().spam()

class C(B):
    def spam(self):
        print('C.spam')
        super().spam()
```

В этом коде класс `B` наследует от класса `A`, а класс `C` наследует от класса `B`. Функция `super()` используется для вызова метода родительского класса.

После определения этих классов мы можем узнать порядок, в котором Python ищет методы. Этот порядок называется Порядком разрешения методов (Method Resolution Order, MRO). Чтобы увидеть MRO класса `C`, введите следующий код:

```python
C.__mro__
```

Вы должны увидеть вывод, похожий на следующий:

```
(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
```

Этот вывод показывает, что Python сначала ищет метод в классе `C`, затем в классе `B`, затем в классе `A` и, наконец, в базовом классе `object`.

Теперь создадим экземпляр класса `C` и вызовем его метод `spam()`. Введите следующий код:

```python
c = C()
c.spam()
```

Вы должны увидеть следующий вывод:

```
C.spam
B.spam
A.spam
```

Этот вывод демонстрирует, как работает `super()` в цепочке одиночного наследования. Когда `C.spam()` вызывает `super().spam()`, он вызывает `B.spam()`. Затем, когда `B.spam()` вызывает `super().spam()`, он вызывает `A.spam()`.

## Множественное наследование

Множественное наследование позволяет классу наследовать от более чем одного родительского класса. Это дает классу доступ к атрибутам и методам всех его родительских классов. Давайте посмотрим, как работает разрешение методов в этом случае.

Введите следующий код в интерпретаторе Python:

```python
class Base:
    def spam(self):
        print('Base.spam')

class X(Base):
    def spam(self):
        print('X.spam')
        super().spam()

class Y(Base):
    def spam(self):
        print('Y.spam')
        super().spam()

class Z(Base):
    def spam(self):
        print('Z.spam')
        super().spam()
```

Теперь мы создадим класс `M`, который наследует от нескольких родительских классов `X`, `Y` и `Z`. Введите следующий код:

```python
class M(X, Y, Z):
    pass

M.__mro__
```

Вы должны увидеть следующий вывод:

```
(<class '__main__.M'>, <class '__main__.X'>, <class '__main__.Y'>, <class '__main__.Z'>, <class '__main__.Base'>, <class 'object'>)
```

Этот вывод показывает Порядок разрешения методов для класса `M`. Python будет искать методы в этом порядке.

Создадим экземпляр класса `M` и вызовем его метод `spam()`:

```python
m = M()
m.spam()
```

Вы должны увидеть следующий вывод:

```
X.spam
Y.spam
Z.spam
Base.spam
```

Обратите внимание, что `super()` не просто вызывает метод непосредственного родительского класса. Вместо этого он следует Порядку разрешения методов (MRO), определенному дочерним классом.

Создадим еще один класс `N` с родительскими классами в другом порядке:

```python
class N(Z, Y, X):
    pass

N.__mro__
```

Вы должны увидеть следующий вывод:

```
(<class '__main__.N'>, <class '__main__.Z'>, <class '__main__.Y'>, <class '__main__.X'>, <class '__main__.Base'>, <class 'object'>)
```

Теперь создадим экземпляр класса `N` и вызовем его метод `spam()`:

```python
n = N()
n.spam()
```

Вы должны увидеть следующий вывод:

```
Z.spam
Y.spam
X.spam
Base.spam
```

Это демонстрирует важный концепт: в множественном наследовании Python порядок родительских классов в определении класса определяет Порядок разрешения методов. Функция `super()` следует этому порядку, независимо из какого класса она вызывается.

Когда вы закончите изучать эти концепции, вы можете выйти из интерпретатора Python, введя следующий код:

```python
exit()
```
