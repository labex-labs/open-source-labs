# Направления наследования

В Python есть два разных "направления" наследования. Первое можно найти в концепции "одноранговое наследование", где ряд классов наследуется от одного родителя. Например, попробуйте этот пример:

```python
>>> class A:
        def spam(self):
            print('A.spam')

>>> class B(A):
        def spam(self):
            print('B.spam')
            super().spam()

>>> class C(B):
        def spam(self):
            print('C.spam')
            super().spam()


>>> C.__mro__
(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
>>> c = C()
>>> c.spam()
C.spam
B.spam
A.spam
>>>
```

Заметьте, что атрибут `__mro__` класса `C` кодирует всех его предков в порядке. Когда вы вызываете метод `spam()`, он последовательно проходит по MRO от класса к классу в иерархии.

При множественном наследовании вы получаете другой вид наследования, который позволяет комбинировать разные классы вместе. Попробуйте этот пример:

```python
>>> class Base:
        def spam(self):
            print('Base.spam')

>>> class X(Base):
        def spam(self):
            print('X.spam')
            super().spam()

>>> class Y(Base):
        def spam(self):
            print('Y.spam')
            super().spam()

>>> class Z(Base):
        def spam(self):
            print('Z.spam')
            super().spam()

>>>
```

Заметьте, что все классы выше наследуются от общего родителя `Base`. Однако классы `X`, `Y` и `Z` не напрямую связаны друг с другом (нет цепочки наследования, связывающей эти классы вместе).

Однако, посмотрите, что происходит при множественном наследовании:

```python
>>> class M(X,Y,Z):
        pass

>>> M.__mro__
(<class '__main__.M'>, <class '__main__.X'>, <class '__main__.Y'>, <class '__main__.Z'>, <class '__main__.Base'>, <class 'object'>)
>>> m = M()
>>> m.spam()
X.spam
Y.spam
Z.spam
Base.spam
>>>
```

Здесь вы видите, что все классы накапливаются вместе в порядке, заданном подклассом. Предположим, что подкласс изменит порядок классов:

```python
>>> class N(Z,Y,X):
        pass

>>> N.__mro__
(<class '__main__.N'>, <class '__main__.Z'>, <class '__main__.Y'>, <class '__main__.X'>, <class '__main__.Base'>, <class 'object'>)
>>> n = N()
>>> n.spam()
Z.spam
Y.spam
X.spam
Base.spam
>>>
```

Здесь вы видите, что порядок родителей меняется. Обратите особое внимание на то, что `super()` делает в обоих случаях. Он не делегирует вызов к непосредственному родителю каждого класса - вместо этого он переходит к следующему классу в MRO. Не только это, но и точный порядок контролируется дочерним классом. Это довольно странно.

Также обратите внимание, что общий родитель `Base` служит для завершения цепи операций `super()`. Конкретно, метод `Base.spam()` не вызывает никаких дополнительных методов. Он также появляется в конце MRO, так как он является родителем для всех классов, комбинируемых вместе.
