# Применение валидаторов к классу Stock

В этом шаге мы увидим, как наши валидаторы работают в реальной ситуации. Валидаторы - это как маленькие контролеры, которые обеспечивают соответствие используемых данных определенным правилам. Мы создадим класс `Stock`. Класс - это как чертеж для создания объектов. В данном случае класс `Stock` будет представлять акцию на фондовом рынке, и мы будем использовать наши валидаторы, чтобы убедиться, что значения его атрибутов (например, количество акций и цена) являются допустимыми.

## Создание класса Stock

Сначала нам нужно создать новый файл. В WebIDE создайте новый файл с именем `stock.py`. Этот файл будет содержать код для нашего класса `Stock`. Теперь добавьте следующий код в файл `stock.py`:

```python
# stock.py
from validate import PositiveInteger, PositiveFloat

class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @property
    def shares(self):
        return self._shares

    @shares.setter
    def shares(self, value):
        self._shares = PositiveInteger.check(value)

    @property
    def price(self):
        return self._price

    @price.setter
    def price(self, value):
        self._price = PositiveFloat.check(value)

    def cost(self):
        return self.shares * self.price
```

Разберем, что делает этот код:

1. Мы начинаем с импорта валидаторов `PositiveInteger` и `PositiveFloat` из модуля `validate`. Эти валидаторы помогут нам убедиться, что количество акций является положительным целым числом, а цена - положительным числом с плавающей точкой.
2. Затем мы определяем класс `Stock`. Внутри класса у нас есть метод `__init__`. Этот метод вызывается, когда мы создаем новый объект `Stock`. Он принимает три параметра: `name`, `shares` и `price` и присваивает их атрибутам объекта.
3. Мы используем свойства (properties) и сеттеры (setters) для валидации значений `shares` и `price`. Свойство - это способ контролировать доступ к атрибуту, а сеттер - это метод, который вызывается, когда мы пытаемся установить значение этого атрибута. Когда мы устанавливаем атрибут `shares`, вызывается метод `PositiveInteger.check`, чтобы убедиться, что значение является положительным целым числом. Аналогично, когда мы устанавливаем атрибут `price`, вызывается метод `PositiveFloat.check`, чтобы убедиться, что значение является положительным числом с плавающей точкой.
4. Наконец, у нас есть метод `cost`. Этот метод вычисляет общую стоимость акций, умножая количество акций на цену.

## Тестирование класса Stock

Теперь, когда мы создали наш класс `Stock`, нам нужно протестировать его, чтобы убедиться, что валидаторы работают правильно. Откройте новый терминал и запустите интерпретатор Python. Вы можете сделать это, выполнив следующую команду:

```bash
python3
```

После запуска интерпретатора Python мы можем импортировать и протестировать наш класс `Stock`. Введите следующий код в интерпретатор Python:

```python
from stock import Stock

# Create a valid stock
s = Stock('GOOG', 100, 490.10)
print(f"Name: {s.name}, Shares: {s.shares}, Price: {s.price}")
print(f"Cost: {s.cost()}")

# Try setting an invalid shares value
try:
    s.shares = -10
except ValueError as e:
    print(f"Error setting shares: {e}")

# Try setting an invalid price value
try:
    s.price = "not a price"
except TypeError as e:
    print(f"Error setting price: {e}")
```

При выполнении этого кода вы должны увидеть вывод, похожий на следующий:

```
Name: GOOG, Shares: 100, Price: 490.1
Cost: 49010.0
Error setting shares: Expected >= 0
Error setting price: Expected <class 'float'>
```

Этот вывод показывает, что наши валидаторы работают как ожидалось. Класс `Stock` не позволяет нам устанавливать недопустимые значения для `shares` и `price`. Когда мы пытаемся установить недопустимое значение, возникает ошибка, и мы можем поймать и вывести эту ошибку.

## Понимание, как наследование помогает

Одним из преимуществ использования наших валидаторов является то, что мы можем легко комбинировать разные правила валидации. Наследование - это мощная концепция в Python, которая позволяет нам создавать новые классы на основе существующих. С помощью множественного наследования мы можем использовать функцию `super()` для вызова методов из нескольких родительских классов.

Например, если мы хотим убедиться, что название акции не является пустой строкой, мы можем выполнить следующие шаги:

1. Импортировать валидатор `NonEmptyString` из модуля `validate`. Этот валидатор поможет нам проверить, что название акции не является пустой строкой.
2. Добавить сеттер свойства для атрибута `name` в классе `Stock`. Этот сеттер будет использовать метод `NonEmptyString.check()` для валидации названия акции.

Это показывает, как наследование, особенно множественное наследование с использованием функции `super()`, позволяет нам создавать гибкие компоненты, которые можно переиспользовать в разных комбинациях.

После завершения тестирования вы можете выйти из интерпретатора Python, выполнив следующую команду:

```python
exit()
```
