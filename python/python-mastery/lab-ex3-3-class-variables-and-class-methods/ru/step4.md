# Создание универсального читателя CSV

В этом последнем шаге мы создадим универсальную функцию. Эта функция сможет читать CSV-файлы и создавать объекты любого класса, который реализует метод класса `from_row()`. Это демонстрирует силу использования методов класса в качестве унифицированного интерфейса. Унифицированный интерфейс означает, что разные классы могут использоваться одинаково, что делает наш код более гибким и легким в управлении.

## Изменение функции read_portfolio()

Сначала мы обновим функцию `read_portfolio()` в файле `stock.py`. Мы будем использовать наш новый метод класса `from_row()`. Откройте файл `stock.py` и измените функцию `read_portfolio()` следующим образом:

```python
def read_portfolio(filename):
    '''
    Прочитать файл с портфелем акций в список экземпляров Stock
    '''
    import csv
    portfolio = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)  # Пропустить заголовок
        for row in rows:
            portfolio.append(Stock.from_row(row))
    return portfolio
```

Эта новая версия функции проще. Она передает ответственность за преобразование типов классу `Stock`, где это действительно должно быть. Преобразование типов означает изменение данных из одного типа в другой, например, преобразование строки в целое число. Таким образом, мы делаем наш код более организованным и легким для понимания.

## Создание универсального читателя CSV

Теперь мы создадим более универсальную функцию в файле `reader.py`. Эта функция может читать данные CSV и создавать экземпляры любого класса, который имеет метод класса `from_row()`.

Откройте файл `reader.py` и добавьте следующую функцию:

```python
def read_csv_as_instances(filename, cls):
    '''
    Прочитать CSV-файл в список экземпляров заданного класса.

    Аргументы:
        filename: Имя CSV-файла
        cls: Класс для создания экземпляров (должен иметь метод класса from_row)

    Возвращает:
        Список экземпляров класса
    '''
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)  # Пропустить заголовок
        for row in rows:
            records.append(cls.from_row(row))
    return records
```

Эта функция принимает два входных параметра: имя файла и класс. Затем она возвращает список экземпляров этого класса, созданных из данных в CSV-файле. Это очень полезно, так как мы можем использовать ее с разными классами, если они имеют метод `from_row()`.

## Тестирование универсального читателя CSV

Давайте создадим тестовый файл, чтобы посмотреть, как работает наш универсальный читатель. Создайте файл с именем `test_csv_reader.py` со следующим содержимым:

```python
# test_csv_reader.py
from reader import read_csv_as_instances
from stock import Stock
from decimal_stock import DStock

# Прочитать портфель как экземпляры Stock
portfolio = read_csv_as_instances('portfolio.csv', Stock)
print(f"Портфель содержит {len(portfolio)} акций")
print(f"Первая акция: {portfolio[0].name}, {portfolio[0].shares} акций по цене ${portfolio[0].price}")

# Прочитать портфель как экземпляры DStock (с ценами Decimal)
decimal_portfolio = read_csv_as_instances('portfolio.csv', DStock)
print(f"\nДесятичный портфель содержит {len(decimal_portfolio)} акций")
print(f"Первая акция: {decimal_portfolio[0].name}, {decimal_portfolio[0].shares} акций по цене ${decimal_portfolio[0].price}")

# Определить новый класс для чтения данных о маршрутах автобусов
class BusRide:
    def __init__(self, route, date, daytype, rides):
        self.route = route
        self.date = date
        self.daytype = daytype
        self.rides = rides

    @classmethod
    def from_row(cls, row):
        return cls(row[0], row[1], row[2], int(row[3]))

# Прочитать некоторые данные о маршрутах автобусов (только первые 5 записей для краткости)
print("\nЧтение данных о маршрутах автобусов...")
import csv
with open('ctabus.csv') as f:
    rows = csv.reader(f)
    headers = next(rows)  # Пропустить заголовок
    bus_rides = []
    for i, row in enumerate(rows):
        if i >= 5:  # Читать только 5 записей для примера
            break
        bus_rides.append(BusRide.from_row(row))

# Вывести данные о маршрутах автобусов
for ride in bus_rides:
    print(f"Маршрут: {ride.route}, Дата: {ride.date}, Тип дня: {ride.daytype}, Количество поездок: {ride.rides}")
```

Запустите этот файл, чтобы увидеть результаты. Откройте терминал и используйте следующие команды:

```bash
cd ~/project
python test_csv_reader.py
```

Вы должны увидеть вывод, показывающий данные о портфеле, загруженные как экземпляры `Stock` и `DStock`, а также данные о маршрутах автобусов, загруженные как экземпляры `BusRide`. Это доказывает, что наш универсальный читатель работает с разными классами.

## Основные преимущества этого подхода

Этот подход демонстрирует несколько мощных концепций:

1. **Разделение ответственностей**: Чтение данных отделено от создания объектов. Это означает, что код для чтения CSV-файла не перемешан с кодом для создания объектов. Это делает код легче для понимания и поддержки.
2. **Полиморфизм**: Один и тот же код может работать с разными классами, которые следуют одному и тому же интерфейсу. В нашем случае, если класс имеет метод `from_row()`, наш универсальный читатель может его использовать.
3. **Гибкость**: Мы можем легко изменить способ преобразования данных, используя разные классы. Например, мы можем использовать `Stock` или `DStock` для разной обработки данных о портфеле.
4. **Расширяемость**: Мы можем добавлять новые классы, которые работают с нашим читателем, не изменяя код читателя. Это делает наш код более устойчивым к изменениям в будущем.

Это распространенный шаблон в Python, который делает код более модульным, повторно используемым и поддерживаемым.

## Финальные замечания о методах класса

Методы класса часто используются в Python в качестве альтернативных конструкторов. Обычно их можно отличить, так как их имена часто содержат слово "from". Например:

```python
# Некоторые примеры из встроенных типов Python
dict.fromkeys(['a', 'b', 'c'], 0)  # Создать словарь с начальными значениями
datetime.datetime.fromtimestamp(1627776000)  # Создать объект datetime из временной метки
int.from_bytes(b'\x00\x01', byteorder='big')  # Создать целое число из байтов
```

Следуя этой конвенции, вы делаете свой код более читаемым и совместимым с встроенными библиотеками Python. Это помогает другим разработчикам легче понять ваш код.
