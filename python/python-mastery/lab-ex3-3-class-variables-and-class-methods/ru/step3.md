# Переменные класса и наследование

В этом шаге мы рассмотрим, как переменные класса взаимодействуют с наследованием и как они могут служить механизмом для настройки. В Python наследование позволяет подклассу наследовать атрибуты и методы от базового класса. Переменные класса - это переменные, которые принадлежат самому классу, а не какому-либо конкретному экземпляру класса. Понимание того, как они работают вместе, является важным для создания гибкого и поддерживаемого кода.

## Переменные класса в наследовании

Когда подкласс наследует от базового класса, он автоматически получает доступ к переменным класса базового класса. Однако подкласс может переопределить эти переменные класса. Таким образом, подкласс может изменить свое поведение, не влияя на базовый класс. Это очень мощная возможность, так как позволяет настроить поведение подкласса в соответствии с вашими конкретными потребностями.

## Создание специализированного класса Stock

Давайте создадим подкласс класса `Stock`. Мы назовем его `DStock`, что означает Decimal Stock (акции с использованием десятичных чисел). Основное отличие между `DStock` и обычным классом `Stock` заключается в том, что `DStock` будет использовать тип `Decimal` для значений цены вместо `float`. В финансовых расчетах точность имеет огромное значение, и тип `Decimal` обеспечивает более точную арифметику с десятичными числами по сравнению с `float`.

Для создания этого подкласса мы создадим новый файл с именем `decimal_stock.py`. Вот код, который нужно поместить в этот файл:

```python
# decimal_stock.py
from decimal import Decimal
from stock import Stock

class DStock(Stock):
    """
    Специализированная версия Stock, которая использует Decimal для цен
    """
    types = (str, int, Decimal)  # Переопределить переменную класса types

# Протестировать подкласс
if __name__ == "__main__":
    # Создать DStock из данных строки
    row = ['AA', '100', '32.20']
    ds = DStock.from_row(row)

    print(f"DStock: {ds.name}")
    print(f"Shares: {ds.shares}")
    print(f"Price: {ds.price} (type: {type(ds.price).__name__})")
    print(f"Cost: {ds.cost()} (type: {type(ds.cost()).__name__})")

    # В сравнении, создать обычный Stock из тех же данных
    s = Stock.from_row(row)
    print(f"\nRegular Stock: {s.name}")
    print(f"Shares: {s.shares}")
    print(f"Price: {s.price} (type: {type(s.price).__name__})")
    print(f"Cost: {s.cost()} (type: {type(s.cost()).__name__})")
```

После того, как вы создадите файл `decimal_stock.py` с приведенным выше кодом, вам нужно запустить его, чтобы увидеть результаты. Откройте терминал и следуйте этим шагам:

```bash
cd ~/project
python decimal_stock.py
```

Вы должны увидеть вывод, похожий на следующий:

```
DStock: AA
Shares: 100
Price: 32.20 (type: Decimal)
Cost: 3220.0 (type: Decimal)

Regular Stock: AA
Shares: 100
Price: 32.2 (type: float)
Cost: 3220.0 (type: float)
```

## Основные моменты о переменных класса и наследовании

Из этого примера мы можем сделать несколько важных выводов:

1. Класс `DStock` наследует все методы от класса `Stock`, например метод `cost()`, не требуя их переопределения. Это одно из основных преимуществ наследования, так как оно позволяет избежать написания избыточного кода.
2. Просто переопределив переменную класса `types`, мы изменили способ преобразования данных при создании новых экземпляров `DStock`. Это показывает, как переменные класса могут быть использованы для настройки поведения подкласса.
3. Базовый класс `Stock` остается неизменным и по-прежнему работает с значениями типа `float`. Это означает, что изменения, которые мы внесли в подкласс, не влияют на базовый класс, что является хорошим принципом дизайна.
4. Метод класса `from_row()` корректно работает как с классом `Stock`, так и с классом `DStock`. Это демонстрирует мощь наследования, так как один и тот же метод может быть использован с разными подклассами.

Этот пример ясно показывает, как переменные класса могут быть использованы как механизм настройки. Подклассы могут переопределить эти переменные, чтобы настроить свое поведение, не переписывая методы.

## Обсуждение дизайна

Рассмотрим альтернативный подход, при котором мы помещаем преобразования типов в метод `__init__`:

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = str(name)
        self.shares = int(shares)
        self.price = float(price)
```

С этим подходом мы можем создать объект `Stock` из строки данных следующим образом:

```python
row = ['AA', '100', '32.20']
s = Stock(*row)
```

Хотя этот подход может показаться проще на первый взгляд, он имеет несколько недостатков:

1. Он объединяет две разные задачи: инициализацию объекта и преобразование данных. Это делает код более сложным для понимания и поддержки.
2. Метод `__init__` становится менее гибким, так как он всегда преобразует входные данные, даже если они уже имеют правильный тип.
3. Он ограничивает способ, которым подклассы могут настроить процесс преобразования. Подклассам будет сложнее изменить логику преобразования, если она встроена в метод `__init__`.
4. Код становится более хрупким. Если какое-либо из преобразований завершается неудачей, объект не может быть создан, что может привести к ошибкам в вашей программе.

С другой стороны, подход с использованием методов класса разделяет эти задачи. Это делает код более поддерживаемым и гибким, так как каждая часть кода имеет единственную ответственность.
