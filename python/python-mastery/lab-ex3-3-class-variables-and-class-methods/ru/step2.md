# Реализация альтернативных конструкторов с использованием методов класса

В этом шаге мы научимся реализовывать альтернативный конструктор с использованием метода класса. Это позволит нам создавать объекты `Stock` из данных строки CSV более элегантным способом.

## Что такое альтернативный конструктор?

В Python альтернативный конструктор представляет собой полезный шаблон. Обычно мы создаем объекты с использованием стандартного метода `__init__`. Однако альтернативный конструктор дает нам дополнительный способ создания объектов. Методы класса очень подходят для реализации альтернативных конструкторов, так как они могут обращаться к самому классу.

## Реализация метода класса from_row()

Мы добавим переменную класса `types` и метод класса `from_row()` в наш класс `Stock`. Это упростит процесс создания экземпляров `Stock` из данных CSV.

Давайте модифицируем файл `stock.py`, добавив выделенный код:

```python
# stock.py

class Stock:
    types = (str, int, float)  # Преобразования типов для применения к данным CSV

    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    @classmethod
    def from_row(cls, row):
        """
        Создать экземпляр Stock из строки данных CSV.

        Аргументы:
            row: Список строк [name, shares, price]

        Возвращает:
            Новый экземпляр Stock
        """
        values = [func(val) for func, val in zip(cls.types, row)]
        return cls(*values)

# Остальная часть файла остается без изменений
```

Теперь давайте пошагово разберем, что происходит в этом коде:

1. Мы определили переменную класса `types`. Это кортеж, который содержит функции преобразования типов `(str, int, float)`. Эти функции будут использоваться для преобразования данных из строки CSV в соответствующие типы.
2. Мы добавили метод класса `from_row()`. Декоратор `@classmethod` помечает этот метод как метод класса.
3. Первым параметром этого метода является `cls`, который является ссылкой на сам класс. В обычных методах мы используем `self` для обращения к экземпляру класса, но здесь мы используем `cls`, так как это метод класса.
4. Функция `zip()` используется для сопоставления каждой функции преобразования типов в `types` с соответствующим значением в списке `row`.
5. Мы используем генератор списка для применения каждой функции преобразования к соответствующему значению в списке `row`. Таким образом, мы преобразуем строковые данные из строки CSV в соответствующие типы.
6. Наконец, мы создаем новый экземпляр класса `Stock` с использованием преобразованных значений и возвращаем его.

## Тестирование альтернативного конструктора

Теперь мы создадим новый файл с именем `test_class_method.py` для тестирования нашего нового метода класса. Это поможет нам убедиться, что альтернативный конструктор работает как ожидается.

```python
# test_class_method.py
from stock import Stock

# Протестировать метод класса from_row()
row = ['AA', '100', '32.20']
s = Stock.from_row(row)

print(f"Stock: {s.name}")
print(f"Shares: {s.shares}")
print(f"Price: {s.price}")
print(f"Cost: {s.cost()}")

# Попробовать с другой строкой
row2 = ['GOOG', '50', '1120.50']
s2 = Stock.from_row(row2)

print(f"\nStock: {s2.name}")
print(f"Shares: {s2.shares}")
print(f"Price: {s2.price}")
print(f"Cost: {s2.cost()}")
```

Чтобы увидеть результаты, выполните следующие команды в терминале:

```bash
cd ~/project
python test_class_method.py
```

Вы должны увидеть вывод, похожий на следующий:

```
Stock: AA
Shares: 100
Price: 32.2
Cost: 3220.0

Stock: GOOG
Shares: 50
Price: 1120.5
Cost: 56025.0
```

Обратите внимание, что теперь мы можем создавать экземпляры `Stock` непосредственно из строковых данных без необходимости вручную выполнять преобразования типов вне класса. Это делает наш код более чистым и обеспечивает, что ответственность за преобразование данных обрабатывается внутри самого класса.
