# Смена ориентации (на столбцы)

Часто можно сэкономить значительную память, изменив представление данных. Например, что произойдет, если прочитать все автобусные данные в столбцы с помощью этой функции?

```python
# readrides.py

...

def read_rides_as_columns(filename):
    '''
    Read the bus ride data into 4 lists, representing columns
    '''
    routes = []
    dates = []
    daytypes = []
    numrides = []
    with open(filename) as f:
        rows = csv.reader(f)
        headings = next(rows)     # Skip headers
        for row in rows:
            routes.append(row[0])
            dates.append(row[1])
            daytypes.append(row[2])
            numrides.append(int(row[3]))
    return dict(routes=routes, dates=dates, daytypes=daytypes, numrides=numrides)
```

В теории эта функция должна сэкономить много памяти. Давайте проанализируем ее перед использованием.

Во - первых, в файле данных было 577563 строки, в каждой из которых содержалось четыре значения. Если каждая строка хранится в виде словаря, то эти словари имеют размер не менее 240 байт.

```python
>>> nrows = 577563     # Number of rows in original file
>>> nrows * 240
138615120
>>>
```

Таким образом, только для словарей это 138 МБ. Это не включает никаких значений, фактически хранящихся в словарях.

Переключившись на столбцы, данные хранятся в 4 отдельных списках. Каждый список требует 8 байт на каждый элемент для хранения указателя. Вот приблизительная оценка потребностей в списках:

```python
>>> nrows * 4 * 8
18482016
>>>
```

Это около 18 МБ на накладные расходы на списки. Таким образом, переход к ориентации по столбцам должен сэкономить около 120 МБ памяти только за счет устранения всей дополнительной информации, которая должна храниться в словарях.

Попробуйте использовать эту функцию для чтения автобусных данных и посмотреть на использование памяти.

```python
>>> import tracemalloc
>>> tracemalloc.start()
>>> columns = read_rides_as_columns('ctabus.csv')
>>> tracemalloc.get_traced_memory()
... look at the result...
>>>
```

Отражает ли результат ожидаемые экономии памяти по нашим грубым расчетам выше?
