# Понимание распределения памяти для списков

В Python списки являются очень полезной структурой данных, особенно когда вам нужно добавлять элементы в них. Списки Python разработаны так, чтобы операции добавления элементов были эффективными. Вместо того чтобы выделять ровно столько памяти, сколько нужно, Python выделяет дополнительную память заранее, ожидая будущих добавлений. Эта стратегия минимизирует количество перераспределений памяти, необходимых при расширении списка.

Попробуем лучше понять этот концепт, используя функцию `sys.getsizeof()`. Эта функция возвращает размер объекта в байтах, что позволяет нам увидеть, сколько памяти использует список на разных этапах.

1. Сначала вам нужно открыть интерактивную оболочку Python в терминале. Это как игровая площадка, где вы можете сразу запускать код Python. Чтобы открыть ее, введите следующую команду в терминале и нажмите Enter:

```bash
python3
```

2. Как только вы находитесь в интерактивной оболочке Python, вам нужно импортировать модуль `sys`. Модули в Python похожи на ящики с инструментами, которые содержат полезные функции. В модуле `sys` есть функция `getsizeof()`, которая нам нужна. После импорта модуля создайте пустой список с именем `items`. Вот код для этого:

```python
import sys
items = []
```

3. Теперь проверим начальный размер пустого списка. Мы будем использовать функцию `sys.getsizeof()` с списком `items` в качестве аргумента. Введите следующий код в интерактивной оболочке Python и нажмите Enter:

```python
sys.getsizeof(items)
```

Вы должны увидеть значение, например, `64` байта. Это значение представляет накладные расходы для пустого списка. Накладные расходы - это базовое количество памяти, которое Python использует для управления списком, даже когда в нем нет элементов.

4. Далее мы начнем добавлять элементы в список по одному и будем наблюдать, как меняется распределение памяти. Мы будем использовать метод `append()` для добавления элемента в список и затем снова проверим размер. Вот код:

```python
items.append(1)
sys.getsizeof(items)
```

Вы должны увидеть большее значение, примерно `96` байт. Это увеличение размера показывает, что Python выделил больше памяти, чтобы вместить новый элемент.

5. Продолжим добавлять больше элементов в список и проверять размер после каждого добавления. Вот код для этого:

```python
items.append(2)
sys.getsizeof(items)  # Размер остается прежним

items.append(3)
sys.getsizeof(items)  # Размер по-прежнему не меняется

items.append(4)
sys.getsizeof(items)  # Размер по-прежнему не меняется

items.append(5)
sys.getsizeof(items)  # Размер резко увеличивается
```

Вы заметите, что размер не увеличивается при каждой операции добавления элемента. Вместо этого он периодически увеличивается. Это показывает, что Python выделяет память блоками, а не отдельно для каждого нового элемента.

Это поведение предусмотрено дизайном. Python изначально выделяет больше памяти, чем нужно, чтобы избежать частых перераспределений при расширении списка. Каждый раз, когда список превышает свою текущую емкость, Python выделяет больший блок памяти.

Помните, что список хранит ссылки на объекты, а не сами объекты. На 64-битной системе каждая ссылка обычно требует 8 байт памяти. Это важно понимать, так как это влияет на то, сколько памяти на самом деле использует список, когда он содержит разные типы объектов.
