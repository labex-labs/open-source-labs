# Улучшение пользовательского контейнера для срезов

Наш пользовательский контейнер отлично подходит для доступа к отдельным записям. Однако возникает проблема при использовании срезов. Когда вы пытаетесь взять срез из нашего контейнера, результат не соответствует обычным ожиданиям.

Понятно, почему это происходит. В Python взятие среза - это распространенная операция, используемая для извлечения части последовательности. Но для нашего пользовательского контейнера Python не знает, как создать новый объект `RideData` только с данными среза. Вместо этого он создает список, содержащий результаты вызова `__getitem__` для каждого индекса в срезе.

1. Давайте протестируем взятие срезов в оболочке Python:

```python
import readrides

rows = readrides.read_rides_as_dicts('ctabus.csv')
r = rows[0:10]  # Take a slice of the first 10 records
type(r)  # This will likely be a list, not a RideData object
print(r)  # This might look like a list of numbers, not dictionaries
```

В этом коде мы сначала импортируем модуль `readrides`. Затем мы читаем данные из файла `ctabus.csv` в переменную `rows`. Когда мы пытаемся взять срез из первых 10 записей и проверить тип результата, мы обнаруживаем, что это список, а не объект `RideData`. Вывод результата может показать что - то неожиданное, например, список чисел вместо словарей.

2. Давайте модифицируем наш класс `RideData`, чтобы он корректно обрабатывал срезы. Откройте файл `readrides.py` и обновите метод `__getitem__`:

```python
def __getitem__(self, index):
    if isinstance(index, slice):
        # Handle slice
        result = RideData()
        result.routes = self.routes[index]
        result.dates = self.dates[index]
        result.daytypes = self.daytypes[index]
        result.numrides = self.numrides[index]
        return result
    else:
        # Handle single index
        return {'route': self.routes[index],
                'date': self.dates[index],
                'daytype': self.daytypes[index],
                'rides': self.numrides[index]}
```

В этом обновленном методе `__getitem__` мы сначала проверяем, является ли `index` срезом. Если это так, мы создаем новый объект `RideData` с именем `result`. Затем мы заполняем этот новый объект срезами исходных столбцов данных (`routes`, `dates`, `daytypes` и `numrides`). Это гарантирует, что при взятии среза из нашего пользовательского контейнера мы получаем другой объект `RideData`, а не список. Если `index` не является срезом (то есть это одиночный индекс), мы возвращаем словарь, содержащий соответствующую запись.

3. Давайте протестируем улучшенную возможность взятия срезов:

```python
import readrides

rows = readrides.read_rides_as_dicts('ctabus.csv')
r = rows[0:10]  # Take a slice of the first 10 records
type(r)  # Should now be readrides.RideData
len(r)   # Should be 10
r[0]     # Should be the same as rows[0]
r[1]     # Should be the same as rows[1]
```

После обновления метода `__getitem__` мы можем снова протестировать взятие срезов. Когда мы берем срез из первых 10 записей, тип результата теперь должен быть `readrides.RideData`. Длина среза должна быть равна 10, и доступ к отдельным элементам среза должен давать те же результаты, что и доступ к соответствующим элементам исходного контейнера.

4. Вы также можете протестировать разные шаблоны срезов:

```python
# Get every other record from the first 20
r2 = rows[0:20:2]
len(r2)  # Should be 10

# Get the last 10 records
r3 = rows[-10:]
len(r3)  # Should be 10
```

Здесь мы тестируем разные шаблоны срезов. Первый срез `rows[0:20:2]` извлекает каждую вторую запись из первых 20 записей, и длина полученного среза должна быть равна 10. Второй срез `rows[-10:]` извлекает последние 10 записей, и его длина также должна быть равна 10.

Правильно реализовав взятие срезов, наш пользовательский контейнер теперь еще больше похож на стандартный список Python, сохраняя при этом эффективность использования памяти столбцовой организации данных.

Подход создания пользовательских контейнерных классов, которые имитируют встроенные контейнеры Python, но имеют разную внутреннюю структуру, является мощной техникой для оптимизации использования памяти без изменения интерфейса, который ваш код предоставляет пользователям.
