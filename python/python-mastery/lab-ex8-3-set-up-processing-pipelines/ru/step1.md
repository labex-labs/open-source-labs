# Понимание корутин на примере программы для отслеживания файлов

Начнем с понимания того, что такое корутины (сопрограммы) и как они работают в Python. Корутина представляет собой специализированную версию генераторной функции. В Python функции обычно начинают выполнение с самого начала каждый раз, когда они вызываются. Однако корутины отличаются. Они могут как потреблять, так и создавать данные, а также имеют возможность приостанавливать и возобновлять свое выполнение. Это означает, что корутина может приостановить свою работу в определенной точке и затем продолжить с того места, где она остановилась.

## Создание базового файлового отслеживателя на основе корутин

На этом этапе мы создадим программу для отслеживания файлов, которая использует корутины для мониторинга файла на предмет появления нового содержимого и его обработки. Это аналогично команде Unix `tail -f`, которая непрерывно отображает конец файла и обновляет его при добавлении новых строк.

1. Откройте текстовый редактор кода и создайте новый файл с именем `cofollow.py` в директории `/home/labex/project`. Именно здесь мы напишем нашу Python - программу для реализации файлового отслеживателя с использованием корутин.

2. Скопируйте следующий код в файл:

```python
# cofollow.py
import os
import time

# Data source
def follow(filename, target):
    with open(filename, 'r') as f:
        f.seek(0, os.SEEK_END)  # Move to the end of the file
        while True:
            line = f.readline()
            if line != '':
                target.send(line)  # Send the line to the target coroutine
            else:
                time.sleep(0.1)  # Sleep briefly if no new content

# Decorator for coroutine functions
from functools import wraps

def consumer(func):
    @wraps(func)
    def start(*args, **kwargs):
        f = func(*args, **kwargs)
        f.send(None)  # Prime the coroutine (necessary first step)
        return f
    return start

# Sample coroutine
@consumer
def printer():
    while True:
        item = yield     # Receive an item sent to me
        print(item)

# Example use
if __name__ == '__main__':
    follow('stocklog.csv', printer())
```

3. Поймем ключевые компоненты этого кода:
   - `follow(filename, target)`: Эта функция отвечает за открытие файла. Сначала она перемещает указатель файла в конец файла с помощью `f.seek(0, os.SEEK_END)`. Затем она входит в бесконечный цикл, в котором непрерывно пытается прочитать новые строки из файла. Если найдена новая строка, она отправляет эту строку в целевую корутину с помощью метода `send`. Если нет нового содержимого, она приостанавливается на короткое время (0,1 секунды) с помощью `time.sleep(0.1)` перед следующей проверкой.
   - Декоратор `@consumer`: В Python корутины должны быть "инициализированы" перед тем, как они могут начать получать данные. Этот декоратор занимается этим. Он автоматически отправляет начальное значение `None` в корутину, что является необходимым первым шагом для подготовки корутины к приему реальных данных.
   - Корутина `printer()`: Это простая корутина. Она имеет бесконечный цикл, в котором использует ключевое слово `yield` для приема отправленного ей элемента. Как только она получает элемент, она просто выводит его на экран.

4. Сохраните файл и запустите его из терминала:

```bash
cd /home/labex/project
python3 cofollow.py
```

5. Вы должны увидеть, как скрипт выводит содержимое файла журнала котировок акций, и он будет продолжать выводить новые строки по мере их добавления в файл. Нажмите `Ctrl+C`, чтобы остановить программу.

Основная концепция здесь заключается в том, что данные передаются из функции `follow` в корутину `printer` с помощью метода `send`. Этот способ "проталкивания" данных противоположен генераторам, которые "тянут" данные с помощью итерации. В генераторе обычно используется цикл `for` для итерации по значениям, которые он генерирует. Однако в этом примере с корутинами данные активно отправляются из одной части кода в другую.
