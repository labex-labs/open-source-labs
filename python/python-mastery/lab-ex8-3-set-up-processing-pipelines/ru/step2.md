# Создание компонентов конвейера на основе корутин

На этом этапе мы создадим более специализированные корутины (сопрограммы) для обработки данных о котировках акций. Корутина представляет собой особый тип функции, которая может приостанавливать и возобновлять свое выполнение, что очень полезно для создания конвейеров обработки данных. Каждая корутина, которую мы создадим, будет выполнять определенную задачу в общем конвейере обработки.

1. Сначала вам нужно создать новый файл. Перейдите в директорию `/home/labex/project` и создайте файл с именем `coticker.py`. Этот файл будет содержать весь код для нашей обработки данных на основе корутин.

2. Теперь начнем писать код в файле `coticker.py`. Сначала импортируем необходимые модули и определим базовую структуру. Модули - это предварительно написанные библиотеки кода, которые предоставляют полезные функции и классы. Следующий код делает именно это:

```python
# coticker.py
from structure import Structure

class Ticker(Structure):
    name = String()
    price = Float()
    date = String()
    time = String()
    change = Float()
    open = Float()
    high = Float()
    low = Float()
    volume = Integer()

from cofollow import consumer, follow
from tableformat import create_formatter
import csv
```

3. Если вы посмотрите на приведенный выше код, заметите, что есть ошибки, связанные с `String()`, `Float()` и `Integer()`. Это классы, которые нам нужно импортировать. Поэтому мы добавим необходимые импорты в начало файла. Таким образом, Python будет знать, где найти эти классы. Вот обновленный код:

```python
# coticker.py
from structure import Structure, String, Float, Integer

class Ticker(Structure):
    name = String()
    price = Float()
    date = String()
    time = String()
    change = Float()
    open = Float()
    high = Float()
    low = Float()
    volume = Integer()

from cofollow import consumer, follow
from tableformat import create_formatter
import csv
```

4. Далее добавим компоненты корутин, которые будут формировать наш конвейер обработки данных. Каждая корутина имеет определенную задачу в конвейере. Вот код для добавления этих корутин:

```python
@consumer
def to_csv(target):
    def producer():
        while True:
            line = yield

    reader = csv.reader(producer())
    while True:
        line = yield
        target.send(next(reader))

@consumer
def create_ticker(target):
    while True:
        row = yield
        target.send(Ticker.from_row(row))

@consumer
def negchange(target):
    while True:
        record = yield
        if record.change < 0:
            target.send(record)

@consumer
def ticker(fmt, fields):
    formatter = create_formatter(fmt)
    formatter.headings(fields)
    while True:
        rec = yield
        row = [getattr(rec, name) for name in fields]
        formatter.row(row)
```

5. Поймем, что делает каждая из этих корутин:
   - `to_csv`: Ее задача - преобразовать необработанные текстовые строки в разобранные строки CSV. Это важно, так как наши данные изначально находятся в текстовом формате, и нам нужно разбить их на структурированные данные CSV.
   - `create_ticker`: Эта корутина принимает строки CSV и создает из них объекты `Ticker`. Объекты `Ticker` представляют данные о котировках акций более организованным образом.
   - `negchange`: Она фильтрует объекты `Ticker`. Она пропускает только те акции, у которых есть отрицательное изменение цены. Это помогает нам сосредоточиться на акциях, которые теряют в цене.
   - `ticker`: Эта корутина форматирует и отображает данные о котировках. Она использует форматер для представления данных в удобочитаемой таблице.

6. Наконец, нам нужно добавить основной код программы, который соединяет все эти компоненты вместе. Этот код настроит поток данных через конвейер. Вот код:

```python
if __name__ == '__main__':
    import sys

    # Define the field names to display
    fields = ['name', 'price', 'change']

    # Create the processing pipeline
    t = ticker('text', fields)
    neg_filter = negchange(t)
    tick_creator = create_ticker(neg_filter)
    csv_parser = to_csv(tick_creator)

    # Connect the pipeline to the data source
    follow('stocklog.csv', csv_parser)
```

7. После написания всего кода сохраните файл `coticker.py`. Затем откройте терминал и выполните следующие команды. Команда `cd` изменяет текущую директорию на ту, где находится наш файл, а команда `python3` запускает наш Python - скрипт:

```bash
cd /home/labex/project
python3 coticker.py
```

8. Если все пройдет успешно, вы должны увидеть отформатированную таблицу в терминале. Эта таблица показывает акции с отрицательным изменением цены. Вывод будет выглядеть примерно так:

```
      name      price     change
---------- ---------- ----------
      MSFT      72.50      -0.25
        AA      35.25      -0.15
       IBM      50.10      -0.15
      GOOG     100.02      -0.01
      AAPL     102.50      -0.06
```

Обратите внимание, что фактические значения в таблице могут отличаться в зависимости от сгенерированных данных о котировках акций.

## Понимание потока данных в конвейере

Самая важная часть этой программы - это то, как данные проходят через корутины. Разберем это пошагово:

1. Функция `follow` начинает чтение строк из файла `stocklog.csv`. Это наш источник данных.
2. Каждая прочитанная строка затем отправляется в корутину `csv_parser`. `csv_parser` берет необработанную текстовую строку и разбирает ее на поля CSV.
3. Разобранные данные CSV затем отправляются в корутину `tick_creator`. Эта корутина создает объекты `Ticker` из строк CSV.
4. Объекты `Ticker` затем отправляются в корутину `neg_filter`. Эта корутина проверяет каждый объект `Ticker`. Если у акции есть отрицательное изменение цены, она пропускает объект дальше; в противном случае она отбрасывает его.
5. Наконец, отфильтрованные объекты `Ticker` отправляются в корутину `ticker`. Корутина `ticker` форматирует данные и отображает их в таблице.

Эта архитектура конвейера очень полезна, так как позволяет каждому компоненту сосредоточиться на одной задаче. Это делает код более модульным, что означает, что его легче понять, изменить и поддерживать.
