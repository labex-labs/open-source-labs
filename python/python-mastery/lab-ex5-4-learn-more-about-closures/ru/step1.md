# Замыкания как структура данных

В Python замыкания (closures) предоставляют мощный способ инкапсуляции данных. Инкапсуляция означает сохранение данных в приватном доступе и контроль доступа к ним. С помощью замыканий вы можете создавать функции, которые управляют и изменяют приватные данные, не прибегая к использованию классов или глобальных переменных. Глобальные переменные могут быть доступны и изменены из любого места в вашем коде, что может привести к непредвиденному поведению. Классы, с другой стороны, требуют более сложной структуры. Замыкания предлагают более простую альтернативу для инкапсуляции данных.

Давайте создадим файл с именем `counter.py`, чтобы продемонстрировать эту концепцию:

1. Откройте WebIDE и создайте новый файл с именем `counter.py` в директории `/home/labex/project`. Именно здесь мы напишем код, который определяет наш счётчик на основе замыкания.

2. Добавьте следующий код в файл:

```python
def counter(value):
    """
    Create a counter with increment and decrement functions.

    Args:
        value: Initial value of the counter

    Returns:
        Two functions: one to increment the counter, one to decrement it
    """
    def incr():
        nonlocal value
        value += 1
        return value

    def decr():
        nonlocal value
        value -= 1
        return value

    return incr, decr
```

В этом коде мы определяем функцию с именем `counter()`. Эта функция принимает начальное значение `value` в качестве аргумента. Внутри функции `counter()` мы определяем две вложенные функции: `incr()` и `decr()`. Эти вложенные функции имеют общий доступ к одной и той же переменной `value`. Ключевое слово `nonlocal` используется, чтобы сообщить Python, что мы хотим изменить переменную `value` из внешней области видимости (функции `counter()`). Без ключевого слова `nonlocal` Python бы создал новую локальную переменную внутри вложенных функций вместо изменения переменной `value` из внешней области видимости.

3. Теперь давайте создадим тестовый файл, чтобы увидеть это в действии. Создайте новый файл с именем `test_counter.py` со следующим содержимым:

```python
from counter import counter

# Create a counter starting at 0
up, down = counter(0)

# Increment the counter several times
print("Incrementing the counter:")
print(up())  # Should print 1
print(up())  # Should print 2
print(up())  # Should print 3

# Decrement the counter
print("\nDecrementing the counter:")
print(down())  # Should print 2
print(down())  # Should print 1
```

В этом тестовом файле мы сначала импортируем функцию `counter()` из файла `counter.py`. Затем мы создаем счётчик, начиная с значения 0, вызвав `counter(0)` и распаковав возвращаемые функции в `up` и `down`. Затем мы вызываем функцию `up()` несколько раз, чтобы увеличить счётчик и выводим результаты. После этого мы вызываем функцию `down()`, чтобы уменьшить счётчик и выводим результаты.

4. Запустите тестовый файл, выполнив следующую команду в терминале:

```bash
python3 test_counter.py
```

Вы должны увидеть следующий вывод:

```
Incrementing the counter:
1
2
3

Decrementing the counter:
2
1
```

Обратите внимание, что здесь не используется определение класса. Функции `up()` и `down()` манипулируют общим значением, которое не является ни глобальной переменной, ни атрибутом экземпляра. Это значение хранится в замыкании, что делает его доступным только функциям, возвращаемым `counter()`.

Это пример того, как замыкания могут быть использованы как структура данных. Заключенная переменная `value` сохраняется между вызовами функций, и она приватна для функций, которые к ней обращаются. Это означает, что никакая другая часть вашего кода не может напрямую получить доступ к этой переменной `value` или изменить ее, обеспечивая определенный уровень защиты данных.
