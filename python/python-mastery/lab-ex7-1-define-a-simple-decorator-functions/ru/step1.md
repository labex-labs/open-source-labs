# Создание своего первого декоратора

## Что такое декораторы?

В Python декораторы представляют собой специальный синтаксис, который может быть очень полезен для начинающих. Они позволяют изменять поведение функций или методов. Представьте декоратор как функцию, которая принимает другую функцию в качестве входного параметра. Затем она возвращает новую функцию. Эта новая функция часто расширяет или изменяет поведение исходной функции.

Декораторы применяются с использованием символа `@`. Вы помещаете этот символ, за которым следует имя декоратора, непосредственно над определением функции. Это простой способ сказать Python, что вы хотите использовать декоратор для этой конкретной функции.

## Создание простого декоратора для логирования

Создадим простой декоратор, который записывает информацию при вызове функции. Логирование - это распространенная задача в реальных приложениях, и использование декоратора для этого - отличный способ понять, как они работают.

1. Сначала откройте редактор VSCode. В директории `/home/labex/project` создайте новый файл с именем `logcall.py`. Этот файл будет содержать нашу функцию - декоратор.

2. Добавьте следующий код в файл `logcall.py`:

```python
# logcall.py

def logged(func):
    print('Adding logging to', func.__name__)
    def wrapper(*args, **kwargs):
        print('Calling', func.__name__)
        return func(*args, **kwargs)
    return wrapper
```

Разберем, что делает этот код:

- Функция `logged` является нашим декоратором. Она принимает другую функцию, которую мы называем `func`, в качестве аргумента. Эта функция `func` - это та функция, для которой мы хотим добавить логирование.
- Когда декоратор применяется к функции, он выводит сообщение. Это сообщение сообщает, что логирование добавляется к функции с заданным именем.
- Внутри функции `logged` мы определяем внутреннюю функцию с именем `wrapper`. Эта функция `wrapper` заменит исходную функцию.
  - Когда вызывается декорированная функция, функция `wrapper` выводит сообщение о том, что функция вызывается.
  - Затем она вызывает исходную функцию (`func`) со всеми аргументами, которые были переданы ей. `*args` и `**kwargs` используются для приема любого количества позиционных и ключевых аргументов.
  - Наконец, она возвращает результат выполнения исходной функции.
- Функция `logged` возвращает функцию `wrapper`. Теперь эта функция `wrapper` будет использоваться вместо исходной функции, добавляя функциональность логирования.

## Использование декоратора

3. Теперь в той же директории (`/home/labex/project`) создайте еще один файл с именем `sample.py` со следующим кодом:

```python
# sample.py

from logcall import logged

@logged
def add(x, y):
    return x + y

@logged
def sub(x, y):
    return x - y
```

Синтаксис `@logged` здесь очень важен. Он сообщает Python, что необходимо применить декоратор `logged` к функциям `add` и `sub`. Таким образом, каждый раз, когда эти функции вызываются, будет выполняться функциональность логирования, добавленная декоратором.

## Тестирование декоратора

4. Чтобы протестировать ваш декоратор, откройте терминал в VSCode. Сначала измените директорию на директорию проекта с помощью следующей команды:

```bash
cd /home/labex/project
```

Затем запустите интерпретатор Python:

```bash
python3
```

5. В интерпретаторе Python импортируйте модуль `sample` и протестируйте декорированные функции:

```python
>>> import sample
Adding logging to add
Adding logging to sub
>>> sample.add(3, 4)
Calling add
7
>>> sample.sub(2, 3)
Calling sub
-1
>>> exit()
```

Обратите внимание, что при импорте модуля `sample` выводятся сообщения "Adding logging to...". Это происходит потому, что декоратор применяется при импорте модуля. Каждый раз, когда вы вызываете одну из декорированных функций, выводится сообщение "Calling...". Это показывает, что декоратор работает как ожидается.

Этот простой декоратор демонстрирует базовую концепцию декораторов. Он оборачивает исходную функцию дополнительной функциональностью (в данном случае - логированием) без изменения кода исходной функции. Это мощный инструмент в Python, который можно использовать в различных сценариях.
