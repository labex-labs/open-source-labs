# Ограничение имен атрибутов

В настоящее время наш класс `Structure` позволяет устанавливать любые атрибуты для его экземпляров. На первый взгляд, для начинающих это может показаться удобным, но на самом деле это может привести к множеству проблем. Когда вы работаете с классом, вы ожидаете, что определенные атрибуты будут присутствовать и использоваться определенным образом. Если пользователи допустят опечатку в именах атрибутов или попытаются установить атрибуты, которые не были частью первоначального дизайна, это может привести к ошибкам, которые трудно обнаружить.

## Необходимость ограничения атрибутов

Рассмотрим простой сценарий, чтобы понять, почему нам нужно ограничивать имена атрибутов. Взгляните на следующий код:

```python
s = Stock('GOOG', 100, 490.1)
s.shares = 50      # Correct attribute name
s.share = 60       # Typo in attribute name - creates a new attribute instead of updating
```

Во второй строке допущена опечатка. Вместо `shares` мы написали `share`. В Python, вместо того чтобы вызвать ошибку, он просто создаст новый атрибут с именем `share`. Это может привести к неочевидным ошибкам, так как вы можете думать, что обновляете атрибут `shares`, но на самом деле создаете новый. Это может сделать поведение вашего кода непредсказуемым и очень сложным для отладки.

## Реализация ограничения атрибутов

Чтобы решить эту проблему, мы можем переопределить метод `__setattr__`. Этот метод вызывается каждый раз, когда вы пытаетесь установить атрибут объекта. Переопределив его, мы можем контролировать, какие атрибуты можно устанавливать, а какие - нет.

Обновите класс `Structure` в файле `structure.py` следующим кодом:

```python
def __setattr__(self, name, value):
    """
    Restrict attribute setting to only those defined in _fields
    or attributes starting with underscore (private attributes).
    """
    if name.startswith('_'):
        # Allow setting private attributes (starting with '_')
        super().__setattr__(name, value)
    elif name in self._fields:
        # Allow setting attributes defined in _fields
        super().__setattr__(name, value)
    else:
        # Raise an error for other attributes
        raise AttributeError(f'No attribute {name}')
```

Вот как работает этот метод:

1. Если имя атрибута начинается с подчеркивания (`_`), он считается приватным атрибутом. Приватные атрибуты часто используются для внутренних целей в классе. Мы позволяем устанавливать эти атрибуты, так как они являются частью внутренней реализации класса.
2. Если имя атрибута находится в списке `_fields`, это означает, что он является одним из атрибутов, определенных в дизайне класса. Мы позволяем устанавливать эти атрибуты, так как они являются частью ожидаемого поведения класса.
3. Если имя атрибута не удовлетворяет ни одному из этих условий, мы вызываем исключение `AttributeError`. Это сообщает пользователю, что он пытается установить атрибут, который не существует в классе.

## Тестирование ограничения атрибутов

Теперь, когда мы реализовали ограничение атрибутов, давайте протестируем его, чтобы убедиться, что он работает как ожидается. Создайте файл с именем `test_attributes.py` со следующим кодом:

```python
# test_attributes.py
from structure import Stock

s = Stock('GOOG', 100, 490.1)

# This should work - valid attribute
print("Setting shares to 50")
s.shares = 50
print(f"Shares is now: {s.shares}")

# This should work - private attribute
print("\nSetting _internal_data")
s._internal_data = "Some data"
print(f"_internal_data is: {s._internal_data}")

# This should fail - invalid attribute
print("\nTrying to set an invalid attribute:")
try:
    s.share = 60  # Typo in attribute name
    print("This should not print")
except AttributeError as e:
    print(f"Error correctly caught: {e}")
```

Чтобы запустить тест, откройте терминал и введите следующую команду:

```bash
python3 test_attributes.py
```

Вы должны увидеть следующий вывод:

```
Setting shares to 50
Shares is now: 50

Setting _internal_data
_internal_data is: Some data

Trying to set an invalid attribute:
Error correctly caught: No attribute share
```

Этот вывод показывает, что наш класс теперь предотвращает случайные ошибки с атрибутами. Он позволяет нам устанавливать допустимые атрибуты и приватные атрибуты, но вызывает ошибку, когда мы пытаемся установить недопустимый атрибут.

## Ценность ограничения атрибутов

Ограничение имен атрибутов очень важно для написания надежного и поддерживаемого кода. Вот почему:

1. Это помогает обнаружить опечатки в именах атрибутов. Если вы допустите ошибку при вводе имени атрибута, код вызовет ошибку вместо создания нового атрибута. Это делает проще найти и исправить ошибки на ранней стадии разработки.
2. Это предотвращает попытки установить атрибуты, которые не существуют в дизайне класса. Это гарантирует, что класс используется как задумано и что код ведет себя предсказуемо.
3. Это избавляет от случайного создания новых атрибутов. Создание новых атрибутов может привести к непредвиденному поведению и сделать код труднее для понимания и поддержки.

Ограничивая имена атрибутов, мы делаем наш код более надежным и удобным для работы.
