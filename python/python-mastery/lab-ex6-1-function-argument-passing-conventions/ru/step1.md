# Понимание передачи аргументов функций

В Python функции - это фундаментальный концепт, который позволяет группировать набор инструкций для выполнения определенной задачи. Когда вы вызываете функцию, вам часто нужно передать ей некоторые данные, которые мы называем аргументами. Python предлагает различные способы передачи этих аргументов функциям. Эта гибкость чрезвычайно полезна, так как помогает писать более чистый и поддерживаемый код. Прежде чем мы применим эти техники к нашему проекту, давайте более подробно рассмотрим эти соглашения по передаче аргументов.

## Создание резервной копии вашей работы

Перед тем как мы начнем вносить изменения в файл `stock.py`, хорошей практикой является создание резервной копии. Таким образом, если что-то пойдет не так во время наших экспериментов, мы всегда сможем вернуться к исходной версии. Чтобы создать резервную копию, откройте терминал и выполните следующую команду:

```bash
cp stock.py orig_stock.py
```

Эта команда использует команду `cp` (копирование) в терминале. Она берет файл `stock.py` и создает его копию с именем `orig_stock.py`. Таким образом, мы обеспечиваем сохранность нашей исходной работы.

## Исследование передачи аргументов функций

В Python существует несколько способов вызова функций с разными типами аргументов. Давайте подробно рассмотрим каждый из этих методов.

### 1. Позиционные аргументы

Самый простой способ передачи аргументов функции - по позиции. Когда вы определяете функцию, вы указываете список параметров. Когда вы вызываете функцию, вы предоставляете значения для этих параметров в том же порядке, в котором они определены.

Вот пример:

```python
def calculate(x, y, z):
    return x + y + z

# Call with positional arguments
result = calculate(1, 2, 3)
print(result)  # Output: 6
```

В этом примере функция `calculate` принимает три параметра: `x`, `y` и `z`. Когда мы вызываем функцию с `calculate(1, 2, 3)`, значение `1` присваивается `x`, `2` присваивается `y`, а `3` присваивается `z`. Затем функция складывает эти значения и возвращает результат.

### 2. Ключевые аргументы

В дополнение к позиционным аргументам, вы также можете указывать аргументы по их именам. Это называется использованием ключевых аргументов. Когда вы используете ключевые аргументы, вам не нужно беспокоиться о порядке аргументов.

Вот пример:

```python
# Call with a mix of positional and keyword arguments
result = calculate(1, z=3, y=2)
print(result)  # Output: 6
```

В этом примере мы сначала передаем позиционный аргумент `1` для `x`. Затем мы используем ключевые аргументы, чтобы указать значения для `y` и `z`. Порядок ключевых аргументов не имеет значения, главное, чтобы вы указали правильные имена.

### 3. Распаковка последовательностей и словарей

Python предоставляет удобный способ передачи последовательностей и словарей в качестве аргументов с использованием синтаксиса `*` и `**`. Это называется распаковкой.

Вот пример распаковки кортежа в позиционные аргументы:

```python
# Unpacking a tuple into positional arguments
args = (1, 2, 3)
result = calculate(*args)
print(result)  # Output: 6
```

В этом примере у нас есть кортеж `args`, который содержит значения `1`, `2` и `3`. Когда мы используем оператор `*` перед `args` при вызове функции, Python распаковывает кортеж и передает его элементы в качестве позиционных аргументов функции `calculate`.

Вот пример распаковки словаря в ключевые аргументы:

```python
# Unpacking a dictionary into keyword arguments
kwargs = {'y': 2, 'z': 3}
result = calculate(1, **kwargs)
print(result)  # Output: 6
```

В этом примере у нас есть словарь `kwargs`, который содержит пары ключ-значение `'y': 2` и `'z': 3`. Когда мы используем оператор `**` перед `kwargs` при вызове функции, Python распаковывает словарь и передает его пары ключ-значение в качестве ключевых аргументов функции `calculate`.

### 4. Прием переменного количества аргументов

Иногда вы можете захотеть определить функцию, которая может принимать любое количество аргументов. Python позволяет сделать это, используя синтаксис `*` и `**` в определении функции.

Вот пример функции, которая принимает любое количество позиционных аргументов:

```python
# Accept any number of positional arguments
def sum_all(*args):
    return sum(args)

print(sum_all(1, 2))           # Output: 3
print(sum_all(1, 2, 3, 4, 5))  # Output: 15
```

В этом примере функция `sum_all` использует параметр `*args` для приема любого количества позиционных аргументов. Оператор `*` собирает все позиционные аргументы в кортеж с именем `args`. Затем функция использует встроенную функцию `sum` для сложения всех элементов кортежа.

Вот пример функции, которая принимает любое количество ключевых аргументов:

```python
# Accept any number of keyword arguments
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Python", year=1991)
# Output:
# name: Python
# year: 1991
```

В этом примере функция `print_info` использует параметр `**kwargs` для приема любого количества ключевых аргументов. Оператор `**` собирает все ключевые аргументы в словарь с именем `kwargs`. Затем функция проходит по парам ключ-значение в словаре и выводит их.

Эти техники помогут нам создать более гибкие и переиспользуемые структуры кода на следующих этапах. Чтобы лучше понять эти концепции, давайте откроем интерпретатор Python и попробуем некоторые из этих примеров.

```bash
python3
```

Как только вы войдете в интерпретатор Python, попробуйте ввести приведенные выше примеры. Это даст вам практический опыт работы с этими техниками передачи аргументов.
