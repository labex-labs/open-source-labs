# Добавление итерации в пользовательские классы

Теперь, когда вы освоили основы генераторов, мы будем использовать их для добавления возможностей итерации в пользовательские классы. В Python, если вы хотите сделать класс итерируемым, вам нужно реализовать специальный метод `__iter__()`. Итерируемый класс позволяет перебирать его элементы, как если бы вы перебирали список или кортеж. Это мощная особенность, которая делает ваши пользовательские классы более гибкими и удобными в использовании.

## Понимание метода `__iter__()`

Метод `__iter__()` является важной частью создания итерируемого класса. Он должен возвращать объект - итератор. Итератор - это объект, который можно перебирать (проходить в цикле). Простой и эффективный способ добиться этого - определить `__iter__()` как функцию - генератор. Функция - генератор использует ключевое слово `yield` для пошагового создания последовательности значений. Каждый раз, когда встречается оператор `yield`, функция приостанавливается и возвращает значение. В следующий раз, когда вызывается итератор, функция продолжает выполнение с того места, где остановилась.

## Изменение класса Structure

В рамках этого лабораторного занятия мы предоставили базовый класс `Structure`. Другие классы, такие как `Stock`, могут наследоваться от этого класса `Structure`. Наследование - это способ создания нового класса, который наследует свойства и методы существующего класса. Добавив метод `__iter__()` в класс `Structure`, мы можем сделать все его подклассы итерируемыми. Это означает, что любой класс, который наследуется от `Structure`, автоматически получит возможность быть перебираемым в цикле.

1. Откройте файл `structure.py` в WebIDE:

```bash
cd ~/project
```

Эта команда изменяет текущую рабочую директорию на директорию `project`, где находится файл `structure.py`. Вам нужно находиться в правильной директории, чтобы получить доступ к файлу и изменить его.

2. Посмотрите на текущую реализацию класса `Structure`:

```python
class Structure(metaclass=StructureMeta):
    _fields = []
    def __init__(self, *args):
        if len(args) != len(self._fields):
            raise TypeError(f'Expected {len(self._fields)} arguments')
        for name, val in zip(self._fields, args):
            setattr(self, '_'+name, val)
```

Класс `Structure` имеет список `_fields`, который хранит имена атрибутов. Метод `__init__()` является конструктором класса. Он инициализирует атрибуты объекта, проверяя, равно ли количество переданных аргументов количеству полей. Если нет, он вызывает исключение `TypeError`. В противном случае он устанавливает атрибуты с помощью функции `setattr()`.

3. Добавьте метод `__iter__()`, который последовательно возвращает каждое значение атрибута:

```python
def __iter__(self):
    for name in self._fields:
        yield getattr(self, name)
```

Этот метод `__iter__()` является функцией - генератором. Он проходит по списку `_fields` и использует функцию `getattr()` для получения значения каждого атрибута. Затем ключевое слово `yield` возвращает значения по одному.

Полностью обновленный файл `structure.py` должен выглядеть следующим образом:

```python
class StructureMeta(type):
    def __new__(cls, name, bases, clsdict):
        fields = clsdict.get('_fields', [])
        for name in fields:
            clsdict[name] = property(lambda self, name=name: getattr(self, '_'+name))
        return super().__new__(cls, name, bases, clsdict)

class Structure(metaclass=StructureMeta):
    _fields = []
    def __init__(self, *args):
        if len(args) != len(self._fields):
            raise TypeError(f'Expected {len(self._fields)} arguments')
        for name, val in zip(self._fields, args):
            setattr(self, '_'+name, val)

    def __iter__(self):
        for name in self._fields:
            yield getattr(self, name)
```

Теперь обновленный класс `Structure` имеет метод `__iter__()`, который делает его и его подклассы итерируемыми.

4. Сохраните файл.
   После внесения изменений в файл `structure.py` вам нужно сохранить его, чтобы изменения вступили в силу.

5. Теперь давайте протестируем возможность итерации, создав экземпляр класса `Stock` и перебрав его элементы:

```bash
python3 -c "from stock import Stock; s = Stock('GOOG', 100, 490.1); print('Iterating over Stock:'); [print(val) for val in s]"
```

Эта команда создает экземпляр класса `Stock`, который наследуется от класса `Structure`. Затем она перебирает экземпляр с использованием списочного выражения и выводит каждое значение.

Вы должны увидеть такой вывод:

```
Iterating over Stock:
GOOG
100
490.1
```

Теперь любой класс, который наследуется от `Structure`, автоматически станет итерируемым, и итерация будет возвращать значения атрибутов в порядке, определенном списком `_fields`. Это означает, что вы можете легко перебирать атрибуты любого подкласса `Structure` без необходимости писать дополнительный код для итерации.
