# Понимание контекста

В предыдущих упражнениях вы, возможно, встречали код, который считывает CSV-файлы и сохраняет данные в различных структурах данных. Цель этого кода - взять необработанные текстовые данные из CSV-файла и преобразовать их в более полезные объекты Python, такие как словари или экземпляры классов. Это преобразование является важным, так как оно позволяет нам работать с данными более структурированным и осмысленным образом в наших Python-программах.

Типичная схема чтения CSV-файлов часто имеет определенную структуру. Вот пример функции, которая считывает CSV-файл и преобразует каждую строку в словарь:

```python
import csv

def read_csv_as_dicts(filename, types):
    records = []
    with open(filename) as file:
        rows = csv.reader(file)
        headers = next(rows)
        for row in rows:
            record = { name: func(val)
                       for name, func, val in zip(headers, types, row) }
            records.append(record)
    return records
```

Разберем, как работает эта функция. Во - первых, она импортирует модуль `csv`, который предоставляет функциональность для работы с CSV-файлами в Python. Функция принимает два параметра: `filename` - имя CSV-файла для чтения, и `types` - список функций, используемых для преобразования данных в каждой колонке в соответствующий тип данных.

Внутри функции инициализируется пустой список `records` для хранения словарей, представляющих каждую строку CSV-файла. Затем файл открывается с использованием оператора `with`, который гарантирует, что файл будет правильно закрыт после выполнения блока кода. Функция `csv.reader` используется для создания итератора, который считывает каждую строку CSV-файла. Первая строка считается заголовками, поэтому она извлекается с помощью функции `next`.

Далее функция проходит по оставшимся строкам в CSV-файле. Для каждой строки создается словарь с использованием включения словаря. Ключами словаря являются заголовки колонок, а значениями - результат применения соответствующей функции преобразования типа из списка `types` к значению в строке. Наконец, словарь добавляется в список `records`, и функция возвращает список словарей.

Теперь рассмотрим похожую функцию, которая считывает данные из CSV-файла в экземпляры класса:

```python
def read_csv_as_instances(filename, cls):
    records = []
    with open(filename) as file:
        rows = csv.reader(file)
        headers = next(rows)
        for row in rows:
            record = cls.from_row(row)
            records.append(record)
    return records
```

Эта функция похожа на предыдущую, но вместо создания словарей она создает экземпляры класса. Функция принимает два параметра: `filename` - имя CSV-файла для чтения, и `cls` - класс, экземпляры которого будут созданы.

Внутри функции используется схожая структура, как в предыдущей функции. Инициализируется пустой список `records` для хранения экземпляров класса. Затем файл открывается, считываются заголовки и проходит по оставшимся строкам. Для каждой строки вызывается метод `from_row` класса `cls` для создания экземпляра класса с использованием данных из строки. Экземпляр затем добавляется в список `records`, и функция возвращает список экземпляров.

В этом практическом занятии (лабораторной работе) мы рефакторим эти функции, чтобы сделать их более гибкими и надежными. Мы также рассмотрим систему подсказок типов (type hinting) Python, которая позволяет нам указывать ожидаемые типы параметров и возвращаемых значений наших функций. Это может сделать наш код более читаемым и легким для понимания, особенно для других разработчиков, которые могут работать с нашим кодом.

Начнем с создания файла `reader.py` и добавления в него этих начальных функций. Убедитесь, что вы протестировали эти функции, чтобы убедиться, что они работают правильно, прежде чем переходить к следующим шагам.
