# タスクスケジューラーのテスト

ここでは、`multitask.py` ファイルにテストを追加します。このテストの目的は、複数のタスクを同時に実行することです。これは並行実行（concurrent execution）と呼ばれます。並行実行では、単一スレッド環境であっても、異なるタスクが見かけ上同時に進捗を遂げることができます。実際には、タスクは順番に実行されます。

このテストを行うには、`multitask.py` ファイルの末尾に以下のコードを追加します。

```python
# Test our scheduler
if __name__ == '__main__':
    # Add tasks to the queue
    tasks.append(countdown(10))  # Count down from 10
    tasks.append(countdown(5))   # Count down from 5
    tasks.append(countup(20))    # Count up to 20

    # Run all tasks
    run()
```

このコードでは、まず `if __name__ == '__main__':` を使って、スクリプトが直接実行されているかどうかを確認します。次に、3 つの異なるタスクを `tasks` キューに追加します。`countdown` タスクは指定された数からカウントダウンし、`countup` タスクは指定された数までカウントアップします。最後に、`run()` 関数を呼び出してこれらのタスクの実行を開始します。

コードを追加した後、ターミナルで以下のコマンドを実行して実行します。

```bash
python3 /home/labex/project/multitask.py
```

コードを実行すると、以下のような出力が表示されるはずです（行の正確な順序は異なる場合があります）。

```
T-minus 10
T-minus 5
Up we go 0
T-minus 9
T-minus 4
Up we go 1
T-minus 8
T-minus 3
Up we go 2
...
```

異なるタスクからの出力が混在していることに注目してください。これは、スケジューラーが 3 つのタスクを並行して実行していることを明確に示しています。タスクが `yield` 文に到達するたびに、スケジューラーはそのタスクを一時停止し、別のタスクに切り替えます。これにより、すべてのタスクが時間の経過とともに進捗を遂げることができます。

## 動作原理

スケジューラーが実行されたときに何が起こるかを詳しく見てみましょう。

1. まず、3 つのジェネレータータスク `countdown(10)`、`countdown(5)`、`countup(20)` をキューに追加します。これらのジェネレータータスクは、`yield` 文で実行を一時停止し、再開できる特殊な関数です。
2. 次に、`run()` 関数が動作を開始します。
   - キューから最初のタスク `countdown(10)` を取り出します。
   - このタスクを `yield` 文に到達するまで実行します。`yield` に到達すると、「T-minus 10」と表示されます。
   - その後、`countdown(10)` タスクをキューに戻し、後で再度実行できるようにします。
   - 次に、キューから `countdown(5)` タスクを取り出します。
   - `countdown(5)` タスクを `yield` 文に到達するまで実行し、「T-minus 5」と表示します。
   - このプロセスが続きます...

このサイクルは、すべてのタスクが完了するまで続きます。各タスクは短時間実行される機会を得ます。これにより、スレッドやコールバックを使用することなく、並行実行のような錯覚を与えます。スレッドは並行性を実現するより複雑な方法であり、コールバックは非同期プログラミングで使用されます。私たちのシンプルなスケジューラーは、ジェネレーターを使って、より簡単な方法で同様の効果を達成しています。
