# Создание планировщика задач с использованием генераторов

В программировании планировщик задач - это важный инструмент, который помогает эффективно управлять и выполнять несколько задач. В этом разделе мы будем использовать генераторы для создания простого планировщика задач, который может запускать несколько генераторных функций одновременно. Это покажет, как можно управлять генераторами для выполнения кооперативного многозадачности, то есть когда задачи поочередно выполняются и делят время выполнения.

Сначала вам нужно создать новый файл. Перейдите в директорию `/home/labex/project` и создайте файл с именем `multitask.py`. Этот файл будет содержать код нашего планировщика задач.

```python
# multitask.py

from collections import deque

# Task queue
tasks = deque()

# Simple task scheduler
def run():
    while tasks:
        task = tasks.popleft()  # Get the next task
        try:
            task.send(None)     # Resume the task
            tasks.append(task)  # Put it back in the queue
        except StopIteration:
            print('Task done')  # Task is complete

# Example task 1: Countdown
def countdown(n):
    while n > 0:
        print('T-minus', n)
        yield              # Pause execution
        n -= 1

# Example task 2: Count up
def countup(n):
    x = 0
    while x < n:
        print('Up we go', x)
        yield              # Pause execution
        x += 1
```

Теперь разберемся, как работает этот планировщик задач:

1. Мы используем `deque` (двустороннюю очередь) для хранения наших генераторных задач. `deque` - это структура данных, которая позволяет эффективно добавлять и удалять элементы с обоих концов. Это отличный выбор для нашей очереди задач, так как нам нужно добавлять задачи в конец и удалять их из начала.
2. Функция `run()` является ядром нашего планировщика задач. Она берет задачи из очереди по одной:
   - Она возобновляет выполнение каждой задачи с помощью `send(None)`. Это аналогично использованию `next()` для генератора. Это сообщает генератору продолжить выполнение с того места, где он остановился.
   - После того, как задача выдает значение (yield), она добавляется обратно в конец очереди. Таким образом, задача получит еще один шанс выполниться позже.
   - Когда задача завершается (возбуждает исключение `StopIteration`), она удаляется из очереди. Это означает, что задача завершила свое выполнение.
3. Каждый оператор `yield` в наших генераторных задачах действует как точка остановки. Когда генератор достигает оператора `yield`, он приостанавливает свое выполнение и возвращает управление планировщику. Это позволяет другим задачам выполняться.

Этот подход реализует кооперативную многозадачность. Каждая задача добровольно возвращает управление планировщику, позволяя другим задачам выполняться. Таким образом, несколько задач могут делить время выполнения и выполняться одновременно.
