# Тестирование нашего планировщика задач

Теперь мы добавим тест в наш файл `multitask.py`. Цель этого теста - запустить несколько задач одновременно, что называется параллельным выполнением (concurrent execution). Параллельное выполнение позволяет разным задачам делать прогресс, казалось бы, одновременно, хотя в однопоточной среде задачи на самом деле выполняются поочередно.

Чтобы выполнить этот тест, добавьте следующий код в конец файла `multitask.py`:

```python
# Test our scheduler
if __name__ == '__main__':
    # Add tasks to the queue
    tasks.append(countdown(10))  # Count down from 10
    tasks.append(countdown(5))   # Count down from 5
    tasks.append(countup(20))    # Count up to 20

    # Run all tasks
    run()
```

В этом коде мы сначала проверяем, запускается ли скрипт напрямую, используя `if __name__ == '__main__':`. Затем мы добавляем три разные задачи в очередь `tasks`. Задачи `countdown` будут выполнять обратный отсчет от заданных чисел, а задача `countup` будет выполнять прямой отсчет до указанного числа. Наконец, мы вызываем функцию `run()`, чтобы начать выполнение этих задач.

После добавления кода запустите его с помощью следующей команды в терминале:

```bash
python3 /home/labex/project/multitask.py
```

Когда вы запустите код, вы должны увидеть вывод, похожий на следующий (точный порядок строк может отличаться):

```
T-minus 10
T-minus 5
Up we go 0
T-minus 9
T-minus 4
Up we go 1
T-minus 8
T-minus 3
Up we go 2
...
```

Обратите внимание, как вывод от разных задач перемешан. Это явный признак того, что наш планировщик запускает все три задачи параллельно. Каждый раз, когда задача достигает оператора `yield`, планировщик приостанавливает эту задачу и переключается на другую, позволяя всем задачам делать прогресс со временем.

## Как это работает

Давайте рассмотрим более подробно, что происходит, когда наш планировщик запускается:

1. Сначала мы добавляем три генераторные задачи в очередь: `countdown(10)`, `countdown(5)` и `countup(20)`. Эти генераторные задачи - это особые функции, которые могут приостанавливать и возобновлять свое выполнение на операторах `yield`.
2. Затем функция `run()` начинает свою работу:
   - Она берет первую задачу, `countdown(10)`, из очереди.
   - Она запускает эту задачу до тех пор, пока не достигнет оператора `yield`. Когда она достигает `yield`, она выводит "T-minus 10".
   - После этого она добавляет задачу `countdown(10)` обратно в очередь, чтобы ее можно было запустить позже.
   - Затем она берет задачу `countdown(5)` из очереди.
   - Она запускает задачу `countdown(5)` до тех пор, пока не достигнет оператора `yield`, выводя "T-minus 5".
   - И этот процесс продолжается...

Этот цикл продолжается до тех пор, пока все задачи не будут завершены. Каждая задача получает возможность выполниться на короткое время, что создает иллюзию параллельного выполнения без необходимости использовать потоки (threads) или колбэки (callbacks). Потоки - это более сложный способ достижения параллелизма, а колбэки используются в асинхронном программировании. Наш простой планировщик использует генераторы, чтобы достичь аналогичного эффекта более простым способом.
