# 작업 스케줄러 테스트

이제 `multitask.py` 파일에 테스트를 추가해 보겠습니다. 이 테스트의 목적은 여러 작업을 동시에 실행하는 것입니다. 이를 동시 실행 (concurrent execution) 이라고 합니다. 동시 실행을 통해 서로 다른 작업이 마치 동시에 진행되는 것처럼 보일 수 있습니다. 단일 스레드 환경에서는 실제로 작업이 번갈아 가며 실행됩니다.

이 테스트를 수행하려면 `multitask.py` 파일의 끝에 다음 코드를 추가합니다.

```python
# Test our scheduler
if __name__ == '__main__':
    # Add tasks to the queue
    tasks.append(countdown(10))  # Count down from 10
    tasks.append(countdown(5))   # Count down from 5
    tasks.append(countup(20))    # Count up to 20

    # Run all tasks
    run()
```

이 코드에서는 먼저 `if __name__ == '__main__':`을 사용하여 스크립트가 직접 실행되는지 확인합니다. 그런 다음 세 가지 다른 작업을 `tasks` 큐에 추가합니다. `countdown` 작업은 주어진 숫자부터 카운트다운하고, `countup` 작업은 지정된 숫자까지 카운트업합니다. 마지막으로 `run()` 함수를 호출하여 이러한 작업을 실행하기 시작합니다.

코드를 추가한 후 터미널에서 다음 명령으로 실행합니다.

```bash
python3 /home/labex/project/multitask.py
```

코드를 실행하면 다음과 유사한 출력이 표시됩니다 (줄의 정확한 순서는 다를 수 있습니다).

```
T-minus 10
T-minus 5
Up we go 0
T-minus 9
T-minus 4
Up we go 1
T-minus 8
T-minus 3
Up we go 2
...
```

서로 다른 작업의 출력이 어떻게 섞여 있는지 확인하십시오. 이는 스케줄러가 세 가지 작업을 모두 동시에 실행하고 있음을 명확하게 나타냅니다. 작업이 `yield` 문에 도달할 때마다 스케줄러는 해당 작업을 일시 중지하고 다른 작업으로 전환하여 모든 작업이 시간이 지남에 따라 진행되도록 합니다.

## 작동 방식

스케줄러가 실행될 때 어떤 일이 발생하는지 자세히 살펴보겠습니다.

1. 먼저 세 개의 제너레이터 작업 `countdown(10)`, `countdown(5)`, `countup(20)`을 큐에 추가합니다. 이러한 제너레이터 작업은 `yield` 문에서 실행을 일시 중지하고 재개할 수 있는 특수 함수입니다.
2. 그런 다음 `run()` 함수가 작업을 시작합니다.
   - 큐에서 첫 번째 작업인 `countdown(10)`을 가져옵니다.
   - `yield` 문에 도달할 때까지 이 작업을 실행합니다. `yield`에 도달하면 "T-minus 10"을 출력합니다.
   - 그 후, `countdown(10)` 작업을 큐에 다시 추가하여 나중에 다시 실행할 수 있도록 합니다.
   - 다음으로 큐에서 `countdown(5)` 작업을 가져옵니다.
   - "T-minus 5"를 출력하면서 `yield` 문에 도달할 때까지 `countdown(5)` 작업을 실행합니다.
   - 그리고 이 프로세스가 계속됩니다...

이 주기는 모든 작업이 완료될 때까지 계속됩니다. 각 작업은 잠시 실행될 기회를 얻으므로 스레드나 콜백을 사용할 필요 없이 동시 실행의 환상을 제공합니다. 스레드는 동시성을 달성하는 더 복잡한 방법이며, 콜백은 비동기 프로그래밍에서 사용됩니다. 우리의 간단한 스케줄러는 제너레이터를 사용하여 더 간단한 방식으로 유사한 효과를 얻습니다.
