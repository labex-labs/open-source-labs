# Создание декоратора класса для валидации

В предыдущем шаге наша реализация работала, но была избыточность. Нам приходилось указывать как кортеж `_fields`, так и атрибуты дескрипторов. Это не очень эффективно, и мы можем это улучшить. В Python декораторы классов — это мощный инструмент, который может помочь нам упростить этот процесс. Декоратор класса — это функция, которая принимает класс в качестве аргумента, как-то его изменяет, а затем возвращает измененный класс. Используя декоратор класса, мы можем автоматически извлекать информацию о полях из дескрипторов, что сделает наш код более чистым и поддерживаемым.

Давайте создадим декоратор класса для упрощения нашего кода. Вот шаги, которым вам нужно следовать:

1. Сначала откройте файл `structure.py` в вашем редакторе.

2. Затем добавьте следующий код в начало файла `structure.py`, сразу после любых операторов импорта. Этот код определяет наш декоратор класса:

```python
from validate import Validator

def validate_attributes(cls):
    """
    Class decorator that extracts Validator instances
    and builds the _fields list automatically
    """
    validators = []
    for name, val in vars(cls).items():
        if isinstance(val, Validator):
            validators.append(val)

    # Set _fields based on validator names
    cls._fields = [val.name for val in validators]

    # Create initialization method
    cls.create_init()

    return cls
```

Давайте разберем, что делает этот декоратор:

- Сначала он создает пустой список `validators`. Затем он перебирает все атрибуты класса с помощью `vars(cls).items()`. Если атрибут является экземпляром класса `Validator`, он добавляет этот атрибут в список `validators`.
- После этого он устанавливает атрибут `_fields` класса. Он создает список имен из валидаторов в списке `validators` и присваивает его `cls._fields`.
- Наконец, он вызывает метод `create_init()` класса для генерации метода `__init__`, а затем возвращает измененный класс.

3. После добавления кода сохраните файл `structure.py`. Сохранение файла гарантирует, что ваши изменения будут сохранены.

4. Теперь нам нужно изменить наш файл `stock.py`, чтобы использовать этот новый декоратор. Откройте файл `stock.py` в вашем редакторе.

5. Обновите файл `stock.py`, чтобы использовать декоратор `validate_attributes`. Замените существующий код следующим:

```python
# stock.py

from structure import Structure, validate_attributes
from validate import String, PositiveInteger, PositiveFloat

@validate_attributes
class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
```

Обратите внимание на внесенные нами изменения:

- Мы добавили декоратор `@validate_attributes` прямо над определением класса `Stock`. Это указывает Python применить декоратор `validate_attributes` к классу `Stock`.
- Мы удалили явное объявление `_fields`, поскольку декоратор будет обрабатывать его автоматически.
- Мы также удалили вызов `Stock.create_init()`, поскольку декоратор берет на себя создание метода `__init__`.

В результате класс стал проще и чище. Декоратор берет на себя все детали, которые мы раньше обрабатывали вручную.

6. После внесения этих изменений нам нужно убедиться, что все по-прежнему работает должным образом. Снова запустите тесты, используя следующие команды:

```bash
cd ~/project
python3 teststock.py
```

Если все работает правильно, вы должны увидеть следующий вывод:

```
.........
----------------------------------------------------------------------
Ran 9 tests in 0.001s

OK
```

Этот вывод указывает на то, что все тесты успешно пройдены.

Давайте также протестируем наш класс `Stock` в интерактивном режиме. Выполните следующую команду в терминале:

```bash
cd ~/project
python3 -c "from stock import Stock; s = Stock('GOOG', 100, 490.1); print(s); print(f'Cost: {s.cost}')"
```

Вы должны увидеть следующий вывод:

```
Stock('GOOG', 100, 490.1)
Cost: 49010.0
```

Отлично! Вы успешно реализовали декоратор класса, который упрощает наш код, автоматически обрабатывая объявления полей и инициализацию. Это делает наш код более эффективным и легким в поддержке.
