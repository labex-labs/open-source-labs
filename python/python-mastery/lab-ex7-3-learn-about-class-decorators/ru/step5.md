# Добавление валидации аргументов методов

В Python валидация данных является важной частью написания надежного кода. В этом разделе мы усовершенствуем нашу валидацию, автоматически проверяя аргументы методов. Файл `validate.py` уже содержит декоратор `@validated`. Декоратор в Python - это специальная функция, которая может модифицировать другую функцию. Декоратор `@validated` здесь может проверять аргументы функции на соответствие их аннотациям. Аннотации в Python - это способ добавления метаданных к параметрам функции и возвращаемым значениям.

Давайте изменим наш код, чтобы применить этот декоратор к методам с аннотациями:

1. Сначала нам нужно понять, как работает декоратор `validated`. Откройте файл `validate.py`, чтобы изучить его:

```bash
code ~/project/validate.py
```

Декоратор `validated` использует аннотации функции для валидации аргументов. Прежде чем разрешить выполнение функции, он проверяет каждый аргумент на соответствие типу, указанному в аннотации. Например, если аргумент аннотирован как целое число, декоратор убедится, что переданное значение действительно является целым числом.

2. Теперь мы изменим функцию `validate_attributes` в файле `structure.py`, чтобы обернуть методы с аннотациями декоратором `validated`. Это означает, что для любого метода с аннотациями в классе аргументы будут автоматически валидироваться. Откройте файл `structure.py`:

```bash
code ~/project/structure.py
```

3. Обновите функцию `validate_attributes`:

```python
def validate_attributes(cls):
    """
    Class decorator that:
    1. Extracts Validator instances and builds _fields and _types lists
    2. Applies @validated decorator to methods with annotations
    """
    # Import the validated decorator
    from validate import validated

    # Process validator descriptors
    validators = []
    for name, val in vars(cls).items():
        if isinstance(val, Validator):
            validators.append(val)

    # Set _fields based on validator names
    cls._fields = [val.name for val in validators]

    # Set _types based on validator expected_types
    cls._types = [getattr(val, 'expected_type', lambda x: x) for val in validators]

    # Apply @validated decorator to methods with annotations
    for name, val in vars(cls).items():
        if callable(val) and hasattr(val, '__annotations__'):
            setattr(cls, name, validated(val))

    # Create initialization method
    cls.create_init()

    return cls
```

Эта обновленная функция теперь делает следующее:

1. Она обрабатывает дескрипторы валидаторов, как и раньше. Дескрипторы валидаторов используются для определения правил валидации атрибутов класса.
2. Она находит все методы с аннотациями в классе. Аннотации добавляются к параметрам метода, чтобы указать ожидаемый тип аргумента.
3. Она применяет декоратор `@validated` к этим методам. Это гарантирует, что аргументы, передаваемые в эти методы, будут валидированы в соответствии с их аннотациями.

4. Сохраните файл после внесения этих изменений. Сохранение файла важно, так как оно гарантирует, что наши изменения будут сохранены и могут быть использованы позже.

5. Теперь давайте обновим метод `sell` в классе `Stock`, чтобы добавить аннотацию. Аннотации помогают указать ожидаемый тип аргумента, который будет использован декоратором `@validated` для валидации. Откройте файл `stock.py`:

```bash
code ~/project/stock.py
```

6. Измените метод `sell`, чтобы добавить аннотацию типа:

```python
# stock.py

from structure import Structure
from validate import String, PositiveInteger, PositiveFloat

class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares: PositiveInteger):
        self.shares -= nshares
```

Основное изменение - это добавление `: PositiveInteger` к параметру `nshares`. Это сообщает Python (и нашему декоратору `@validated`), что этот аргумент должен быть валидирован с использованием валидатора `PositiveInteger`. Таким образом, когда мы вызываем метод `sell`, аргумент `nshares` должен быть положительным целым числом.

7. Запустите тесты еще раз, чтобы убедиться, что все по-прежнему работает. Запуск тестов - это хороший способ убедиться, что наши изменения не сломали существующую функциональность.

```bash
cd ~/project
python3 teststock.py
```

Вы должны увидеть, что все тесты проходят:

```
.........
----------------------------------------------------------------------
Ran 9 tests in 0.001s

OK
```

8. Давайте протестируем нашу новую валидацию аргументов. Мы попробуем вызвать метод `sell` с корректными и некорректными аргументами, чтобы проверить, работает ли валидация как ожидается.

```bash
cd ~/project
python3 -c "from stock import Stock; s = Stock('GOOG', 100, 490.1); s.sell(25); print(s); try: s.sell(-25); except Exception as e: print(f'Error: {e}')"
```

Вы должны увидеть вывод, похожий на следующий:

```
Stock('GOOG', 75, 490.1)
Error: Bad Arguments
  nshares: must be >= 0
```

Это показывает, что наша валидация аргументов методов работает! Первый вызов `sell(25)` завершается успешно, потому что `25` - это положительное целое число. Но второй вызов `sell(-25)` завершается с ошибкой, потому что `-25` не является положительным целым числом.

Теперь вы реализовали полную систему для:

1. Валидации атрибутов класса с использованием дескрипторов. Дескрипторы используются для определения правил валидации атрибутов класса.
2. Автоматического сбора информации о полях с использованием декораторов класса. Декораторы класса могут изменять поведение класса, например, собирать информацию о полях.
3. Преобразования строковых данных в экземпляры. Это полезно при работе с данными из внешних источников.
4. Валидации аргументов методов с использованием аннотаций. Аннотации помогают указать ожидаемый тип аргумента для валидации.

Это демонстрирует мощь комбинации дескрипторов и декораторов в Python для создания выразительных, самовалидирующихся классов.
