# Добавление валидации аргументов методов

В Python валидация данных является важной частью написания надежного кода. В этом разделе мы расширим нашу валидацию, автоматически проверяя аргументы методов. Файл `validate.py` уже содержит декоратор `@validated`. Декоратор в Python — это специальная функция, которая может изменять другую функцию. Декоратор `@validated` здесь может проверять аргументы функции на соответствие их аннотациям. Аннотации в Python — это способ добавления метаданных к параметрам и возвращаемым значениям функций.

Давайте модифицируем наш код, чтобы применить этот декоратор к методам с аннотациями:

1. Сначала нам нужно понять, как работает декоратор `validated`. Откройте файл `validate.py` в вашем редакторе, чтобы ознакомиться с ним.

Декоратор `validated` использует аннотации функций для валидации аргументов. Прежде чем разрешить выполнение функции, он создает экземпляр класса валидатора для каждого аннотированного параметра и вызывает метод `validate` для проверки аргумента. Например, если аргумент аннотирован как `PositiveInteger`, декоратор создаст экземпляр `PositiveInteger` и проверит, действительно ли переданное значение является положительным целым числом. Если валидация не удалась, он собирает все ошибки и вызывает `TypeError` с подробными сообщениями об ошибках.

2. Теперь мы модифицируем функцию `validate_attributes` в `structure.py`, чтобы обернуть аннотированные методы декоратором `validated`. Это означает, что любые методы с аннотациями в классе будут автоматически проверять свои аргументы. Откройте файл `structure.py` в вашем редакторе.

3. Обновите функцию `validate_attributes`:

```python
def validate_attributes(cls):
    """
    Class decorator that:
    1. Extracts Validator instances and builds _fields and _types lists
    2. Applies @validated decorator to methods with annotations
    """
    # Import the validated decorator
    from validate import validated

    # Process validator descriptors
    validators = []
    for name, val in vars(cls).items():
        if isinstance(val, Validator):
            validators.append(val)

    # Set _fields based on validator names
    cls._fields = [val.name for val in validators]

    # Set _types based on validator expected_types
    cls._types = [getattr(val, 'expected_type', lambda x: x) for val in validators]

    # Apply @validated decorator to methods with annotations
    for name, val in vars(cls).items():
        if callable(val) and hasattr(val, '__annotations__'):
            setattr(cls, name, validated(val))

    # Create initialization method
    cls.create_init()

    return cls
```

Эта обновленная функция теперь выполняет следующее:

1. Обрабатывает дескрипторы валидаторов, как и раньше. Дескрипторы валидаторов используются для определения правил валидации для атрибутов класса.
2. Находит все методы с аннотациями в классе. Аннотации добавляются к параметрам методов для указания ожидаемого типа аргумента.
3. Применяет декоратор `@validated` к этим методам. Это гарантирует, что аргументы, передаваемые этим методам, будут валидированы в соответствии с их аннотациями.

4. Сохраните файл после внесения этих изменений. Сохранение файла важно, поскольку оно гарантирует, что наши модификации будут сохранены и могут быть использованы позже.

5. Теперь давайте обновим метод `sell` в классе `Stock`, чтобы включить аннотацию. Аннотации помогают указать ожидаемый тип аргумента, который будет использоваться декоратором `@validated` для валидации. Откройте файл `stock.py` в вашем редакторе.

6. Измените метод `sell`, чтобы включить аннотацию типа:

```python
# stock.py

from structure import Structure
from validate import String, PositiveInteger, PositiveFloat

class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares: PositiveInteger):
        self.shares -= nshares
```

Важное изменение — добавление `: PositiveInteger` к параметру `nshares`. Это указывает Python (и нашему декоратору `@validated`), чтобы валидировать этот аргумент с использованием валидатора `PositiveInteger`. Таким образом, при вызове метода `sell` аргумент `nshares` должен быть положительным целым числом.

7. Снова запустите тесты, чтобы убедиться, что все по-прежнему работает. Запуск тестов — это хороший способ убедиться, что наши изменения не нарушили существующую функциональность.

```bash
cd ~/project
python3 teststock.py
```

Вы должны увидеть, что все тесты пройдены:

```
.........
----------------------------------------------------------------------
Ran 9 tests in 0.001s

OK
```

8. Давайте протестируем нашу новую валидацию аргументов. Мы попробуем вызвать метод `sell` с допустимыми и недопустимыми аргументами, чтобы увидеть, работает ли валидация должным образом.

```bash
cd ~/project
python3 -c "
from stock import Stock
s = Stock('GOOG', 100, 490.1)
s.sell(25)
print(s)
try:
    s.sell(-25)
except Exception as e:
    print(f'Error: {e}')
"
```

Вы должны увидеть вывод, похожий на:

```
Stock('GOOG', 75, 490.1)
Error: Bad Arguments
  nshares: nshares must be >= 0
```

Это показывает, что валидация аргументов нашего метода работает! Первый вызов `sell(25)` успешен, потому что `25` — это положительное целое число. Но второй вызов `sell(-25)` завершается ошибкой, потому что `-25` не является положительным целым числом.

Теперь вы реализовали полную систему для:

1. Валидации атрибутов класса с использованием дескрипторов. Дескрипторы используются для определения правил валидации для атрибутов класса.
2. Автоматического сбора информации о полях с использованием декораторов классов. Декораторы классов могут изменять поведение класса, например, собирать информацию о полях.
3. Преобразования данных строк в экземпляры. Это полезно при работе с данными из внешних источников.
4. Валидации аргументов методов с использованием аннотаций. Аннотации помогают указать ожидаемый тип аргумента для валидации.

Это демонстрирует мощь сочетания дескрипторов и декораторов в Python для создания выразительных, самовалидирующихся классов.
