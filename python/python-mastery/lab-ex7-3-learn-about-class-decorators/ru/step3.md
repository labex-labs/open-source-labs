# Применение декораторов через наследование

Во втором шаге мы создали декоратор класса, который упрощает наш код. Декоратор класса — это особый тип функции, которая принимает класс в качестве аргумента и возвращает измененный класс. Это полезный инструмент в Python для добавления функциональности классам без изменения их исходного кода. Однако нам все еще приходится явно применять декоратор `@validate_attributes` к каждому классу. Это означает, что каждый раз, когда мы создаем новый класс, требующий валидации, нам нужно помнить о добавлении этого декоратора, что может быть несколько обременительно.

Мы можем улучшить это, автоматически применяя декоратор через наследование. Наследование — это фундаментальная концепция в объектно-ориентированном программировании, где подкласс может наследовать атрибуты и методы от родительского класса. Метод `__init_subclass__` в Python 3.6 был введен для того, чтобы родительские классы могли настраивать инициализацию подклассов. Это означает, что при создании подкласса родительский класс может выполнять над ним некоторые действия. Мы можем использовать эту функцию для автоматического применения нашего декоратора к любому классу, который наследуется от `Structure`.

Давайте реализуем это:

1. Откройте файл `structure.py` в вашем редакторе. Этот файл содержит определение класса `Structure`, и мы собираемся изменить его, чтобы использовать метод `__init_subclass__`.

2. Добавьте метод `__init_subclass__` в класс `Structure`:

```python
class Structure:
    _fields = ()
    _types = ()

    def __init__(self, *args):
        if len(args) != len(self._fields):
            raise TypeError(f'Expected {len(self._fields)} arguments')
        for name, val in zip(self._fields, args):
            setattr(self, name, val)

    def __repr__(self):
        values = ', '.join(repr(getattr(self, name)) for name in self._fields)
        return f'{type(self).__name__}({values})'

    @classmethod
    def create_init(cls):
        '''
        Create an __init__ method from _fields
        '''
        body = 'def __init__(self, %s):\n' % ', '.join(cls._fields)
        for name in cls._fields:
            body += f'    self.{name} = {name}\n'

        # Execute the function creation code
        namespace = {}
        exec(body, namespace)
        setattr(cls, '__init__', namespace['__init__'])

    @classmethod
    def __init_subclass__(cls):
        validate_attributes(cls)
```

Метод `__init_subclass__` является классовым методом, что означает, что его можно вызывать для самого класса, а не для экземпляра класса. Когда создается подкласс `Structure`, этот метод будет вызван автоматически. Внутри этого метода мы вызываем декоратор `validate_attributes` для подкласса `cls`. Таким образом, каждый подкласс `Structure` автоматически получит поведение валидации.

3. Сохраните файл.

После внесения изменений в файл `structure.py` нам нужно сохранить его, чтобы изменения были применены.

4. Теперь давайте обновим наш файл `stock.py`, чтобы воспользоваться этой новой функцией. Откройте файл `stock.py` в вашем редакторе, чтобы изменить его. Этот файл содержит определение класса `Stock`, и мы собираемся сделать его наследуемым от класса `Structure` для использования автоматического применения декоратора.

5. Измените файл `stock.py`, чтобы удалить явный декоратор:

```python
# stock.py

from structure import Structure
from validate import String, PositiveInteger, PositiveFloat

class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares):
        self.shares -= nshares
```

Обратите внимание, что мы:

- Удален импорт `validate_attributes`, поскольку нам больше не нужно импортировать его явно, так как декоратор применяется автоматически через наследование.
- Удален декоратор `@validate_attributes`, поскольку метод `__init_subclass__` в классе `Structure` позаботится о его применении.
- Код теперь полагается исключительно на наследование от `Structure` для получения поведения валидации.

6. Снова запустите тесты, чтобы убедиться, что все по-прежнему работает:

```bash
cd ~/project
python3 teststock.py
```

Запуск тестов важен, чтобы убедиться, что наши изменения ничего не сломали. Если все тесты пройдены, это означает, что автоматическое применение декоратора через наследование работает правильно.

Вы должны увидеть, что все тесты пройдены:

```
.........
----------------------------------------------------------------------
Ran 9 tests in 0.001s

OK
```

Давайте снова протестируем наш класс `Stock`, чтобы убедиться, что он работает должным образом:

```bash
cd ~/project
python3 -c "from stock import Stock; s = Stock('GOOG', 100, 490.1); print(s); print(f'Cost: {s.cost}')"
```

Эта команда создает экземпляр класса `Stock` и выводит его представление и стоимость. Если вывод соответствует ожиданиям, это означает, что класс `Stock` работает правильно с автоматическим применением декоратора.

Вывод:

```
Stock('GOOG', 100, 490.1)
Cost: 49010.0
```

Эта реализация еще чище! Используя `__init_subclass__`, мы устранили необходимость явного применения декораторов. Любой класс, наследуемый от `Structure`, автоматически получает поведение валидации.
