# Понимание основ работы с функцией exec()

В Python функция `exec()` представляет собой мощный инструмент, который позволяет выполнять код, создаваемый динамически во время выполнения программы. Это означает, что вы можете генерировать код на лету на основе определенных входных данных или конфигурации, что чрезвычайно полезно во многих сценариях программирования.

Начнем с изучения базового использования функции `exec()`. Для этого откроем оболочку Python. Откройте терминал и введите команду `python3`. Эта команда запустит интерактивный интерпретатор Python, в котором вы можете напрямую запускать Python-код.

```bash
python3
```

Теперь мы определим кусок Python-кода в виде строки и затем используем функцию `exec()` для его выполнения. Вот как это работает:

```python
>>> code = '''
for i in range(n):
    print(i, end=' ')
'''
>>> n = 10
>>> exec(code)
0 1 2 3 4 5 6 7 8 9
```

В этом примере:

1. Сначала мы определили строку с именем `code`. Эта строка содержит цикл `for` на Python. Цикл предназначен для выполнения `n` итераций и вывода номера каждой итерации.
2. Затем мы определили переменную `n` и присвоили ей значение 10. Эта переменная используется как верхняя граница для функции `range()` в нашем цикле.
3. После этого мы вызвали функцию `exec()` с аргументом в виде строки `code`. Функция `exec()` принимает строку и выполняет ее как Python-код.
4. Наконец, цикл был выполнен, и были выведены числа от 0 до 9.

Реальная мощь функции `exec()` становится более очевидной, когда мы используем ее для создания более сложных структур кода, таких как функции или методы. Попробуем более сложный пример, в котором мы динамически создадим метод `__init__()` для класса.

```python
>>> class Stock:
...     _fields = ('name', 'shares', 'price')
...
>>> argstr = ','.join(Stock._fields)
>>> code = f'def __init__(self, {argstr}):\n'
>>> for name in Stock._fields:
...     code += f'    self.{name} = {name}\n'
...
>>> print(code)
def __init__(self, name,shares,price):
    self.name = name
    self.shares = shares
    self.price = price

>>> locs = { }
>>> exec(code, locs)
>>> Stock.__init__ = locs['__init__']

>>> # Now try the class
>>> s = Stock('GOOG', 100, 490.1)
>>> s.name
'GOOG'
>>> s.shares
100
>>> s.price
490.1
```

В этом более сложном примере:

1. Сначала мы определили класс `Stock` с атрибутом `_fields`. Этот атрибут представляет собой кортеж, содержащий имена атрибутов класса.
2. Затем мы создали строку, представляющую Python-код для метода `__init__`. Этот метод используется для инициализации атрибутов объекта.
3. Далее мы использовали функцию `exec()` для выполнения строки кода. Мы также передали пустой словарь `locs` в функцию `exec()`. Полученная в результате выполнения функция сохраняется в этом словаре.
4. После этого мы присвоили функцию, хранящуюся в словаре, в качестве метода `__init__` нашего класса `Stock`.
5. Наконец, мы создали экземпляр класса `Stock` и проверили, что метод `__init__` работает правильно, обратившись к атрибутам объекта.

Этот пример демонстрирует, как функция `exec()` может быть использована для динамического создания методов на основе данных, доступных во время выполнения программы.
