# Ваш первый декоратор с аргументами

Декоратор `@logged`, который вы определили ранее, всегда просто выводит простое сообщение с именем функции. Предположим, что вы хотели, чтобы пользователь мог задавать какой-то пользовательский формат сообщения.

Определите новый декоратор `@logformat(fmt)`, который принимает строку форматирования в качестве аргумента и использует `fmt.format(func=func)` для форматирования переданной функции в сообщение для журнала:

```python
# sample.py
...
from logcall import logformat

@logformat('{func.__code__.co_filename}:{func.__name__}')
def mul(x,y):
    return x*y
```

Для этого вам нужно определить декоратор, который принимает аргумент. Вот, как это должно выглядеть при тестировании:

```python
>>> import sample
Adding logging to add
Adding logging to sub
Adding logging to mul
>>> sample.add(2,3)
Calling add
5
>>> sample.mul(2,3)
sample.py:mul
6
>>>
```

Для дальнейшего упрощения кода покажите, как можно определить исходный декоратор `@logged` с использованием декоратора `@logformat`.
