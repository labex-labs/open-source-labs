# Создание базового вызываемого объекта

В Python вызываемый объект - это объект, который можно использовать так же, как функцию. Вы можете представить его как что-то, что можно "вызвать", поставив после него скобки, аналогично тому, как вы вызываете обычную функцию. Чтобы класс в Python вел себя как вызываемый объект, нам нужно реализовать специальный метод под названием `__call__`. Этот метод автоматически вызывается, когда вы используете объект с скобками, так же, как когда вы вызываете функцию.

Начнем с модификации файла `validate.py`. Мы добавим в этот файл новый класс с именем `ValidatedFunction`, и этот класс станет нашим вызываемым объектом. Чтобы открыть файл в редакторе кода, выполните следующую команду в терминале:

```bash
code /home/labex/project/validate.py
```

После открытия файла прокрутите его до конца и добавьте следующий код:

```python
class ValidatedFunction:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print('Calling', self.func)
        result = self.func(*args, **kwargs)
        return result
```

Разберем, что делает этот код. Класс `ValidatedFunction` имеет метод `__init__`, который является конструктором. Когда вы создаете экземпляр этого класса, вы передаете в него функцию. Эта функция затем сохраняется как атрибут экземпляра с именем `self.func`.

Метод `__call__` - это ключевой элемент, который делает этот класс вызываемым. Когда вы вызываете экземпляр класса `ValidatedFunction`, метод `__call__` выполняется. Вот что он делает пошагово:

1. Он выводит сообщение, которое сообщает, какую функцию вызывают. Это полезно для отладки и понимания происходящего.
2. Он вызывает функцию, которая была сохранена в `self.func`, с аргументами, которые вы передали при вызове экземпляра. `*args` и `**kwargs` позволяют передавать любое количество позиционных и именованных аргументов.
3. Он возвращает результат вызова функции.

Теперь давайте протестируем класс `ValidatedFunction`. Мы создадим новый файл с именем `test_callable.py` для написания нашего тестового кода. Чтобы открыть этот новый файл в редакторе кода, выполните следующую команду:

```bash
code /home/labex/project/test_callable.py
```

Добавьте следующий код в файл `test_callable.py`:

```python
from validate import ValidatedFunction

def add(x, y):
    return x + y

# Wrap the add function with ValidatedFunction
validated_add = ValidatedFunction(add)

# Call the wrapped function
result = validated_add(2, 3)
print(f"Result: {result}")

# Try another call
result = validated_add(10, 20)
print(f"Result: {result}")
```

В этом коде мы сначала импортируем класс `ValidatedFunction` из файла `validate.py`. Затем мы определяем простую функцию с именем `add`, которая принимает два числа и возвращает их сумму.

Мы создаем экземпляр класса `ValidatedFunction`, передавая в него функцию `add`. Это "оборачивает" функцию `add` внутри экземпляра класса `ValidatedFunction`.

Затем мы вызываем обернутую функцию дважды, один раз с аргументами `2` и `3`, а затем с `10` и `20`. Каждый раз, когда мы вызываем обернутую функцию, метод `__call__` класса `ValidatedFunction` вызывается, который в свою очередь вызывает исходную функцию `add`.

Чтобы запустить тестовый код, выполните следующую команду в терминале:

```bash
python3 /home/labex/project/test_callable.py
```

Вы должны увидеть вывод, похожий на следующий:

```
Calling <function add at 0x7f2d1c3a9940>
Result: 5
Calling <function add at 0x7f2d1c3a9940>
Result: 30
```

Этот вывод показывает, что наш вызываемый объект работает как ожидается. Когда мы вызываем `validated_add(2, 3)`, на самом деле вызывается метод `__call__` класса `ValidatedFunction`, который затем вызывает исходную функцию `add`.

Прямо сейчас наш класс `ValidatedFunction` просто выводит сообщение и передает вызов исходной функции. На следующем этапе мы улучшим этот класс, чтобы он выполнял валидацию типов на основе аннотаций функции.
