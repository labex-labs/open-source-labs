# Понимание валидаторных классов

В этом практическом занятии (лабораторной работе) мы будем использовать набор валидаторных классов для создания вызываемого объекта. Прежде чем приступить к созданию, важно понять валидаторные классы, предоставленные в файле `validate.py`. Эти классы помогут нам выполнять проверку типов, что является важной частью обеспечения корректной работы нашего кода.

Начнем с открытия файла `validate.py` в WebIDE. Этот файл содержит код валидаторных классов, которые мы будем использовать. Чтобы открыть его, выполните следующую команду в терминале:

```bash
code /home/labex/project/validate.py
```

После открытия файла вы увидите, что он содержит несколько классов. Вот краткое описание того, что делает каждый класс:

1. `Validator`: Это базовый класс. Он имеет метод `check`, но в настоящее время этот метод ничего не делает. Он служит отправной точкой для других валидаторных классов.
2. `Typed`: Это подкласс `Validator`. Его основная задача - проверить, является ли значение определенного типа.
3. `Integer`, `Float` и `String`: Это конкретные валидаторы типов, которые наследуются от `Typed`. Они предназначены для проверки, является ли значение целым числом, числом с плавающей точкой или строкой соответственно.

Теперь давайте посмотрим, как эти валидаторные классы работают на практике. Мы создадим новый файл с именем `test.py` для их тестирования. Чтобы создать и открыть этот файл, выполните следующую команду:

```bash
code /home/labex/project/test.py
```

После открытия файла `test.py` добавьте в него следующий код. Этот код будет тестировать валидаторы `Integer` и `String`:

```python
from validate import Integer, String, Float

# Test Integer validator
print("Testing Integer validator:")
try:
    Integer.check(42)
    print("✓ Integer check passed for 42")
except TypeError as e:
    print(f"✗ Error: {e}")

try:
    Integer.check("Hello")
    print("✗ Integer check incorrectly passed for 'Hello'")
except TypeError as e:
    print(f"✓ Correctly raised error: {e}")

# Test String validator
print("\nTesting String validator:")
try:
    String.check("Hello")
    print("✓ String check passed for 'Hello'")
except TypeError as e:
    print(f"✗ Error: {e}")
```

В этом коде мы сначала импортируем валидаторы `Integer`, `String` и `Float` из файла `validate.py`. Затем мы тестируем валидатор `Integer`, пытаясь проверить целочисленное значение (`42`) и строковое значение (`"Hello"`). Если проверка проходит для целого числа, мы выводим сообщение об успехе. Если проверка проходит ошибочно для строки, мы выводим сообщение об ошибке. Если проверка правильно вызывает исключение `TypeError` для строки, мы выводим сообщение об успехе. Мы выполняем аналогичный тест для валидатора `String`.

После добавления кода запустите тестовый файл, используя следующую команду:

```bash
python3 /home/labex/project/test.py
```

Вы должны увидеть вывод, похожий на следующий:

```
Testing Integer validator:
✓ Integer check passed for 42
✓ Correctly raised error: Expected <class 'int'>

Testing String validator:
✓ String check passed for 'Hello'
```

Как вы можете видеть, эти валидаторные классы позволяют нам легко выполнять проверку типов. Например, когда вы вызываете `Integer.check(x)`, он вызовет исключение `TypeError`, если `x` не является целым числом.

Теперь давайте подумаем о практическом сценарии. Предположим, у нас есть функция, которая требует, чтобы ее аргументы были определенного типа. Вот пример такой функции:

```python
def add(x, y):
    Integer.check(x)  # Make sure x is an integer
    Integer.check(y)  # Make sure y is an integer
    return x + y
```

Эта функция работает, но есть проблема. Мы должны вручную добавлять проверки валидаторов каждый раз, когда хотим использовать проверку типов. Это может быть затратным по времени и ошибочным, особенно для более крупных функций или проектов.

В следующих шагах мы решим эту проблему, создав вызываемый объект. Этот объект сможет автоматически применять эти проверки типов на основе аннотаций функций. Таким образом, нам не придется добавлять проверки вручную каждый раз.
