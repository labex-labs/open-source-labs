# Understanding the `yield from` Statement

In this step, we're going to explore the `yield from` statement in Python. This statement is a powerful tool when working with generators, and it simplifies the process of delegating operations to other generators. By the end of this step, you'll understand what `yield from` is, how it works, and how it can handle value passing between different generators.

## What is `yield from`?

The `yield from` statement was introduced in Python 3.3. Its main purpose is to simplify the delegation of operations to subgenerators. A subgenerator is just another generator that a main generator can delegate work to.

Normally, when you want a generator to yield values from another generator, you'd have to use a loop. For example, without `yield from`, you'd write code like this:

```python
def delegating_generator():
    for value in subgenerator():
        yield value
```

In this code, the `delegating_generator` uses a `for` loop to iterate over the values produced by `subgenerator` and then yields each value one by one.

However, with the `yield from` statement, the code becomes much simpler:

```python
def delegating_generator():
    yield from subgenerator()
```

This single line of code achieves the same result as the loop in the previous example. But `yield from` is not just a shortcut. It also manages the bidirectional communication between the caller and the subgenerator. This means that any values sent to the delegating generator are passed directly to the subgenerator.

## Basic Example

Let's create a simple example to see how `yield from` works in action.

1. First, we need to open the `cofollow.py` file in the editor. To do this, we'll use the `cd` command to navigate to the correct directory. Run the following command in the terminal:

```bash
cd /home/labex/project
```

2. Next, we'll add two functions to the `cofollow.py` file. The `subgen` function is a simple generator that yields the numbers from 0 to 4. The `main_gen` function uses `yield from` to delegate the generation of these numbers to `subgen` and then yields the string `'Done'`. Add the following code to the end of the `cofollow.py` file:

```python
def subgen():
    for i in range(5):
        yield i

def main_gen():
    yield from subgen()
    yield 'Done'
```

3. Now, let's test these functions. Open a Python shell and run the following code:

```python
from cofollow import subgen, main_gen

# Test subgen directly
for x in subgen():
    print(x)

# Test main_gen that delegates to subgen
for x in main_gen():
    print(x)
```

When you run this code, you should see the following output:

```
0
1
2
3
4

0
1
2
3
4
Done
```

This output shows that `yield from` allows `main_gen` to pass all the values generated by `subgen` directly to the caller.

## Value Passing with `yield from`

One of the most powerful features of `yield from` is its ability to handle value passing in both directions. Let's create a more complex example to demonstrate this.

1. Add the following functions to the `cofollow.py` file:

```python
def accumulator():
    total = 0
    while True:
        value = yield total
        if value is None:
            break
        total += value

def caller():
    acc = accumulator()
    yield from acc
    yield 'Total accumulated'
```

The `accumulator` function is a coroutine that keeps track of a running total. It yields the current total and then waits to receive a new value. If it receives `None`, it stops the loop. The `caller` function creates an instance of `accumulator` and uses `yield from` to delegate all send and receive operations to it.

2. Test these functions in a Python shell:

```python
from cofollow import caller

c = caller()
print(next(c))  # Start the coroutine
print(c.send(1))  # Send value 1, get accumulated value
print(c.send(2))  # Send value 2, get accumulated value
print(c.send(3))  # Send value 3, get accumulated value
print(c.send(None))  # Send None to exit the accumulator
```

When you run this code, you should see the following output:

```
0
1
3
6
'Total accumulated'
```

This output shows that `yield from` fully delegates all send and receive operations to the subgenerator until it's exhausted.

Now that you understand the basics of `yield from`, we'll move on to more practical applications in the next step.
