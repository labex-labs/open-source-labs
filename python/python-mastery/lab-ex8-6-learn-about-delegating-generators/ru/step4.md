# От генераторов к async/await

На этом последнем этапе мы рассмотрим, как паттерн `yield from` в Python превратился в современный синтаксис `async`/`await`. Понимание этого эволюционного процесса крайне важно, так как оно помогает увидеть связь между генераторами и асинхронным программированием. Асинхронное программирование позволяет вашему приложению обрабатывать несколько задач одновременно, не дожидаясь завершения каждой из них, что особенно полезно в сетевом программировании и других операциях, ограниченных вводом-выводом (I/O).

## Связь между генераторами и async/await

Синтаксис `async`/`await`, введенный в Python 3.5, основан на функциональности генераторов и оператора `yield from`. По сути, `async`-функции реализуются с использованием генераторов. Это означает, что концепции, которые вы узнали о генераторах, напрямую связаны с тем, как работает `async`/`await`.

Для перехода от использования генераторов к синтаксису `async`/`await` нам нужно выполнить следующие шаги:

1. Использовать декоратор `@coroutine` из модуля `types`. Этот декоратор помогает преобразовать функции, основанные на генераторах, в форму, которая может использоваться с `async`/`await`.
2. Преобразовать функции, использующие `yield from`, на использование `async` и `await` вместо этого. Это делает код более читаемым и лучше выражает асинхронную природу операций.
3. Обновить цикл событий для обработки нативных корутин. Цикл событий отвечает за планирование и выполнение асинхронных задач.

## Обновление класса GenSocket

Теперь давайте модифицируем наш класс `GenSocket` для работы с декоратором `@coroutine`. Это позволит нашему классу использоваться в контексте `async`/`await`.

1. Откройте файл `server.py` в редакторе. Вы можете сделать это, выполнив следующую команду в терминале:

```bash
cd /home/labex/project
```

2. В начале файла `server.py` добавьте импорт `coroutine`. Этот импорт необходим для использования декоратора `@coroutine`.

```python
from types import coroutine
```

3. Обновите класс `GenSocket` для использования декоратора `@coroutine`. Этот декоратор преобразует наши методы, основанные на генераторах, в ожидаемые корутины, что означает, что они могут использоваться с ключевым словом `await`.

```python
class GenSocket:
    """
    A generator-based wrapper for socket operations
    that works with async/await.
    """
    def __init__(self, sock):
        self.sock = sock

    @coroutine
    def accept(self):
        """Accept a connection and return a new GenSocket"""
        yield 'recv', self.sock
        client, addr = self.sock.accept()
        return GenSocket(client), addr

    @coroutine
    def recv(self, maxsize):
        """Receive data from the socket"""
        yield 'recv', self.sock
        return self.sock.recv(maxsize)

    @coroutine
    def send(self, data):
        """Send data to the socket"""
        yield 'send', self.sock
        return self.sock.send(data)

    def __getattr__(self, name):
        """Forward any other attributes to the underlying socket"""
        return getattr(self.sock, name)
```

## Преобразование к синтаксису async/await

Далее, давайте преобразуем наш серверный код для использования синтаксиса `async`/`await`. Это сделает код более читаемым и ясно выражает асинхронную природу операций.

```python
async def tcp_server(address, handler):
    """
    An asynchronous TCP server using async/await.
    """
    sock = GenSocket(socket(AF_INET, SOCK_STREAM))
    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    sock.bind(address)
    sock.listen(5)
    while True:
        client, addr = await sock.accept()
        tasks.append(handler(client, addr))

async def echo_handler(client, address):
    """
    An asynchronous handler for echo clients.
    """
    print('Connection from', address)
    while True:
        data = await client.recv(1000)
        if not data:
            break
        await client.send(b'GOT:' + data)
    print('Connection closed')
    client.close()
```

Обратите внимание, что `yield from` заменено на `await`, и функции теперь определяются с помощью `async def` вместо `def`. Это изменение делает код более интуитивно понятным и легким для понимания.

## Понимание преобразования

Переход от генераторов с `yield from` к синтаксису `async`/`await` не является просто простым синтаксическим изменением. Он представляет собой сдвиг в том, как мы думаем о асинхронном программировании.

1. **Генераторы с yield from**:

   - При использовании генераторов с `yield from` вы явно передаете управление, чтобы сигнализировать, что задача готова. Это означает, что вы должны вручную управлять тем, когда задача может продолжиться.
   - Вам также нужно вручную управлять планированием задач. Это может быть сложно, особенно в более крупных программах.
   - Основное внимание уделяется механике управления потоком выполнения, что может сделать код труднее для чтения и поддержки.

2. **Синтаксис async/await**:
   - С синтаксисом `async`/`await` управление неявно передается в точках `await`. Это делает код более простым, так как вам не нужно беспокоиться о явном передаче управления.
   - Цикл событий заботится о планировании задач, поэтому вам не нужно управлять этим вручную.
   - Основное внимание уделяется логическому потоку программы, что делает код более читаемым и поддерживаемым.

Это преобразование позволяет создавать более читаемый и поддерживаемый асинхронный код, что особенно важно для сложных приложений, таких как сетевые серверы.

## Современное асинхронное программирование

В современном Python обычно используется модуль `asyncio` для асинхронного программирования вместо собственного цикла событий. Модуль `asyncio` предоставляет встроенную поддержку многих полезных функций:

- Запуск нескольких корутин одновременно. Это позволяет вашему приложению обрабатывать несколько задач одновременно.
- Управление сетевым вводом-выводом. Он упрощает процесс отправки и получения данных по сети.
- Примитивы синхронизации. Они помогают управлять доступом к общими ресурсам в многопоточном окружении.
- Планирование и отмену задач. Вы можете легко запланировать выполнение задач в определенное время и отменить их при необходимости.

Вот как может выглядеть наш сервер с использованием `asyncio`:

```python
import asyncio

async def handle_client(reader, writer):
    addr = writer.get_extra_info('peername')
    print(f'Connection from {addr}')

    while True:
        data = await reader.read(1000)
        if not data:
            break

        writer.write(b'GOT:' + data)
        await writer.drain()

    print('Connection closed')
    writer.close()
    await writer.wait_closed()

async def main():
    server = await asyncio.start_server(
        handle_client, 'localhost', 25000
    )

    addr = server.sockets[0].getsockname()
    print(f'Serving on {addr}')

    async with server:
        await server.serve_forever()

if __name__ == '__main__':
    asyncio.run(main())
```

Этот код реализует ту же функциональность, что и наш сервер на основе генераторов, но использует стандартную библиотеку `asyncio`, которая более надежная и богатая по функционалу.

## Заключение

В этом практическом занятии вы узнали о нескольких важных концепциях:

1. Оператор `yield from` и то, как он делегирует выполнение другому генератору. Это фундаментальная концепция для понимания работы генераторов.
2. Как использовать `yield from` с корутинами для передачи сообщений. Это позволяет вам обмениваться данными между различными частями вашего асинхронного приложения.
3. Оборачивание операций с сокетами с использованием генераторов для более чистого кода. Это делает ваш сетевой код более организованным и легким для понимания.
4. Переход от генераторов к современному синтаксису `async`/`await`. Понимание этого перехода поможет вам писать более читаемый и поддерживаемый асинхронный код на Python, будь то использование генераторов напрямую или современного синтаксиса `async`/`await`.
