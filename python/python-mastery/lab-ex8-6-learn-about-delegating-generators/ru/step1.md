# Понимание оператора `yield from`

На этом этапе мы рассмотрим оператор `yield from` в Python. Этот оператор представляет собой мощный инструмент при работе с генераторами и упрощает процесс делегирования операций другим генераторам. К концу этого этапа вы поймете, что такое `yield from`, как он работает и как он может обрабатывать передачу значений между разными генераторами.

## Что такое `yield from`?

Оператор `yield from` был введен в Python 3.3. Его основная цель - упростить делегирование операций подгенераторам. Подгенератор - это просто другой генератор, которому основной генератор может делегировать работу.

Обычно, когда вы хотите, чтобы генератор возвращал значения из другого генератора, вам приходится использовать цикл. Например, без `yield from` вы бы написали код следующим образом:

```python
def delegating_generator():
    for value in subgenerator():
        yield value
```

В этом коде `delegating_generator` использует цикл `for` для перебора значений, генерируемых `subgenerator`, и затем возвращает каждое значение по очереди.

Однако с использованием оператора `yield from` код становится намного проще:

```python
def delegating_generator():
    yield from subgenerator()
```

Эта одна строка кода дает тот же результат, что и цикл в предыдущем примере. Но `yield from` не просто сокращенная запись. Он также управляет двусторонней связью между вызывающим кодом и подгенератором. Это означает, что любые значения, отправленные в делегирующий генератор, передаются непосредственно в подгенератор.

## Простой пример

Создадим простой пример, чтобы увидеть, как работает `yield from` на практике.

1. Сначала нам нужно открыть файл `cofollow.py` в редакторе. Для этого мы используем команду `cd` для перехода в правильную директорию. Выполните следующую команду в терминале:

```bash
cd /home/labex/project
```

2. Затем мы добавим две функции в файл `cofollow.py`. Функция `subgen` - это простой генератор, который возвращает числа от 0 до 4. Функция `main_gen` использует `yield from` для делегирования генерации этих чисел `subgen` и затем возвращает строку `'Done'`. Добавьте следующий код в конец файла `cofollow.py`:

```python
def subgen():
    for i in range(5):
        yield i

def main_gen():
    yield from subgen()
    yield 'Done'
```

3. Теперь протестируем эти функции. Откройте оболочку Python и выполните следующий код:

```python
from cofollow import subgen, main_gen

# Test subgen directly
for x in subgen():
    print(x)

# Test main_gen that delegates to subgen
for x in main_gen():
    print(x)
```

При выполнении этого кода вы должны увидеть следующий вывод:

```
0
1
2
3
4

0
1
2
3
4
Done
```

Этот вывод показывает, что `yield from` позволяет `main_gen` передавать все значения, сгенерированные `subgen`, непосредственно вызывающему коду.

## Передача значений с использованием `yield from`

Одна из самых мощных возможностей `yield from` - это его способность обрабатывать передачу значений в обоих направлениях. Создадим более сложный пример, чтобы продемонстрировать это.

1. Добавьте следующие функции в файл `cofollow.py`:

```python
def accumulator():
    total = 0
    while True:
        value = yield total
        if value is None:
            break
        total += value

def caller():
    acc = accumulator()
    yield from acc
    yield 'Total accumulated'
```

Функция `accumulator` - это корутина, которая отслеживает текущую сумму. Она возвращает текущую сумму и затем ожидает получения нового значения. Если она получает `None`, то останавливает цикл. Функция `caller` создает экземпляр `accumulator` и использует `yield from` для делегирования всех операций отправки и приема значений ему.

2. Протестируйте эти функции в оболочке Python:

```python
from cofollow import caller

c = caller()
print(next(c))  # Start the coroutine
print(c.send(1))  # Send value 1, get accumulated value
print(c.send(2))  # Send value 2, get accumulated value
print(c.send(3))  # Send value 3, get accumulated value
print(c.send(None))  # Send None to exit the accumulator
```

При выполнении этого кода вы должны увидеть следующий вывод:

```
0
1
3
6
'Total accumulated'
```

Этот вывод показывает, что `yield from` полностью делегирует все операции отправки и приема значений подгенератору до тех пор, пока он не исчерпает все значения.

Теперь, когда вы понимаете основы `yield from`, мы перейдем к более практическим применениям на следующем этапе.
