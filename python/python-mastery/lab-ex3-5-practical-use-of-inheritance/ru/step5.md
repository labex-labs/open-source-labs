# Создание фабричной функции

При использовании наследования одной из распространенных проблем является то, что пользователям приходится помнить имена конкретных классов форматеров. Это может быть довольно утомительно, особенно по мере увеличения количества классов. Чтобы упростить этот процесс, мы можем создать фабричную функцию. Фабричная функция представляет собой особый тип функции, которая создает и возвращает объекты. В нашем случае она будет возвращать соответствующий форматер на основе простого имени формата.

Добавим следующую функцию в файл `tableformat.py`. Эта функция будет принимать имя формата в качестве аргумента и возвращать соответствующий объект форматера.

```python
def create_formatter(format_name):
    """
    Create a formatter of the specified type.

    Args:
        format_name: Name of the formatter ('text', 'csv', 'html')

    Returns:
        A TableFormatter object

    Raises:
        ValueError: If format_name is not recognized
    """
    if format_name == 'text':
        return TextTableFormatter()
    elif format_name == 'csv':
        return CSVTableFormatter()
    elif format_name == 'html':
        return HTMLTableFormatter()
    else:
        raise ValueError(f'Unknown format {format_name}')
```

Функция `create_formatter()` является фабричной функцией. Она проверяет аргумент `format_name`, который вы предоставляете. Если он равен 'text', она создает и возвращает объект `TextTableFormatter`. Если он равен 'csv', она возвращает объект `CSVTableFormatter`, а если он равен 'html', то возвращает объект `HTMLTableFormatter`. Если имя формата не распознается, функция вызывает исключение `ValueError`. Таким образом, пользователи могут легко выбрать форматер, просто указав простое имя, не зная конкретных имен классов.

Теперь протестируем фабричную функцию. Мы будем использовать некоторые существующие функции и классы для чтения данных из CSV - файла и вывода их в разных форматах.

```python
import stock
import reader
from tableformat import create_formatter, print_table

portfolio = reader.read_csv_as_instances('portfolio.csv', stock.Stock)

# Test with text formatter
formatter = create_formatter('text')
print("\nText Format:")
print_table(portfolio, ['name', 'shares', 'price'], formatter)

# Test with CSV formatter
formatter = create_formatter('csv')
print("\nCSV Format:")
print_table(portfolio, ['name', 'shares', 'price'], formatter)

# Test with HTML formatter
formatter = create_formatter('html')
print("\nHTML Format:")
print_table(portfolio, ['name', 'shares', 'price'], formatter)
```

В этом коде мы сначала импортируем необходимые модули и функции. Затем мы читаем данные из файла `portfolio.csv` и создаем объект `portfolio`. После этого мы тестируем функцию `create_formatter()` с разными именами форматов: 'text', 'csv' и 'html'. Для каждого формата мы создаем объект форматера, выводим имя формата, а затем используем функцию `print_table()` для вывода данных из `portfolio` в указанном формате.

При запуске этого кода вы должны увидеть вывод в трех форматах, разделенных именами форматов:

```
Text Format:
      name     shares      price
---------- ---------- ----------
        AA        100       32.2
       IBM         50       91.1
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50       65.1
       IBM        100      70.44

CSV Format:
name,shares,price
AA,100,32.2
IBM,50,91.1
CAT,150,83.44
MSFT,200,51.23
GE,95,40.37
MSFT,50,65.1
IBM,100,70.44

HTML Format:
<tr> <th>name</th> <th>shares</th> <th>price</th> </tr>
<tr> <td>AA</td> <td>100</td> <td>32.2</td> </tr>
<tr> <td>IBM</td> <td>50</td> <td>91.1</td> </tr>
<tr> <td>CAT</td> <td>150</td> <td>83.44</td> </tr>
<tr> <td>MSFT</td> <td>200</td> <td>51.23</td> </tr>
<tr> <td>GE</td> <td>95</td> <td>40.37</td> </tr>
<tr> <td>MSFT</td> <td>50</td> <td>65.1</td> </tr>
<tr> <td>IBM</td> <td>100</td> <td>70.44</td> </tr>
```

Фабричная функция делает код более удобным для пользователя, так как скрывает детали создания экземпляров классов. Пользователям не нужно знать, как создавать объекты форматеров; им нужно только указать желаемый формат.

Эта модель использования фабричной функции для создания объектов представляет собой распространенную шаблон проектирования в объектно - ориентированном программировании, известный как Фабричный шаблон (Factory Pattern). Он обеспечивает уровень абстракции между клиентским кодом (кодом, который использует форматер) и фактическими классами реализации (классами форматеров). Это делает код более модульным и легким в использовании.

**Обзор ключевых концепций:**

1. **Абстрактный базовый класс**: Класс `TableFormatter` служит в качестве интерфейса. Интерфейс определяет набор методов, которые должны иметь все классы, реализующие его. В нашем случае все классы форматеров должны реализовать методы, определенные в классе `TableFormatter`.

2. **Наследование**: Конкретные классы форматеров, такие как `TextTableFormatter`, `CSVTableFormatter` и `HTMLTableFormatter`, наследуются от базового класса `TableFormatter`. Это означает, что они получают базовую структуру и методы от базового класса и могут предоставлять свои собственные конкретные реализации.

3. **Полиморфизм**: Функция `print_table()` может работать с любым форматером, реализующим необходимый интерфейс. Это означает, что вы можете передать разные объекты форматеров в функцию `print_table()`, и она будет работать корректно с каждым из них.

4. **Фабричный шаблон**: Функция `create_formatter()` упрощает создание объектов форматеров. Она заботится о деталях создания правильного объекта на основе имени формата, так что пользователям не нужно об этом беспокоиться.

Используя эти объектно - ориентированные принципы, мы создали гибкую и расширяемую систему для форматирования табличных данных в различных форматах вывода.
