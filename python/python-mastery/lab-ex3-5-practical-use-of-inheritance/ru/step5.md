# Упрощение выбора

Одна проблема при использовании наследования - это дополнительная сложность выбора разных классов для использования (например, запоминание имен, использование правильных инструкций `import` и т.д.). Фабричная функция может упростить это. Добавьте функцию `create_formatter()` в файл `tableformat.py`, которая позволит пользователю更容易地通过指定格式（如 `'text'`、`'csv'` 或 `'html'`）创建格式化器。例如：

```python
>>> from tableformat import create_formatter, print_table
>>> formatter = create_formatter('html')
>>> print_table(portfolio, ['name','shares','price'], formatter)
<tr> <th>name</th> <th>shares</th> <th>price</th> </tr>
<tr> <td>AA</td> <td>100</td> <td>32.2</td> </tr>
<tr> <td>IBM</td> <td>50</td> <td>91.1</td> </tr>
<tr> <td>CAT</td> <td>150</td> <td>83.44</td> </tr>
<tr> <td>MSFT</td> <td>200</td> <td>51.23</td> </tr>
<tr> <td>GE</td> <td>95</td> <td>40.37</td> </tr>
<tr> <td>MSFT</td> <td>50</td> <td>65.1</td> </tr>
<tr> <td>IBM</td> <td>100</td> <td>70.44</td> </tr>
>>>
```

**Обсуждение**

Класс `TableFormatter` в этом упражнении является примером того, что называется "абстрактным базовым классом". Это не что-то, что предназначено для прямого использования. Вместо этого оно служит как определение интерфейса для компонента программы - в данном случае для различных форматов вывода. По существу, код, который генерирует таблицу, будет написан с использованием абстрактного базового класса с ожиданием, что пользователь предоставит соответствующую реализацию. Пока все необходимые методы будут реализованы, все должно просто "работать" (давайте надеемся).
