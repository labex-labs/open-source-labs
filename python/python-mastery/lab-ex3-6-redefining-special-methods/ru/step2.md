# Сравнение объектов с использованием `__eq__`

В Python, когда вы используете оператор `==` для сравнения двух объектов, Python на самом деле вызывает специальный метод `__eq__`. По умолчанию этот метод сравнивает идентификаторы объектов, то есть проверяет, хранятся ли они по одному и тому же адресу в памяти, а не сравнивает их содержимое.

Давайте рассмотрим пример. Предположим, у нас есть класс `Stock`, и мы создаем два объекта этого класса с одинаковыми значениями. Затем мы пытаемся сравнить их с помощью оператора `==`. Вот как это можно сделать в интерпретаторе Python:

Сначала запустите интерпретатор Python, выполнив следующую команду в терминале:

```bash
python3
```

Затем в интерпретаторе Python выполните следующий код:

```python
>>> import stock
>>> a = stock.Stock('GOOG', 100, 490.1)
>>> b = stock.Stock('GOOG', 100, 490.1)
>>> a == b
False
```

Как вы видите, даже несмотря на то, что два объекта `Stock` `a` и `b` имеют одинаковые значения своих атрибутов (`name`, `shares` и `price`), Python считает их разными объектами, потому что они хранятся по разным адресам в памяти.

Чтобы исправить эту проблему, мы можем реализовать метод `__eq__` в нашем классе `Stock`. Этот метод будет вызываться каждый раз, когда на объектах класса `Stock` используется оператор `==`.

Теперь откройте файл `stock.py` снова. Внутри класса `Stock` добавьте следующий метод `__eq__`:

```python
def __eq__(self, other):
    return isinstance(other, Stock) and ((self.name, self.shares, self.price) ==
                                         (other.name, other.shares, other.price))
```

Разберем, что делает этот метод:

1. Сначала он использует функцию `isinstance` для проверки, является ли объект `other` экземпляром класса `Stock`. Это важно, потому что мы хотим сравнивать объекты `Stock` только с другими объектами `Stock`.
2. Если `other` является объектом `Stock`, то он сравнивает атрибуты (`name`, `shares` и `price`) как объекта `self`, так и объекта `other`.
3. Он возвращает `True` только в том случае, если оба объекта являются экземплярами `Stock` и их атрибуты идентичны.

После добавления метода `__eq__` ваш полный класс `Stock` должен выглядеть следующим образом:

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    def cost(self):
        return self.shares * self.price

    def sell(self, shares):
        self.shares -= shares

    def __repr__(self):
        return f"Stock('{self.name}', {self.shares}, {self.price})"

    def __eq__(self, other):
        return isinstance(other, Stock) and ((self.name, self.shares, self.price) ==
                                             (other.name, other.shares, other.price))
```

Теперь давайте протестируем наш улучшенный класс `Stock`. Запустите интерпретатор Python снова:

```bash
python3
```

Затем выполните следующий код в интерпретаторе Python:

```python
>>> import stock
>>> a = stock.Stock('GOOG', 100, 490.1)
>>> b = stock.Stock('GOOG', 100, 490.1)
>>> a == b
True
>>> c = stock.Stock('GOOG', 200, 490.1)
>>> a == c
False
```

Отлично! Теперь наши объекты `Stock` можно корректно сравнивать по их содержимому, а не по адресам в памяти.

Проверка `isinstance` в методе `__eq__` является важной. Она гарантирует, что мы сравниваем только объекты `Stock`. Если бы этой проверки не было, сравнение объекта `Stock` с чем-то, что не является объектом `Stock`, могло бы вызвать ошибки.

После завершения тестирования вы можете выйти из интерпретатора Python, выполнив следующую команду:

```python
>>> exit()
```
