# 継承の代替手段としての委任

委任は時々継承の代替手段として使用されます。その考え方は、(b)の部分で定義したプロキシクラスとほぼ同じです。次のクラスを定義してみてください。

```python
>>> class Spam:
        def a(self):
            print('Spam.a')
        def b(self):
            print('Spam.b')

>>>
```

次に、それをラップして一部のメソッドを再定義するクラスを作成します。

```python
>>> class MySpam:
        def __init__(self):
            self._spam = Spam()
        def a(self):
            print('MySpam.a')
            self._spam.a()
        def c(self):
            print('MySpam.c')
        def __getattr__(self, name):
            return getattr(self._spam, name)

>>> s = MySpam()
>>> s.a()
MySpam.a
Spam.a
>>> s.b()
Spam.b
>>> s.c()
MySpam.c
>>>
```

結果として得られるクラスが継承に似ていることに注意してください。たとえば、`a()` メソッドは `super()` 呼び出しと似たことをしています。`b()` メソッドは内部に保持されている `Spam` インスタンスに委任する `__getattr__()` メソッドを介して取得されます。

**考察**

`__getattr__()` メソッドは、他のオブジェクトのラッパーとして機能するクラスで一般的に定義されます。ただし、このように他のオブジェクトをラップするプロセスは、しばしば他の複雑さをもたらすことに注意する必要があります。たとえば、アプリケーションの他の部分が `isinstance()` 関数を使用している場合、ラッパー オブジェクトが型チェックを破壊する可能性があります。

`__getattr__()` を通じてメソッドを委任すると、`__getitem__()`、`__enter__()` などの特殊メソッドでは機能しません。クラスがこのようなメソッドを大量に使用する場合、ラッパー クラスにも同様の関数を提供する必要があります。
