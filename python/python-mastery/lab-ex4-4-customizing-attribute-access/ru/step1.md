# Slots vs. setattr

В предыдущих упражнениях использовалось `__slots__`, чтобы перечислить атрибуты экземпляра в классе. Основная цель slots - оптимизировать использование памяти. Второстепенный эффект - это то, что он строго ограничивает допустимые атрибуты только перечисленным. Недостаток slots заключается в том, что он часто взаимодействует странно с другими частями Python (например, классы, использующие slots, не могут использоваться с множественным наследованием). В связи с этим вы на самом деле не должны использовать slots, кроме особых случаев.

Если вы действительно хотели ограничить набор допустимых атрибутов, альтернативным способом этого было бы определить метод `__setattr__()`. Попробуйте этот эксперимент:

```python
>>> class Stock:
        def __init__(self, name, shares, price):
            self.name = name
            self.shares = shares
            self.price = price
        def __setattr__(self, name, value):
            if name not in { 'name','shares', 'price' }:
                raise AttributeError('No attribute %s' % name)
            super().__setattr__(name, value)

>>> s = Stock('GOOG', 100, 490.1)
>>> s.name
'GOOG'
>>> s.shares = 75
>>> s.share = 50
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 8, in __setattr__
AttributeError: No attribute share
>>>
```

В этом примере нет slots, но метод `__setattr__()` по-прежнему ограничивает атрибуты только теми, которые находятся в заранее определенном наборе. Возможно, вам придется подумать, как этот подход может взаимодействовать с наследованием (например, если подклассы хотели добавить новые атрибуты, они, вероятно, должны были бы переопределить `__setattr__()`, чтобы он работал).
