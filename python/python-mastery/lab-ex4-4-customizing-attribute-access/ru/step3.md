# Делегирование в качестве альтернативы наследованию

Делегирование иногда используется в качестве альтернативы наследованию. В идее оно почти такое же, как и класс-заместитель, который вы определили в части (b). Попробуйте определить следующий класс:

```python
>>> class Spam:
        def a(self):
            print('Spam.a')
        def b(self):
            print('Spam.b')

>>>
```

Теперь создайте класс, который оборачивает его и переопределяет некоторые методы:

```python
>>> class MySpam:
        def __init__(self):
            self._spam = Spam()
        def a(self):
            print('MySpam.a')
            self._spam.a()
        def c(self):
            print('MySpam.c')
        def __getattr__(self, name):
            return getattr(self._spam, name)

>>> s = MySpam()
>>> s.a()
MySpam.a
Spam.a
>>> s.b()
Spam.b
>>> s.c()
MySpam.c
>>>
```

Обратите внимание, что результирующий класс выглядит очень похож на наследование. Например, метод `a()` делает что-то похожее на вызов `super()`. Метод `b()` подбирается через метод `__getattr__()`, который делегирует внутреннему экземпляру `Spam`.

**Обсуждение**

Метод `__getattr__()` обычно определяется в классах, которые действуют как обертки вокруг других объектов. Однако, вы должны знать, что процесс оборачивания другого объекта таким образом часто приводит к другим сложностям. Например, обертка может нарушить проверку типа, если любая другая часть приложения использует функцию `isinstance()`.

Делегирование методов через `__getattr__()` также не работает с специальными методами, такими как `__getitem__()`, `__enter__()` и т.д. Если класс широко использует такие методы, вам придется предоставить аналогичные функции в вашем классе-обертке.
