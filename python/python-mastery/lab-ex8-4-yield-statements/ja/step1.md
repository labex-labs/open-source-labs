# ジェネレータのライフタイムとクロージャの理解

このステップでは、Python のジェネレータのライフタイムを調べ、適切にクローズする方法を学びます。Python のジェネレータは、特別な種類のイテレータで、一度にすべての値を計算してメモリに格納するのではなく、必要に応じて値のシーケンスを生成することができます。これは、大規模なデータセットや無限シーケンスを扱う場合に非常に便利です。

## `follow()` ジェネレータとは？

まず、プロジェクトディレクトリ内の `follow.py` ファイルを見てみましょう。このファイルには、`follow()` という名前のジェネレータ関数が含まれています。ジェネレータ関数は通常の関数のように定義されますが、`return` キーワードの代わりに `yield` を使用します。ジェネレータ関数が呼び出されると、ジェネレータオブジェクトが返され、これを反復処理することで、生成される値を取得できます。

`follow()` ジェネレータ関数は、ファイルから行を継続的に読み取り、読み取った各行を生成します。これは、新しい行を継続的に監視する Unix の `tail -f` コマンドに似ています。

WebIDE エディタで `follow.py` ファイルを開きます。

```python
import os
import time

def follow(filename):
    with open(filename,'r') as f:
        f.seek(0,os.SEEK_END)
        while True:
            line = f.readline()
            if line == '':
                time.sleep(0.1)    # Sleep briefly to avoid busy wait
                continue
            yield line
```

このコードでは、`with open(filename, 'r') as f` 文がファイルを読み取りモードで開き、ブロックを抜けるときに適切に閉じることを保証します。`f.seek(0, os.SEEK_END)` 行は、ファイルポインタをファイルの末尾に移動させるため、ジェネレータは末尾から読み取りを開始します。`while True` ループは、ファイルから行を継続的に読み取ります。行が空の場合、まだ新しい行がないことを意味するので、プログラムは 0.1 秒間スリープしてビジーウェイトを避け、次の反復に進みます。行が空でない場合、その行が生成されます。

このジェネレータは無限ループで実行されます。これにより、重要な質問が生じます。ジェネレータの使用を停止する場合、または早期に終了させたい場合、何が起こるのでしょうか？

## クロージャを処理するためのジェネレータの修正

`follow.py` の `follow()` 関数を修正して、ジェネレータが適切にクローズされた場合を処理する必要があります。これを行うには、`GeneratorExit` 例外をキャッチする `try-except` ブロックを追加します。`GeneratorExit` 例外は、ガベージコレクションまたは `close()` メソッドの呼び出しによってジェネレータがクローズされたときに発生します。

```python
import os
import time

def follow(filename):
    try:
        with open(filename,'r') as f:
            f.seek(0,os.SEEK_END)
            while True:
                line = f.readline()
                if line == '':
                    time.sleep(0.1)    # Sleep briefly to avoid busy wait
                    continue
                yield line
    except GeneratorExit:
        print('Following Done')
```

この修正されたコードでは、`try` ブロックにジェネレータの主要なロジックが含まれています。`GeneratorExit` 例外が発生した場合、`except` ブロックがそれをキャッチし、メッセージ 'Following Done' を出力します。これは、ジェネレータがクローズされたときにクリーンアップアクションを実行する簡単な方法です。

これらの変更を加えた後、ファイルを保存します。

## ジェネレータのクロージャの実験

では、ジェネレータがガベージコレクションされたり、明示的にクローズされたりしたときの動作を確認するために、いくつかの実験を行いましょう。

ターミナルを開き、Python インタープリタを起動します。

```bash
cd ~/project
python3
```

### 実験 1: 実行中のジェネレータのガベージコレクション

```python
>>> from follow import follow
>>> # Experiment: Garbage collection of a running generator
>>> f = follow('stocklog.csv')
>>> next(f)
'"MO",70.29,"6/11/2007","09:30.09",-0.01,70.25,70.30,70.29,365314\n'
>>> del f  # Delete the generator object
Following Done  # This message appears because of our GeneratorExit handler
```

この実験では、まず `follow.py` ファイルから `follow` 関数をインポートします。次に、`follow('stocklog.csv')` を呼び出してジェネレータオブジェクト `f` を作成します。`next()` 関数を使用して、ジェネレータから次の行を取得します。最後に、`del` 文を使用してジェネレータオブジェクトを削除します。ジェネレータオブジェクトが削除されると、自動的にクローズされ、`GeneratorExit` 例外ハンドラがトリガーされ、メッセージ 'Following Done' が出力されます。

### 実験 2: ジェネレータの明示的なクローズ

```python
>>> f = follow('stocklog.csv')
>>> for line in f:
...     print(line, end='')
...     if 'IBM' in line:
...         f.close()  # Explicitly close the generator
...
"MO",70.29,"6/11/2007","09:30.09",-0.01,70.25,70.30,70.29,365314
"VZ",42.91,"6/11/2007","09:34.28",-0.16,42.95,42.91,42.78,210151
"HPQ",45.76,"6/11/2007","09:34.29",0.06,45.80,45.76,45.59,257169
"GM",31.45,"6/11/2007","09:34.31",0.45,31.00,31.50,31.45,582429
"IBM",102.86,"6/11/2007","09:34.44",-0.21,102.87,102.86,102.77,147550
Following Done
>>> for line in f:
...     print(line, end='')  # No output: generator is closed
...
```

この実験では、新しいジェネレータオブジェクト `f` を作成し、`for` ループを使用して反復処理します。ループ内では、各行を出力し、行に文字列 'IBM' が含まれているかどうかを確認します。含まれている場合、ジェネレータの `close()` メソッドを呼び出して明示的にクローズします。ジェネレータがクローズされると、`GeneratorExit` 例外が発生し、例外ハンドラがメッセージ 'Following Done' を出力します。ジェネレータがクローズされた後、再度反復処理を試みると、ジェネレータがもはやアクティブでないため、出力はありません。

### 実験 3: ジェネレータのループからの脱出と再開

```python
>>> f = follow('stocklog.csv')
>>> for line in f:
...     print(line, end='')
...     if 'IBM' in line:
...         break  # Break out of the loop, but don't close the generator
...
"MO",70.29,"6/11/2007","09:30.09",-0.01,70.25,70.30,70.29,365314
"VZ",42.91,"6/11/2007","09:34.28",-0.16,42.95,42.91,42.78,210151
"HPQ",45.76,"6/11/2007","09:34.29",0.06,45.80,45.76,45.59,257169
"GM",31.45,"6/11/2007","09:34.31",0.45,31.00,31.50,31.45,582429
"IBM",102.86,"6/11/2007","09:34.44",-0.21,102.87,102.86,102.77,147550
>>> # Resume iteration - the generator is still active
>>> for line in f:
...     print(line, end='')
...     if 'IBM' in line:
...         break
...
"CAT",78.36,"6/11/2007","09:37.19",-0.16,78.32,78.36,77.99,237714
"VZ",42.99,"6/11/2007","09:37.20",-0.08,42.95,42.99,42.78,268459
"IBM",102.91,"6/11/2007","09:37.31",-0.16,102.87,102.91,102.77,190859
>>> del f  # Clean up
Following Done
```

この実験では、ジェネレータオブジェクト `f` を作成し、`for` ループを使用して反復処理します。ループ内では、各行を出力し、行に文字列 'IBM' が含まれているかどうかを確認します。含まれている場合、`break` 文を使用してループから脱出します。ループから脱出してもジェネレータはクローズされないため、ジェネレータは依然としてアクティブです。その後、同じジェネレータオブジェクトに対して新しい `for` ループを開始することで、反復処理を再開できます。最後に、ジェネレータオブジェクトを削除してクリーンアップし、`GeneratorExit` 例外ハンドラがトリガーされます。

## 要点

1. ジェネレータがクローズされると（ガベージコレクションまたは `close()` の呼び出しによる）、ジェネレータ内で `GeneratorExit` 例外が発生します。
2. この例外をキャッチすることで、ジェネレータがクローズされたときにクリーンアップアクションを実行できます。
3. ジェネレータの反復処理から脱出する（`break` を使用）と、ジェネレータはクローズされず、後で再開できます。

`exit()` と入力するか、`Ctrl+D` を押して Python インタープリタを終了します。
