# Понимание отношения между классами и экземплярами

Теперь мы рассмотрим, как классы и экземпляры связаны в Python, и как работает поиск методов. Это важное понятие, так как оно помогает понять, как Python находит и использует методы и атрибуты при работе с объектами.

Сначала проверим, какому классу принадлежат наши экземпляры. Знание класса экземпляра является важным, так как оно показывает, где Python будет искать методы и атрибуты, связанные с этим экземпляром.

```python
>>> goog.__class__
<class '__main__.SimpleStock'>
>>> ibm.__class__
<class '__main__.SimpleStock'>
```

Оба экземпляра имеют ссылку на класс `SimpleStock`. Эта ссылка похожа на указатель, который Python использует, когда ему нужно найти метод. Когда вы вызываете метод у экземпляра, Python использует эту ссылку для нахождения соответствующего определения метода.

Когда вы вызываете метод у экземпляра, Python выполняет следующие шаги:

1. Он ищет атрибут в `__dict__` экземпляра. `__dict__` экземпляра - это своего рода хранилище, где хранятся все атрибуты, специфичные для этого экземпляра.
2. Если атрибут не найден, он проверяет `__dict__` класса. `__dict__` класса хранит все атрибуты и методы, общие для всех экземпляров этого класса.
3. Если атрибут найден в классе, он возвращает этот атрибут.

Давайте посмотрим, как это работает на практике. Сначала убедимся, что метод `cost` отсутствует в словарях экземпляров. Этот шаг помогает понять, что метод `cost` не специфичен для каждого экземпляра, а определен на уровне класса.

```python
>>> 'cost' in goog.__dict__
False
>>> 'cost' in ibm.__dict__
False
```

Тогда откуда берется метод `cost`? Давайте проверим класс. Посмотрев на `__dict__` класса, мы можем узнать, где определен метод `cost`.

```python
>>> SimpleStock.__dict__['cost']
<function SimpleStock.cost at 0x7f...>
```

Метод определен в классе, а не в экземплярах. Когда вы вызываете `goog.cost()`, Python не находит `cost` в `goog.__dict__`, поэтому он ищет в `SimpleStock.__dict__` и находит его там.

Вы можете даже вызвать метод напрямую из словаря класса, передав экземпляр в качестве первого аргумента (который становится `self`). Это показывает, как Python внутренне вызывает методы, когда вы используете обычный синтаксис instance.method().

```python
>>> SimpleStock.__dict__['cost'](goog)
49010.0
>>> SimpleStock.__dict__['cost'](ibm)
4561.5
```

В сущности, это то, что Python делает "за кулисами", когда вы вызываете `goog.cost()`.

Теперь давайте добавим атрибут класса. Атрибуты класса общие для всех экземпляров. Это означает, что все экземпляры класса могут получить доступ к этому атрибуту, и он хранится только один раз на уровне класса.

```python
>>> SimpleStock.exchange = 'NASDAQ'
>>> goog.exchange
'NASDAQ'
>>> ibm.exchange
'NASDAQ'
```

Оба экземпляра могут получить доступ к атрибуту `exchange`, но он не хранится в их индивидуальных словарях. Давайте убедимся в этом, проверив словари экземпляра и класса.

```python
>>> 'exchange' in goog.__dict__
False
>>> 'exchange' in SimpleStock.__dict__
True
>>> SimpleStock.__dict__['exchange']
'NASDAQ'
```

Это демонстрирует, что:

1. Атрибуты класса общие для всех экземпляров. Все экземпляры могут получить доступ к одному и тому же атрибуту класса без создания собственной копии.
2. Python сначала проверяет словарь экземпляра, а затем словарь класса. Это порядок, в котором Python ищет атрибуты, когда вы пытаетесь получить доступ к ним у экземпляра.
3. Классы служат хранилищем для общих данных и поведения (методов). Класс хранит все общие атрибуты и методы, которые могут быть использованы всеми его экземплярами.

Если мы изменим атрибут экземпляра с тем же именем, он перекроет атрибут класса. Это означает, что когда вы обращаетесь к атрибуту у этого экземпляра, Python будет использовать значение, специфичное для экземпляра, вместо значения на уровне класса.

```python
>>> ibm.exchange = 'NYSE'
>>> ibm.exchange
'NYSE'
>>> goog.exchange  # По-прежнему используется атрибут класса
'NASDAQ'
>>> ibm.__dict__['exchange']
'NYSE'
```

Теперь у `ibm` есть собственный атрибут `exchange`, который перекрывает атрибут класса, в то время как `goog` по-прежнему использует атрибут класса.
