# 基本的な反復処理とシーケンスのアンパッキング

このステップでは、Python での `for` ループを使った基本的な反復処理とシーケンスのアンパッキングについて探索します。反復処理はプログラミングにおける基本的な概念で、シーケンス内の各要素を1つずつ処理することができます。一方、シーケンスのアンパッキングを使うと、シーケンスの個々の要素を便利に変数に割り当てることができます。

## CSV ファイルからのデータの読み込み

まずは、CSV ファイルからデータを読み込みましょう。CSV (Comma-Separated Values、カンマ区切り値) は、表形式のデータを保存するためによく使われるファイル形式です。始めるには、WebIDE でターミナルを開き、Python インタープリターを起動する必要があります。これにより、Python コードを対話的に実行することができます。

```bash
cd ~/project
python3
```

これで Python インタープリターに入ったので、以下の Python コードを実行して `portfolio.csv` ファイルからデータを読み込みます。まず、CSV ファイルを扱う機能を提供する `csv` モジュールをインポートします。次に、ファイルを開き、`csv.reader` オブジェクトを作成してデータを読み込みます。`next` 関数を使って列のヘッダーを取得し、残りのデータをリストに変換します。最後に、`pprint` モジュールの `pprint` 関数を使って行をより読みやすい形式で表示します。

```python
import csv

f = open('portfolio.csv')
f_csv = csv.reader(f)
headers = next(f_csv)    # Get the column headers
rows = list(f_csv)       # Convert the remaining data to a list
from pprint import pprint
pprint(rows)             # Pretty print the rows
```

以下のような出力が表示されるはずです。

```
[['AA', '100', '32.20'],
 ['IBM', '50', '91.10'],
 ['CAT', '150', '83.44'],
 ['MSFT', '200', '51.23'],
 ['GE', '95', '40.37'],
 ['MSFT', '50', '65.10'],
 ['IBM', '100', '70.44']]
```

## `for` ループによる基本的な反復処理

Python の `for` 文は、リスト、タプル、文字列など、あらゆるデータのシーケンスを反復処理するために使われます。この場合、CSV ファイルから読み込んだデータの行を反復処理するために使います。

```python
for row in rows:
    print(row)
```

このコードは、`rows` リストの各行を順番に処理し、それを表示します。CSV ファイルの各行のデータが1つずつ表示されます。

```
['AA', '100', '32.20']
['IBM', '50', '91.10']
['CAT', '150', '83.44']
['MSFT', '200', '51.23']
['GE', '95', '40.37']
['MSFT', '50', '65.10']
['IBM', '100', '70.44']
```

## ループ内でのシーケンスのアンパッキング

Python では、`for` ループ内で直接シーケンスをアンパッキングすることができます。シーケンス内の各要素の構造がわかっている場合、これは非常に便利です。この場合、`rows` リストの各行には3つの要素が含まれています。名前、株式数、価格です。これらの要素を `for` ループ内で直接アンパッキングすることができます。

```python
for name, shares, price in rows:
    print(name, shares, price)
```

このコードは、各行を `name`、`shares`、`price` という変数にアンパッキングし、それらを表示します。データがより読みやすい形式で表示されます。

```
AA 100 32.20
IBM 50 91.10
CAT 150 83.44
MSFT 200 51.23
GE 95 40.37
MSFT 50 65.10
IBM 100 70.44
```

一部の値が必要ない場合は、`_` をプレースホルダーとして使って、それらの値を無視することができます。たとえば、名前と価格だけを表示したい場合は、以下のコードを使うことができます。

```python
for name, _, price in rows:
    print(name, price)
```

このコードは、各行の2番目の要素を無視し、名前と価格だけを表示します。

```
AA 32.20
IBM 91.10
CAT 83.44
MSFT 51.23
GE 40.37
MSFT 65.10
IBM 70.44
```

## `*` 演算子による拡張アンパッキング

より高度なアンパッキングには、`*` 演算子をワイルドカードとして使うことができます。これにより、複数の要素をリストにまとめることができます。この技術を使って、データを名前でグループ化してみましょう。

```python
from collections import defaultdict

byname = defaultdict(list)
for name, *data in rows:
    byname[name].append(data)

# Print the data for IBM
print(byname['IBM'])

# Iterate through IBM's data
for shares, price in byname['IBM']:
    print(shares, price)
```

このコードでは、まず `collections` モジュールから `defaultdict` クラスをインポートします。`defaultdict` は、キーが存在しない場合に自動的に新しい値 (この場合は空のリスト) を作成する辞書です。次に、`*` 演算子を使って、最初の要素以外のすべての要素を `data` というリストにまとめます。このリストを `byname` 辞書に名前でグループ化して保存します。最後に、IBM のデータを表示し、それを反復処理して株式数と価格を表示します。

出力:

```
[['50', '91.10'], ['100', '70.44']]
50 91.10
100 70.44
```

この例では、`*data` が最初の要素以外のすべての要素をリストにまとめ、それを名前でグループ化して辞書に保存します。これは、可変長シーケンスのデータを扱うための強力な技術です。
