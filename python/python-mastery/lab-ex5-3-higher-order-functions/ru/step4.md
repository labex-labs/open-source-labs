# Использование функции map()

В Python функция высшего порядка - это функция, которая может принимать другую функцию в качестве аргумента или возвращать функцию в качестве результата. Функция `map()` в Python является отличным примером функции высшего порядка. Это мощный инструмент, который позволяет применить заданную функцию к каждому элементу итерируемого объекта, такого как список или кортеж. После применения функции к каждому элементу, она возвращает итератор с результатами. Эта особенность делает `map()` идеальным для обработки последовательностей данных, например, строк в файле CSV.

Базовый синтаксис функции `map()` выглядит следующим образом:

```python
map(function, iterable, ...)
```

Здесь `function` - это операция, которую вы хотите выполнить над каждым элементом в `iterable`. `iterable` - это последовательность элементов, например, список или кортеж.

Рассмотрим простой пример. Предположим, у вас есть список чисел, и вы хотите возвести каждое число в этом списке в квадрат. Вы можете использовать функцию `map()` для достижения этого. Вот как это можно сделать:

```python
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x * x, numbers))
print(squared)  # Output: [1, 4, 9, 16, 25]
```

В этом примере мы сначала определяем список с именем `numbers`. Затем мы используем функцию `map()`. Лямбда-функция `lambda x: x * x` - это операция, которую мы хотим выполнить над каждым элементом в списке `numbers`. Функция `map()` применяет эту лямбда-функцию к каждому числу в списке. Поскольку `map()` возвращает итератор, мы преобразуем его в список с помощью функции `list()`. Наконец, мы выводим список `squared`, который содержит квадраты исходных чисел.

Теперь давайте посмотрим, как можно использовать функцию `map()` для модификации нашей функции `convert_csv()`. Ранее мы использовали цикл `for` для перебора строк в данных CSV. Теперь мы заменим этот цикл `for` функцией `map()`.

```python
def convert_csv(lines, conversion_func, *, headers=None):
    '''
    Convert lines of CSV data using the provided conversion function
    '''
    rows = csv.reader(lines)
    if headers is None:
        headers = next(rows)

    # Use map to apply conversion_func to each row
    records = list(map(lambda row: conversion_func(headers, row), rows))
    return records
```

Обновленная версия функции `convert_csv()` делает то же самое, что и предыдущая версия, но использует функцию `map()` вместо цикла `for`. Лямбда-функция внутри `map()` берет каждую строку из данных CSV и применяет к ней `conversion_func` вместе с заголовками.

Давайте протестируем эту обновленную функцию, чтобы убедиться, что она работает правильно. Сначала откройте терминал и перейдите в директорию проекта. Затем запустите интерактивную оболочку Python с файлом `reader.py`.

```bash
cd ~/project
python3 -i reader.py
```

Как только вы окажетесь в оболочке Python, запустите следующий код для тестирования обновленной функции `convert_csv()`:

```python
# Test the updated convert_csv function
with open('portfolio.csv') as f:
    result = convert_csv(f, make_dict)
print(result[0])  # Should print the first dictionary

# Test that csv_as_dicts still works
with open('portfolio.csv') as f:
    portfolio = csv_as_dicts(f, [str, int, float])
print(portfolio[0])  # Should print the first dictionary with converted types
```

После выполнения этого кода вы должны увидеть вывод, похожий на следующий:

```
{'name': 'AA', 'shares': '100', 'price': '32.20'}
{'name': 'AA', 'shares': 100, 'price': 32.2}
```

Этот вывод показывает, что обновленная функция `convert_csv()`, использующая функцию `map()`, работает правильно, и функции, которые на нее основаны, также продолжают работать как ожидается.

Использование функции `map()` имеет несколько преимуществ:

1. Он может быть более компактным, чем цикл `for`. Вместо того, чтобы писать несколько строк кода для цикла `for`, вы можете достичь того же результата одной строкой с использованием `map()`.
2. Он четко сообщает о намерении преобразовать каждый элемент в последовательности. Когда вы видите `map()`, вы сразу понимаете, что вы применяете функцию к каждому элементу итерируемого объекта.
3. Он может быть более экономным по памяти, так как возвращает итератор. Итератор генерирует значения по мере необходимости, что означает, что он не хранит все результаты в памяти сразу. В нашем примере мы преобразовали итератор, возвращаемый `map()`, в список, но в некоторых случаях вы можете работать непосредственно с итератором, чтобы сэкономить память.

Чтобы выйти из оболочки Python, вы можете ввести `exit()` или нажать Ctrl+D.
