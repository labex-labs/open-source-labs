# 코드 중복 이해하기

`reader.py` 파일의 현재 코드를 살펴보는 것으로 시작해 봅시다. 프로그래밍에서 기존 코드를 검토하는 것은 작동 방식을 이해하고 개선할 부분을 식별하는 중요한 단계입니다. WebIDE 에서 `reader.py` 파일을 열 수 있습니다. 이렇게 하는 두 가지 방법이 있습니다. 파일 탐색기에서 파일을 클릭하거나 터미널에서 다음 명령을 실행할 수 있습니다. 이 명령은 먼저 프로젝트 디렉토리로 이동한 다음 `reader.py` 파일의 내용을 표시합니다.

```bash
cd ~/project
cat reader.py
```

코드를 보면 두 개의 함수가 있다는 것을 알 수 있습니다. Python 의 함수는 특정 작업을 수행하는 코드 블록입니다. 다음은 두 함수와 그 기능입니다.

1. `csv_as_dicts()`: 이 함수는 CSV 데이터를 받아 딕셔너리 목록으로 변환합니다. Python 에서 딕셔너리는 키 - 값 쌍의 모음이며, 데이터를 구조화된 방식으로 저장하는 데 유용합니다.
2. `csv_as_instances()`: 이 함수는 CSV 데이터를 받아 인스턴스 목록으로 변환합니다. 인스턴스는 객체를 생성하기 위한 청사진인 클래스에서 생성된 객체입니다.

이제 이 두 함수를 자세히 살펴보겠습니다. 두 함수가 매우 유사하다는 것을 알 수 있습니다. 두 함수 모두 다음 단계를 따릅니다.

- 먼저, 빈 `records` 리스트를 초기화합니다. Python 에서 리스트는 서로 다른 유형의 항목 모음입니다. 빈 리스트를 초기화하는 것은 항목이 없는 리스트를 생성하는 것을 의미하며, 처리된 데이터를 저장하는 데 사용됩니다.
- 그런 다음 `csv.reader()`를 사용하여 입력을 파싱합니다. 파싱은 의미 있는 정보를 추출하기 위해 입력 데이터를 분석하는 것을 의미합니다. 이 경우 `csv.reader()`는 CSV 데이터를 행별로 읽는 데 도움이 됩니다.
- 헤더를 동일한 방식으로 처리합니다. CSV 파일의 헤더는 일반적으로 열의 이름이 포함된 첫 번째 행입니다.
- 그 후, CSV 데이터의 각 행을 반복합니다. 루프는 코드 블록을 여러 번 실행할 수 있게 해주는 프로그래밍 구성 요소입니다.
- 각 행에 대해 레코드를 생성하기 위해 처리합니다. 이 레코드는 함수에 따라 딕셔너리 또는 인스턴스가 될 수 있습니다.
- 레코드를 `records` 리스트에 추가합니다. 추가는 리스트의 끝에 항목을 추가하는 것을 의미합니다.
- 마지막으로, 처리된 모든 데이터가 포함된 `records` 리스트를 반환합니다.

이러한 코드 중복은 여러 가지 이유로 문제가 됩니다. 코드가 중복되면 다음과 같은 문제가 발생합니다.

- 유지 관리가 더 어려워집니다. 코드를 변경해야 하는 경우 여러 위치에서 동일한 변경을 수행해야 합니다. 이는 더 많은 시간과 노력이 필요합니다.
- 모든 변경 사항은 여러 위치에서 구현되어야 합니다. 이는 변경 사항을 한 곳에서 잊어버려 일관성 없는 동작을 초래할 가능성을 높입니다.
- 또한 버그가 발생할 가능성이 높아집니다. 버그는 예상치 못한 동작을 유발할 수 있는 코드의 오류입니다.

이 두 함수의 유일한 실제 차이점은 행을 레코드로 변환하는 방식입니다. 이것은 고차 함수가 매우 유용할 수 있는 전형적인 상황입니다. 고차 함수는 다른 함수를 인수로 받거나 함수를 결과로 반환할 수 있는 함수입니다.

이 함수들이 어떻게 작동하는지 더 잘 이해하기 위해 이러한 함수의 몇 가지 사용 예시를 살펴보겠습니다. 다음 코드는 `csv_as_dicts()` 및 `csv_as_instances()`를 사용하는 방법을 보여줍니다.

```python
# Example of using csv_as_dicts
with open('portfolio.csv') as f:
    portfolio = csv_as_dicts(f, [str, int, float])
print(portfolio[0])  # {'name': 'AA', 'shares': 100, 'price': 32.2}

# Example of using csv_as_instances
class Stock:
    @classmethod
    def from_row(cls, row):
        return cls(row[0], int(row[1]), float(row[2]))

    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

with open('portfolio.csv') as f:
    portfolio = csv_as_instances(f, Stock)
print(portfolio[0].name, portfolio[0].shares, portfolio[0].price)  # AA 100 32.2
```

다음 단계에서는 이 코드 중복을 제거하기 위해 고차 함수를 만들 것입니다. 이렇게 하면 코드를 더 유지 관리하기 쉽고 오류가 발생하기 쉬워집니다.
