# Использование функции `locals()` для доступа к аргументам функции

В Python понимание областей видимости переменных является крайне важным. Область видимости переменной определяет, где в коде можно к ней обращаться. Python предоставляет встроенную функцию `locals()`, которая очень полезна для начинающих программистов, чтобы понять области видимости. Функция `locals()` возвращает словарь, содержащий все локальные переменные в текущей области видимости. Это может быть чрезвычайно полезно, когда вы хотите проверить аргументы функции, так как оно дает вам ясное представление о том, какие переменные доступны в определенной части вашего кода.

Давайте проведем простой эксперимент в интерпретаторе Python, чтобы увидеть, как это работает. Сначала нам нужно перейти в директорию проекта и запустить интерпретатор Python. Вы можете сделать это, запустив следующие команды в терминале:

```bash
cd ~/project
python3
```

Как только вы окажетесь в интерактивной оболочке Python, мы определим класс `Stock`. Класс в Python представляет собой чертеж для создания объектов. В этом классе мы будем использовать специальный метод `__init__`. Метод `__init__` является конструктором в Python, то есть он автоматически вызывается при создании объекта класса. Внутри этого метода `__init__` мы будем использовать функцию `locals()` для вывода всех локальных переменных.

```python
class Stock:
    def __init__(self, name, shares, price):
        print(locals())
```

Теперь давайте создадим экземпляр этого класса `Stock`. Экземпляр - это фактический объект, созданный на основе чертежа класса. Мы передадим некоторые значения для параметров `name`, `shares` и `price`.

```python
s = Stock('GOOG', 100, 490.1)
```

Когда вы запустите этот код, вы должны увидеть вывод, похожий на следующий:

```
{'self': <__main__.Stock object at 0x...>, 'name': 'GOOG', 'shares': 100, 'price': 490.1}
```

Этот вывод показывает, что функция `locals()` возвращает словарь, содержащий все локальные переменные в методе `__init__`. Ссылка `self` является специальной переменной в классах Python, которая ссылается на экземпляр класса. Другие переменные - это значения параметров, которые мы передали при создании объекта `Stock`.

Мы можем использовать функциональность `locals()` для автоматической инициализации атрибутов объекта. Атрибуты - это переменные, связанные с объектом. Давайте определим вспомогательную функцию и изменим наш класс `Stock`.

```python
def _init(locs):
    self = locs.pop('self')
    for name, val in locs.items():
        setattr(self, name, val)

class Stock:
    def __init__(self, name, shares, price):
        _init(locals())
```

Функция `_init` принимает словарь локальных переменных, полученный с помощью `locals()`. Сначала она удаляет ссылку `self` из словаря с помощью метода `pop`. Затем она проходит по оставшимся парам ключ - значение в словаре и использует функцию `setattr` для установки каждой переменной в качестве атрибута объекта.

Теперь давайте протестируем эту реализацию как с позиционными, так и с именованными аргументами. Позиционные аргументы передаются в том порядке, в котором они определены в сигнатуре функции, в то время как именованные аргументы передаются с указанием имен параметров.

```python
# Test with positional arguments
s1 = Stock('GOOG', 100, 490.1)
print(s1.name, s1.shares, s1.price)

# Test with keyword arguments
s2 = Stock(name='AAPL', shares=50, price=125.3)
print(s2.name, s2.shares, s2.price)
```

Теперь оба подхода должны работать! Функция `_init` позволяет нам без проблем обрабатывать как позиционные, так и именованные аргументы. Она также сохраняет имена параметров в сигнатуре функции, что делает вывод функции `help()` более полезным. Функция `help()` в Python предоставляет информацию о функциях, классах и модулях, и сохранение имен параметров делает эту информацию более осмысленной.

Когда вы закончите экспериментировать, вы можете выйти из интерпретатора Python, запустив следующую команду:

```python
exit()
```
