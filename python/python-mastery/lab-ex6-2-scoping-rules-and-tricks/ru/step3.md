# Исследование инспекции стека вызовов

Подход `_init(locals())`, который мы использовали, работает, но имеет недостаток. Каждый раз, когда мы определяем метод `__init__`, мы должны явно вызывать `locals()`. Это может стать немного утомительным, особенно при работе с несколькими классами. К счастью, мы можем сделать наш код более чистым и эффективным, используя инспекцию стека вызовов. Эта техника позволяет нам автоматически получить доступ к локальным переменным вызывающего кода без необходимости явного вызова `locals()`.

Давайте начнем изучать эту технику в интерпретаторе Python. Сначала откройте терминал и перейдите в директорию проекта. Затем запустите интерпретатор Python. Вы можете сделать это, запустив следующие команды:

```bash
cd ~/project
python3
```

Теперь, когда мы находимся в интерпретаторе Python, нам нужно импортировать модуль `sys`. Модуль `sys` предоставляет доступ к некоторым переменным, используемым или поддерживаемым интерпретатором Python. Мы будем использовать его для доступа к информации о стеке вызовов.

```python
import sys
```

Далее мы определим улучшенную версию нашей функции `_init()`. Эта новая версия будет напрямую получать доступ к кадру (frame) вызывающего кода, устраняя необходимость явно передавать `locals()`.

```python
def _init():
    # Get the caller's frame (1 level up in the call stack)
    frame = sys._getframe(1)

    # Get the local variables from that frame
    locs = frame.f_locals

    # Extract self and set other variables as attributes
    self = locs.pop('self')
    for name, val in locs.items():
        setattr(self, name, val)
```

В этом коде `sys._getframe(1)` извлекает объект кадра (frame) вызывающей функции. Аргумент `1` означает, что мы ищем на один уровень выше в стеке вызовов. Как только у нас есть объект кадра, мы можем получить доступ к его локальным переменным с помощью `frame.f_locals`. Это дает нам словарь всех локальных переменных в области видимости вызывающего кода. Затем мы извлекаем переменную `self` и устанавливаем оставшиеся переменные в качестве атрибутов объекта `self`.

Теперь давайте протестируем эту новую функцию `_init()` с новой версией нашего класса `Stock`.

```python
class Stock:
    def __init__(self, name, shares, price):
        _init()  # No need to pass locals() anymore!

# Test it
s = Stock('GOOG', 100, 490.1)
print(s.name, s.shares, s.price)

# Also works with keyword arguments
s = Stock(name='AAPL', shares=50, price=125.3)
print(s.name, s.shares, s.price)
```

Как вы можете видеть, метод `__init__` больше не нуждается в явном передаче `locals()`. Это делает наш код более чистым и легким для чтения с точки зрения вызывающего кода.

### Как работает инспекция стека вызовов

Когда вы вызываете `sys._getframe(1)`, Python возвращает объект кадра (frame), представляющий выполнение вызывающего кода. Аргумент `1` означает "на один уровень выше от текущего кадра" (вызывающей функции).

Объект кадра содержит важную информацию о контексте выполнения. Это включает в себя текущую выполняемую функцию, локальные переменные в этой функции и номер текущей выполняемой строки.

Путем доступа к `frame.f_locals` мы получаем словарь всех локальных переменных в области видимости вызывающего кода. Это похоже на то, что вернет `locals()`, если его вызвать напрямую из этой области видимости.

Эта техника очень мощная, но ее следует использовать с осторожностью. Она обычно считается продвинутой возможностью Python и может показаться немного "магической", так как она выходит за обычные границы области видимости Python.

После того, как вы закончите экспериментировать с инспекцией стека вызовов, вы можете выйти из интерпретатора Python, запустив следующую команду:

```python
exit()
```
