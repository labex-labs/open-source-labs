# Создайте свою первую мета-класс

Создайте файл с именем `mymeta.py` и поместите в него следующий код (из слайдов):

```python
# mymeta.py

class mytype(type):
    @staticmethod
    def __new__(meta, name, bases, __dict__):
        print("Creating class :", name)
        print("Base classes   :", bases)
        print("Attributes     :", list(__dict__))
        return super().__new__(meta, name, bases, __dict__)

class myobject(metaclass=mytype):
    pass
```

После этого определите класс, который наследуется от `myobject` вместо `object`. Например:

```python
class Stock(myobject):
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
    def cost(self):
        return self.shares * self.price
    def sell(self, nshares):
        self.shares -= nshares
```

Попробуйте запустить свой код и создать экземпляры `Stock`. Посмотрите, что произойдет. Вы должны увидеть выводимые на экран строки из вашего `mytype` один раз при определении класса `Stock`.

Что произойдет, если вы унаследуете класс от `Stock`?

```python
class MyStock(Stock):
    pass
```

Вы по-прежнему должны увидеть, как работает ваша мета-класс. Метаклассы "прилипают" к классам, так что они применяются на всей иерархии наследования.

**Обсуждение**

Зачем вы бы хотели сделать что-то подобное? Основная сила мета-класса заключается в том, что она позволяет программисту получить информацию о классах сразу перед их созданием. Например, в методе `__new__()` вам передаются все основные сведения, включая имя класса, базовые классы и данные методов. Если вы изучите эти данные, вы можете выполнить различные виды диагностических проверок. Если вы более смелы, вы можете изменить данные и изменить то, что будет помещено в определение класса при его создании.不用说，这里有很多机会可以做出极其邪恶的事情。
