# Понимание проблемы

Прежде чем мы приступим к изучению метаклассов, важно понять проблему, которую мы стремимся решить. В программировании мы часто должны создавать структуры с определенными типами для своих атрибутов. В нашей предыдущей работе мы разработали систему для структур с проверкой типов. Эта система позволяет нам определять классы, в которых каждый атрибут имеет определенный тип, и значения, присваиваемые этим атрибутам, проверяются в соответствии с этим типом.

Вот пример того, как мы использовали эту систему для создания класса `Stock`:

```python
from validate import String, PositiveInteger, PositiveFloat
from structure import Structure

class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares: PositiveInteger):
        self.shares -= nshares
```

В этом коде мы сначала импортируем типы валидаторов (`String`, `PositiveInteger`, `PositiveFloat`) из модуля `validate` и класс `Structure` из модуля `structure`. Затем мы определяем класс `Stock`, который наследуется от `Structure`. Внутри класса `Stock` мы определяем атрибуты с определенными типами валидаторов. Например, атрибут `name` должен быть строкой, `shares` должен быть положительным целым числом, а `price` должен быть положительным числом с плавающей точкой.

Однако у этого подхода есть проблема. Мы должны импортировать все типы валидаторов в начале нашего файла. В реальной ситуации, по мере добавления все большего количества типов валидаторов, эти импорты могут стать очень длинными и сложными для управления. Это может привести нас к использованию `from validate import *`, что обычно считается плохой практикой, так как может вызвать конфликты имен и сделать код менее читаемым.

Для того чтобы понять, с чего мы начинаем, давайте посмотрим на класс `Structure`. Вам нужно открыть файл `structure.py` в редакторе и изучить его содержимое. Это поможет вам увидеть, как реализована базовая обработка структур, прежде чем мы добавим функциональность метакласса.

```bash
code structure.py
```

Когда вы откроете файл, вы увидите базовую реализацию класса `Structure`. Этот класс отвечает за обработку инициализации атрибутов, но пока не имеет какой - либо функциональности метакласса.

Далее, давайте рассмотрим классы валидаторов. Эти классы определены в файле `validate.py`. Они уже имеют функциональность дескрипторов, что означает, что они могут контролировать, как к атрибутам обращаются и как их устанавливают. Но нам нужно будет улучшить их, чтобы решить проблему импорта, о которой мы говорили ранее.

```bash
code validate.py
```

Изучив эти классы валидаторов, вы лучше поймете, как работает процесс валидации и какие изменения нам нужно внести, чтобы улучшить наш код.
