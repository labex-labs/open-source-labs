# Тестирование нашей реализации

Теперь, когда мы реализовали наш метакласс и модифицировали класс `Structure`, пришло время протестировать нашу реализацию. Тестирование является важным, так как оно помогает нам убедиться, что все работает правильно. Запуская тесты, мы можем выявить любые потенциальные проблемы на ранней стадии и убедиться, что наш код ведет себя как ожидается.

Сначала давайте запустим модульные тесты (unit tests), чтобы проверить, работает ли наш класс `Stock` как ожидается. Модульные тесты - это небольшие, изолированные тесты, которые проверяют отдельные части нашего кода. В данном случае мы хотим убедиться, что класс `Stock` функционирует корректно. Чтобы запустить модульные тесты, мы используем следующую команду в терминале:

```bash
python3 teststock.py
```

Если все работает правильно, все тесты должны пройти без ошибок. Когда тесты успешно выполнятся, вывод должен выглядеть примерно так:

```
........
----------------------------------------------------------------------
Ran 6 tests in 0.001s

OK
```

Точки представляют каждый пройденный тест, а конечный `OK` указывает, что все тесты прошли успешно.

Теперь давайте протестируем наш класс `Stock` с некоторыми реальными данными и функциональностью форматирования таблиц. Это даст нам более реальный сценарий, чтобы увидеть, как наш класс `Stock` взаимодействует с данными и как работает форматирование таблиц. Мы используем следующую команду в терминале:

```bash
python3 -c "
from stock import Stock
from reader import read_csv_as_instances
from tableformat import create_formatter, print_table

# Read portfolio data into Stock instances
portfolio = read_csv_as_instances('portfolio.csv', Stock)
print('Portfolio:')
print(portfolio)

# Format and print the portfolio data
print('\nFormatted table:')
formatter = create_formatter('text')
print_table(portfolio, ['name', 'shares', 'price'], formatter)
"
```

В этом коде мы сначала импортируем необходимые классы и функции. Затем мы считываем данные из CSV - файла в экземпляры класса `Stock`. После этого мы выводим данные о портфеле, а затем форматируем их в таблицу и выводим отформатированную таблицу.

Вы должны увидеть вывод, похожий на следующий:

```
Portfolio:
[Stock('AA',100,32.2), Stock('IBM',50,91.1), Stock('CAT',150,83.44), Stock('MSFT',200,51.23), Stock('GE',95,40.37), Stock('MSFT',50,65.1), Stock('IBM',100,70.44)]

Formatted table:
      name     shares      price
---------- ---------- ----------
        AA        100       32.2
       IBM         50       91.1
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50       65.1
       IBM        100      70.44
```

Отдохните на минуту и оцените, что мы достигли:

1. Мы создали механизм для автоматического сбора всех типов валидаторов. Это означает, что нам не нужно вручную отслеживать все валидаторы, что экономит наше время и снижает вероятность ошибок.
2. Мы реализовали метакласс, который внедряет эти типы в пространство имен подклассов `Structure`. Это позволяет подклассам использовать эти валидаторы без необходимости явного импорта.
3. Мы избавились от необходимости явного импорта типов валидаторов. Это делает наш код чище и проще для чтения.
4. Все это происходит в фоновом режиме, делая код для определения новых структур чистым и простым.

Финальный файл `stock.py` удивительно чистый по сравнению с тем, каким он был бы без нашего метакласса:

```python
from structure import Structure

class Stock(Structure):
    name = String()
    shares = PositiveInteger()
    price = PositiveFloat()

    @property
    def cost(self):
        return self.shares * self.price

    def sell(self, nshares: PositiveInteger):
        self.shares -= nshares
```

Без необходимости напрямую импортировать типы валидаторов код становится более компактным и легким в поддержке. Это отличный пример того, как метаклассы могут повысить качество нашего кода.
