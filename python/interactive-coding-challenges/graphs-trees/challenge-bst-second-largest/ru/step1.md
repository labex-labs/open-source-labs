# Второе по величине в BST

## Задача

Дано двоичное дерево поиска. Найти вторую по величине вершину в дереве. Если входные данные равны None или представляют собой одну вершину, должно быть возбуждено исключение.

Для решения этой задачи мы можем обходить дерево в определенном порядке и отслеживать вторую по величине вершину, которую мы видели до сих пор. Мы можем начать с обхода правого поддерева корневой вершины, и если правое поддерево равно None, то наибольшая вершина - это сама корневая вершина. Если правое поддерево не равно None, мы можем продолжить обход правого поддерева, пока не дойдем до вершины, у которой нет правого потомка. В этом случае наибольшая вершина в дереве - это родитель этой вершины. Если у этого родительской вершины есть левый потомок, то вторая по величине вершина - это наибольшая вершина в левом поддереве родительской вершины. Если у родительской вершины нет левого потомка, то вторая по величине вершина - это сама родительская вершина.

## Требования

Требования к этой задаче следующие:

- Если входные данные равны None или представляют собой одну вершину, должно быть возбуждено исключение.
  - Входные данные None должны вызывать исключение TypeError.
  - Входные данные, представляющие собой одну вершину, должны вызывать исключение ValueError.
- Можно предположить, что у нас уже есть класс Node с методом insert.
- Можно предположить, что данная задача помещается в память.

## Пример использования

Вот несколько примеров использования этой функции:

- None или одна вершина -> Исключение

```txt
Входные данные:
                _10_
              _/    \_
             5        15
            / \       / \
           3   8     12  20
          /     \         \
         2       4        30

Результат: 20

Входные данные:
                 10
                 /
                5
               / \
              3   7
Результат: 7
```
