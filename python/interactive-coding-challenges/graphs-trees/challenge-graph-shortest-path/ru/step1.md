# Кратчайший путь в графе

## Задача

Дан направленный граф с взвешенными ребрами. Найти кратчайший путь между двумя узлами.

## Требования

Для решения этой задачи необходимо рассмотреть следующие требования:

- Это направленный граф? - Да
- Может ли граф содержать циклы? - Да
  - Примечание: Если ответ был бы "нет", это был бы DAG.
    - DAG можно решить с помощью [топологической сортировки](http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/)
- Являются ли ребра взвешенными? - Да
  - Примечание: Если ребра не были бы взвешенными, мы могли бы выполнить BFS
- Являются ли все веса ребер неотрицательными числами? - Да
  - Примечание: Графы с отрицательными ребрами можно решить с помощью Беллмана-Форда
    - Графы с циклами отрицательного веса не имеют определенного кратчайшего пути
- Нужно ли проверять на неотрицательные ребра? - Нет
- Можем ли мы предположить, что это связанный граф? - Да
- Можем ли мы предположить, что входные данные действительны? - Нет
- Можем ли мы предположить, что у нас уже есть класс графа? - Да
- Можем ли мы предположить, что у нас уже есть класс приоритетной очереди? - Да
- Можем ли мы предположить, что это помещается в память? - Да

## Пример

Рассмотрим следующий граф:

```txt
graph.add_edge('a', 'b', weight=5)
graph.add_edge('a', 'c', weight=3)
graph.add_edge('a', 'e', weight=2)
graph.add_edge('b', 'd', weight=2)
graph.add_edge('c', 'b', weight=1)
graph.add_edge('c', 'd', weight=1)
graph.add_edge('d', 'a', weight=1)
graph.add_edge('d', 'g', weight=2)
graph.add_edge('d', 'h', weight=1)
graph.add_edge('e', 'a', weight=1)
graph.add_edge('e', 'h', weight=4)
graph.add_edge('e', 'i', weight=7)
graph.add_edge('f', 'b', weight=3)
graph.add_edge('f', 'g', weight=1)
graph.add_edge('g', 'c', weight=3)
graph.add_edge('g', 'i', weight=2)
graph.add_edge('h', 'c', weight=2)
graph.add_edge('h', 'f', weight=2)
graph.add_edge('h', 'g', weight=2)
```

Мы можем найти кратчайший путь между узлом 'a' и узлом 'i' с использованием класса ShortestPath:

```txt
shortest_path = ShortestPath(graph)
result = shortest_path.find_shortest_path('a', 'i')
```

Ожидаемый результат:

```txt
['a', 'c', 'd', 'g', 'i']
```

Мы также можем проверить вес кратчайшего пути:

```txt
self.assertEqual(shortest_path.path_weight['i'], 8)
```
