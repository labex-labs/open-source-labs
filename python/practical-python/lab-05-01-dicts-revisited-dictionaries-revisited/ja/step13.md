# 多重継承における MRO

多重継承の場合、最上位までの単一のパスはありません。例を見てみましょう。

```python
class A: pass
class B: pass
class C(A, B): pass
class D(B): pass
class E(C, D): pass
```

属性にアクセスしたときに何が起こりますか？

```python
e = E()
e.attr
```

属性検索プロセスが行われますが、その順序は何でしょうか？ それが問題です。

Python は _協調的多重継承_ を使用しており、クラスの順序付けに関するいくつかの規則を遵守しています。

- 子クラスは常に親クラスよりも先にチェックされます
- 親クラス（複数の場合）は常に列挙された順序でチェックされます。

MRO は、それらの規則に従って階層内のすべてのクラスをソートすることによって計算されます。

```python
>>> E.__mro__
(
  <class 'E'>,
  <class 'C'>,
  <class 'A'>,
  <class 'D'>,
  <class 'B'>,
  <class 'object'>)
>>>
```

根本的なアルゴリズムは「C3 線形化アルゴリズム」と呼ばれます。家が火事になり避難しなければならない場合に従うのと同じ順序付けの規則をクラス階層が遵守している限り、正確な詳細は重要ではありません。子供たちが先で、その後に親が続きます。
