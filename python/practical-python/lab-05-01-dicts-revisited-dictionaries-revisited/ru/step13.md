# MRO в множественном наследовании

При множественном наследовании нет единственного пути к вершине. Посмотрим на пример.

```python
class A: pass
class B: pass
class C(A, B): pass
class D(B): pass
class E(C, D): pass
```

Что происходит, когда вы обращаетесь к атрибуту?

```python
e = E()
e.attr
```

Производится процесс поиска атрибута, но какой порядок? Это проблема.

Python использует _совместное множественное наследование_, которое подчиняется некоторым правилам порядка классов.

- Дети всегда проверяются перед родителями
- Родители (если несколько) всегда проверяются в указанном порядке.

MRO вычисляется путём сортировки всех классов в иерархии согласно этим правилам.

```python
>>> E.__mro__
(
  <class 'E'>,
  <class 'C'>,
  <class 'A'>,
  <class 'D'>,
  <class 'B'>,
  <class 'object'>)
>>>
```

В основе лежит алгоритм, называемый "алгоритмом C3-линейной иерархии". Точные детали не важны, главное запомнить, что иерархия классов подчиняется тем же правилам порядка, что и при эвакуации из дома при пожаре - сначала дети, затем родители.
