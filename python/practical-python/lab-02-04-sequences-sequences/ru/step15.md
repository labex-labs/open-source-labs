# Упражнение 2.16: Использование функции zip()

В файле `portfolio.csv` первая строка содержит заголовки столбцов. Везде в предыдущем коде мы просто игнорировали их.

```python
>>> f = open('/home/labex/project/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name','shares', 'price']
>>>
```

Однако, что если бы вы могли использовать заголовки для чего-то полезного? Именно здесь функция `zip()` приходит на помощь. Сначала попробуйте это, чтобы сопоставить заголовки файла с одной строкой данных:

```python
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>> list(zip(headers, row))
[ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ]
>>>
```

Заметьте, как `zip()` сопоставляет заголовки столбцов с значениями столбцов. Здесь мы использовали `list()`, чтобы превратить результат в список, чтобы вы могли его увидеть. Обычно `zip()` создает итератор, который должен быть использован в цикле `for`.

Это сопоставление является промежуточным этапом для создания словаря. Теперь попробуйте это:

```python
>>> record = dict(zip(headers, row))
>>> record
{'price': '32.20', 'name': 'AA','shares': '100'}
>>>
```

Это преобразование является одним из самых полезных приемов, которые стоит знать при обработке большого количества файлов с данными. Например, предположим, что вы хотели, чтобы программа `pcost.py` работала с различными входными файлами, не зависимо от того, в каком столбце фактически находятся имя, количество акций и цена.

Модифицируйте функцию `portfolio_cost()` в `pcost.py` так, чтобы она выглядела так:

```python
# pcost.py

def portfolio_cost(filename):
 ...
        for rowno, row in enumerate(rows, start=1):
            record = dict(zip(headers, row))
            try:
                nshares = int(record['shares'])
                price = float(record['price'])
                total_cost += nshares * price
            # Это ловит ошибки в преобразованиях int() и float() выше
            except ValueError:
                print(f'Строка {rowno}: Плохая строка: {row}')
 ...
```

Теперь, попробуйте вашу функцию на совершенно другом файле с данными `portfoliodate.csv`, который выглядит так:

```csv
name,date,time,shares,price
"AA","6/11/2007","9:50am",100,32.20
"IBM","5/13/2007","4:20pm",50,91.10
"CAT","9/23/2006","1:30pm",150,83.44
"MSFT","5/17/2007","10:30am",200,51.23
"GE","2/1/2006","10:45am",95,40.37
"MSFT","10/31/2006","12:05pm",50,65.10
"IBM","7/9/2006","3:15pm",100,70.44
```

```python
>>> portfolio_cost('/home/labex/project/portfoliodate.csv')
44671.15
>>>
```

Если вы сделали это правильно, вы обнаружите, что ваша программа по-прежнему работает, даже если файл с данными имеет совершенно другой формат столбцов, чем раньше. Это круто!

Изменение, сделанное здесь, незаметно, но существенно. Вместо того, чтобы `portfolio_cost()` был жестко закодирован для чтения одного фиксированного формата файла, новая версия читает любой CSV-файл и выбирает из него интересующие значения. Пока файл имеет нужные столбцы, код будет работать.

Модифицируйте программу `report.py`, которую вы написали в разделе 2.3, так, чтобы она использовала ту же технику для выбора заголовков столбцов.

Попробуйте запустить программу `report.py` на файле `portfoliodate.csv` и убедитесь, что она дает ту же ответ, что и раньше.
