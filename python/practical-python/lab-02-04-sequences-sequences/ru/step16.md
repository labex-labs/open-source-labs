# Упражнение 2.17: Обратное отображение словаря

Словарь сопоставляет ключи значениям. Например, словарь цен на акции.

```python
>>> prices = {
        'GOOG' : 490.1,
        'AA' : 23.45,
        'IBM' : 91.1,
        'MSFT' : 34.23
    }
>>>
```

Если использовать метод `items()`, можно получить пары `(ключ, значение)`:

```python
>>> prices.items()
dict_items([('GOOG', 490.1), ('AA', 23.45), ('IBM', 91.1), ('MSFT', 34.23)])
>>>
```

Однако, что если бы вы хотели получить список пар `(значение, ключ)` вместо этого? _Подсказка: используйте `zip()`._

```python
>>> pricelist = list(zip(prices.values(),prices.keys()))
>>> pricelist
[(490.1, 'GOOG'), (23.45, 'AA'), (91.1, 'IBM'), (34.23, 'MSFT')]
>>>
```

Зачем это делать? Во-первых, это позволяет выполнять определенные виды обработки данных над данными словаря.

```python
>>> min(pricelist)
(23.45, 'AA')
>>> max(pricelist)
(490.1, 'GOOG')
>>> sorted(pricelist)
[(23.45, 'AA'), (34.23, 'MSFT'), (91.1, 'IBM'), (490.1, 'GOOG')]
>>>
```

Это также иллюстрирует важную особенность кортежей. При использовании в сравнениях кортежи сравниваются элемент за элементом, начиная с первого элемента. Подобно тому, как строки сравниваются по символам.

`zip()` часто используется в таких ситуациях, когда нужно сопоставить данные из разных источников. Например, сопоставить имена столбцов с значениями столбцов, чтобы создать словарь именованных значений.

Обратите внимание, что `zip()` не ограничивается парами. Например, можно использовать его с любыми количеством входных списков:

```python
>>> a = [1, 2, 3, 4]
>>> b = ['w', 'x', 'y', 'z']
>>> c = [0.2, 0.4, 0.6, 0.8]
>>> list(zip(a, b, c))
[(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))]
>>>
```

Также обратите внимание, что `zip()` останавливается, как только исчерпан самая короткая входная последовательность.

```python
>>> a = [1, 2, 3, 4, 5, 6]
>>> b = ['x', 'y', 'z']
>>> list(zip(a,b))
[(1, 'x'), (2, 'y'), (3, 'z')]
>>>
```
