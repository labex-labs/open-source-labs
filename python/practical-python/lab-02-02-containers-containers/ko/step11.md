# 연습 문제 2.6: 컨테이너로서의 딕셔너리

딕셔너리는 정수가 아닌 다른 인덱스를 사용하여 항목을 조회하려는 경우 항목을 추적하는 데 유용한 방법입니다. Python 셸에서 딕셔너리를 가지고 놀아보십시오.

```python
>>> prices = { }
>>> prices['IBM'] = 92.45
>>> prices['MSFT'] = 45.12
>>> prices
... 결과를 확인하십시오 ...
>>> prices['IBM']
92.45
>>> prices['AAPL']
... 결과를 확인하십시오 ...
>>> 'AAPL' in prices
False
>>>
```

`prices.csv` 파일에는 일련의 주가가 포함되어 있습니다. 파일은 다음과 같습니다.

```csv
"AA",9.22
"AXP",24.85
"BA",44.85
"BAC",11.27
"C",3.72
...
```

이와 같은 일련의 가격을 딕셔너리로 읽어 들이는 함수 `read_prices(filename)`을 작성하십시오. 여기서 딕셔너리의 키는 주식 이름이고 딕셔너리의 값은 주가입니다.

이렇게 하려면 빈 딕셔너리에서 시작하여 위에서 했던 것처럼 값을 삽입하십시오. 그러나 이제 파일에서 값을 읽고 있습니다.

이 데이터 구조를 사용하여 주어진 주식 이름의 가격을 빠르게 조회할 것입니다.

이 부분에 필요한 몇 가지 작은 팁이 있습니다. 먼저, 이전과 마찬가지로 `csv` 모듈을 사용해야 합니다. 여기서는 바퀴를 다시 발명할 필요가 없습니다.

```python
>>> import csv
>>> f = open('/home/labex/project/prices.csv', 'r')
>>> rows = csv.reader(f)
>>> for row in rows:
        print(row)


['AA', '9.22']
['AXP', '24.85']
...
[]
>>>
```

또 다른 작은 복잡한 점은 `prices.csv` 파일에 빈 줄이 있을 수 있다는 것입니다. 위의 마지막 데이터 행이 빈 목록인 것을 확인하십시오. 즉, 해당 줄에 데이터가 없었습니다.

이로 인해 프로그램이 예외와 함께 종료될 수 있습니다. `try` 및 `except` 문을 사용하여 적절하게 이를 잡으십시오. 생각: `if` 문을 사용하여 잘못된 데이터를 방지하는 것이 더 나을까요?

`read_prices()` 함수를 작성했으면 대화형으로 테스트하여 작동하는지 확인하십시오.

```python
>>> prices = read_prices('/home/labex/project/prices.csv')
>>> prices['IBM']
106.28
>>> prices['MSFT']
20.89
>>>
```
