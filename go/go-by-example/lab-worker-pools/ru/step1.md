# Пул рабочих потоков

Реализуйте пул рабочих потоков, который получает задания по каналу `jobs` и отправляет соответствующие результаты по каналу `results`. Пул рабочих потоков должен иметь несколько параллельных экземпляров, и каждый рабочий поток должен спать в течение одной секунды на каждое задание, чтобы имитировать дорогостоящую задачу.

- Используйте горутины и каналы для реализации пула рабочих потоков.
- Пул рабочих потоков должен иметь несколько параллельных экземпляров.
- Каждый рабочий поток должен спать в течение одной секунды на каждое задание, чтобы имитировать дорогостоящую задачу.
- Пул рабочих потоков должен получать задания по каналу `jobs` и отправлять соответствующие результаты по каналу `results`.

```sh
# Наша работающая программа показывает, как 5 заданий
# выполняются различными рабочими потоками. Программа
# занимает всего около 2 секунды, несмотря на то, что
# суммарная длительность работы составляет около 5 секунд,
# потому что 3 рабочих потока работают параллельно.
$ time go run worker-pools.go
worker 1 started job 1
worker 2 started job 2
worker 3 started job 3
worker 1 finished job 1
worker 1 started job 4
worker 2 finished job 2
worker 2 started job 5
worker 3 finished job 3
worker 1 finished job 4
worker 2 finished job 5

real 0m2.358s
```

Ниже представлен полный код:

```go
// В этом примере мы рассмотрим, как реализовать
// _пул рабочих потоков_ с использованием горутин и каналов.

package main

import (
	"fmt"
	"time"
)

// Вот рабочий поток, из которого мы запустим несколько
// параллельных экземпляров. Эти рабочие потоки будут
// получать задания по каналу `jobs` и отправлять
// соответствующие результаты по `results`. Мы будем
// спать одну секунду на каждое задание, чтобы
// имитировать дорогостоящую задачу.
func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Println("worker", id, "started  job", j)
		time.Sleep(time.Second)
		fmt.Println("worker", id, "finished job", j)
		results <- j * 2
	}
}

func main() {

	// Чтобы использовать наш пул рабочих потоков, нам
	// нужно отправить им задания и собрать их результаты.
	//为此我们创建2个通道。
	const numJobs = 5
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	// Это запускает 3 рабочих потока, которые изначально
	// заблокированы, потому что заданий еще нет.
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// Здесь мы отправляем 5 `jobs` и затем `закрываем`
	// этот канал, чтобы показать, что все задания отправлены.
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	// Наконец, мы собираем все результаты работы.
	// Это также гарантирует, что горутины рабочих
	// потоков завершились. Альтернативный способ
	// ожидания завершения нескольких горутин - это
	// использование [WaitGroup](waitgroups).
	for a := 1; a <= numJobs; a++ {
		<-results
	}
}

```
