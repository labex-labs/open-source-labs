# Восстановление

Функция `mayPanic` в предоставленном коде будет вызывать панику при вызове. Ваша задача - модифицировать функцию `main` для восстановления от паники и вывода сообщения об ошибке.

- Используйте функцию `recover` для обработки паники в функции `mayPanic`.
- Выведите сообщение об ошибке, когда возникает паника.

```sh
$ go run recover.go
Recovered. Error:
a problem
```

Ниже представлен полный код:

```go
// Go позволяет _восстанавливаться_ от паники,
// используя встроенную функцию `recover`. `recover` может
// остановить панику, не прерывая выполнение программы, и
// позволить ей продолжить выполнение вместо этого.

// Пример того, где это может быть полезно: сервер
// не должен завершаться сбоем, если у одного из соединений
// клиента возникает критическая ошибка. Вместо этого сервер
// должен закрыть это соединение и продолжать обслуживать
// других клиентов. На самом деле, именно так по умолчанию
//行事 Go's `net/http` для HTTP-серверов.

package main

import "fmt"

// Эта функция вызывает панику.
func mayPanic() {
	panic("a problem")
}

func main() {
	// `recover` должен вызываться внутри отложенной функции.
	// Когда окружающая функция вызывает панику, отложенная
	// функция будет активирована, и вызов `recover` внутри нее
	// поймает панику.
	defer func() {
		if r := recover(); r!= nil {
			// Возвращаемое значение `recover` - это ошибка,
			// поднимаемая при вызове `panic`.
			fmt.Println("Recovered. Error:\n", r)
		}
	}()

	mayPanic()

	// Этот код не будет выполняться, потому что `mayPanic` вызывает панику.
	// Выполнение `main` останавливается в точке паники и продолжается
	// в отложенной функции.
	fmt.Println("После mayPanic()")
}

```
