# 回復

提供されたコードの`mayPanic`関数は、呼び出されたときにパニックを起こします。あなたのタスクは、`main`関数を修正してパニックから回復し、エラーメッセージを表示することです。

- `recover`関数を使用して、`mayPanic`関数内のパニックを処理します。
- パニックが発生したときにエラーメッセージを表示します。

```sh
$ go run recover.go
回復しました。エラー:
問題があります
```

以下に完全なコードがあります。

```go
// Go 言語は、組み込み関数 `recover` を使用することで、パニックから回復することが可能です。`recover` は、パニックがプログラムを中断するのを防ぎ、代わりに実行を続けることができます。

// これが役立つ例：サーバーは、クライアント接続の 1 つが重大なエラーを示した場合にクラッシュしたくありません。代わりに、サーバーはその接続を閉じて、他のクライアントにサービスを続けたいと思います。実際、これが Go の `net/http` が HTTP サーバーに対してデフォルトで行っていることです。

package main

import "fmt"

// この関数はパニックを起こします。
func mayPanic() {
	panic("a problem")
}

func main() {
	// `recover` は、遅延関数内で呼び出す必要があります。
	// 囲まれた関数がパニックを起こしたとき、遅延処理が実行され、その中の `recover` 呼び出しがパニックをキャッチします。
	defer func() {
		if r := recover(); r!= nil {
			// `recover` の戻り値は、`panic` 呼び出しで発生したエラーです。
			fmt.Println("回復しました。エラー:\n", r)
		}
	}()

	mayPanic()

	// このコードは実行されません。なぜなら、`mayPanic` がパニックを起こすからです。
	// `main` の実行は、パニックの時点で停止し、遅延クロージャで再開されます。
	fmt.Println("mayPanic() の後")
}

```
