# Замыкания

Вам нужно создать функцию, которая возвращает другую функцию. Возвращаемая функция должна увеличивать переменную на единицу каждый раз, когда она вызывается. Переменная должна быть уникальной для каждой возвращаемой функции.

- Функция `intSeq` должна возвращать другую функцию.
- Возвращаемая функция должна увеличивать переменную на единицу каждый раз, когда она вызывается.
- Переменная должна быть уникальной для каждой возвращаемой функции.

```sh
$ go run closures.go
1
2
3
1

# Последняя особенность функций, которую мы рассмотрим на данный момент, - это
# рекурсия.
```

Ниже представлен полный код:

```go
// Go поддерживает [анонимные функции](https://en.wikipedia.org/wiki/Anonymous_function),
// которые могут образовывать <a href="https://en.wikipedia.org/wiki/Closure_(computer_science)"><em>замыкания</em></a>.
// Анонимные функции полезны, когда вы хотите определить
// функцию inline, не давая ей имя.

package main

import "fmt"

// Эта функция `intSeq` возвращает другую функцию, которую
// мы определяем анонимно в теле `intSeq`. Возвращаемая функция
// _замыкает_ переменную `i`, чтобы сформировать замыкание.
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {

	// Мы вызываем `intSeq`, присваивая результат (функцию)
	// переменной `nextInt`. Эта функция-значение захватывает
	// собственное значение `i`, которое будет обновляться каждый раз,
	// когда мы вызываем `nextInt`.
	nextInt := intSeq()

	// Посмотрите на эффект замыкания, вызвав `nextInt`
	// несколько раз.
	fmt.Println(nextInt())
	fmt.Println(nextInt())
	fmt.Println(nextInt())

	// Чтобы убедиться, что состояние уникально для этой
	// конкретной функции, создайте и протестируйте новую.
	newInts := intSeq()
	fmt.Println(newInts())
}

```
