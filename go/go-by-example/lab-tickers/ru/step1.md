# Таймеры и тикеры

В этом лабе вам нужно создать тикер, который будет тикать каждые 500 миллисекунд, пока мы не остановим его. Вы будете использовать канал для ожидания значений по мере их поступления.

- Используйте пакет `time` для создания тикера.
- Используйте канал для ожидания значений по мере их поступления.
- Используйте оператор `select` для приема значений из канала.
- Остановите тикер после 1600 миллисекунд.

```sh
# Когда мы запускаем эту программу, тикер должен тикать 3 раза
# до тех пор, пока мы не остановим его.
$ go run tickers.go
Tick at 2012-09-23 11:29:56.487625 -0700 PDT
Tick at 2012-09-23 11:29:56.988063 -0700 PDT
Tick at 2012-09-23 11:29:57.488076 -0700 PDT
Ticker stopped
```

Ниже представлен полный код:

```go
// [Таймеры](timers) используются, когда вы хотите сделать
// что-то один раз в будущем - _тикеры_ используются, когда
// вы хотите выполнять какое-то действие с регулярным
// интервалом. Вот пример тикера, который периодически
// тикает, пока мы не остановим его.

package main

import (
	"fmt"
	"time"
)

func main() {

	// Тикеры используют механизм, похожий на таймеры:
	// канал, в который отправляются значения. Здесь мы
	// будем использовать встроенную функцию `select` для
	// канала, чтобы ожидать значений по мере их поступления
	// каждые 500 миллисекунд.
	ticker := time.NewTicker(500 * time.Millisecond)
	done := make(chan bool)

	go func() {
		for {
			select {
			case <-done:
				return
			case t := <-ticker.C:
				fmt.Println("Tick at", t)
			}
		}
	}()

	// Тикеры можно останавливать, как и таймеры. Как только
	// тикер остановлен, он больше не получит никаких значений
	// на своем канале. Мы остановим наш тикер после 1600
	// миллисекунд.
	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	done <- true
	fmt.Println("Ticker stopped")
}

```
