# 고루틴 (Goroutines)

이 랩에서 해결해야 할 문제는 함수를 동시적으로 실행하기 위해 고루틴을 생성하고 실행하는 것입니다.

- `f` 함수는 입력 문자열과 카운터 변수를 세 번 출력해야 합니다.
- `main` 함수는 `f` 함수를 동기적으로 호출하고 "direct"와 카운터 변수를 세 번 출력해야 합니다.
- `main` 함수는 고루틴을 사용하여 `f` 함수를 비동기적으로 호출하고 "goroutine"과 카운터 변수를 세 번 출력해야 합니다.
- `main` 함수는 메시지를 출력하는 익명 함수를 실행하기 위해 고루틴을 시작해야 합니다.
- `main` 함수는 "done"을 출력하기 전에 고루틴의 실행이 완료될 때까지 기다려야 합니다.

```sh
# 이 프로그램을 실행하면,
# 블로킹 호출의 출력이 먼저 보이고, 그 다음 두
# 고루틴의 출력이 보입니다. 고루틴의 출력은
# Go 런타임에 의해 동시적으로 실행되기 때문에
# 인터리빙될 수 있습니다.

# 다음으로, 동시 Go 프로그램에서 고루틴의 보완적인
# 요소인 채널 (channels) 을 살펴보겠습니다.
```

전체 코드는 다음과 같습니다.

```go
// _고루틴_은 가벼운 실행 스레드입니다.

package main

import (
	"fmt"
	"time"
)

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {

	// `f(s)` 함수 호출이 있다고 가정해 봅시다.
	// 여기서는 일반적인 방식으로 호출하여
	// 동기적으로 실행합니다.
	f("direct")

	// 이 함수를 고루틴에서 호출하려면
	// `go f(s)`를 사용하십시오. 이 새로운 고루틴은
	// 호출하는 고루틴과 동시에 실행됩니다.
	go f("goroutine")

	// 익명 함수 호출에 대한 고루틴을 시작할 수도 있습니다.
	go func(msg string) {
		fmt.Println(msg)
	}("going")

	// 우리의 두 함수 호출은 이제 비동기적으로
	// 별도의 고루틴에서 실행되고 있습니다.
	// (더 강력한 접근 방식의 경우, [WaitGroup](waitgroups) 을 사용하십시오.)
	time.Sleep(time.Second)
	fmt.Println("done")
}
```
