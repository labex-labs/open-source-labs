# Горутины

Задача, которую нужно решить в этом лабе, - это создать и запустить горутины для одновременного выполнения функций.

- Функция `f` должна выводить свою входящую строку и переменную-счетчик три раза.
- Функция `main` должна вызывать функцию `f` синхронно и выводить "direct" и переменную-счетчик три раза.
- Функция `main` должна вызывать функцию `f` асинхронно с использованием горутины и выводить "goroutine" и переменную-счетчик три раза.
- Функция `main` должна запустить горутину для выполнения анонимной функции, которая выводит сообщение.
- Функция `main` должна дождаться завершения выполнения горутин, прежде чем вывести "done".

```sh
# Когда мы запускаем эту программу, мы видим вывод
# блокирующего вызова сначала, а затем вывод двух
# горутин. Вывод горутин может быть перемешанным,
# потому что горутины выполняются одновременно
# Go-런таймом.
$ go run goroutines.go
direct : 0
direct : 1
direct : 2
goroutine : 0
going
goroutine : 1
goroutine : 2
done

# Далее мы рассмотрим дополнение к горутинам в
# конкурентных Go-программах: каналы.

```

Ниже представлен полный код:

```go
// _Горутина_ - это легковесный поток выполнения.

package main

import (
	"fmt"
	"time"
)

func f(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {

	// Предположим, что у нас есть вызов функции `f(s)`. Вот,
	// как мы бы вызывали это обычным способом, запуская
	// его синхронно.
	f("direct")

	// Чтобы вызвать эту функцию в горутине, используйте
	// `go f(s)`. Эта новая горутина будет выполняться
	// одновременно с вызывающей.
	go f("goroutine")

	// Также можно запустить горутину для вызова
	// анонимной функции.
	go func(msg string) {
		fmt.Println(msg)
	}("going")

	// Наши два вызова функций теперь выполняются
	// асинхронно в отдельных горутинах. Дождитесь их
	// завершения (для более надежного подхода используйте
	// [WaitGroup](waitgroups)).
	time.Sleep(time.Second)
	fmt.Println("done")
}

```
