# Таймеры

В практическом занятии требуется реализовать таймер, который будет ожидать заданный период времени и затем сработать. Кроме того, таймер должен быть отменяемым до срабатывания.

- Импортировать пакет `time`.
- Создать два таймера, один из которых будет ожидать 2 секунды, а другой — 1 секунду.
- Первый таймер должен выводить "Timer 1 fired" при срабатывании.
- Второй таймер должен выводить "Timer 2 fired" при срабатывании.
- Второй таймер должен быть отменен до срабатывания.
- Программа должна ожидать 2 секунды, чтобы показать, что второй таймер не сработал.

```sh
// Первый таймер сработает приблизительно через 2 секунды после запуска
// программы, а второй должен быть остановлен, прежде чем успеет сработать.
$ go run timers.go
Timer 1 fired
Timer 2 stopped
```

Ниже представлен полный код:

```go
// Мы часто хотим выполнить Go-код в будущем или повторять его с определенным интервалом. Встроенные в Go
// функции _таймера_ и _тикера_ упрощают оба эти действия. Сначала рассмотрим таймеры, а затем
// [тикеры](tickers).

package main

import (
	"fmt"
	"time"
)

func main() {

	// Таймеры представляют собой одно событие в будущем. Вы
	// сообщаете таймеру, сколько времени вы хотите дождаться, и он
	// предоставляет канал, по которому будет отправлено уведомление в то время. Этот таймер будет ждать 2 секунды.
	timer1 := time.NewTimer(2 * time.Second)

	// `<-timer1.C` блокируется на канале `C` таймера,
	// пока он не отправит значение, указывающее на то, что таймер сработал.
	<-timer1.C
	fmt.Println("Timer 1 fired")

	// Если вы просто хотели дождаться, вы могли бы использовать
	// `time.Sleep`. Одна из причин, по которой таймер может быть полезен, заключается в том, что вы можете отменить таймер до его срабатывания.
	// Вот пример этого.
	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	// Дайте `timer2` достаточно времени, чтобы сработать, если это когда-либо случилось, чтобы показать, что он на самом деле остановлен.
	time.Sleep(2 * time.Second)
}

```
