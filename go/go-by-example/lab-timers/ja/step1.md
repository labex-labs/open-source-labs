# タイマー

この実験では、指定された期間待機した後に実行されるタイマーの実装が必要です。また、タイマーが実行される前にキャンセルできるようにする必要があります。

- `time` パッケージをインポートする必要があります。
- 2 つのタイマーを作成します。1 つは 2 秒待機するものと、もう 1 つは 1 秒待機するものです。
- 最初のタイマーが実行されたときに "Timer 1 fired" を出力するようにします。
- 2 番目のタイマーが実行されたときに "Timer 2 fired" を出力するようにします。
- 2 番目のタイマーが実行される前にキャンセルするようにします。
- 2 番目のタイマーが実行されなかったことを示すために、プログラムを 2 秒間待機させます。

```sh
// 最初のタイマーは、プログラムを開始してから約2秒後に実行されますが、2番目のタイマーは実行される前に停止される必要があります。
$ go run timers.go
Timer 1 fired
Timer 2 stopped
```

以下が完全なコードです：

```go
// 私たちはしばしば、将来のある時点で Go コードを実行したり、一定の間隔で繰り返し実行したりしたいものです。Go の組み込みの _タイマー_ と _チェッカー_ 機能により、これらの両方のタスクが簡単になります。まずはタイマーを見て、その後 [チェッカー](tickers) を見ます。

package main

import (
	"fmt"
	"time"
)

func main() {

	// タイマーは、将来の単一のイベントを表します。あなたはタイマーにどれだけ待機するかを伝え、それがその時に通知されるチャネルを提供します。このタイマーは 2 秒間待機します。
	timer1 := time.NewTimer(2 * time.Second)

	// `<-timer1.C` は、タイマーのチャネル `C` をブロックして、タイマーが実行されたことを示す値を送信するまで待ちます。
	<-timer1.C
	fmt.Println("Timer 1 fired")

	// ただ待ちたい場合、`time.Sleep` を使うこともできます。タイマーが便利な理由の 1 つは、タイマーが実行される前にキャンセルできることです。ここにその例を示します。
	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	// `timer2` が実行されるのに十分な時間を与えて、もしそれが実行される予定だった場合には、それが実際に停止されていることを示します。
	time.Sleep(2 * time.Second)
}

```
