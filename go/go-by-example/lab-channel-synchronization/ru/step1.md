# Синхронизация по каналам

Задача, которую нужно решить в этом лабораторном проекте, - создать goroutine, которая выполняет какую-то работу и уведомляет другую goroutine, когда закончит работу, используя канал.

Для завершения этого лабораторного проекта вам понадобится:

- Создать функцию с именем `worker`, которая принимает канал типа `bool` в качестве параметра.
- Внутри функции `worker` выполнить какую-то работу, а затем отправить значение в канал, чтобы уведомить, что работа завершена.
- В функции `main` создать канал типа `bool` с размером буфера 1.
- Запустить goroutine, которая вызывает функцию `worker` и передает канал в качестве параметра.
- Заблокировать функцию `main`, пока не будет получено значение из канала.

```sh
$ go run channel-synchronization.go
working...done

# Если вы удалили строку `<- done` из этой программы,
# программа завершилась бы, даже не запустив `worker`.
```

Ниже представлен полный код:

```go
// Мы можем использовать каналы для синхронизации выполнения
// между goroutine. Вот пример использования блокирующего приема,
// чтобы дождаться завершения goroutine.
// Когда нужно дождаться завершения нескольких goroutine,
// вы, возможно, предпочтете использовать [WaitGroup](waitgroups).

package main

import (
	"fmt"
	"time"
)

// Эта функция будет выполняться в goroutine. Канал
// `done` будет использоваться для уведомления другой
// goroutine о том, что работа этой функции завершена.
func worker(done chan bool) {
	fmt.Print("working...")
	time.Sleep(time.Second)
	fmt.Println("done")

	// Отправить значение, чтобы уведомить, что мы закончили.
	done <- true
}

func main() {

	// Запустить goroutine-рабочий, передав ему канал для
	// уведомления.
	done := make(chan bool, 1)
	go worker(done)

	// Заблокировать, пока не получим уведомление от
	// рабочего по каналу.
	<-done
}

```
