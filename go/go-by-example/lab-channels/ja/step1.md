# チャネル

この実験では、新しいチャネルを作成し、新しい goroutine から値を送信する必要があります。その後、チャネルから値を受信して表示します。

- 新しいチャネルを作成するには、`make(chan val-type)` 構文を使用する必要があります。
- チャネルは、それが伝える値によって型付けされます。
- 値をチャネルに送信するには、`channel <-` 構文を使用する必要があります。
- チャネルから値を受信するには、`<-channel` 構文を使用する必要があります。
- 値をチャネルに送信するには、新しい goroutine を使用する必要があります。

```sh
# プログラムを実行すると、"ping" メッセージが
# チャネルを介して 1 つの goroutine から別の goroutine に
# 正常に渡されます。
$ go run channels.go
ping

# 既定では、送信と受信は、送信者と受信者の両方が準備できるまでブロックされます。この特性により、
# プログラムの最後で "ping" メッセージを待つことができ、
# その他の同期化を使用する必要がなくなります。
```

以下が完全なコードです：

```go
// _チャネル_ は、並行した goroutine を接続するパイプです。
// 1 つの goroutine からチャネルに値を送信し、別の goroutine でそれらの値を受信することができます。

package main

import "fmt"

func main() {

	// `make(chan val-type)` を使用して新しいチャネルを作成します。
	// チャネルは、それが伝える値によって型付けされます。
	messages := make(chan string)

	// `channel <-` 構文を使用して、値をチャネルに _送信_ します。
	// ここでは、新しい goroutine から、上で作成した `messages` チャネルに "ping" を送信します。
	go func() { messages <- "ping" }()

	// `<-channel` 構文は、チャネルから値を _受信_ します。
	// ここでは、上で送信した "ping" メッセージを受信して表示します。
	msg := <-messages
	fmt.Println(msg)
}

```
