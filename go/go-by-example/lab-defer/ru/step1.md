# Defer

В этом практическом задании вам нужно использовать `defer` для создания файла, записи в него и закрытия файла после завершения операций.

- Функция `createFile` должна создать файл с указанным путём и вернуть указатель на файл.
- Функция `writeFile` должна записать строку "data" в файл.
- Функция `closeFile` должна закрыть файл и проверить наличие ошибок.

```sh
# Запуск программы подтверждает, что файл закрывается
# после записи.
$ go run defer.go
создаю
пишу
закрываю
```

Ниже представлен полный код:

```go
// _Defer_ используется для обеспечения выполнения вызова функции
// позже в ходе выполнения программы, обычно для целей очистки.
// `defer` часто используется там, где в других языках
// применяются `ensure` и `finally`.

package main

import (
	"fmt"
	"os"
)

// Предположим, что мы хотим создать файл, записать в него
// и затем закрыть его после завершения операций. Вот, как мы
// можем это сделать с использованием `defer`.
func main() {

	// Только что после получения объекта файла с помощью
	// `createFile` мы откладываем закрытие этого файла с
	// использованием `closeFile`. Это будет выполнено в конце
	// окружающей функции (`main`), после окончания
	// выполнения `writeFile`.
	f := createFile("/tmp/defer.txt")
	defer closeFile(f)
	writeFile(f)
}

func createFile(p string) *os.File {
	fmt.Println("создаю")
	f, err := os.Create(p)
	if err!= nil {
		panic(err)
	}
	return f
}

func writeFile(f *os.File) {
	fmt.Println("пишу")
	fmt.Fprintln(f, "data")

}

func closeFile(f *os.File) {
	fmt.Println("закрываю")
	err := f.Close()
	// Важно проверять наличие ошибок при закрытии файла,
	// даже в отложенной функции.
	if err!= nil {
		fmt.Fprintf(os.Stderr, "ошибка: %v\n", err)
		os.Exit(1)
	}
}

```
