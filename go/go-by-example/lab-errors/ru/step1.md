# Ошибки

В лабораторном задании представлены две функции, которые возвращают ошибку, если входной аргумент равен 42. Первая функция возвращает базовое значение ошибки, а вторая функция использует пользовательский тип для представления ошибки.

- Необходимо импортировать пакет `errors`.
- Функция `f1` должна возвращать ошибку, если входной аргумент равен 42.
- Функция `f2` должна возвращать ошибку типа `argError`, если входной аргумент равен 42.
- Тип `argError` должен иметь два поля: `arg` и `prob`.
- Тип `argError` должен реализовать метод `Error()`.
- Функция `main` должна вызывать обе `f1` и `f2` с входными аргументами 7 и 42.
- Функция `main` должна выводить результат каждого вызова функции, а также любую возвращаемую ошибку.
- Функция `main` должна показать, как программно использовать данные в пользовательской ошибке.

```sh

# См. этот [отличный пост](https://go.dev/blog/error-handling-and-go)
# на блоге Go для получения дополнительной информации о обработке ошибок.
```

Ниже представлен полный код:

```go
// В Go принято передавать ошибки через явный, отдельный возвращаемый параметр.
// Это отличается от исключений, используемых в языках, таких как Java и Ruby,
// и от перегруженного единственного результата / значения ошибки,
// иногда используемого в C. Подход Go позволяет легко увидеть,
// какие функции возвращают ошибки, и обрабатывать их с использованием
// тех же языковых конструкций, что и для любых других, не связанных с ошибками, задач.

package main

import (
	"errors"
	"fmt"
)

// По соглашению ошибки являются последним возвращаемым значением и
// имеют тип `error`, встроенный интерфейс.
func f1(arg int) (int, error) {
	if arg == 42 {

		// `errors.New` создает базовое значение `error`
		// с заданным сообщением об ошибке.
		return -1, errors.New("can't work with 42")

	}

	// Значение `nil` в позиции ошибки означает, что ошибки не было.
	return arg + 3, nil
}

// Возможно использовать пользовательские типы в качестве `error`,
// реализовав метод `Error()` для них. Вот вариант предыдущего примера,
// который использует пользовательский тип для явного представления ошибки аргумента.
type argError struct {
	arg  int
	prob string
}

func (e *argError) Error() string {
	return fmt.Sprintf("%d - %s", e.arg, e.prob)
}

func f2(arg int) (int, error) {
	if arg == 42 {

		// В этом случае мы используем синтаксис `&argError` для создания
		// нового структуры, передавая значения для двух полей `arg` и `prob`.
		return -1, &argError{arg, "can't work with it"}
	}
	return arg + 3, nil
}

func main() {

	// Два цикла ниже проверяют каждую из наших функций, возвращающих ошибки.
	// Обратите внимание, что использование встроенной проверки ошибки на строке `if`
	// является распространенной идиомой в коде Go.
	for _, i := range []int{7, 42} {
		if r, e := f1(i); e!= nil {
			fmt.Println("f1 failed:", e)
		} else {
			fmt.Println("f1 worked:", r)
		}
	}
	for _, i := range []int{7, 42} {
		if r, e := f2(i); e!= nil {
			fmt.Println("f2 failed:", e)
		} else {
			fmt.Println("f2 worked:", r)
		}
	}

	// Если вы хотите программно использовать данные в пользовательской ошибке,
	// вам нужно получить ошибку в виде экземпляра пользовательского типа ошибки
	// с помощью утверждения типа.
	_, e := f2(42)
	if ae, ok := e.(*argError); ok {
		fmt.Println(ae.arg)
		fmt.Println(ae.prob)
	}
}

```
