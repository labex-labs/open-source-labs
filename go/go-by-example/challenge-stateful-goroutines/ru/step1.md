# Состоятельные горутины

В параллельном программировании至关重要的是同步对共享状态的访问，以避免竞争条件和数据损坏。此挑战呈现了一种场景，其中单个 горутина拥有状态，而其他 горутины发送消息以读取或写入该状态。

## Требования

- Использовать каналы для отправки запросов на чтение и запись состояния в горутину, которая владеет состоянием.
- Использовать структуры `readOp` и `writeOp` для инкапсуляции запросов и ответов.
- Использовать мапу для хранения состояния.
- Использовать каналы `resp` для индикации успеха и возврата значений.
- Использовать пакет `atomic` для подсчета операций чтения и записи.
- Использовать пакет `time` для добавления задержки между операциями.

## Пример

```sh
# Запуск нашей программы показывает, что пример управления
# состоянием на основе горутин завершает около 80 000
# операций в сумме.
$ go run stateful-goroutines.go
readOps: 71708
writeOps: 7177

# В этом конкретном случае подход на основе горутин был
# немного более сложным, чем подход на основе мьютексов.
# Тем не менее, он может быть полезен в некоторых случаях,
# например, когда есть другие каналы, или когда управление
# несколькими такими мьютексами было бы ошибочным. Вы
# должны использовать подход, который кажется наиболее
# естественным, особенно в отношении понимания
# правильности вашей программы.
```
