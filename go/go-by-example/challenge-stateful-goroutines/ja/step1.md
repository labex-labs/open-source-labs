# 状態を持つ goroutine

並列プログラミングにおいて、共有状態へのアクセスを同期させることは、競合条件やデータの破損を回避するために不可欠です。このチャレンジでは、単一の goroutine が状態を所有し、他の goroutine が状態を読み書きするためのメッセージを送信するシナリオを提示します。

## 要件

- 状態を所有する goroutine に対して読み書き要求を行うためにチャネルを使用する。
- 要求と応答をカプセル化するために `readOp` と `writeOp` 構造体を使用する。
- 状態を格納するために map を使用する。
- 成功と戻り値を示すために `resp` チャネルを使用する。
- 読み書き操作の回数をカウントするために `atomic` パッケージを使用する。
- 操作間に遅延を追加するために `time` パッケージを使用する。

## 例

```sh
# 私たちのプログラムを実行すると、goroutine ベースの
# 状態管理の例が約 80,000 回の合計操作を完了することがわかります。
$ go run stateful-goroutines.go
readOps: 71708
writeOps: 7177

# この特定のケースでは、goroutine ベースのアプローチは
# ミューテックスベースのアプローチよりも少し複雑でした。
# ただし、特定のケースでは役立つ場合があります。
# たとえば、他のチャネルが関係している場合や、
# 複数のこのようなミューテックスを管理するのが誤りやすい場合です。
# プログラムの正しさを理解することに関して、
# どちらのアプローチも自然に感じられるものを使用する必要があります。
```
