# Таймауты

Таймауты важны для программ, которые подключаются к внешним ресурсам или иначе должны ограничивать время выполнения. В этом лабораторном занятии мы реализуем таймауты в Go с использованием каналов и `select`.

- Реализовать таймауты в Go с использованием каналов и `select`.
- Использовать буферизованный канал, чтобы предотвратить утечку горутин, если канал никогда не читается.
- Использовать `time.After`, чтобы ожидать значения, которое будет отправлено после истечения таймаута.
- Использовать `select`, чтобы продолжить выполнение с первого готового приема.

```sh
# Запуск этой программы показывает, что первая операция
# завершается по таймауту, а вторая - успешно.
$ go run timeouts.go
timeout 1
result 2
```

Ниже представлен полный код:

```go
// _Таймауты_ важны для программ, которые подключаются к
// внешним ресурсам или иначе должны ограничивать
// время выполнения. Реализация таймаутов в Go проста и
// элегантна благодаря каналам и `select`.

package main

import (
	"fmt"
	"time"
)

func main() {

	// В нашем примере предположим, что мы выполняем внешний
	// вызов, который возвращает результат по каналу `c1`
	// спустя 2 секунды. Обратите внимание, что канал
	// буферизован, поэтому отправка в горутине не блокирует.
	// Это распространенный паттерн для предотвращения
	// утечки горутин, если канал никогда не читается.
	c1 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()

	// Вот `select`, реализующий таймаут. `res := <-c1`
	// ожидает результата, а `<-time.After` ожидает значения,
	// которое будет отправлено после таймаута в 1 секунду.
	// Поскольку `select` продолжает выполнение с первого
	// готового приема, мы получим случай с таймаутом, если
	// операция выполняется дольше разрешенного 1 секунды.
	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	// Если мы допустим более длинный таймаут в 3 секунды,
	// то прием из `c2` будет успешным и мы выведем результат.
	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}

```
