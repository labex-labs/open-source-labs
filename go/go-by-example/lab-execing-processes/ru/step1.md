# Запуск процессов

Задача заключается в замене текущего процесса Go на другой процесс, например, не-Go процесс.

- Язык программирования Go
- Основы знания функции `exec` в Go
- Ознакомленность с переменными окружения

```sh
# Когда мы запускаем нашу программу, она заменяется на `ls`.
$ go run execing-processes.go
total 16
drwxr-xr-x 4 mark 136B Oct 3 16:29.
drwxr-xr-x 91 mark 3.0K Oct 3 12:50..
-rw-r--r-- 1 mark 1.3K Oct 3 16:28 execing-processes.go

# Обратите внимание, что Go не предоставляет классическую Unix функцию `fork`.
# Обычно это не является проблемой, так как запуск goroutines, создание процессов и запуск процессов
# покрывает большинство случаев использования `fork`.
```

Ниже представлен полный код:

```go
// В предыдущем примере мы рассматривали
// [создание внешних процессов](spawning-processes). Мы
// делаем это, когда нам нужен внешний процесс, доступный для
// запущенного процесса Go. Иногда мы просто хотим
// полностью заменить текущий процесс Go на другой
// (возможно, не-Go) процесс. Для этого мы будем использовать реализацию Go
// классической
// <a href="https://en.wikipedia.org/wiki/Exec_(operating_system)"><code>exec</code></a>
// функции.

package main

import (
	"os"
	"os/exec"
	"syscall"
)

func main() {

	// Для нашего примера мы будем запускать `ls`. Go требует
	// абсолютного пути к бинарнику, который мы хотим выполнить, поэтому
	// мы будем использовать `exec.LookPath`, чтобы найти его (скорее всего
	// `/bin/ls`).
	binary, lookErr := exec.LookPath("ls")
	if lookErr!= nil {
		panic(lookErr)
	}

	// `Exec` требует аргументов в виде среза (в отличие от
	// одной большой строки). Мы передадим `ls` несколько
	// общих аргументов. Обратите внимание, что первый аргумент должен
	// быть именем программы.
	args := []string{"ls", "-a", "-l", "-h"}

	// `Exec` также требует набора [переменных окружения](environment-variables)
	// для использования. Здесь мы просто предоставляем нашу текущую
	// среду.
	env := os.Environ()

	// Вот фактический вызов `syscall.Exec`. Если этот вызов
	// успешен, выполнение нашего процесса будет завершено
	// здесь и будет заменено процессом `/bin/ls -a -l -h`. Если
	// возникнет ошибка, мы получим возвращаемое значение.
	execErr := syscall.Exec(binary, args, env)
	if execErr!= nil {
		panic(execErr)
	}
}

```
