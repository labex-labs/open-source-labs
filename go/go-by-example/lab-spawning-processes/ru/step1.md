# Запуск процессов

В данной лабораторной работе требуется реализовать Go-программу, которая запускает внешние процессы и собирает их вывод.

- Программа должна уметь запускать внешние процессы.
- Программа должна уметь собирать вывод внешних процессов.
- Программа должна обрабатывать ошибки, которые могут возникнуть во время выполнения внешних процессов.

```sh
# Запущенные программы возвращают такой же вывод,
# как если бы мы запускали их напрямую из командной строки.
$ go run spawning-processes.go
> date
Чт 05 мая 2022 22:10:12 PDT

# date не имеет флага `-x`, поэтому она завершится с
# сообщением об ошибке и ненулевым кодом возврата.
команда завершилась с кодом возврата rc = 1
hello > grep
hello grep

-a > ls -l -h
drwxr-xr-x 4 mark 136B Oct 3 16:29.
drwxr-xr-x 91 mark 3.0K Oct 3 12:50..
-rw-r--r-- 1 mark 1.3K Oct 3 16:28 spawning-processes.go
```

Ниже представлен полный код:

```go
// Иногда наши Go-программы должны запускать другие, не на Go
// процессы.

package main

import (
	"fmt"
	"io"
	"os/exec"
)

func main() {

	// Начнем с простой команды, которая не требует
	// аргументов или ввода и просто выводит что-то в
	// stdout. Помощник `exec.Command` создает объект,
	// представляющий этот внешний процесс.
	dateCmd := exec.Command("date")

	// Метод `Output` запускает команду, ждет ее завершения
	// и собирает ее стандартный вывод.
	// Если не возникло ошибок, `dateOut` будет содержать байты
	// с информацией о дате.
	dateOut, err := dateCmd.Output()
	if err!= nil {
		panic(err)
	}
	fmt.Println("> date")
	fmt.Println(string(dateOut))

	// `Output` и другие методы `Command` вернут
	// `*exec.Error`, если при выполнении команды возникла проблема
	// (например, неправильный путь), и `*exec.ExitError`,
	// если команда завершилась с ненулевым кодом возврата.
	_, err = exec.Command("date", "-x").Output()
	if err!= nil {
		switch e := err.(type) {
		case *exec.Error:
			fmt.Println("не удалось выполнить:", err)
		case *exec.ExitError:
			fmt.Println("команда завершилась с кодом возврата rc =", e.ExitCode())
		default:
			panic(err)
		}
	}

	// Далее рассмотрим более сложный случай, когда мы
	// передаем данные в внешний процесс по его
	// `stdin` и собираем результаты с его `stdout`.
	grepCmd := exec.Command("grep", "hello")

	// Здесь мы явно получаем каналы ввода/вывода, запускаем
	// процесс, записываем в него некоторый ввод, читаем
	// результирующий вывод и, наконец, ждем завершения процесса.
	grepIn, _ := grepCmd.StdinPipe()
	grepOut, _ := grepCmd.StdoutPipe()
	grepCmd.Start()
	grepIn.Write([]byte("hello grep\ngoodbye grep"))
	grepIn.Close()
	grepBytes, _ := io.ReadAll(grepOut)
	grepCmd.Wait()

	// В вышеприведенном примере мы опустили проверку ошибок, но
	// вы можете использовать обычный шаблон `if err!= nil` для всех них.
	// Мы также собираем только результаты `StdoutPipe`, но вы можете
	// собирать результаты `StderrPipe` точно так же.
	fmt.Println("> grep hello")
	fmt.Println(string(grepBytes))

	// Обратите внимание, что при запуске команд нам нужно
	// явно указать массив команды и аргументов, в отличие от
	// возможности просто передать одну командную строку. Если вы
	// хотите запустить полную команду из строки, вы можете использовать
	// параметр `-c` `bash`:
	lsCmd := exec.Command("bash", "-c", "ls -a -l -h")
	lsOut, err := lsCmd.Output()
	if err!= nil {
		panic(err)
	}
	fmt.Println("> ls -a -l -h")
	fmt.Println(string(lsOut))
}

```
