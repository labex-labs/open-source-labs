# Activando modelos

Ese pequeño código de modelo le da a Django mucha información. Con él, Django es capaz de:

- Crear un esquema de base de datos (`CREATE TABLE` statements) para esta aplicación.
- Crear una API de acceso a la base de datos de Python para acceder a objetos `Question` y `Choice`.

Pero primero debemos decirle a nuestro proyecto que la aplicación `polls` está instalada.

Las aplicaciones de Django son "pluggables": Puede usar una aplicación en múltiples proyectos y puede distribuir aplicaciones, porque no tienen que estar vinculadas a una instalación de Django determinada.

Para incluir la aplicación en nuestro proyecto, debemos agregar una referencia a su clase de configuración en la configuración `INSTALLED_APPS`. La clase `PollsConfig` está en el archivo `polls/apps.py`, por lo que su ruta puntual es `'polls.apps.PollsConfig'`. Edite el archivo `mysite/settings.py` y agregue esa ruta puntual a la configuración `INSTALLED_APPS`. Se verá así:

```python
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

Ahora Django sabe que debe incluir la aplicación `polls`. Vamos a ejecutar otro comando:

```bash
python manage.py makemigrations polls
```

Debería ver algo similar a lo siguiente:

```plaintext
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
```

Al ejecutar `makemigrations`, está diciendo a Django que ha hecho algunos cambios en sus modelos (en este caso, ha creado nuevos) y que desea que los cambios se almacenen como una _migración_.

Las migraciones son la forma en que Django almacena los cambios en sus modelos (y por lo tanto en su esquema de base de datos); son archivos en el disco. Puede leer la migración de su nuevo modelo si lo desea; es el archivo `polls/migrations/0001_initial.py`. No se preocupe, no se espera que los lea cada vez que Django los hace, pero están diseñados para ser editables por humanos en caso de que desee ajustar manualmente cómo Django cambia las cosas.

Hay un comando que ejecutará las migraciones por usted y gestionará automáticamente su esquema de base de datos; se llama `migrate`, y llegaremos a él en un momento, pero primero, veamos qué SQL ejecutaría esa migración. El comando `sqlmigrate` toma los nombres de las migraciones y devuelve su SQL:

```bash
python manage.py sqlmigrate polls 0001
```

Debería ver algo similar a lo siguiente (lo hemos reformateado para mayor legibilidad):

```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

Tenga en cuenta lo siguiente:

- La salida exacta variará según la base de datos que esté usando. El ejemplo anterior se genera para PostgreSQL.
- Los nombres de las tablas se generan automáticamente combinando el nombre de la aplicación (`polls`) y el nombre en minúsculas del modelo: `question` y `choice`. (Puede anular este comportamiento.)
- Las claves primarias (IDs) se agregan automáticamente. (También puede anular esto.)
- Por convención, Django agrega `"_id"` al nombre del campo de clave externa. (Sí, también puede anular esto.)
- La relación de clave externa se hace explícita por una restricción `FOREIGN KEY`. No se preocupe por las partes `DEFERRABLE`; está diciendo a PostgreSQL que no enforce la clave externa hasta el final de la transacción.
- Está adaptado a la base de datos que está usando, por lo que los tipos de campo específicos de la base de datos como `auto_increment` (MySQL), `bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY` (PostgreSQL) o `integer primary key autoincrement` (SQLite) se manejan automáticamente para usted. Lo mismo ocurre con la citación de los nombres de los campos, por ejemplo, usando comillas dobles o simples.
- El comando `sqlmigrate` no ejecuta realmente la migración en su base de datos; en cambio, la imprime en la pantalla para que pueda ver qué SQL Django piensa que es necesario. Es útil para comprobar lo que Django va a hacer o si tiene administradores de base de datos que requieren scripts SQL para los cambios.

Si está interesado, también puede ejecutar `python manage.py check <check>`; esto comprueba si hay algún problema en su proyecto sin hacer migraciones ni tocar la base de datos.

Ahora, ejecute `migrate` nuevamente para crear esas tablas de modelo en su base de datos:

```bash
python manage.py migrate
```

```plaintext
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying polls.0001_initial... OK
```

El comando `migrate` toma todas las migraciones que no se han aplicado (Django rastrea cuáles se han aplicado usando una tabla especial en su base de datos llamada `django_migrations`) y las ejecuta en su base de datos, esencialmente, sincronizando los cambios que hizo en sus modelos con el esquema en la base de datos.

Las migraciones son muy poderosas y le permiten cambiar sus modelos con el tiempo, a medida que desarrolla su proyecto, sin necesidad de eliminar su base de datos o tablas y crear nuevas; se especializa en actualizar su base de datos en vivo, sin perder datos. Lo cubriremos en mayor profundidad en una parte posterior del tutorial, pero por ahora, recuerde la guía de tres pasos para hacer cambios en los modelos:

- Cambie sus modelos (en `models.py`).
- Ejecute `python manage.py makemigrations <makemigrations>` para crear migraciones para esos cambios.
- Ejecute `python manage.py migrate <migrate>` para aplicar esos cambios a la base de datos.

La razón de que haya comandos separados para crear y aplicar migraciones es porque se enviarán las migraciones a su sistema de control de versiones y se enviarán con su aplicación; no solo facilitan su desarrollo, sino que también son utilizables por otros desarrolladores y en producción.

Lea la `documentación de django-admin </ref/django-admin>` para obtener información completa sobre lo que puede hacer la utilidad `manage.py`.
