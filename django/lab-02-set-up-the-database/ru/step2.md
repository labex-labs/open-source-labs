# Создание моделей

Теперь мы определим ваши модели - по существу, схему вашей базы данных, с дополнительными метаданными.

Модель - это единственный определяющий источник информации о ваших данных. Она содержит основные поля и поведение данных, которые вы храните. Django следуют принципу `DRY <dry>`. Цель - определить вашу модель данных в одном месте и автоматически получать из нее все необходимое.

Это включает в себя миграции - в отличие, например, от Ruby On Rails, миграции полностью определяются вашим файлом моделей и представляют собой, по сути, историю, которую Django может использовать для обновления схемы вашей базы данных, чтобы она соответствовала вашим текущим моделям.

В нашем приложении для опросов мы создадим две модели: `Question` (Вопрос) и `Choice` (Вариант ответа). `Question` имеет вопрос и дату публикации. `Choice` имеет два поля: текст варианта ответа и счетчик голосов. Каждый `Choice` связан с `Question`.

Эти концепции представлены в виде Python-классов. Отредактируйте файл `polls/models.py` так, чтобы он выглядел следующим образом:

```python
from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
```

Здесь каждая модель представлена классом, который наследуется от `django.db.models.Model`. Каждая модель имеет ряд переменных класса, каждая из которых представляет собой поле базы данных в модели.

Каждое поле представлено экземпляром класса `~django.db.models.Field` - например, `~django.db.models.CharField` для текстовых полей и `~django.db.models.DateTimeField` для дат и времени. Это сообщает Django, какой тип данных хранит каждое поле.

Имя каждого экземпляра `~django.db.models.Field` (например, `question_text` или `pub_date`) - это имя поля в формате, удобном для машин. Вы будете использовать это значение в своем Python-коде, а ваша база данных будет использовать его в качестве имени столбца.

Вы можете использовать необязательный первый позиционный аргумент для `~django.db.models.Field`, чтобы указать человекочитаемое имя. Это используется в нескольких интроспективных частях Django и служит одновременно и документацией. Если это поле не указано, Django будет использовать машиночитаемое имя. В этом примере мы определили только человекочитаемое имя для `Question.pub_date`. Для всех других полей в этой модели имя поля в машиночитаемом формате будет достаточно и в качестве его человекочитаемого имени.

Некоторые классы `~django.db.models.Field` требуют обязательных аргументов. Например, `~django.db.models.CharField` требует, чтобы вы указали для него `~django.db.models.CharField.max_length`. Это используется не только в схеме базы данных, но и при валидации, как мы вскоре увидим.

`~django.db.models.Field` также может иметь различные необязательные аргументы; в этом случае мы установили значение `~django.db.models.Field.default` для `votes` равным 0.

Наконец, обратите внимание, что определена связь, с использованием `~django.db.models.ForeignKey`. Это сообщает Django, что каждый `Choice` связан с одним `Question`. Django поддерживает все общие типы отношений базы данных: многие-ко-одному, многие-ко-многим и один-ко-одному.
