# Activation des modèles

Ce petit bout de code de modèle fournit beaucoup d'informations à Django. Avec cela, Django est capable de :

- Créer un schéma de base de données (`CREATE TABLE` statements) pour cette application.
- Créer une API d'accès à la base de données en Python pour accéder aux objets `Question` et `Choice`.

Mais tout d'abord, nous devons informer notre projet que l'application `polls` est installée.

Les applications Django sont "pluggables" : vous pouvez utiliser une application dans plusieurs projets, et vous pouvez distribuer des applications, car elles n'ont pas besoin d'être liées à une installation de Django donnée.

Pour inclure l'application dans notre projet, nous devons ajouter une référence à sa classe de configuration dans la configuration `INSTALLED_APPS`. La classe `PollsConfig` se trouve dans le fichier `polls/apps.py`, donc son chemin ponctué est `'polls.apps.PollsConfig'`. Éditez le fichier `mysite/settings.py` et ajoutez ce chemin ponctué à la configuration `INSTALLED_APPS`. Cela devrait ressembler à ceci :

```python
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

Maintenant, Django sait qu'il doit inclure l'application `polls`. Exécutons une autre commande :

```bash
python manage.py makemigrations polls
```

Vous devriez voir quelque chose de similaire au suivant :

```plaintext
Migrations pour 'polls' :
  polls/migrations/0001_initial.py
    - Créer le modèle Question
    - Créer le modèle Choice
```

En exécutant `makemigrations`, vous dites à Django que vous avez apporté certaines modifications à vos modèles (dans ce cas, vous avez créé de nouveaux modèles) et que vous souhaitez que les modifications soient stockées sous forme de _migration_.

Les migrations sont la manière dont Django stocke les modifications apportées à vos modèles (et donc à votre schéma de base de données) - ce sont des fichiers sur le disque. Vous pouvez lire la migration pour votre nouveau modèle si vous le souhaitez ; il s'agit du fichier `polls/migrations/0001_initial.py`. Ne vous inquiétez pas, vous n'êtes pas censé les lire chaque fois que Django en crée une, mais ils sont conçus pour être modifiables à la main au cas où vous souhaiteriez modifier manuellement la manière dont Django modifie les choses.

Il existe une commande qui exécutera les migrations pour vous et gérera automatiquement votre schéma de base de données - c'est la commande `migrate`, et nous y reviendrons tout de suite - mais tout d'abord, voyons quelle requête SQL cette migration exécuterait. La commande `sqlmigrate` prend les noms de migrations et renvoie leur SQL :

```bash
python manage.py sqlmigrate polls 0001
```

Vous devriez voir quelque chose de similaire au suivant (nous l'avons reformatté pour plus de lisibilité) :

```sql
BEGIN;
--
-- Créer le modèle Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Créer le modèle Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

Remarquez ceci :

- La sortie exacte variera selon la base de données que vous utilisez. L'exemple ci-dessus est généré pour PostgreSQL.
- Les noms de tables sont générés automatiquement en combinant le nom de l'application (`polls`) et le nom en minuscules du modèle - `question` et `choice`. (Vous pouvez modifier ce comportement.)
- Les clés primaires (IDs) sont ajoutées automatiquement. (Vous pouvez également modifier cela.)
- Par convention, Django ajoute `"_id"` au nom du champ de clé étrangère. (Oui, vous pouvez également modifier cela.)
- La relation de clé étrangère est explicitée par une contrainte `FOREIGN KEY`. Ne vous inquiétez pas des parties `DEFERRABLE` ; elle indique à PostgreSQL de ne pas appliquer la contrainte de clé étrangère jusqu'à la fin de la transaction.
- Elle est adaptée à la base de données que vous utilisez, donc les types de champs spécifiques à la base de données tels que `auto_increment` (MySQL), `bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY` (PostgreSQL) ou `integer primary key autoincrement` (SQLite) sont gérés automatiquement pour vous. Il en est de même pour la cote des noms de champs - par exemple, en utilisant des guillemets doubles ou des guillemets simples.
- La commande `sqlmigrate` n'exécute pas réellement la migration sur votre base de données - au lieu de cela, elle l'affiche à l'écran afin que vous puissiez voir quelle requête SQL Django estime nécessaire. C'est utile pour vérifier ce que Django va faire ou si vous avez des administrateurs de base de données qui exigent des scripts SQL pour les modifications.

Si vous êtes intéressé, vous pouvez également exécuter `python manage.py check <check>` ; cela vérifie s'il y a des problèmes dans votre projet sans effectuer de migrations ni toucher la base de données.

Maintenant, exécutez `migrate` à nouveau pour créer ces tables de modèles dans votre base de données :

```bash
python manage.py migrate
```

```plaintext
Opérations à effectuer :
  Appliquer toutes les migrations : admin, auth, contenttypes, polls, sessions
Exécution des migrations :
  Appliquer polls.0001_initial... OK
```

La commande `migrate` prend toutes les migrations qui n'ont pas été appliquées (Django suit les migrations appliquées en utilisant une table spéciale dans votre base de données appelée `django_migrations`) et les exécute sur votre base de données - essentiellement, elle synchronise les modifications que vous avez apportées à vos modèles avec le schéma dans la base de données.

Les migrations sont très puissantes et vous permettent de modifier vos modèles au fil du temps, au fur et à mesure que vous développez votre projet, sans avoir à supprimer votre base de données ou vos tables et à en créer de nouvelles - elle se spécialise dans la mise à jour en direct de votre base de données, sans perte de données. Nous aborderons cela plus en détail dans une partie ultérieure du tutoriel, mais pour l'instant, rappelez-vous le guide en trois étapes pour apporter des modifications aux modèles :

- Modifiez vos modèles (dans `models.py`).
- Exécutez `python manage.py makemigrations <makemigrations>` pour créer des migrations pour ces modifications
- Exécutez `python manage.py migrate <migrate>` pour appliquer ces modifications à la base de données.

La raison pour laquelle il existe des commandes distinctes pour créer et appliquer les migrations est que vous commettrez les migrations dans votre système de contrôle de version et les livrerez avec votre application ; elles facilitent non seulement votre développement, mais sont également utilisables par d'autres développeurs et en production.

Lisez la `documentation django-admin </ref/django-admin>` pour plus d'informations sur ce que peut faire l'utilitaire `manage.py`.
