# 激活模型

那一小段模型代码为Django提供了很多信息。有了它，Django能够：

- 为这个应用创建一个数据库模式（`CREATE TABLE` 语句）。
- 创建一个用于访问 `Question` 和 `Choice` 对象的Python数据库访问API。

但首先我们需要告诉我们的项目 `polls` 应用已安装。

Django应用是 “可插拔的”：你可以在多个项目中使用一个应用，并且你可以分发应用，因为它们不必与特定的Django安装绑定。

要将应用包含在我们的项目中，我们需要在 `INSTALLED_APPS` 设置中添加对其配置类的引用。`PollsConfig` 类在 `polls/apps.py` 文件中，所以它的点分路径是 `'polls.apps.PollsConfig'`。编辑 `mysite/settings.py` 文件，并将该点分路径添加到 `INSTALLED_APPS` 设置中。它将如下所示：

```python
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

现在Django知道要包含 `polls` 应用了。让我们运行另一个命令：

```bash
python manage.py makemigrations polls
```

你应该会看到类似于以下内容：

```plaintext
Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
```

通过运行 `makemigrations`，你是在告诉Django你已经对你的模型做了一些更改（在这种情况下，你创建了新模型），并且你希望这些更改被存储为一个 _迁移_。

迁移是Django存储对模型（以及因此对你的数据库模式）的更改的方式 —— 它们是磁盘上的文件。如果你愿意，你可以阅读新模型的迁移文件；它是 `polls/migrations/0001_initial.py` 文件。别担心，不期望你每次Django创建迁移时都去阅读它们，但它们设计为可人工编辑，以防你想手动调整Django更改事物的方式。

有一个命令可以为你运行迁移并自动管理你的数据库模式 —— 那就是 `migrate`，我们稍后会讲到 —— 但首先，让我们看看那个迁移会运行什么SQL。`sqlmigrate` 命令接受迁移名称并返回它们的SQL：

```bash
python manage.py sqlmigrate polls 0001
```

你应该会看到类似于以下内容（我们为了可读性重新格式化了它）：

```sql
BEGIN;
--
-- Create model Question
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

请注意以下几点：

- 确切的输出将根据你使用的数据库而有所不同。上面的示例是为PostgreSQL生成的。
- 表名是通过组合应用的名称（`polls`）和模型的小写名称自动生成的 —— `question` 和 `choice`。（你可以覆盖此行为。）
- 主键（ID）会自动添加。（你也可以覆盖此设置。）
- 按照惯例，Django会在外部键字段名称后附加 `"_id"`。（是的，你也可以覆盖此设置。）
- 外键关系通过 `FOREIGN KEY` 约束明确表示。不用担心 `DEFERRABLE` 部分；它是在告诉PostgreSQL直到事务结束才强制执行外键。
- 它是根据你正在使用的数据库量身定制的，所以特定于数据库的字段类型，如 `auto_increment`（MySQL）、`bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY`（PostgreSQL）或 `integer primary key autoincrement`（SQLite）会为你自动处理。字段名称的引用也是如此 —— 例如，使用双引号或单引号。
- `sqlmigrate` 命令实际上不会在你的数据库上运行迁移 —— 相反，它会将其打印到屏幕上，以便你可以看到Django认为需要什么SQL。这对于检查Django要做什么或者如果你有需要SQL脚本进行更改的数据库管理员来说很有用。

如果你感兴趣，你也可以运行 `python manage.py check <check>`；这会检查你的项目中是否有任何问题，而不会进行迁移或触及数据库。

现在，再次运行 `migrate` 以在你的数据库中创建那些模型表：

```bash
python manage.py migrate
```

```plaintext
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Applying polls.0001_initial... OK
```

`migrate` 命令会获取所有尚未应用的迁移（Django使用你数据库中的一个名为 `django_migrations` 的特殊表来跟踪哪些迁移已应用），并针对你的数据库运行它们 —— 本质上，是将你对模型所做的更改与数据库中的模式同步。

迁移非常强大，它允许你在开发项目时随着时间的推移更改模型，而无需删除你的数据库或表并重新创建它们 —— 它专门用于实时升级你的数据库，而不会丢失数据。我们将在本教程的后面部分更深入地介绍它们，但现在，请记住进行模型更改的三步指南：

- 更改你的模型（在 `models.py` 中）。
- 运行 `python manage.py makemigrations <makemigrations>` 为这些更改创建迁移。
- 运行 `python manage.py migrate <migrate>` 将这些更改应用到数据库。

之所以有单独的命令来创建和应用迁移，是因为你将把迁移提交到你的版本控制系统并与你的应用一起发布；它们不仅使你的开发更容易，其他开发人员也可以使用它们，并且可以用于生产环境。

阅读 `django-admin文档 </ref/django-admin>` 以获取有关 `manage.py` 实用工具功能的完整信息。
