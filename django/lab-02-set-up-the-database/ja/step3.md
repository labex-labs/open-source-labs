# モデルの有効化

この小さなモデルコードは、Djangoに多くの情報を与えます。これにより、Djangoは以下のことができます。

- このアプリケーション用のデータベーススキーマ（`CREATE TABLE` 文）を作成する。
- `Question` と `Choice` オブジェクトにアクセスするためのPythonデータベースアクセスAPIを作成する。

しかし、最初に、`polls` アプリケーションがインストールされていることをプロジェクトに伝える必要があります。

Djangoアプリケーションは「プラグ可能」です。1つのアプリケーションを複数のプロジェクトで使用でき、また、特定のDjangoインストールに束縛される必要がないため、アプリケーションを配布することもできます。

プロジェクトにアプリケーションを含めるには、`INSTALLED_APPS` 設定にその構成クラスへの参照を追加する必要があります。`PollsConfig` クラスは `polls/apps.py` ファイルにあるため、そのドット区切りパスは `'polls.apps.PollsConfig'` になります。`mysite/settings.py` ファイルを編集して、そのドット区切りパスを `INSTALLED_APPS` 設定に追加します。以下のようになります。

```python
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
```

これでDjangoは `polls` アプリケーションを含めるようになりました。次に、別のコマンドを実行しましょう。

```bash
python manage.py makemigrations polls
```

以下のような出力が表示されるはずです。

```plaintext
'polls' のマイグレーション:
  polls/migrations/0001_initial.py
    - モデル Question を作成する
    - モデル Choice を作成する
```

`makemigrations` を実行することで、Djangoに対してモデルに変更を加えたこと（この場合は新しいモデルを作成したこと）を伝え、その変更を _マイグレーション_ として保存してもらうように指示しています。

マイグレーションは、Djangoがモデル（つまりデータベーススキーマ）の変更を保存する方法です。ディスク上のファイルです。新しいモデルのマイグレーションを好きなら読むことができます。それは `polls/migrations/0001_initial.py` ファイルです。心配しないでください。Djangoがマイグレーションを作成するたびに読む必要はありませんが、Djangoが何を変更するかを手動で微調整したい場合には、人間が編集可能なように設計されています。

マイグレーションを実行してデータベーススキーマを自動的に管理するコマンドがあります。それは `migrate` と呼ばれるもので、すぐに説明しますが、まずは、そのマイグレーションが実行するSQLを見てみましょう。`sqlmigrate` コマンドはマイグレーション名を引数に取り、そのSQLを返します。

```bash
python manage.py sqlmigrate polls 0001
```

以下のような出力が表示されるはずです（読みやすさのために整形しています）。

```sql
BEGIN;
--
-- モデル Question を作成する
--
CREATE TABLE "polls_question" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "question_text" varchar(200) NOT NULL,
    "pub_date" timestamp with time zone NOT NULL
);
--
-- モデル Choice を作成する
--
CREATE TABLE "polls_choice" (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "choice_text" varchar(200) NOT NULL,
    "votes" integer NOT NULL,
    "question_id" bigint NOT NULL
);
ALTER TABLE "polls_choice"
  ADD CONSTRAINT "polls_choice_question_id_c5b4b260_fk_polls_question_id"
    FOREIGN KEY ("question_id")
    REFERENCES "polls_question" ("id")
    DEFERRABLE INITIALLY DEFERRED;
CREATE INDEX "polls_choice_question_id_c5b4b260" ON "polls_choice" ("question_id");

COMMIT;
```

以下の点に注意してください。

- 正確な出力は使用しているデータベースによって異なります。上の例はPostgreSQL用に生成されています。
- テーブル名は、アプリケーション名（`polls`）とモデルの小文字の名前（`question` と `choice`）を組み合わせて自動的に生成されます。（この動作をオーバーライドできます。）
- 主キー（ID）は自動的に追加されます。（これもオーバーライドできます。）
- 慣例として、Djangoは外部キーフィールド名に `"_id"` を付けます。（はい、これもオーバーライドできます。）
- 外部キー関係は `FOREIGN KEY` 制約によって明示的になされます。`DEFERRABLE` の部分は心配しないでください。PostgreSQLに対して、トランザクション終了まで外部キー制約を強制しないように指示しています。
- 使用しているデータベースに合わせて調整されているため、`auto_increment`（MySQL）、`bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY`（PostgreSQL）、または `integer primary key autoincrement`（SQLite）などのデータベース固有のフィールド型が自動的に処理されます。フィールド名の引用符付けも同様です。たとえば、二重引用符または単一引用符を使用します。
- `sqlmigrate` コマンドは実際にはデータベースにマイグレーションを実行しません。代わりに、画面に表示して、Djangoが必要と思うSQLを見ることができます。Djangoが何を行う予定かを確認するため、またはデータベース管理者が変更にSQLスクリプトを必要とする場合に便利です。

興味がある場合は、`python manage.py check <check>` も実行できます。これは、マイグレーションを作成せず、データベースに触れることなく、プロジェクト内の問題をチェックします。

次に、`migrate` を実行してデータベースにそれらのモデルテーブルを作成しましょう。

```bash
python manage.py migrate
```

```plaintext
実行する操作:
  すべてのマイグレーションを適用する: admin, auth, contenttypes, polls, sessions
マイグレーションの実行:
  polls.0001_initialを適用中... OK
```

`migrate` コマンドは、適用されていないすべてのマイグレーション（Djangoは、データベース内の特殊なテーブル `django_migrations` を使用して、どのマイグレーションが適用されているかを追跡します）を取得し、データベースに対して実行します。つまり、モデルに加えた変更をデータベース内のスキーマと同期させます。

マイグレーションは非常に強力で、プロジェクトを開発する際に、時間の経過とともにモデルを変更できるようにします。データベースやテーブルを削除して新しく作成する必要がなくなります。ライブでデータベースをアップグレードし、データを失うことなく機能します。このチュートリアルの後半で詳しく説明しますが、今のところ、モデル変更の3ステップガイドを覚えておいてください。

- モデルを変更する（`models.py` 内）。
- `python manage.py makemigrations <makemigrations>` を実行して、それらの変更に対するマイグレーションを作成する。
- `python manage.py migrate <migrate>` を実行して、それらの変更をデータベースに適用する。

マイグレーションを作成するコマンドと適用するコマンドが別々にある理由は、マイグレーションをバージョン管理システムにコミットしてアプリケーションと一緒に配布するためです。これにより、開発が容易になるだけでなく、他の開発者や本番環境でも使用できます。

`manage.py` ユーティリティができることの詳細については、`django-admin ドキュメント </ref/django-admin>` を参照してください。
